{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - animation - keyframes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - keyframes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\tlet mixer;\n\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tconst stats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xbfe3dd );\n\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\tcamera.position.set( 5, 2, 8 );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\tcontrols.update();\n\t\t\tcontrols.enablePan = false;\n\t\t\tcontrols.enableDamping = true;\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\tconst loader = new GLTFLoader();\n\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\tloader.load( 'models/gltf/LittlestTokyo.glb', function ( gltf ) {\n\n\t\t\t\tconst model = gltf.scene;\n\t\t\t\tmodel.position.set( 1, 1, 0 );\n\t\t\t\tmodel.scale.set( 0.01, 0.01, 0.01 );\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}, undefined, function ( e ) {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t} );\n\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t};\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - animation - keyframes Model: Littlest Tokyo by Glen Fox , CC Attribution."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation keyframes in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - keyframes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\tlet mixer;\n\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tconst stats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xbfe3dd );\n\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\tcamera.position.set( 5, 2, 8 );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\tcontrols.update();\n\t\t\tcontrols.enablePan = false;\n\t\t\tcontrols.enableDamping = true;\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\tconst loader = new GLTFLoader();\n\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\tloader.load( 'models/gltf/LittlestTokyo.glb', function ( gltf ) {\n\n\t\t\t\tconst model = gltf.scene;\n\t\t\t\tmodel.position.set( 1, 1, 0 );\n\t\t\t\tmodel.scale.set( 0.01, 0.01, 0.01 );\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}, undefined, function ( e ) {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t} );\n\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t};\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - animation - keyframes Model: Littlest Tokyo by Glen Fox , CC Attribution."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - animation - skinning"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, renderer, camera, stats;\n\t\t\tlet model, skeleton, mixer, clock;\n\n\t\t\tconst crossFadeControls = [];\n\n\t\t\tlet idleAction, walkAction, runAction;\n\t\t\tlet idleWeight, walkWeight, runWeight;\n\t\t\tlet actions, settings;\n\n\t\t\tlet singleStepMode = false;\n\t\t\tlet sizeOfNextStep = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 1, 2, - 3 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3, 10, - 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcreatePanel();\n\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst animations = gltf.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tidleAction = mixer.clipAction( animations[ 0 ] );\n\t\t\t\t\twalkAction = mixer.clipAction( animations[ 3 ] );\n\t\t\t\t\trunAction = mixer.clipAction( animations[ 1 ] );\n\n\t\t\t\t\tactions = [ idleAction, walkAction, runAction ];\n\n\t\t\t\t\tactivateAllActions();\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tconst folder1 = panel.addFolder( 'Visibility' );\n\t\t\t\tconst folder2 = panel.addFolder( 'Activation/Deactivation' );\n\t\t\t\tconst folder3 = panel.addFolder( 'Pausing/Stepping' );\n\t\t\t\tconst folder4 = panel.addFolder( 'Crossfading' );\n\t\t\t\tconst folder5 = panel.addFolder( 'Blend Weights' );\n\t\t\t\tconst folder6 = panel.addFolder( 'General Speed' );\n\n\t\t\t\tsettings = {\n\t\t\t\t\t'show model': true,\n\t\t\t\t\t'show skeleton': false,\n\t\t\t\t\t'deactivate all': deactivateAllActions,\n\t\t\t\t\t'activate all': activateAllActions,\n\t\t\t\t\t'pause/continue': pauseContinue,\n\t\t\t\t\t'make single step': toSingleStepMode,\n\t\t\t\t\t'modify step size': 0.05,\n\t\t\t\t\t'from walk to idle': function () {\n\n\t\t\t\t\t\tprepareCrossFade( walkAction, idleAction, 1.0 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from idle to walk': function () {\n\n\t\t\t\t\t\tprepareCrossFade( idleAction, walkAction, 0.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from walk to run': function () {\n\n\t\t\t\t\t\tprepareCrossFade( walkAction, runAction, 2.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from run to walk': function () {\n\n\t\t\t\t\t\tprepareCrossFade( runAction, walkAction, 5.0 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'use default duration': true,\n\t\t\t\t\t'set custom duration': 3.5,\n\t\t\t\t\t'modify idle weight': 0.0,\n\t\t\t\t\t'modify walk weight': 1.0,\n\t\t\t\t\t'modify run weight': 0.0,\n\t\t\t\t\t'modify time scale': 1.0\n\t\t\t\t};\n\n\t\t\t\tfolder1.add( settings, 'show model' ).onChange( showModel );\n\t\t\t\tfolder1.add( settings, 'show skeleton' ).onChange( showSkeleton );\n\t\t\t\tfolder2.add( settings, 'deactivate all' );\n\t\t\t\tfolder2.add( settings, 'activate all' );\n\t\t\t\tfolder3.add( settings, 'pause/continue' );\n\t\t\t\tfolder3.add( settings, 'make single step' );\n\t\t\t\tfolder3.add( settings, 'modify step size', 0.01, 0.1, 0.001 );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from walk to idle' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from idle to walk' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from walk to run' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from run to walk' ) );\n\t\t\t\tfolder4.add( settings, 'use default duration' );\n\t\t\t\tfolder4.add( settings, 'set custom duration', 0, 10, 0.01 );\n\t\t\t\tfolder5.add( settings, 'modify idle weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( idleAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder5.add( settings, 'modify walk weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( walkAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder5.add( settings, 'modify run weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( runAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder6.add( settings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\t\t\t\tfolder3.open();\n\t\t\t\tfolder4.open();\n\t\t\t\tfolder5.open();\n\t\t\t\tfolder6.open();\n\n\t\t\t}\n\n\n\t\t\tfunction showModel( visibility ) {\n\n\t\t\t\tmodel.visible = visibility;\n\n\t\t\t}\n\n\n\t\t\tfunction showSkeleton( visibility ) {\n\n\t\t\t\tskeleton.visible = visibility;\n\n\t\t\t}\n\n\n\t\t\tfunction modifyTimeScale( speed ) {\n\n\t\t\t\tmixer.timeScale = speed;\n\n\t\t\t}\n\n\n\t\t\tfunction deactivateAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.stop();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction activateAllActions() {\n\n\t\t\t\tsetWeight( idleAction, settings[ 'modify idle weight' ] );\n\t\t\t\tsetWeight( walkAction, settings[ 'modify walk weight' ] );\n\t\t\t\tsetWeight( runAction, settings[ 'modify run weight' ] );\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.play();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction pauseContinue() {\n\n\t\t\t\tif ( singleStepMode ) {\n\n\t\t\t\t\tsingleStepMode = false;\n\t\t\t\t\tunPauseAllActions();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( idleAction.paused ) {\n\n\t\t\t\t\t\tunPauseAllActions();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpauseAllActions();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction pauseAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.paused = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction unPauseAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.paused = false;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction toSingleStepMode() {\n\n\t\t\t\tunPauseAllActions();\n\n\t\t\t\tsingleStepMode = true;\n\t\t\t\tsizeOfNextStep = settings[ 'modify step size' ];\n\n\t\t\t}\n\n\t\t\tfunction prepareCrossFade( startAction, endAction, defaultDuration ) {\n\n\t\t\t\t// Switch default / custom crossfade duration (according to the user's choice)\n\n\t\t\t\tconst duration = setCrossFadeDuration( defaultDuration );\n\n\t\t\t\t// Make sure that we don't go on in singleStepMode, and that all actions are unpaused\n\n\t\t\t\tsingleStepMode = false;\n\t\t\t\tunPauseAllActions();\n\n\t\t\t\t// If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;\n\t\t\t\t// else wait until the current action has finished its current loop\n\n\t\t\t\tif ( startAction === idleAction ) {\n\n\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsynchronizeCrossFade( startAction, endAction, duration );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setCrossFadeDuration( defaultDuration ) {\n\n\t\t\t\t// Switch default crossfade duration <-> custom crossfade duration\n\n\t\t\t\tif ( settings[ 'use default duration' ] ) {\n\n\t\t\t\t\treturn defaultDuration;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn settings[ 'set custom duration' ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction synchronizeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\tmixer.addEventListener( 'loop', onLoopFinished );\n\n\t\t\t\tfunction onLoopFinished( event ) {\n\n\t\t\t\t\tif ( event.action === startAction ) {\n\n\t\t\t\t\t\tmixer.removeEventListener( 'loop', onLoopFinished );\n\n\t\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction executeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// Not only the start action, but also the end action must get a weight of 1 before fading\n\t\t\t\t// (concerning the start action this is already guaranteed in this place)\n\n\t\t\t\tsetWeight( endAction, 1 );\n\t\t\t\tendAction.time = 0;\n\n\t\t\t\t// Crossfade with warping - you can also try without warping by setting the third parameter to false\n\n\t\t\t\tstartAction.crossFadeTo( endAction, duration, true );\n\n\t\t\t}\n\n\t\t\t// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n\t\t\t// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\t// Called by the render loop\n\n\t\t\tfunction updateWeightSliders() {\n\n\t\t\t\tsettings[ 'modify idle weight' ] = idleWeight;\n\t\t\t\tsettings[ 'modify walk weight' ] = walkWeight;\n\t\t\t\tsettings[ 'modify run weight' ] = runWeight;\n\n\t\t\t}\n\n\t\t\t// Called by the render loop\n\n\t\t\tfunction updateCrossFadeControls() {\n\n\t\t\t\tif ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].disable();\n\t\t\t\t\tcrossFadeControls[ 1 ].enable();\n\t\t\t\t\tcrossFadeControls[ 2 ].disable();\n\t\t\t\t\tcrossFadeControls[ 3 ].disable();\n\n\t\t\t\t}\n\n\t\t\t\tif ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].enable();\n\t\t\t\t\tcrossFadeControls[ 1 ].disable();\n\t\t\t\t\tcrossFadeControls[ 2 ].enable();\n\t\t\t\t\tcrossFadeControls[ 3 ].disable();\n\n\t\t\t\t}\n\n\t\t\t\tif ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].disable();\n\t\t\t\t\tcrossFadeControls[ 1 ].disable();\n\t\t\t\t\tcrossFadeControls[ 2 ].disable();\n\t\t\t\t\tcrossFadeControls[ 3 ].enable();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tidleWeight = idleAction.getEffectiveWeight();\n\t\t\t\twalkWeight = walkAction.getEffectiveWeight();\n\t\t\t\trunWeight = runAction.getEffectiveWeight();\n\n\t\t\t\t// Update the panel values if weights are modified from \"outside\" (by crossfadings)\n\n\t\t\t\tupdateWeightSliders();\n\n\t\t\t\t// Enable/disable crossfade controls according to current weight values\n\n\t\t\t\tupdateCrossFadeControls();\n\n\t\t\t\t// Get the time elapsed since the last frame, used for mixer update (if not in single step mode)\n\n\t\t\t\tlet mixerUpdateDelta = clock.getDelta();\n\n\t\t\t\t// If in single step mode, make one step and then do nothing (until the user clicks again)\n\n\t\t\t\tif ( singleStepMode ) {\n\n\t\t\t\t\tmixerUpdateDelta = sizeOfNextStep;\n\t\t\t\t\tsizeOfNextStep = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Update the animation mixer, the stats panel, and render this frame\n\n\t\t\t\tmixer.update( mixerUpdateDelta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Skeletal Animation Blending (model from mixamo.com ) Note: crossfades are possible with blend weights being set to (1,0,0), (0,1,0) or (0,0,1)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation skinning blending in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, renderer, camera, stats;\n\t\t\tlet model, skeleton, mixer, clock;\n\n\t\t\tconst crossFadeControls = [];\n\n\t\t\tlet idleAction, walkAction, runAction;\n\t\t\tlet idleWeight, walkWeight, runWeight;\n\t\t\tlet actions, settings;\n\n\t\t\tlet singleStepMode = false;\n\t\t\tlet sizeOfNextStep = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 1, 2, - 3 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3, 10, - 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcreatePanel();\n\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst animations = gltf.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tidleAction = mixer.clipAction( animations[ 0 ] );\n\t\t\t\t\twalkAction = mixer.clipAction( animations[ 3 ] );\n\t\t\t\t\trunAction = mixer.clipAction( animations[ 1 ] );\n\n\t\t\t\t\tactions = [ idleAction, walkAction, runAction ];\n\n\t\t\t\t\tactivateAllActions();\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tconst folder1 = panel.addFolder( 'Visibility' );\n\t\t\t\tconst folder2 = panel.addFolder( 'Activation/Deactivation' );\n\t\t\t\tconst folder3 = panel.addFolder( 'Pausing/Stepping' );\n\t\t\t\tconst folder4 = panel.addFolder( 'Crossfading' );\n\t\t\t\tconst folder5 = panel.addFolder( 'Blend Weights' );\n\t\t\t\tconst folder6 = panel.addFolder( 'General Speed' );\n\n\t\t\t\tsettings = {\n\t\t\t\t\t'show model': true,\n\t\t\t\t\t'show skeleton': false,\n\t\t\t\t\t'deactivate all': deactivateAllActions,\n\t\t\t\t\t'activate all': activateAllActions,\n\t\t\t\t\t'pause/continue': pauseContinue,\n\t\t\t\t\t'make single step': toSingleStepMode,\n\t\t\t\t\t'modify step size': 0.05,\n\t\t\t\t\t'from walk to idle': function () {\n\n\t\t\t\t\t\tprepareCrossFade( walkAction, idleAction, 1.0 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from idle to walk': function () {\n\n\t\t\t\t\t\tprepareCrossFade( idleAction, walkAction, 0.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from walk to run': function () {\n\n\t\t\t\t\t\tprepareCrossFade( walkAction, runAction, 2.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'from run to walk': function () {\n\n\t\t\t\t\t\tprepareCrossFade( runAction, walkAction, 5.0 );\n\n\t\t\t\t\t},\n\t\t\t\t\t'use default duration': true,\n\t\t\t\t\t'set custom duration': 3.5,\n\t\t\t\t\t'modify idle weight': 0.0,\n\t\t\t\t\t'modify walk weight': 1.0,\n\t\t\t\t\t'modify run weight': 0.0,\n\t\t\t\t\t'modify time scale': 1.0\n\t\t\t\t};\n\n\t\t\t\tfolder1.add( settings, 'show model' ).onChange( showModel );\n\t\t\t\tfolder1.add( settings, 'show skeleton' ).onChange( showSkeleton );\n\t\t\t\tfolder2.add( settings, 'deactivate all' );\n\t\t\t\tfolder2.add( settings, 'activate all' );\n\t\t\t\tfolder3.add( settings, 'pause/continue' );\n\t\t\t\tfolder3.add( settings, 'make single step' );\n\t\t\t\tfolder3.add( settings, 'modify step size', 0.01, 0.1, 0.001 );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from walk to idle' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from idle to walk' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from walk to run' ) );\n\t\t\t\tcrossFadeControls.push( folder4.add( settings, 'from run to walk' ) );\n\t\t\t\tfolder4.add( settings, 'use default duration' );\n\t\t\t\tfolder4.add( settings, 'set custom duration', 0, 10, 0.01 );\n\t\t\t\tfolder5.add( settings, 'modify idle weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( idleAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder5.add( settings, 'modify walk weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( walkAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder5.add( settings, 'modify run weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\tsetWeight( runAction, weight );\n\n\t\t\t\t} );\n\t\t\t\tfolder6.add( settings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\t\t\t\tfolder3.open();\n\t\t\t\tfolder4.open();\n\t\t\t\tfolder5.open();\n\t\t\t\tfolder6.open();\n\n\t\t\t}\n\n\n\t\t\tfunction showModel( visibility ) {\n\n\t\t\t\tmodel.visible = visibility;\n\n\t\t\t}\n\n\n\t\t\tfunction showSkeleton( visibility ) {\n\n\t\t\t\tskeleton.visible = visibility;\n\n\t\t\t}\n\n\n\t\t\tfunction modifyTimeScale( speed ) {\n\n\t\t\t\tmixer.timeScale = speed;\n\n\t\t\t}\n\n\n\t\t\tfunction deactivateAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.stop();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction activateAllActions() {\n\n\t\t\t\tsetWeight( idleAction, settings[ 'modify idle weight' ] );\n\t\t\t\tsetWeight( walkAction, settings[ 'modify walk weight' ] );\n\t\t\t\tsetWeight( runAction, settings[ 'modify run weight' ] );\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.play();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction pauseContinue() {\n\n\t\t\t\tif ( singleStepMode ) {\n\n\t\t\t\t\tsingleStepMode = false;\n\t\t\t\t\tunPauseAllActions();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( idleAction.paused ) {\n\n\t\t\t\t\t\tunPauseAllActions();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpauseAllActions();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction pauseAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.paused = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction unPauseAllActions() {\n\n\t\t\t\tactions.forEach( function ( action ) {\n\n\t\t\t\t\taction.paused = false;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction toSingleStepMode() {\n\n\t\t\t\tunPauseAllActions();\n\n\t\t\t\tsingleStepMode = true;\n\t\t\t\tsizeOfNextStep = settings[ 'modify step size' ];\n\n\t\t\t}\n\n\t\t\tfunction prepareCrossFade( startAction, endAction, defaultDuration ) {\n\n\t\t\t\t// Switch default / custom crossfade duration (according to the user's choice)\n\n\t\t\t\tconst duration = setCrossFadeDuration( defaultDuration );\n\n\t\t\t\t// Make sure that we don't go on in singleStepMode, and that all actions are unpaused\n\n\t\t\t\tsingleStepMode = false;\n\t\t\t\tunPauseAllActions();\n\n\t\t\t\t// If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;\n\t\t\t\t// else wait until the current action has finished its current loop\n\n\t\t\t\tif ( startAction === idleAction ) {\n\n\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsynchronizeCrossFade( startAction, endAction, duration );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setCrossFadeDuration( defaultDuration ) {\n\n\t\t\t\t// Switch default crossfade duration <-> custom crossfade duration\n\n\t\t\t\tif ( settings[ 'use default duration' ] ) {\n\n\t\t\t\t\treturn defaultDuration;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn settings[ 'set custom duration' ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction synchronizeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\tmixer.addEventListener( 'loop', onLoopFinished );\n\n\t\t\t\tfunction onLoopFinished( event ) {\n\n\t\t\t\t\tif ( event.action === startAction ) {\n\n\t\t\t\t\t\tmixer.removeEventListener( 'loop', onLoopFinished );\n\n\t\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction executeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// Not only the start action, but also the end action must get a weight of 1 before fading\n\t\t\t\t// (concerning the start action this is already guaranteed in this place)\n\n\t\t\t\tsetWeight( endAction, 1 );\n\t\t\t\tendAction.time = 0;\n\n\t\t\t\t// Crossfade with warping - you can also try without warping by setting the third parameter to false\n\n\t\t\t\tstartAction.crossFadeTo( endAction, duration, true );\n\n\t\t\t}\n\n\t\t\t// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n\t\t\t// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\t// Called by the render loop\n\n\t\t\tfunction updateWeightSliders() {\n\n\t\t\t\tsettings[ 'modify idle weight' ] = idleWeight;\n\t\t\t\tsettings[ 'modify walk weight' ] = walkWeight;\n\t\t\t\tsettings[ 'modify run weight' ] = runWeight;\n\n\t\t\t}\n\n\t\t\t// Called by the render loop\n\n\t\t\tfunction updateCrossFadeControls() {\n\n\t\t\t\tif ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].disable();\n\t\t\t\t\tcrossFadeControls[ 1 ].enable();\n\t\t\t\t\tcrossFadeControls[ 2 ].disable();\n\t\t\t\t\tcrossFadeControls[ 3 ].disable();\n\n\t\t\t\t}\n\n\t\t\t\tif ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].enable();\n\t\t\t\t\tcrossFadeControls[ 1 ].disable();\n\t\t\t\t\tcrossFadeControls[ 2 ].enable();\n\t\t\t\t\tcrossFadeControls[ 3 ].disable();\n\n\t\t\t\t}\n\n\t\t\t\tif ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {\n\n\t\t\t\t\tcrossFadeControls[ 0 ].disable();\n\t\t\t\t\tcrossFadeControls[ 1 ].disable();\n\t\t\t\t\tcrossFadeControls[ 2 ].disable();\n\t\t\t\t\tcrossFadeControls[ 3 ].enable();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tidleWeight = idleAction.getEffectiveWeight();\n\t\t\t\twalkWeight = walkAction.getEffectiveWeight();\n\t\t\t\trunWeight = runAction.getEffectiveWeight();\n\n\t\t\t\t// Update the panel values if weights are modified from \"outside\" (by crossfadings)\n\n\t\t\t\tupdateWeightSliders();\n\n\t\t\t\t// Enable/disable crossfade controls according to current weight values\n\n\t\t\t\tupdateCrossFadeControls();\n\n\t\t\t\t// Get the time elapsed since the last frame, used for mixer update (if not in single step mode)\n\n\t\t\t\tlet mixerUpdateDelta = clock.getDelta();\n\n\t\t\t\t// If in single step mode, make one step and then do nothing (until the user clicks again)\n\n\t\t\t\tif ( singleStepMode ) {\n\n\t\t\t\t\tmixerUpdateDelta = sizeOfNextStep;\n\t\t\t\t\tsizeOfNextStep = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Update the animation mixer, the stats panel, and render this frame\n\n\t\t\t\tmixer.update( mixerUpdateDelta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Skeletal Animation Blending (model from mixamo.com ) Note: crossfades are possible with blend weights being set to (1,0,0), (0,1,0) or (0,0,1)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - additive animation - skinning"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - additive animation - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, renderer, camera, stats;\n\t\t\tlet model, skeleton, mixer, clock;\n\n\t\t\tconst crossFadeControls = [];\n\n\t\t\tlet currentBaseAction = 'idle';\n\t\t\tconst allActions = [];\n\t\t\tconst baseActions = {\n\t\t\t\tidle: { weight: 1 },\n\t\t\t\twalk: { weight: 0 },\n\t\t\t\trun: { weight: 0 }\n\t\t\t};\n\t\t\tconst additiveActions = {\n\t\t\t\tsneak_pose: { weight: 0 },\n\t\t\t\tsad_pose: { weight: 0 },\n\t\t\t\tagree: { weight: 0 },\n\t\t\t\theadShake: { weight: 0 }\n\t\t\t};\n\t\t\tlet panelSettings, numAnimations;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 3, 10, 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Xbot.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\tconst animations = gltf.animations;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tnumAnimations = animations.length;\n\n\t\t\t\t\tfor ( let i = 0; i !== numAnimations; ++ i ) {\n\n\t\t\t\t\t\tlet clip = animations[ i ];\n\t\t\t\t\t\tconst name = clip.name;\n\n\t\t\t\t\t\tif ( baseActions[ name ] ) {\n\n\t\t\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\t\t\tactivateAction( action );\n\t\t\t\t\t\t\tbaseActions[ name ].action = action;\n\t\t\t\t\t\t\tallActions.push( action );\n\n\t\t\t\t\t\t} else if ( additiveActions[ name ] ) {\n\n\t\t\t\t\t\t\t// Make the clip additive and remove the reference frame\n\n\t\t\t\t\t\t\tTHREE.AnimationUtils.makeClipAdditive( clip );\n\n\t\t\t\t\t\t\tif ( clip.name.endsWith( '_pose' ) ) {\n\n\t\t\t\t\t\t\t\tclip = THREE.AnimationUtils.subclip( clip, clip.name, 2, 3, 30 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\t\t\tactivateAction( action );\n\t\t\t\t\t\t\tadditiveActions[ name ].action = action;\n\t\t\t\t\t\t\tallActions.push( action );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcreatePanel();\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 1, 2, 3 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tconst folder1 = panel.addFolder( 'Base Actions' );\n\t\t\t\tconst folder2 = panel.addFolder( 'Additive Action Weights' );\n\t\t\t\tconst folder3 = panel.addFolder( 'General Speed' );\n\n\t\t\t\tpanelSettings = {\n\t\t\t\t\t'modify time scale': 1.0\n\t\t\t\t};\n\n\t\t\t\tconst baseNames = [ 'None', ...Object.keys( baseActions ) ];\n\n\t\t\t\tfor ( let i = 0, l = baseNames.length; i !== l; ++ i ) {\n\n\t\t\t\t\tconst name = baseNames[ i ];\n\t\t\t\t\tconst settings = baseActions[ name ];\n\t\t\t\t\tpanelSettings[ name ] = function () {\n\n\t\t\t\t\t\tconst currentSettings = baseActions[ currentBaseAction ];\n\t\t\t\t\t\tconst currentAction = currentSettings ? currentSettings.action : null;\n\t\t\t\t\t\tconst action = settings ? settings.action : null;\n\n\t\t\t\t\t\tif ( currentAction !== action ) {\n\n\t\t\t\t\t\t\tprepareCrossFade( currentAction, action, 0.35 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcrossFadeControls.push( folder1.add( panelSettings, name ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const name of Object.keys( additiveActions ) ) {\n\n\t\t\t\t\tconst settings = additiveActions[ name ];\n\n\t\t\t\t\tpanelSettings[ name ] = settings.weight;\n\t\t\t\t\tfolder2.add( panelSettings, name, 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\t\tsetWeight( settings.action, weight );\n\t\t\t\t\t\tsettings.weight = weight;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tfolder3.add( panelSettings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\t\t\t\tfolder3.open();\n\n\t\t\t\tcrossFadeControls.forEach( function ( control ) {\n\n\t\t\t\t\tcontrol.setInactive = function () {\n\n\t\t\t\t\t\tcontrol.domElement.classList.add( 'control-inactive' );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcontrol.setActive = function () {\n\n\t\t\t\t\t\tcontrol.domElement.classList.remove( 'control-inactive' );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tconst settings = baseActions[ control.property ];\n\n\t\t\t\t\tif ( ! settings || ! settings.weight ) {\n\n\t\t\t\t\t\tcontrol.setInactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction activateAction( action ) {\n\n\t\t\t\tconst clip = action.getClip();\n\t\t\t\tconst settings = baseActions[ clip.name ] || additiveActions[ clip.name ];\n\t\t\t\tsetWeight( action, settings.weight );\n\t\t\t\taction.play();\n\n\t\t\t}\n\n\t\t\tfunction modifyTimeScale( speed ) {\n\n\t\t\t\tmixer.timeScale = speed;\n\n\t\t\t}\n\n\t\t\tfunction prepareCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// If the current action is 'idle', execute the crossfade immediately;\n\t\t\t\t// else wait until the current action has finished its current loop\n\n\t\t\t\tif ( currentBaseAction === 'idle' || ! startAction || ! endAction ) {\n\n\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsynchronizeCrossFade( startAction, endAction, duration );\n\n\t\t\t\t}\n\n\t\t\t\t// Update control colors\n\n\t\t\t\tif ( endAction ) {\n\n\t\t\t\t\tconst clip = endAction.getClip();\n\t\t\t\t\tcurrentBaseAction = clip.name;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentBaseAction = 'None';\n\n\t\t\t\t}\n\n\t\t\t\tcrossFadeControls.forEach( function ( control ) {\n\n\t\t\t\t\tconst name = control.property;\n\n\t\t\t\t\tif ( name === currentBaseAction ) {\n\n\t\t\t\t\t\tcontrol.setActive();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontrol.setInactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction synchronizeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\tmixer.addEventListener( 'loop', onLoopFinished );\n\n\t\t\t\tfunction onLoopFinished( event ) {\n\n\t\t\t\t\tif ( event.action === startAction ) {\n\n\t\t\t\t\t\tmixer.removeEventListener( 'loop', onLoopFinished );\n\n\t\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction executeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// Not only the start action, but also the end action must get a weight of 1 before fading\n\t\t\t\t// (concerning the start action this is already guaranteed in this place)\n\n\t\t\t\tif ( endAction ) {\n\n\t\t\t\t\tsetWeight( endAction, 1 );\n\t\t\t\t\tendAction.time = 0;\n\n\t\t\t\t\tif ( startAction ) {\n\n\t\t\t\t\t\t// Crossfade with warping\n\n\t\t\t\t\t\tstartAction.crossFadeTo( endAction, duration, true );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Fade in\n\n\t\t\t\t\t\tendAction.fadeIn( duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Fade out\n\n\t\t\t\t\tstartAction.fadeOut( duration );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n\t\t\t// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Render loop\n\n\t\t\t\tfor ( let i = 0; i !== numAnimations; ++ i ) {\n\n\t\t\t\t\tconst action = allActions[ i ];\n\t\t\t\t\tconst clip = action.getClip();\n\t\t\t\t\tconst settings = baseActions[ clip.name ] || additiveActions[ clip.name ];\n\t\t\t\t\tsettings.weight = action.getEffectiveWeight();\n\n\t\t\t\t}\n\n\t\t\t\t// Get the time elapsed since the last frame, used for mixer update\n\n\t\t\t\tconst mixerUpdateDelta = clock.getDelta();\n\n\t\t\t\t// Update the animation mixer, the stats panel, and render this frame\n\n\t\t\t\tmixer.update( mixerUpdateDelta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Skeletal Additive Animation Blending (model from mixamo.com )"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation skinning additive blending in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - additive animation - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, renderer, camera, stats;\n\t\t\tlet model, skeleton, mixer, clock;\n\n\t\t\tconst crossFadeControls = [];\n\n\t\t\tlet currentBaseAction = 'idle';\n\t\t\tconst allActions = [];\n\t\t\tconst baseActions = {\n\t\t\t\tidle: { weight: 1 },\n\t\t\t\twalk: { weight: 0 },\n\t\t\t\trun: { weight: 0 }\n\t\t\t};\n\t\t\tconst additiveActions = {\n\t\t\t\tsneak_pose: { weight: 0 },\n\t\t\t\tsad_pose: { weight: 0 },\n\t\t\t\tagree: { weight: 0 },\n\t\t\t\theadShake: { weight: 0 }\n\t\t\t};\n\t\t\tlet panelSettings, numAnimations;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 3, 10, 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Xbot.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\tconst animations = gltf.animations;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tnumAnimations = animations.length;\n\n\t\t\t\t\tfor ( let i = 0; i !== numAnimations; ++ i ) {\n\n\t\t\t\t\t\tlet clip = animations[ i ];\n\t\t\t\t\t\tconst name = clip.name;\n\n\t\t\t\t\t\tif ( baseActions[ name ] ) {\n\n\t\t\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\t\t\tactivateAction( action );\n\t\t\t\t\t\t\tbaseActions[ name ].action = action;\n\t\t\t\t\t\t\tallActions.push( action );\n\n\t\t\t\t\t\t} else if ( additiveActions[ name ] ) {\n\n\t\t\t\t\t\t\t// Make the clip additive and remove the reference frame\n\n\t\t\t\t\t\t\tTHREE.AnimationUtils.makeClipAdditive( clip );\n\n\t\t\t\t\t\t\tif ( clip.name.endsWith( '_pose' ) ) {\n\n\t\t\t\t\t\t\t\tclip = THREE.AnimationUtils.subclip( clip, clip.name, 2, 3, 30 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\t\t\tactivateAction( action );\n\t\t\t\t\t\t\tadditiveActions[ name ].action = action;\n\t\t\t\t\t\t\tallActions.push( action );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcreatePanel();\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 1, 2, 3 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tconst folder1 = panel.addFolder( 'Base Actions' );\n\t\t\t\tconst folder2 = panel.addFolder( 'Additive Action Weights' );\n\t\t\t\tconst folder3 = panel.addFolder( 'General Speed' );\n\n\t\t\t\tpanelSettings = {\n\t\t\t\t\t'modify time scale': 1.0\n\t\t\t\t};\n\n\t\t\t\tconst baseNames = [ 'None', ...Object.keys( baseActions ) ];\n\n\t\t\t\tfor ( let i = 0, l = baseNames.length; i !== l; ++ i ) {\n\n\t\t\t\t\tconst name = baseNames[ i ];\n\t\t\t\t\tconst settings = baseActions[ name ];\n\t\t\t\t\tpanelSettings[ name ] = function () {\n\n\t\t\t\t\t\tconst currentSettings = baseActions[ currentBaseAction ];\n\t\t\t\t\t\tconst currentAction = currentSettings ? currentSettings.action : null;\n\t\t\t\t\t\tconst action = settings ? settings.action : null;\n\n\t\t\t\t\t\tif ( currentAction !== action ) {\n\n\t\t\t\t\t\t\tprepareCrossFade( currentAction, action, 0.35 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcrossFadeControls.push( folder1.add( panelSettings, name ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const name of Object.keys( additiveActions ) ) {\n\n\t\t\t\t\tconst settings = additiveActions[ name ];\n\n\t\t\t\t\tpanelSettings[ name ] = settings.weight;\n\t\t\t\t\tfolder2.add( panelSettings, name, 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {\n\n\t\t\t\t\t\tsetWeight( settings.action, weight );\n\t\t\t\t\t\tsettings.weight = weight;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tfolder3.add( panelSettings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\t\t\t\tfolder3.open();\n\n\t\t\t\tcrossFadeControls.forEach( function ( control ) {\n\n\t\t\t\t\tcontrol.setInactive = function () {\n\n\t\t\t\t\t\tcontrol.domElement.classList.add( 'control-inactive' );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcontrol.setActive = function () {\n\n\t\t\t\t\t\tcontrol.domElement.classList.remove( 'control-inactive' );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tconst settings = baseActions[ control.property ];\n\n\t\t\t\t\tif ( ! settings || ! settings.weight ) {\n\n\t\t\t\t\t\tcontrol.setInactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction activateAction( action ) {\n\n\t\t\t\tconst clip = action.getClip();\n\t\t\t\tconst settings = baseActions[ clip.name ] || additiveActions[ clip.name ];\n\t\t\t\tsetWeight( action, settings.weight );\n\t\t\t\taction.play();\n\n\t\t\t}\n\n\t\t\tfunction modifyTimeScale( speed ) {\n\n\t\t\t\tmixer.timeScale = speed;\n\n\t\t\t}\n\n\t\t\tfunction prepareCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// If the current action is 'idle', execute the crossfade immediately;\n\t\t\t\t// else wait until the current action has finished its current loop\n\n\t\t\t\tif ( currentBaseAction === 'idle' || ! startAction || ! endAction ) {\n\n\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsynchronizeCrossFade( startAction, endAction, duration );\n\n\t\t\t\t}\n\n\t\t\t\t// Update control colors\n\n\t\t\t\tif ( endAction ) {\n\n\t\t\t\t\tconst clip = endAction.getClip();\n\t\t\t\t\tcurrentBaseAction = clip.name;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentBaseAction = 'None';\n\n\t\t\t\t}\n\n\t\t\t\tcrossFadeControls.forEach( function ( control ) {\n\n\t\t\t\t\tconst name = control.property;\n\n\t\t\t\t\tif ( name === currentBaseAction ) {\n\n\t\t\t\t\t\tcontrol.setActive();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontrol.setInactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction synchronizeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\tmixer.addEventListener( 'loop', onLoopFinished );\n\n\t\t\t\tfunction onLoopFinished( event ) {\n\n\t\t\t\t\tif ( event.action === startAction ) {\n\n\t\t\t\t\t\tmixer.removeEventListener( 'loop', onLoopFinished );\n\n\t\t\t\t\t\texecuteCrossFade( startAction, endAction, duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction executeCrossFade( startAction, endAction, duration ) {\n\n\t\t\t\t// Not only the start action, but also the end action must get a weight of 1 before fading\n\t\t\t\t// (concerning the start action this is already guaranteed in this place)\n\n\t\t\t\tif ( endAction ) {\n\n\t\t\t\t\tsetWeight( endAction, 1 );\n\t\t\t\t\tendAction.time = 0;\n\n\t\t\t\t\tif ( startAction ) {\n\n\t\t\t\t\t\t// Crossfade with warping\n\n\t\t\t\t\t\tstartAction.crossFadeTo( endAction, duration, true );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Fade in\n\n\t\t\t\t\t\tendAction.fadeIn( duration );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Fade out\n\n\t\t\t\t\tstartAction.fadeOut( duration );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n\t\t\t// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Render loop\n\n\t\t\t\tfor ( let i = 0; i !== numAnimations; ++ i ) {\n\n\t\t\t\t\tconst action = allActions[ i ];\n\t\t\t\t\tconst clip = action.getClip();\n\t\t\t\t\tconst settings = baseActions[ clip.name ] || additiveActions[ clip.name ];\n\t\t\t\t\tsettings.weight = action.getEffectiveWeight();\n\n\t\t\t\t}\n\n\t\t\t\t// Get the time elapsed since the last frame, used for mixer update\n\n\t\t\t\tconst mixerUpdateDelta = clock.getDelta();\n\n\t\t\t\t// Update the animation mixer, the stats panel, and render this frame\n\n\t\t\t\tmixer.update( mixerUpdateDelta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Skeletal Additive Animation Blending (model from mixamo.com )"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - animation - skinning - ik"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - skinning - ik:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\timport { CCDIKSolver, CCDIKHelper } from 'three/addons/animation/CCDIKSolver.js';\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\tlet scene, camera, renderer, orbitControls, transformControls;\n\t\tlet mirrorSphereCamera;\n\n\t\tconst OOI = {};\n\t\tlet IKSolver;\n\n\t\tlet stats, gui, conf;\n\t\tconst v0 = new THREE.Vector3();\n\n\t\tinit();\n\n\t\tasync function init() {\n\n\t\t\tconf = {\n\t\t\t\tfollowSphere: false,\n\t\t\t\tturnHead: true,\n\t\t\t\tik_solver: true,\n\t\t\t\tupdate: updateIK\n\t\t\t};\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.fog = new THREE.FogExp2( 0xffffff, .17 );\n\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.001, 5000 );\n\t\t\tcamera.position.set( 0.9728517749133652, 1.1044765132727201, 0.7316689528482836 );\n\t\t\tcamera.lookAt( scene.position );\n\n\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 8 ); // soft white light\n\t\t\tscene.add( ambientLight );\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\n\t\t\tconst gltf = await gltfLoader.loadAsync( 'models/gltf/kira.glb' );\n\t\t\tgltf.scene.traverse( n => {\n\n\t\t\t\tif ( n.name === 'head' ) OOI.head = n;\n\t\t\t\tif ( n.name === 'lowerarm_l' ) OOI.lowerarm_l = n;\n\t\t\t\tif ( n.name === 'Upperarm_l' ) OOI.Upperarm_l = n;\n\t\t\t\tif ( n.name === 'hand_l' ) OOI.hand_l = n;\n\t\t\t\tif ( n.name === 'target_hand_l' ) OOI.target_hand_l = n;\n\n\t\t\t\tif ( n.name === 'boule' ) OOI.sphere = n;\n\t\t\t\tif ( n.name === 'Kira_Shirt_left' ) OOI.kira = n;\n\n\t\t\t} );\n\t\t\tscene.add( gltf.scene );\n\n\t\t\tconst targetPosition = OOI.sphere.position.clone(); // for orbit controls\n\t\t\tOOI.hand_l.attach( OOI.sphere );\n\n\t\t\t// mirror sphere cube-camera\n\t\t\tconst cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 1024 );\n\t\t\tmirrorSphereCamera = new THREE.CubeCamera( 0.05, 50, cubeRenderTarget );\n\t\t\tscene.add( mirrorSphereCamera );\n\t\t\tconst mirrorSphereMaterial = new THREE.MeshBasicMaterial( { envMap: cubeRenderTarget.texture } );\n\t\t\tOOI.sphere.material = mirrorSphereMaterial;\n\n\t\t\tOOI.kira.add( OOI.kira.skeleton.bones[ 0 ] );\n\t\t\tconst iks = [\n\t\t\t\t{\n\t\t\t\t\ttarget: 22, // \"target_hand_l\"\n\t\t\t\t\teffector: 6, // \"hand_l\"\n\t\t\t\t\tlinks: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex: 5, // \"lowerarm_l\"\n\t\t\t\t\t\t\trotationMin: new THREE.Vector3( 1.2, - 1.8, - .4 ),\n\t\t\t\t\t\t\trotationMax: new THREE.Vector3( 1.7, - 1.1, .3 )\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex: 4, // \"Upperarm_l\"\n\t\t\t\t\t\t\trotationMin: new THREE.Vector3( 0.1, - 0.7, - 1.8 ),\n\t\t\t\t\t\t\trotationMax: new THREE.Vector3( 1.1, 0, - 1.4 )\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}\n\t\t\t];\n\t\t\tIKSolver = new CCDIKSolver( OOI.kira, iks );\n\t\t\tconst ccdikhelper = new CCDIKHelper( OOI.kira, iks, 0.01 );\n\t\t\tscene.add( ccdikhelper );\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( conf, 'followSphere' ).name( 'follow sphere' );\n\t\t\tgui.add( conf, 'turnHead' ).name( 'turn head' );\n\t\t\tgui.add( conf, 'ik_solver' ).name( 'IK auto update' );\n\t\t\tgui.add( conf, 'update' ).name( 'IK manual update()' );\n\t\t\tgui.open();\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\torbitControls = new OrbitControls( camera, renderer.domElement );\n\t\t\torbitControls.minDistance = 0.2;\n\t\t\torbitControls.maxDistance = 1.5;\n\t\t\torbitControls.enableDamping = true;\n\t\t\torbitControls.target.copy( targetPosition );\n\n\t\t\ttransformControls = new TransformControls( camera, renderer.domElement );\n\t\t\ttransformControls.size = 0.75;\n\t\t\ttransformControls.showX = false;\n\t\t\ttransformControls.space = 'world';\n\t\t\ttransformControls.attach( OOI.target_hand_l );\n\t\t\tscene.add( transformControls.getHelper() );\n\n\t\t\t// disable orbitControls while using transformControls\n\t\t\ttransformControls.addEventListener( 'mouseDown', () => orbitControls.enabled = false );\n\t\t\ttransformControls.addEventListener( 'mouseUp', () => orbitControls.enabled = true );\n\n\t\t\t//\n\n\t\t\tstats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t}\n\n\t\tfunction animate( ) {\n\n\t\t\tif ( OOI.sphere && mirrorSphereCamera ) {\n\n\t\t\t\tOOI.sphere.visible = false;\n\t\t\t\tOOI.sphere.getWorldPosition( mirrorSphereCamera.position );\n\t\t\t\tmirrorSphereCamera.update( renderer, scene );\n\t\t\t\tOOI.sphere.visible = true;\n\n\t\t\t}\n\n\t\t\tif ( OOI.sphere && conf.followSphere ) {\n\n\t\t\t\t// orbitControls follows the sphere\n\t\t\t\tOOI.sphere.getWorldPosition( v0 );\n\t\t\t\torbitControls.target.lerp( v0, 0.1 );\n\n\t\t\t}\n\n\t\t\tif ( OOI.head && OOI.sphere && conf.turnHead ) {\n\n\t\t\t\t// turn head\n\t\t\t\tOOI.sphere.getWorldPosition( v0 );\n\t\t\t\tOOI.head.lookAt( v0 );\n\t\t\t\tOOI.head.rotation.set( OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z );\n\n\t\t\t}\n\n\t\t\tif ( conf.ik_solver ) {\n\n\t\t\t\tupdateIK();\n\n\t\t\t}\n\n\t\t\torbitControls.update();\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update(); // fps stats\n\n\t\t}\n\n\t\tfunction updateIK() {\n\n\t\t\tif ( IKSolver ) IKSolver.update();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) object.computeBoundingSphere();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n```\n\nThis example three.js - webgl - inverse kinematics Character model by Aki , furnitures from poly.pizza , scene by abernier . CC0."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation skinning ik in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - skinning - ik:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\timport { CCDIKSolver, CCDIKHelper } from 'three/addons/animation/CCDIKSolver.js';\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\tlet scene, camera, renderer, orbitControls, transformControls;\n\t\tlet mirrorSphereCamera;\n\n\t\tconst OOI = {};\n\t\tlet IKSolver;\n\n\t\tlet stats, gui, conf;\n\t\tconst v0 = new THREE.Vector3();\n\n\t\tinit();\n\n\t\tasync function init() {\n\n\t\t\tconf = {\n\t\t\t\tfollowSphere: false,\n\t\t\t\tturnHead: true,\n\t\t\t\tik_solver: true,\n\t\t\t\tupdate: updateIK\n\t\t\t};\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.fog = new THREE.FogExp2( 0xffffff, .17 );\n\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.001, 5000 );\n\t\t\tcamera.position.set( 0.9728517749133652, 1.1044765132727201, 0.7316689528482836 );\n\t\t\tcamera.lookAt( scene.position );\n\n\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 8 ); // soft white light\n\t\t\tscene.add( ambientLight );\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\n\t\t\tconst gltf = await gltfLoader.loadAsync( 'models/gltf/kira.glb' );\n\t\t\tgltf.scene.traverse( n => {\n\n\t\t\t\tif ( n.name === 'head' ) OOI.head = n;\n\t\t\t\tif ( n.name === 'lowerarm_l' ) OOI.lowerarm_l = n;\n\t\t\t\tif ( n.name === 'Upperarm_l' ) OOI.Upperarm_l = n;\n\t\t\t\tif ( n.name === 'hand_l' ) OOI.hand_l = n;\n\t\t\t\tif ( n.name === 'target_hand_l' ) OOI.target_hand_l = n;\n\n\t\t\t\tif ( n.name === 'boule' ) OOI.sphere = n;\n\t\t\t\tif ( n.name === 'Kira_Shirt_left' ) OOI.kira = n;\n\n\t\t\t} );\n\t\t\tscene.add( gltf.scene );\n\n\t\t\tconst targetPosition = OOI.sphere.position.clone(); // for orbit controls\n\t\t\tOOI.hand_l.attach( OOI.sphere );\n\n\t\t\t// mirror sphere cube-camera\n\t\t\tconst cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 1024 );\n\t\t\tmirrorSphereCamera = new THREE.CubeCamera( 0.05, 50, cubeRenderTarget );\n\t\t\tscene.add( mirrorSphereCamera );\n\t\t\tconst mirrorSphereMaterial = new THREE.MeshBasicMaterial( { envMap: cubeRenderTarget.texture } );\n\t\t\tOOI.sphere.material = mirrorSphereMaterial;\n\n\t\t\tOOI.kira.add( OOI.kira.skeleton.bones[ 0 ] );\n\t\t\tconst iks = [\n\t\t\t\t{\n\t\t\t\t\ttarget: 22, // \"target_hand_l\"\n\t\t\t\t\teffector: 6, // \"hand_l\"\n\t\t\t\t\tlinks: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex: 5, // \"lowerarm_l\"\n\t\t\t\t\t\t\trotationMin: new THREE.Vector3( 1.2, - 1.8, - .4 ),\n\t\t\t\t\t\t\trotationMax: new THREE.Vector3( 1.7, - 1.1, .3 )\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex: 4, // \"Upperarm_l\"\n\t\t\t\t\t\t\trotationMin: new THREE.Vector3( 0.1, - 0.7, - 1.8 ),\n\t\t\t\t\t\t\trotationMax: new THREE.Vector3( 1.1, 0, - 1.4 )\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}\n\t\t\t];\n\t\t\tIKSolver = new CCDIKSolver( OOI.kira, iks );\n\t\t\tconst ccdikhelper = new CCDIKHelper( OOI.kira, iks, 0.01 );\n\t\t\tscene.add( ccdikhelper );\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( conf, 'followSphere' ).name( 'follow sphere' );\n\t\t\tgui.add( conf, 'turnHead' ).name( 'turn head' );\n\t\t\tgui.add( conf, 'ik_solver' ).name( 'IK auto update' );\n\t\t\tgui.add( conf, 'update' ).name( 'IK manual update()' );\n\t\t\tgui.open();\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\torbitControls = new OrbitControls( camera, renderer.domElement );\n\t\t\torbitControls.minDistance = 0.2;\n\t\t\torbitControls.maxDistance = 1.5;\n\t\t\torbitControls.enableDamping = true;\n\t\t\torbitControls.target.copy( targetPosition );\n\n\t\t\ttransformControls = new TransformControls( camera, renderer.domElement );\n\t\t\ttransformControls.size = 0.75;\n\t\t\ttransformControls.showX = false;\n\t\t\ttransformControls.space = 'world';\n\t\t\ttransformControls.attach( OOI.target_hand_l );\n\t\t\tscene.add( transformControls.getHelper() );\n\n\t\t\t// disable orbitControls while using transformControls\n\t\t\ttransformControls.addEventListener( 'mouseDown', () => orbitControls.enabled = false );\n\t\t\ttransformControls.addEventListener( 'mouseUp', () => orbitControls.enabled = true );\n\n\t\t\t//\n\n\t\t\tstats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t}\n\n\t\tfunction animate( ) {\n\n\t\t\tif ( OOI.sphere && mirrorSphereCamera ) {\n\n\t\t\t\tOOI.sphere.visible = false;\n\t\t\t\tOOI.sphere.getWorldPosition( mirrorSphereCamera.position );\n\t\t\t\tmirrorSphereCamera.update( renderer, scene );\n\t\t\t\tOOI.sphere.visible = true;\n\n\t\t\t}\n\n\t\t\tif ( OOI.sphere && conf.followSphere ) {\n\n\t\t\t\t// orbitControls follows the sphere\n\t\t\t\tOOI.sphere.getWorldPosition( v0 );\n\t\t\t\torbitControls.target.lerp( v0, 0.1 );\n\n\t\t\t}\n\n\t\t\tif ( OOI.head && OOI.sphere && conf.turnHead ) {\n\n\t\t\t\t// turn head\n\t\t\t\tOOI.sphere.getWorldPosition( v0 );\n\t\t\t\tOOI.head.lookAt( v0 );\n\t\t\t\tOOI.head.rotation.set( OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z );\n\n\t\t\t}\n\n\t\t\tif ( conf.ik_solver ) {\n\n\t\t\t\tupdateIK();\n\n\t\t\t}\n\n\t\t\torbitControls.update();\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update(); // fps stats\n\n\t\t}\n\n\t\tfunction updateIK() {\n\n\t\t\tif ( IKSolver ) IKSolver.update();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) object.computeBoundingSphere();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n```\n\nThis example three.js - webgl - inverse kinematics Character model by Aki , furnitures from poly.pizza , scene by abernier . CC0."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - skinning and morphing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - skinning and morphing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet container, stats, clock, gui, mixer, actions, activeAction, previousAction;\n\t\t\tlet camera, scene, renderer, model, face;\n\n\t\t\tconst api = { state: 'Walking' };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 100 );\n\t\t\t\tcamera.position.set( - 5, 3, 10 );\n\t\t\t\tcamera.lookAt( 0, 2, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xe0e0e0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xe0e0e0, 20, 100 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 0, 20, 10 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 200, 40, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/RobotExpressive/RobotExpressive.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tcreateGUI( model, gltf.animations );\n\n\t\t\t\t}, undefined, function ( e ) {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction createGUI( model, animations ) {\n\n\t\t\t\tconst states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing' ];\n\t\t\t\tconst emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\tactions = {};\n\n\t\t\t\tfor ( let i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tconst clip = animations[ i ];\n\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\tactions[ clip.name ] = action;\n\n\t\t\t\t\tif ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {\n\n\t\t\t\t\t\taction.clampWhenFinished = true;\n\t\t\t\t\t\taction.loop = THREE.LoopOnce;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// states\n\n\t\t\t\tconst statesFolder = gui.addFolder( 'States' );\n\n\t\t\t\tconst clipCtrl = statesFolder.add( api, 'state' ).options( states );\n\n\t\t\t\tclipCtrl.onChange( function () {\n\n\t\t\t\t\tfadeToAction( api.state, 0.5 );\n\n\t\t\t\t} );\n\n\t\t\t\tstatesFolder.open();\n\n\t\t\t\t// emotes\n\n\t\t\t\tconst emoteFolder = gui.addFolder( 'Emotes' );\n\n\t\t\t\tfunction createEmoteCallback( name ) {\n\n\t\t\t\t\tapi[ name ] = function () {\n\n\t\t\t\t\t\tfadeToAction( name, 0.2 );\n\n\t\t\t\t\t\tmixer.addEventListener( 'finished', restoreState );\n\n\t\t\t\t\t};\n\n\t\t\t\t\temoteFolder.add( api, name );\n\n\t\t\t\t}\n\n\t\t\t\tfunction restoreState() {\n\n\t\t\t\t\tmixer.removeEventListener( 'finished', restoreState );\n\n\t\t\t\t\tfadeToAction( api.state, 0.2 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < emotes.length; i ++ ) {\n\n\t\t\t\t\tcreateEmoteCallback( emotes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\temoteFolder.open();\n\n\t\t\t\t// expressions\n\n\t\t\t\tface = model.getObjectByName( 'Head_4' );\n\n\t\t\t\tconst expressions = Object.keys( face.morphTargetDictionary );\n\t\t\t\tconst expressionFolder = gui.addFolder( 'Expressions' );\n\n\t\t\t\tfor ( let i = 0; i < expressions.length; i ++ ) {\n\n\t\t\t\t\texpressionFolder.add( face.morphTargetInfluences, i, 0, 1, 0.01 ).name( expressions[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveAction = actions[ 'Walking' ];\n\t\t\t\tactiveAction.play();\n\n\t\t\t\texpressionFolder.open();\n\n\t\t\t}\n\n\t\t\tfunction fadeToAction( name, duration ) {\n\n\t\t\t\tpreviousAction = activeAction;\n\t\t\t\tactiveAction = actions[ name ];\n\n\t\t\t\tif ( previousAction !== activeAction ) {\n\n\t\t\t\t\tpreviousAction.fadeOut( duration );\n\n\t\t\t\t}\n\n\t\t\t\tactiveAction\n\t\t\t\t\t.reset()\n\t\t\t\t\t.setEffectiveTimeScale( 1 )\n\t\t\t\t\t.setEffectiveWeight( 1 )\n\t\t\t\t\t.fadeIn( duration )\n\t\t\t\t\t.play();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst dt = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( dt );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - skinning and morphing The animation system allows clips to be played individually, looped, or crossfaded with other clips. This example shows a character looping in one of several base animation states, then transitioning smoothly to one-time actions. Facial expressions are controlled independently with morph targets. Model by Tom\u00e1s Laulh\u00e9 , modifications by Don McCurdy . CC0."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation skinning morph in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - skinning and morphing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet container, stats, clock, gui, mixer, actions, activeAction, previousAction;\n\t\t\tlet camera, scene, renderer, model, face;\n\n\t\t\tconst api = { state: 'Walking' };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 100 );\n\t\t\t\tcamera.position.set( - 5, 3, 10 );\n\t\t\t\tcamera.lookAt( 0, 2, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xe0e0e0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xe0e0e0, 20, 100 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 0, 20, 10 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 200, 40, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/RobotExpressive/RobotExpressive.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tcreateGUI( model, gltf.animations );\n\n\t\t\t\t}, undefined, function ( e ) {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction createGUI( model, animations ) {\n\n\t\t\t\tconst states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing' ];\n\t\t\t\tconst emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\tactions = {};\n\n\t\t\t\tfor ( let i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tconst clip = animations[ i ];\n\t\t\t\t\tconst action = mixer.clipAction( clip );\n\t\t\t\t\tactions[ clip.name ] = action;\n\n\t\t\t\t\tif ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {\n\n\t\t\t\t\t\taction.clampWhenFinished = true;\n\t\t\t\t\t\taction.loop = THREE.LoopOnce;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// states\n\n\t\t\t\tconst statesFolder = gui.addFolder( 'States' );\n\n\t\t\t\tconst clipCtrl = statesFolder.add( api, 'state' ).options( states );\n\n\t\t\t\tclipCtrl.onChange( function () {\n\n\t\t\t\t\tfadeToAction( api.state, 0.5 );\n\n\t\t\t\t} );\n\n\t\t\t\tstatesFolder.open();\n\n\t\t\t\t// emotes\n\n\t\t\t\tconst emoteFolder = gui.addFolder( 'Emotes' );\n\n\t\t\t\tfunction createEmoteCallback( name ) {\n\n\t\t\t\t\tapi[ name ] = function () {\n\n\t\t\t\t\t\tfadeToAction( name, 0.2 );\n\n\t\t\t\t\t\tmixer.addEventListener( 'finished', restoreState );\n\n\t\t\t\t\t};\n\n\t\t\t\t\temoteFolder.add( api, name );\n\n\t\t\t\t}\n\n\t\t\t\tfunction restoreState() {\n\n\t\t\t\t\tmixer.removeEventListener( 'finished', restoreState );\n\n\t\t\t\t\tfadeToAction( api.state, 0.2 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < emotes.length; i ++ ) {\n\n\t\t\t\t\tcreateEmoteCallback( emotes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\temoteFolder.open();\n\n\t\t\t\t// expressions\n\n\t\t\t\tface = model.getObjectByName( 'Head_4' );\n\n\t\t\t\tconst expressions = Object.keys( face.morphTargetDictionary );\n\t\t\t\tconst expressionFolder = gui.addFolder( 'Expressions' );\n\n\t\t\t\tfor ( let i = 0; i < expressions.length; i ++ ) {\n\n\t\t\t\t\texpressionFolder.add( face.morphTargetInfluences, i, 0, 1, 0.01 ).name( expressions[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveAction = actions[ 'Walking' ];\n\t\t\t\tactiveAction.play();\n\n\t\t\t\texpressionFolder.open();\n\n\t\t\t}\n\n\t\t\tfunction fadeToAction( name, duration ) {\n\n\t\t\t\tpreviousAction = activeAction;\n\t\t\t\tactiveAction = actions[ name ];\n\n\t\t\t\tif ( previousAction !== activeAction ) {\n\n\t\t\t\t\tpreviousAction.fadeOut( duration );\n\n\t\t\t\t}\n\n\t\t\t\tactiveAction\n\t\t\t\t\t.reset()\n\t\t\t\t\t.setEffectiveTimeScale( 1 )\n\t\t\t\t\t.setEffectiveWeight( 1 )\n\t\t\t\t\t.fadeIn( duration )\n\t\t\t\t\t.play();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst dt = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( dt );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - skinning and morphing The animation system allows clips to be played individually, looped, or crossfaded with other clips. This example shows a character looping in one of several base animation states, then transitioning smoothly to one-time actions. Facial expressions are controlled independently with morph targets. Model by Tom\u00e1s Laulh\u00e9 , modifications by Don McCurdy . CC0."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates Multiple animated skinned meshes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Multiple animated skinned meshes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, clock;\n\t\t\tlet model, animations;\n\n\t\t\tconst mixers = [], objects = [];\n\n\t\t\tconst params = {\n\t\t\t\tsharedSkeleton: false\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 2, 3, - 6 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3, 10, - 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 4;\n\t\t\t\tdirLight.shadow.camera.bottom = - 4;\n\t\t\t\tdirLight.shadow.camera.left = - 4;\n\t\t\t\tdirLight.shadow.camera.right = 4;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 200, 200 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tanimations = gltf.animations;\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tsetupDefaultScene();\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'sharedSkeleton' ).onChange( function () {\n\n\t\t\t\t\tclearScene();\n\t\t\t\n\t\t\t\t\tif ( params.sharedSkeleton === true ) {\n\n\t\t\t\t\t\tsetupSharedSkeletonScene();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetupDefaultScene();\n\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction clearScene() {\n\n\t\t\t\tfor ( const mixer of mixers ) {\n\n\t\t\t\t\tmixer.stopAllAction();\n\n\t\t\t\t}\n\n\t\t\t\tmixers.length = 0;\n\n\t\t\t\t//\n\n\t\t\t\tfor ( const object of objects ) {\n\n\t\t\t\t\tscene.remove( object );\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isSkinnedMesh ) child.skeleton.dispose();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setupDefaultScene() {\n\n\t\t\t\t// three cloned models with independent skeletons.\n\t\t\t\t// each model can have its own animation state\n\n\t\t\t\tconst model1 = SkeletonUtils.clone( model );\n\t\t\t\tconst model2 = SkeletonUtils.clone( model );\n\t\t\t\tconst model3 = SkeletonUtils.clone( model );\n\n\t\t\t\tmodel1.position.x = - 2;\n\t\t\t\tmodel2.position.x = 0;\n\t\t\t\tmodel3.position.x = 2;\n\n\t\t\t\tconst mixer1 = new THREE.AnimationMixer( model1 );\n\t\t\t\tconst mixer2 = new THREE.AnimationMixer( model2 );\n\t\t\t\tconst mixer3 = new THREE.AnimationMixer( model3 );\n\n\t\t\t\tmixer1.clipAction( animations[ 0 ] ).play(); // idle\n\t\t\t\tmixer2.clipAction( animations[ 1 ] ).play(); // run\n\t\t\t\tmixer3.clipAction( animations[ 3 ] ).play(); // walk\n\n\t\t\t\tscene.add( model1, model2, model3 );\n\t\t\t\n\t\t\t\tobjects.push( model1, model2, model3 );\n\t\t\t\tmixers.push( mixer1, mixer2, mixer3 );\n\n\t\t\t}\n\n\t\t\tfunction setupSharedSkeletonScene() {\n\n\t\t\t\t// three cloned models with a single shared skeleton.\n\t\t\t\t// all models share the same animation state\n\n\t\t\t\tconst sharedModel = SkeletonUtils.clone( model );\n\t\t\t\tconst shareSkinnedMesh = sharedModel.getObjectByName( 'vanguard_Mesh' );\n\t\t\t\tconst sharedSkeleton = shareSkinnedMesh.skeleton;\n\t\t\t\tconst sharedParentBone = sharedModel.getObjectByName( 'mixamorigHips' );\n\t\t\t\tscene.add( sharedParentBone ); // the bones need to be in the scene for the animation to work\n\n\t\t\t\tconst model1 = shareSkinnedMesh.clone();\n\t\t\t\tconst model2 = shareSkinnedMesh.clone();\n\t\t\t\tconst model3 = shareSkinnedMesh.clone();\n\n\t\t\t\tmodel1.bindMode = THREE.DetachedBindMode;\n\t\t\t\tmodel2.bindMode = THREE.DetachedBindMode;\n\t\t\t\tmodel3.bindMode = THREE.DetachedBindMode;\n\n\t\t\t\tconst identity = new THREE.Matrix4();\n\n\t\t\t\tmodel1.bind( sharedSkeleton, identity );\n\t\t\t\tmodel2.bind( sharedSkeleton, identity );\n\t\t\t\tmodel3.bind( sharedSkeleton, identity );\n\n\t\t\t\tmodel1.position.x = - 2;\n\t\t\t\tmodel2.position.x = 0;\n\t\t\t\tmodel3.position.x = 2;\n\n\t\t\t\t// apply transformation from the glTF asset\n\n\t\t\t\tmodel1.scale.setScalar( 0.01 );\n\t\t\t\tmodel1.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmodel2.scale.setScalar( 0.01 );\n\t\t\t\tmodel2.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmodel3.scale.setScalar( 0.01 );\n\t\t\t\tmodel3.rotation.x = - Math.PI * 0.5;\n\n\t\t\t\t//\n\n\t\t\t\tconst mixer = new THREE.AnimationMixer( sharedParentBone );\n\t\t\t\tmixer.clipAction( animations[ 1 ] ).play();\n\n\t\t\t\tscene.add( sharedParentBone, model1, model2, model3 );\n\t\t\t\n\t\t\t\tobjects.push( sharedParentBone, model1, model2, model3 );\n\t\t\t\tmixers.push( mixer );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( const mixer of mixers ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example This demo shows the usage of SkeletonUtils.clone() and how to setup a shared skeleton. Soldier model from https://www.mixamo.com ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation multiple in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Multiple animated skinned meshes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, clock;\n\t\t\tlet model, animations;\n\n\t\t\tconst mixers = [], objects = [];\n\n\t\t\tconst params = {\n\t\t\t\tsharedSkeleton: false\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 2, 3, - 6 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3, 10, - 10 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 4;\n\t\t\t\tdirLight.shadow.camera.bottom = - 4;\n\t\t\t\tdirLight.shadow.camera.left = - 4;\n\t\t\t\tdirLight.shadow.camera.right = 4;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 40;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 200, 200 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tanimations = gltf.animations;\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) object.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tsetupDefaultScene();\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'sharedSkeleton' ).onChange( function () {\n\n\t\t\t\t\tclearScene();\n\t\t\t\n\t\t\t\t\tif ( params.sharedSkeleton === true ) {\n\n\t\t\t\t\t\tsetupSharedSkeletonScene();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetupDefaultScene();\n\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction clearScene() {\n\n\t\t\t\tfor ( const mixer of mixers ) {\n\n\t\t\t\t\tmixer.stopAllAction();\n\n\t\t\t\t}\n\n\t\t\t\tmixers.length = 0;\n\n\t\t\t\t//\n\n\t\t\t\tfor ( const object of objects ) {\n\n\t\t\t\t\tscene.remove( object );\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isSkinnedMesh ) child.skeleton.dispose();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setupDefaultScene() {\n\n\t\t\t\t// three cloned models with independent skeletons.\n\t\t\t\t// each model can have its own animation state\n\n\t\t\t\tconst model1 = SkeletonUtils.clone( model );\n\t\t\t\tconst model2 = SkeletonUtils.clone( model );\n\t\t\t\tconst model3 = SkeletonUtils.clone( model );\n\n\t\t\t\tmodel1.position.x = - 2;\n\t\t\t\tmodel2.position.x = 0;\n\t\t\t\tmodel3.position.x = 2;\n\n\t\t\t\tconst mixer1 = new THREE.AnimationMixer( model1 );\n\t\t\t\tconst mixer2 = new THREE.AnimationMixer( model2 );\n\t\t\t\tconst mixer3 = new THREE.AnimationMixer( model3 );\n\n\t\t\t\tmixer1.clipAction( animations[ 0 ] ).play(); // idle\n\t\t\t\tmixer2.clipAction( animations[ 1 ] ).play(); // run\n\t\t\t\tmixer3.clipAction( animations[ 3 ] ).play(); // walk\n\n\t\t\t\tscene.add( model1, model2, model3 );\n\t\t\t\n\t\t\t\tobjects.push( model1, model2, model3 );\n\t\t\t\tmixers.push( mixer1, mixer2, mixer3 );\n\n\t\t\t}\n\n\t\t\tfunction setupSharedSkeletonScene() {\n\n\t\t\t\t// three cloned models with a single shared skeleton.\n\t\t\t\t// all models share the same animation state\n\n\t\t\t\tconst sharedModel = SkeletonUtils.clone( model );\n\t\t\t\tconst shareSkinnedMesh = sharedModel.getObjectByName( 'vanguard_Mesh' );\n\t\t\t\tconst sharedSkeleton = shareSkinnedMesh.skeleton;\n\t\t\t\tconst sharedParentBone = sharedModel.getObjectByName( 'mixamorigHips' );\n\t\t\t\tscene.add( sharedParentBone ); // the bones need to be in the scene for the animation to work\n\n\t\t\t\tconst model1 = shareSkinnedMesh.clone();\n\t\t\t\tconst model2 = shareSkinnedMesh.clone();\n\t\t\t\tconst model3 = shareSkinnedMesh.clone();\n\n\t\t\t\tmodel1.bindMode = THREE.DetachedBindMode;\n\t\t\t\tmodel2.bindMode = THREE.DetachedBindMode;\n\t\t\t\tmodel3.bindMode = THREE.DetachedBindMode;\n\n\t\t\t\tconst identity = new THREE.Matrix4();\n\n\t\t\t\tmodel1.bind( sharedSkeleton, identity );\n\t\t\t\tmodel2.bind( sharedSkeleton, identity );\n\t\t\t\tmodel3.bind( sharedSkeleton, identity );\n\n\t\t\t\tmodel1.position.x = - 2;\n\t\t\t\tmodel2.position.x = 0;\n\t\t\t\tmodel3.position.x = 2;\n\n\t\t\t\t// apply transformation from the glTF asset\n\n\t\t\t\tmodel1.scale.setScalar( 0.01 );\n\t\t\t\tmodel1.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmodel2.scale.setScalar( 0.01 );\n\t\t\t\tmodel2.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmodel3.scale.setScalar( 0.01 );\n\t\t\t\tmodel3.rotation.x = - Math.PI * 0.5;\n\n\t\t\t\t//\n\n\t\t\t\tconst mixer = new THREE.AnimationMixer( sharedParentBone );\n\t\t\t\tmixer.clipAction( animations[ 1 ] ).play();\n\n\t\t\t\tscene.add( sharedParentBone, model1, model2, model3 );\n\t\t\t\n\t\t\t\tobjects.push( sharedParentBone, model1, model2, model3 );\n\t\t\t\tmixers.push( mixer );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( const mixer of mixers ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example This demo shows the usage of SkeletonUtils.clone() and how to setup a shared skeleton. Soldier model from https://www.mixamo.com ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - animation - walk"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - walk:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet scene, renderer, camera, floor, orbitControls;\n\t\t\tlet group, followGroup, model, skeleton, mixer, clock;\n\n\t\t\tlet actions;\n\n\t\t\tconst settings = {\n\t\t\t\tshow_skeleton: false,\n\t\t\t\tfixe_transition: true,\n\t\t\t};\n\n\t\t\tconst PI = Math.PI;\n\t\t\tconst PI90 = Math.PI / 2;\n\n\t\t\tconst controls = {\n\n\t\t\t\tkey: [ 0, 0 ],\n\t\t\t\tease: new THREE.Vector3(),\n\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\tup: new THREE.Vector3( 0, 1, 0 ),\n\t\t\t\trotate: new THREE.Quaternion(),\n\t\t\t\tcurrent: 'Idle',\n\t\t\t\tfadeDuration: 0.5,\n\t\t\t\trunVelocity: 5,\n\t\t\t\twalkVelocity: 1.8,\n\t\t\t\trotateSpeed: 0.05,\n\t\t\t\tfloorDecale: 0,\n\n\t\t\t};\n\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 2, - 5 );\n\t\t\t\t//camera.lookAt( 0, 1, 0 );\n\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x5e5d5d );\n\t\t\t\tscene.fog = new THREE.Fog( 0x5e5d5d, 2, 20 );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tfollowGroup = new THREE.Group();\n\t\t\t\tscene.add( followGroup );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 5 );\n\t\t\t\tdirLight.position.set( - 2, 5, - 3 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tconst cam = dirLight.shadow.camera;\n\t\t\t\tcam.top = cam.right = 2;\n\t\t\t\tcam.bottom = cam.left = - 2;\n\t\t\t\tcam.near = 3;\n\t\t\t\tcam.far = 8;\n\t\t\t\tdirLight.shadow.bias = - 0.005;\n\t\t\t\tdirLight.shadow.radius = 4;\n\t\t\t\tfollowGroup.add( dirLight );\n\t\t\t\tfollowGroup.add( dirLight.target );\n\n\t\t\t\t//scene.add( new THREE.CameraHelper( cam ) );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\torbitControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\torbitControls.target.set( 0, 1, 0 );\n\t\t\t\torbitControls.enableDamping = true;\n\t\t\t\torbitControls.enablePan = false;\n\t\t\t\torbitControls.maxPolarAngle = PI90 - 0.05;\n\t\t\t\torbitControls.update();\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\t\t\t\tdocument.addEventListener( 'keyup', onKeyUp );\n\n\n\t\t\t\t// DEMO\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'lobe.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\tscene.environment = texture;\n\t\t\t\t\t\tscene.environmentIntensity = 1.5;\n\n\t\t\t\t\t\tloadModel();\n\t\t\t\t\t\taddFloor();\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction addFloor() {\n\n\t\t\t\tconst size = 50;\n\t\t\t\tconst repeat = 16;\n\n\t\t\t\tconst maxAnisotropy = renderer.capabilities.getMaxAnisotropy();\n\n\t\t\t\tconst floorT = new THREE.TextureLoader().load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tfloorT.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tfloorT.repeat.set( repeat, repeat );\n\t\t\t\tfloorT.wrapS = floorT.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorT.anisotropy = maxAnisotropy;\n\n\t\t\t\tconst floorN = new THREE.TextureLoader().load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorN.repeat.set( repeat, repeat );\n\t\t\t\tfloorN.wrapS = floorN.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorN.anisotropy = maxAnisotropy;\n\n\t\t\t\tconst mat = new THREE.MeshStandardMaterial( { map: floorT, normalMap: floorN, normalScale: new THREE.Vector2( 0.5, 0.5 ), color: 0x404040, depthWrite: false, roughness: 0.85 } );\n\n\t\t\t\tconst g = new THREE.PlaneGeometry( size, size, 50, 50 );\n\t\t\t\tg.rotateX( - PI90 );\n\n\t\t\t\tfloor = new THREE.Mesh( g, mat );\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tcontrols.floorDecale = ( size / repeat ) * 4;\n\n\t\t\t\tconst bulbGeometry = new THREE.SphereGeometry( 0.05, 16, 8 );\n\t\t\t\tconst bulbLight = new THREE.PointLight( 0xffee88, 2, 500, 2 );\n\n\t\t\t\tconst bulbMat = new THREE.MeshStandardMaterial( { emissive: 0xffffee, emissiveIntensity: 1, color: 0x000000 } );\n\t\t\t\tbulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );\n\t\t\t\tbulbLight.position.set( 1, 0.1, - 3 );\n\t\t\t\tbulbLight.castShadow = true;\n\t\t\t\tfloor.add( bulbLight );\n\n\t\t\t}\n\n\t\t\tfunction loadModel() {\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tgroup.add( model );\n\t\t\t\t\tmodel.rotation.y = PI;\n\t\t\t\t\tgroup.rotation.y = PI;\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\t\tif ( object.name == 'vanguard_Mesh' ) {\n\n\t\t\t\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\t\t\t\tobject.receiveShadow = true;\n\t\t\t\t\t\t\t\tobject.material.shadowSide = THREE.DoubleSide;\n\t\t\t\t\t\t\t\t//object.material.envMapIntensity = 0.5;\n\t\t\t\t\t\t\t\tobject.material.metalness = 1.0;\n\t\t\t\t\t\t\t\tobject.material.roughness = 0.2;\n\t\t\t\t\t\t\t\tobject.material.color.set( 1, 1, 1 );\n\t\t\t\t\t\t\t\tobject.material.metalnessMap = object.material.map;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject.material.metalness = 1;\n\t\t\t\t\t\t\t\tobject.material.roughness = 0;\n\t\t\t\t\t\t\t\tobject.material.transparent = true;\n\t\t\t\t\t\t\t\tobject.material.opacity = 0.8;\n\t\t\t\t\t\t\t\tobject.material.color.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcreatePanel();\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst animations = gltf.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tactions = {\n\t\t\t\t\t\tIdle: mixer.clipAction( animations[ 0 ] ),\n\t\t\t\t\t\tWalk: mixer.clipAction( animations[ 3 ] ),\n\t\t\t\t\t\tRun: mixer.clipAction( animations[ 1 ] )\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( const m in actions ) {\n\n\t\t\t\t\t\tactions[ m ].enabled = true;\n\t\t\t\t\t\tactions[ m ].setEffectiveTimeScale( 1 );\n\t\t\t\t\t\tif ( m !== 'Idle' ) actions[ m ].setEffectiveWeight( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tactions.Idle.play();\n\n\t\t\t\t\tanimate();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction updateCharacter( delta ) {\n\n\t\t\t\tconst fade = controls.fadeDuration;\n\t\t\t\tconst key = controls.key;\n\t\t\t\tconst up = controls.up;\n\t\t\t\tconst ease = controls.ease;\n\t\t\t\tconst rotate = controls.rotate;\n\t\t\t\tconst position = controls.position;\n\t\t\t\tconst azimuth = orbitControls.getAzimuthalAngle();\n\n\t\t\t\tconst active = key[ 0 ] === 0 && key[ 1 ] === 0 ? false : true;\n\t\t\t\tconst play = active ? ( key[ 2 ] ? 'Run' : 'Walk' ) : 'Idle';\n\n\t\t\t\t// change animation\n\n\t\t\t\tif ( controls.current != play ) {\n\n\n\n\t\t\t\t\tconst current = actions[ play ];\n\t\t\t\t\tconst old = actions[ controls.current ];\n\t\t\t\t\tcontrols.current = play;\n\n\t\t\t\t\tif ( settings.fixe_transition ) {\n\n\t\t\t\t\t\tcurrent.reset();\n\t\t\t\t\t\tcurrent.weight = 1.0;\n\t\t\t\t\t\tcurrent.stopFading();\n\t\t\t\t\t\told.stopFading();\n\t\t\t\t\t\t// synchro if not idle\n\t\t\t\t\t\tif ( play !== 'Idle' ) current.time = old.time * ( current.getClip().duration / old.getClip().duration );\n\t\t\t\t\t\told._scheduleFading( fade, old.getEffectiveWeight(), 0 );\n\t\t\t\t\t\tcurrent._scheduleFading( fade, current.getEffectiveWeight(), 1 );\n\t\t\t\t\t\tcurrent.play();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetWeight( current, 1.0 );\n\t\t\t\t\t\told.fadeOut( fade );\n\t\t\t\t\t\tcurrent.reset().fadeIn( fade ).play();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// move object\n\n\t\t\t\tif ( controls.current !== 'Idle' ) {\n\n\t\t\t\t\t// run/walk velocity\n\t\t\t\t\tconst velocity = controls.current == 'Run' ? controls.runVelocity : controls.walkVelocity;\n\n\t\t\t\t\t// direction with key\n\t\t\t\t\tease.set( key[ 1 ], 0, key[ 0 ] ).multiplyScalar( velocity * delta );\n\n\t\t\t\t\t// calculate camera direction\n\t\t\t\t\tconst angle = unwrapRad( Math.atan2( ease.x, ease.z ) + azimuth );\n\t\t\t\t\trotate.setFromAxisAngle( up, angle );\n\n\t\t\t\t\t// apply camera angle on ease\n\t\t\t\t\tcontrols.ease.applyAxisAngle( up, azimuth );\n\n\t\t\t\t\tposition.add( ease );\n\t\t\t\t\tcamera.position.add( ease );\n\n\t\t\t\t\tgroup.position.copy( position );\n\t\t\t\t\tgroup.quaternion.rotateTowards( rotate, controls.rotateSpeed );\n\n\t\t\t\t\torbitControls.target.copy( position ).add( { x: 0, y: 1, z: 0 } );\n\t\t\t\t\tfollowGroup.position.copy( position );\n\n\t\t\t\t\t// Move the floor without any limit\n\t\t\t\t\tconst dx = ( position.x - floor.position.x );\n\t\t\t\t\tconst dz = ( position.z - floor.position.z );\n\t\t\t\t\tif ( Math.abs( dx ) > controls.floorDecale ) floor.position.x += dx;\n\t\t\t\t\tif ( Math.abs( dz ) > controls.floorDecale ) floor.position.z += dz;\n\n\t\t\t\t}\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\torbitControls.update();\n\n\t\t\t}\n\n\t\t\tfunction unwrapRad( r ) {\n\n\t\t\t\treturn Math.atan2( Math.sin( r ), Math.cos( r ) );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tpanel.add( settings, 'show_skeleton' ).onChange( ( b ) => {\n\n\t\t\t\t\tskeleton.visible = b;\n\n\t\t\t\t} );\n\n\t\t\t\tpanel.add( settings, 'fixe_transition' );\n\n\t\t\t}\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tconst key = controls.key;\n\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\tcase 'ArrowUp': case 'KeyW': case 'KeyZ': key[ 0 ] = - 1; break;\n\t\t\t\t\tcase 'ArrowDown': case 'KeyS': key[ 0 ] = 1; break;\n\t\t\t\t\tcase 'ArrowLeft': case 'KeyA': case 'KeyQ': key[ 1 ] = - 1; break;\n\t\t\t\t\tcase 'ArrowRight': case 'KeyD': key[ 1 ] = 1; break;\n\t\t\t\t\tcase 'ShiftLeft' : case 'ShiftRight' : key[ 2 ] = 1; break;\n\n\t}\n\n\t\t\t}\n\n\t\t\tfunction onKeyUp( event ) {\n\n\t\t\t\tconst key = controls.key;\n\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\tcase 'ArrowUp': case 'KeyW': case 'KeyZ': key[ 0 ] = key[ 0 ] < 0 ? 0 : key[ 0 ]; break;\n\t\t\t\t\tcase 'ArrowDown': case 'KeyS': key[ 0 ] = key[ 0 ] > 0 ? 0 : key[ 0 ]; break;\n\t\t\t\t\tcase 'ArrowLeft': case 'KeyA': case 'KeyQ': key[ 1 ] = key[ 1 ] < 0 ? 0 : key[ 1 ]; break;\n\t\t\t\t\tcase 'ArrowRight': case 'KeyD': key[ 1 ] = key[ 1 ] > 0 ? 0 : key[ 1 ]; break;\n\t\t\t\t\tcase 'ShiftLeft' : case 'ShiftRight' : key[ 2 ] = 0; break;\n\n\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Render loop\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tupdateCharacter( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Skeletal Animation Walking (model from mixamo.com ) use arrows to control characters"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl animation walk in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - walk:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet scene, renderer, camera, floor, orbitControls;\n\t\t\tlet group, followGroup, model, skeleton, mixer, clock;\n\n\t\t\tlet actions;\n\n\t\t\tconst settings = {\n\t\t\t\tshow_skeleton: false,\n\t\t\t\tfixe_transition: true,\n\t\t\t};\n\n\t\t\tconst PI = Math.PI;\n\t\t\tconst PI90 = Math.PI / 2;\n\n\t\t\tconst controls = {\n\n\t\t\t\tkey: [ 0, 0 ],\n\t\t\t\tease: new THREE.Vector3(),\n\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\tup: new THREE.Vector3( 0, 1, 0 ),\n\t\t\t\trotate: new THREE.Quaternion(),\n\t\t\t\tcurrent: 'Idle',\n\t\t\t\tfadeDuration: 0.5,\n\t\t\t\trunVelocity: 5,\n\t\t\t\twalkVelocity: 1.8,\n\t\t\t\trotateSpeed: 0.05,\n\t\t\t\tfloorDecale: 0,\n\n\t\t\t};\n\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 2, - 5 );\n\t\t\t\t//camera.lookAt( 0, 1, 0 );\n\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x5e5d5d );\n\t\t\t\tscene.fog = new THREE.Fog( 0x5e5d5d, 2, 20 );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tfollowGroup = new THREE.Group();\n\t\t\t\tscene.add( followGroup );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 5 );\n\t\t\t\tdirLight.position.set( - 2, 5, - 3 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tconst cam = dirLight.shadow.camera;\n\t\t\t\tcam.top = cam.right = 2;\n\t\t\t\tcam.bottom = cam.left = - 2;\n\t\t\t\tcam.near = 3;\n\t\t\t\tcam.far = 8;\n\t\t\t\tdirLight.shadow.bias = - 0.005;\n\t\t\t\tdirLight.shadow.radius = 4;\n\t\t\t\tfollowGroup.add( dirLight );\n\t\t\t\tfollowGroup.add( dirLight.target );\n\n\t\t\t\t//scene.add( new THREE.CameraHelper( cam ) );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\torbitControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\torbitControls.target.set( 0, 1, 0 );\n\t\t\t\torbitControls.enableDamping = true;\n\t\t\t\torbitControls.enablePan = false;\n\t\t\t\torbitControls.maxPolarAngle = PI90 - 0.05;\n\t\t\t\torbitControls.update();\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\t\t\t\tdocument.addEventListener( 'keyup', onKeyUp );\n\n\n\t\t\t\t// DEMO\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'lobe.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\tscene.environment = texture;\n\t\t\t\t\t\tscene.environmentIntensity = 1.5;\n\n\t\t\t\t\t\tloadModel();\n\t\t\t\t\t\taddFloor();\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction addFloor() {\n\n\t\t\t\tconst size = 50;\n\t\t\t\tconst repeat = 16;\n\n\t\t\t\tconst maxAnisotropy = renderer.capabilities.getMaxAnisotropy();\n\n\t\t\t\tconst floorT = new THREE.TextureLoader().load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tfloorT.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tfloorT.repeat.set( repeat, repeat );\n\t\t\t\tfloorT.wrapS = floorT.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorT.anisotropy = maxAnisotropy;\n\n\t\t\t\tconst floorN = new THREE.TextureLoader().load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorN.repeat.set( repeat, repeat );\n\t\t\t\tfloorN.wrapS = floorN.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorN.anisotropy = maxAnisotropy;\n\n\t\t\t\tconst mat = new THREE.MeshStandardMaterial( { map: floorT, normalMap: floorN, normalScale: new THREE.Vector2( 0.5, 0.5 ), color: 0x404040, depthWrite: false, roughness: 0.85 } );\n\n\t\t\t\tconst g = new THREE.PlaneGeometry( size, size, 50, 50 );\n\t\t\t\tg.rotateX( - PI90 );\n\n\t\t\t\tfloor = new THREE.Mesh( g, mat );\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tcontrols.floorDecale = ( size / repeat ) * 4;\n\n\t\t\t\tconst bulbGeometry = new THREE.SphereGeometry( 0.05, 16, 8 );\n\t\t\t\tconst bulbLight = new THREE.PointLight( 0xffee88, 2, 500, 2 );\n\n\t\t\t\tconst bulbMat = new THREE.MeshStandardMaterial( { emissive: 0xffffee, emissiveIntensity: 1, color: 0x000000 } );\n\t\t\t\tbulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );\n\t\t\t\tbulbLight.position.set( 1, 0.1, - 3 );\n\t\t\t\tbulbLight.castShadow = true;\n\t\t\t\tfloor.add( bulbLight );\n\n\t\t\t}\n\n\t\t\tfunction loadModel() {\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Soldier.glb', function ( gltf ) {\n\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tgroup.add( model );\n\t\t\t\t\tmodel.rotation.y = PI;\n\t\t\t\t\tgroup.rotation.y = PI;\n\n\t\t\t\t\tmodel.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\t\tif ( object.name == 'vanguard_Mesh' ) {\n\n\t\t\t\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\t\t\t\tobject.receiveShadow = true;\n\t\t\t\t\t\t\t\tobject.material.shadowSide = THREE.DoubleSide;\n\t\t\t\t\t\t\t\t//object.material.envMapIntensity = 0.5;\n\t\t\t\t\t\t\t\tobject.material.metalness = 1.0;\n\t\t\t\t\t\t\t\tobject.material.roughness = 0.2;\n\t\t\t\t\t\t\t\tobject.material.color.set( 1, 1, 1 );\n\t\t\t\t\t\t\t\tobject.material.metalnessMap = object.material.map;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject.material.metalness = 1;\n\t\t\t\t\t\t\t\tobject.material.roughness = 0;\n\t\t\t\t\t\t\t\tobject.material.transparent = true;\n\t\t\t\t\t\t\t\tobject.material.opacity = 0.8;\n\t\t\t\t\t\t\t\tobject.material.color.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tskeleton = new THREE.SkeletonHelper( model );\n\t\t\t\t\tskeleton.visible = false;\n\t\t\t\t\tscene.add( skeleton );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcreatePanel();\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst animations = gltf.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tactions = {\n\t\t\t\t\t\tIdle: mixer.clipAction( animations[ 0 ] ),\n\t\t\t\t\t\tWalk: mixer.clipAction( animations[ 3 ] ),\n\t\t\t\t\t\tRun: mixer.clipAction( animations[ 1 ] )\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( const m in actions ) {\n\n\t\t\t\t\t\tactions[ m ].enabled = true;\n\t\t\t\t\t\tactions[ m ].setEffectiveTimeScale( 1 );\n\t\t\t\t\t\tif ( m !== 'Idle' ) actions[ m ].setEffectiveWeight( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tactions.Idle.play();\n\n\t\t\t\t\tanimate();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction updateCharacter( delta ) {\n\n\t\t\t\tconst fade = controls.fadeDuration;\n\t\t\t\tconst key = controls.key;\n\t\t\t\tconst up = controls.up;\n\t\t\t\tconst ease = controls.ease;\n\t\t\t\tconst rotate = controls.rotate;\n\t\t\t\tconst position = controls.position;\n\t\t\t\tconst azimuth = orbitControls.getAzimuthalAngle();\n\n\t\t\t\tconst active = key[ 0 ] === 0 && key[ 1 ] === 0 ? false : true;\n\t\t\t\tconst play = active ? ( key[ 2 ] ? 'Run' : 'Walk' ) : 'Idle';\n\n\t\t\t\t// change animation\n\n\t\t\t\tif ( controls.current != play ) {\n\n\n\n\t\t\t\t\tconst current = actions[ play ];\n\t\t\t\t\tconst old = actions[ controls.current ];\n\t\t\t\t\tcontrols.current = play;\n\n\t\t\t\t\tif ( settings.fixe_transition ) {\n\n\t\t\t\t\t\tcurrent.reset();\n\t\t\t\t\t\tcurrent.weight = 1.0;\n\t\t\t\t\t\tcurrent.stopFading();\n\t\t\t\t\t\told.stopFading();\n\t\t\t\t\t\t// synchro if not idle\n\t\t\t\t\t\tif ( play !== 'Idle' ) current.time = old.time * ( current.getClip().duration / old.getClip().duration );\n\t\t\t\t\t\told._scheduleFading( fade, old.getEffectiveWeight(), 0 );\n\t\t\t\t\t\tcurrent._scheduleFading( fade, current.getEffectiveWeight(), 1 );\n\t\t\t\t\t\tcurrent.play();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetWeight( current, 1.0 );\n\t\t\t\t\t\told.fadeOut( fade );\n\t\t\t\t\t\tcurrent.reset().fadeIn( fade ).play();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// move object\n\n\t\t\t\tif ( controls.current !== 'Idle' ) {\n\n\t\t\t\t\t// run/walk velocity\n\t\t\t\t\tconst velocity = controls.current == 'Run' ? controls.runVelocity : controls.walkVelocity;\n\n\t\t\t\t\t// direction with key\n\t\t\t\t\tease.set( key[ 1 ], 0, key[ 0 ] ).multiplyScalar( velocity * delta );\n\n\t\t\t\t\t// calculate camera direction\n\t\t\t\t\tconst angle = unwrapRad( Math.atan2( ease.x, ease.z ) + azimuth );\n\t\t\t\t\trotate.setFromAxisAngle( up, angle );\n\n\t\t\t\t\t// apply camera angle on ease\n\t\t\t\t\tcontrols.ease.applyAxisAngle( up, azimuth );\n\n\t\t\t\t\tposition.add( ease );\n\t\t\t\t\tcamera.position.add( ease );\n\n\t\t\t\t\tgroup.position.copy( position );\n\t\t\t\t\tgroup.quaternion.rotateTowards( rotate, controls.rotateSpeed );\n\n\t\t\t\t\torbitControls.target.copy( position ).add( { x: 0, y: 1, z: 0 } );\n\t\t\t\t\tfollowGroup.position.copy( position );\n\n\t\t\t\t\t// Move the floor without any limit\n\t\t\t\t\tconst dx = ( position.x - floor.position.x );\n\t\t\t\t\tconst dz = ( position.z - floor.position.z );\n\t\t\t\t\tif ( Math.abs( dx ) > controls.floorDecale ) floor.position.x += dx;\n\t\t\t\t\tif ( Math.abs( dz ) > controls.floorDecale ) floor.position.z += dz;\n\n\t\t\t\t}\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\torbitControls.update();\n\n\t\t\t}\n\n\t\t\tfunction unwrapRad( r ) {\n\n\t\t\t\treturn Math.atan2( Math.sin( r ), Math.cos( r ) );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI( { width: 310 } );\n\n\t\t\t\tpanel.add( settings, 'show_skeleton' ).onChange( ( b ) => {\n\n\t\t\t\t\tskeleton.visible = b;\n\n\t\t\t\t} );\n\n\t\t\t\tpanel.add( settings, 'fixe_transition' );\n\n\t\t\t}\n\n\t\t\tfunction setWeight( action, weight ) {\n\n\t\t\t\taction.enabled = true;\n\t\t\t\taction.setEffectiveTimeScale( 1 );\n\t\t\t\taction.setEffectiveWeight( weight );\n\n\t\t\t}\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tconst key = controls.key;\n\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\tcase 'ArrowUp': case 'KeyW': case 'KeyZ': key[ 0 ] = - 1; break;\n\t\t\t\t\tcase 'ArrowDown': case 'KeyS': key[ 0 ] = 1; break;\n\t\t\t\t\tcase 'ArrowLeft': case 'KeyA': case 'KeyQ': key[ 1 ] = - 1; break;\n\t\t\t\t\tcase 'ArrowRight': case 'KeyD': key[ 1 ] = 1; break;\n\t\t\t\t\tcase 'ShiftLeft' : case 'ShiftRight' : key[ 2 ] = 1; break;\n\n\t}\n\n\t\t\t}\n\n\t\t\tfunction onKeyUp( event ) {\n\n\t\t\t\tconst key = controls.key;\n\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\tcase 'ArrowUp': case 'KeyW': case 'KeyZ': key[ 0 ] = key[ 0 ] < 0 ? 0 : key[ 0 ]; break;\n\t\t\t\t\tcase 'ArrowDown': case 'KeyS': key[ 0 ] = key[ 0 ] > 0 ? 0 : key[ 0 ]; break;\n\t\t\t\t\tcase 'ArrowLeft': case 'KeyA': case 'KeyQ': key[ 1 ] = key[ 1 ] < 0 ? 0 : key[ 1 ]; break;\n\t\t\t\t\tcase 'ArrowRight': case 'KeyD': key[ 1 ] = key[ 1 ] > 0 ? 0 : key[ 1 ]; break;\n\t\t\t\t\tcase 'ShiftLeft' : case 'ShiftRight' : key[ 2 ] = 0; break;\n\n\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Render loop\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tupdateCharacter( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Skeletal Animation Walking (model from mixamo.com ) use arrows to control characters"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates raycaster - batch - lod - bvh"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js raycaster - batch - lod - bvh:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { MapControls } from 'three/addons/controls/MapControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { acceleratedRaycast, computeBatchedBoundsTree } from 'three-mesh-bvh';\n\n\t\t\timport { createRadixSort, extendBatchedMeshPrototype, getBatchedMeshLODCount } from '@three.ez/batched-mesh-extensions';\n\t\t\timport { performanceRangeLOD, simplifyGeometriesByErrorLOD } from '@three.ez/simplify-geometry';\n\n\t\t\t// add and override BatchedMesh methods ( @three.ez/batched-mesh-extensions )\n\t\t\textendBatchedMeshPrototype();\n\n\t\t\t// add the extension functions ( three-mesh-bvh )\n\t\t\tTHREE.Mesh.prototype.raycast = acceleratedRaycast;\n\t\t\tTHREE.BatchedMesh.prototype.computeBoundsTree = computeBatchedBoundsTree;\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst instancesCount = 500000;\n\t\t\tlet batchedMesh;\n\t\t\tlet lastHoveredInstance = null;\n\t\t\tconst lastHoveredColor = new THREE.Color();\n\t\t\tconst yellow = new THREE.Color( 'yellow' );\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst mouse = new THREE.Vector2( 1, 1 );\n\t\t\tconst position = new THREE.Vector3();\n\t\t\tconst quaternion = new THREE.Quaternion();\n\t\t\tconst scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\t// environment\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 600 );\n\t\t\t\tcamera.position.set( 0, 10, 50 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 500, 600 );\n\n\t\t\t\tconst ambient = new THREE.AmbientLight();\n\t\t\t\tscene.add( camera, ambient );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 'white', 2 );\n\t\t\t\tcamera.add( dirLight, dirLight.target );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\traycaster.firstHitOnly = true;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tconst controls = new MapControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 1, 1 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 1, 2 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 1, 3 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 1, 4 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 1, 5 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 2, 1 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 2, 3 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 3, 1 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 4, 1 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 256, 32, 5, 3 )\n\t\t\t\t];\n\n\t\t\t\t// generate 4 LODs (levels of detail) for each geometry\n\t\t\t\tconst geometriesLODArray = await simplifyGeometriesByErrorLOD( geometries, 4, performanceRangeLOD );\n\n\t\t\t\t// create BatchedMesh\n\t\t\t\tconst { vertexCount, indexCount, LODIndexCount } = getBatchedMeshLODCount( geometriesLODArray );\n\t\t\t\tbatchedMesh = new THREE.BatchedMesh( instancesCount, vertexCount, indexCount, new THREE.MeshStandardMaterial( { metalness: 0.2, roughness: 0.2 } ) );\n\t\t\t\n\t\t\t\t// enable radix sort for better performance\n\t\t\t\tbatchedMesh.customSort = createRadixSort( batchedMesh );\n\n\t\t\t\t// add geometries and their LODs to the batched mesh ( all LODs share the same position array )\n\t\t\t\tfor ( let i = 0; i < geometriesLODArray.length; i ++ ) {\n\n\t\t\t\t\tconst geometryLOD = geometriesLODArray[ i ];\n\t\t\t\t\tconst geometryId = batchedMesh.addGeometry( geometryLOD[ 0 ], - 1, LODIndexCount[ i ] );\n\t\t\t\t\tbatchedMesh.addGeometryLOD( geometryId, geometryLOD[ 1 ], 15 );\n\t\t\t\t\tbatchedMesh.addGeometryLOD( geometryId, geometryLOD[ 2 ], 75 );\n\t\t\t\t\tbatchedMesh.addGeometryLOD( geometryId, geometryLOD[ 3 ], 125 );\n\t\t\t\t\tbatchedMesh.addGeometryLOD( geometryId, geometryLOD[ 4 ], 200 );\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// place instances in a 2D grid with randomized rotation and color\n\t\t\t\tconst sqrtCount = Math.ceil( Math.sqrt( instancesCount ) );\n\t\t\t\tconst size = 5.5;\n\t\t\t\tconst start = ( sqrtCount / - 2 * size ) + ( size / 2 );\n\n\t\t\t\tfor ( let i = 0; i < instancesCount; i ++ ) {\n\n\t\t\t\t\tconst r = Math.floor( i / sqrtCount );\n\t\t\t\t\tconst c = i % sqrtCount;\n\t\t\t\t\tconst id = batchedMesh.addInstance( Math.floor( Math.random() * geometriesLODArray.length ) );\n\t\t\t\t\tposition.set( c * size + start, 0, r * size + start );\n\t\t\t\t\tquaternion.random();\n\t\t\t\t\tbatchedMesh.setMatrixAt( id, matrix.compose( position, quaternion, scale ) );\n\t\t\t\t\tbatchedMesh.setColorAt( id, color.setHSL( Math.random(), 0.6, 0.5 ) );\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// compute blas (bottom-level acceleration structure) bvh ( three-mesh-bvh )\n\t\t\t\tbatchedMesh.computeBoundsTree();\n\n\t\t\t\t// compute tlas (top-level acceleration structure) bvh ( @three.ez/batched-mesh-extensions )\n\t\t\t\tbatchedMesh.computeBVH( THREE.WebGLCoordinateSystem );\n\t\t\t\n\t\t\t\tscene.add( batchedMesh );\n\t\t\t\n\t\t\t\t// set up gui\n\t\t\t\tconst config = {\n\t\t\t\t\tfreeze: false,\n\t\t\t\t\tuseBVH: true,\n\t\t\t\t\tuseLOD: true\n\t\t\t\t};\n\t\t\t\n\t\t\t\tconst bvh = batchedMesh.bvh;\n\t\t\t\tconst lods = batchedMesh._geometryInfo.map( x => x.LOD );\n\t\t\t\tconst onBeforeRender = batchedMesh.onBeforeRender;\n\t\t\t\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( batchedMesh, 'instanceCount' ).disable();\n\t\t\t\n\t\t\t\tgui.add( config, 'freeze' ).onChange( v => {\n\n\t\t\t\t\tbatchedMesh.onBeforeRender = v ? () => {} : onBeforeRender;\n\n\t\t\t\t} );\n\n\t\t\t\tconst frustumCullingFolder = gui.addFolder( 'Frustum culling & raycasting' );\n\t\t\t\tfrustumCullingFolder.add( config, 'useBVH' ).onChange( v => {\n\n\t\t\t\t\tbatchedMesh.bvh = v ? bvh : null;\n\n\t\t\t\t} );\n\n\t\t\t\tconst geometriesFolder = gui.addFolder( 'Geometries' );\n\t\t\t\tgeometriesFolder.add( config, 'useLOD' ).onChange( v => {\n\n\t\t\t\t\tconst geometryInfo = batchedMesh._geometryInfo;\n\t\t\t\t\tfor ( let i = 0; i < geometryInfo.length; i ++ ) {\n\n\t\t\t\t\t\tgeometryInfo[ i ].LOD = v ? lods[ i ] : null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\t\t\t\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}\n\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\traycast();\n\n\t\t\t}\n\t\t\t\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction raycast() {\n\n\t\t\t\traycaster.setFromCamera( mouse, camera );\n\t\t\t\tconst intersection = raycaster.intersectObject( batchedMesh );\n\n\t\t\t\tconst batchId = intersection.length > 0 ? intersection[ 0 ].batchId : null;\n\t\t\t\n\t\t\t\tif ( lastHoveredInstance === batchId ) return;\n\n\t\t\t\tif ( lastHoveredInstance ) {\n\n\t\t\t\t\tbatchedMesh.setColorAt( lastHoveredInstance, lastHoveredColor );\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\tif ( batchId ) {\n\n\t\t\t\t\tbatchedMesh.getColorAt( batchId, lastHoveredColor );\n\t\t\t\t\tbatchedMesh.setColorAt( batchId, yellow );\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\tlastHoveredInstance = batchId;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js batch lod bvh - @three.ez/batched-mesh-extensions BatchedMesh with 10 geometries and 500k instances. Each geometry has 5 LODs (4 generated with meshoptimizer). Frustum culling and raycasting are accelerated by using BVHs (TLAS & BLAS). See main project repository for more information and examples on BatchedMesh extensions."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_camera example that demonstrates webgl - cameras"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - cameras:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tlet aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, mesh;\n\t\t\tlet cameraRig, activeCamera, activeHelper;\n\t\t\tlet cameraPerspective, cameraOrtho;\n\t\t\tlet cameraPerspectiveHelper, cameraOrthoHelper;\n\t\t\tconst frustumSize = 600;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );\n\t\t\t\tcamera.position.z = 2500;\n\n\t\t\t\tcameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 1000 );\n\n\t\t\t\tcameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );\n\t\t\t\tscene.add( cameraPerspectiveHelper );\n\n\t\t\t\t//\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );\n\n\t\t\t\tcameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );\n\t\t\t\tscene.add( cameraOrthoHelper );\n\n\t\t\t\t//\n\n\t\t\t\tactiveCamera = cameraPerspective;\n\t\t\t\tactiveHelper = cameraPerspectiveHelper;\n\n\n\t\t\t\t// counteract different front orientation of cameras vs rig\n\n\t\t\t\tcameraOrtho.rotation.y = Math.PI;\n\t\t\t\tcameraPerspective.rotation.y = Math.PI;\n\n\t\t\t\tcameraRig = new THREE.Group();\n\n\t\t\t\tcameraRig.add( cameraPerspective );\n\t\t\t\tcameraRig.add( cameraOrtho );\n\n\t\t\t\tscene.add( cameraRig );\n\n\t\t\t\t//\n\n\t\t\t\tmesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 100, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 50, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tmesh2.position.y = 150;\n\t\t\t\tmesh.add( mesh2 );\n\n\t\t\t\tconst mesh3 = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 5, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tmesh3.position.z = 150;\n\t\t\t\tcameraRig.add( mesh3 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < 10000; i ++ ) {\n\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // x\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // y\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // z\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tconst particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\tcase 79: /*O*/\n\n\t\t\t\t\t\tactiveCamera = cameraOrtho;\n\t\t\t\t\t\tactiveHelper = cameraOrthoHelper;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 80: /*P*/\n\n\t\t\t\t\t\tactiveCamera = cameraPerspective;\n\t\t\t\t\t\tactiveHelper = cameraPerspectiveHelper;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\t\t\t\taspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = 0.5 * aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tcameraPerspective.aspect = 0.5 * aspect;\n\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = - 0.5 * frustumSize * aspect / 2;\n\t\t\t\tcameraOrtho.right = 0.5 * frustumSize * aspect / 2;\n\t\t\t\tcameraOrtho.top = frustumSize / 2;\n\t\t\t\tcameraOrtho.bottom = - frustumSize / 2;\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst r = Date.now() * 0.0005;\n\n\t\t\t\tmesh.position.x = 700 * Math.cos( r );\n\t\t\t\tmesh.position.z = 700 * Math.sin( r );\n\t\t\t\tmesh.position.y = 700 * Math.sin( r );\n\n\t\t\t\tmesh.children[ 0 ].position.x = 70 * Math.cos( 2 * r );\n\t\t\t\tmesh.children[ 0 ].position.z = 70 * Math.sin( r );\n\n\t\t\t\tif ( activeCamera === cameraPerspective ) {\n\n\t\t\t\t\tcameraPerspective.fov = 35 + 30 * Math.sin( 0.5 * r );\n\t\t\t\t\tcameraPerspective.far = mesh.position.length();\n\t\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\t\tcameraPerspectiveHelper.update();\n\t\t\t\t\tcameraPerspectiveHelper.visible = true;\n\n\t\t\t\t\tcameraOrthoHelper.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcameraOrtho.far = mesh.position.length();\n\t\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\t\tcameraOrthoHelper.update();\n\t\t\t\t\tcameraOrthoHelper.visible = true;\n\n\t\t\t\t\tcameraPerspectiveHelper.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\tcameraRig.lookAt( mesh.position );\n\n\t\t\t\t//\n\n\t\t\t\tactiveHelper.visible = false;\n\n\t\t\t\trenderer.setClearColor( 0x000000, 1 );\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.setViewport( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene, activeCamera );\n\n\t\t\t\t//\n\n\t\t\t\tactiveHelper.visible = true;\n\n\t\t\t\trenderer.setClearColor( 0x111111, 1 );\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.setViewport( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - cameras O orthographic P perspective"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_camera example that demonstrates webgl - arraycamera"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - arraycamera:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh;\n\t\t\tconst AMOUNT = 6;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst ASPECT_RATIO = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst WIDTH = ( window.innerWidth / AMOUNT ) * window.devicePixelRatio;\n\t\t\t\tconst HEIGHT = ( window.innerHeight / AMOUNT ) * window.devicePixelRatio;\n\n\t\t\t\tconst cameras = [];\n\n\t\t\t\tfor ( let y = 0; y < AMOUNT; y ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < AMOUNT; x ++ ) {\n\n\t\t\t\t\t\tconst subcamera = new THREE.PerspectiveCamera( 40, ASPECT_RATIO, 0.1, 10 );\n\t\t\t\t\t\tsubcamera.viewport = new THREE.Vector4( Math.floor( x * WIDTH ), Math.floor( y * HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );\n\t\t\t\t\t\tsubcamera.position.x = ( x / AMOUNT ) - 0.5;\n\t\t\t\t\t\tsubcamera.position.y = 0.5 - ( y / AMOUNT );\n\t\t\t\t\t\tsubcamera.position.z = 1.5;\n\t\t\t\t\t\tsubcamera.position.multiplyScalar( 2 );\n\t\t\t\t\t\tsubcamera.lookAt( 0, 0, 0 );\n\t\t\t\t\t\tsubcamera.updateMatrixWorld();\n\t\t\t\t\t\tcameras.push( subcamera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcamera = new THREE.ArrayCamera( cameras );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x999999 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0.5, 0.5, 1 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.zoom = 4; // tighter shadow map\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometryBackground = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst materialBackground = new THREE.MeshPhongMaterial( { color: 0x000066 } );\n\n\t\t\t\tconst background = new THREE.Mesh( geometryBackground, materialBackground );\n\t\t\t\tbackground.receiveShadow = true;\n\t\t\t\tbackground.position.set( 0, 0, - 1 );\n\t\t\t\tscene.add( background );\n\n\t\t\t\tconst geometryCylinder = new THREE.CylinderGeometry( 0.5, 0.5, 1, 32 );\n\t\t\t\tconst materialCylinder = new THREE.MeshPhongMaterial( { color: 0xff0000 } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometryCylinder, materialCylinder );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst ASPECT_RATIO = window.innerWidth / window.innerHeight;\n\t\t\t\tconst WIDTH = ( window.innerWidth / AMOUNT ) * window.devicePixelRatio;\n\t\t\t\tconst HEIGHT = ( window.innerHeight / AMOUNT ) * window.devicePixelRatio;\n\n\t\t\t\tcamera.aspect = ASPECT_RATIO;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tfor ( let y = 0; y < AMOUNT; y ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < AMOUNT; x ++ ) {\n\n\t\t\t\t\t\tconst subcamera = camera.cameras[ AMOUNT * y + x ];\n\n\t\t\t\t\t\tsubcamera.viewport.set(\n\t\t\t\t\t\t\tMath.floor( x * WIDTH ),\n\t\t\t\t\t\t\tMath.floor( y * HEIGHT ),\n\t\t\t\t\t\t\tMath.ceil( WIDTH ),\n\t\t\t\t\t\t\tMath.ceil( HEIGHT ) );\n\n\t\t\t\t\t\tsubcamera.aspect = ASPECT_RATIO;\n\t\t\t\t\t\tsubcamera.updateProjectionMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.x += 0.005;\n\t\t\t\tmesh.rotation.z += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - cameras - logarithmic depth buffer"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - cameras - logarithmic depth buffer:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\t// 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...\n\t\t\tconst NEAR = 1e-6, FAR = 1e27;\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tlet screensplit = .25, screensplit_right = 0;\n\t\t\tconst mouse = [ .5, .5 ];\n\t\t\tlet zoompos = - 100, minzoomspeed = .015;\n\t\t\tlet zoomspeed = minzoomspeed;\n\n\t\t\tlet container, border, stats;\n\t\t\tconst objects = {};\n\n\t\t\t// Generate a number of text labels, from 1\u00b5m in size up to 100,000,000 light years\n\t\t\t// Try to use some descriptive real-world examples of objects at each scale\n\n\t\t\tconst labeldata = [\n\t\t\t\t{ size: .01, scale: 0.0001, label: 'microscopic (1\u00b5m)' }, // FIXME - triangulating text fails at this size, so we scale instead\n\t\t\t\t{ size: .01, scale: 0.1, label: 'minuscule (1mm)' },\n\t\t\t\t{ size: .01, scale: 1.0, label: 'tiny (1cm)' },\n\t\t\t\t{ size: 1, scale: 1.0, label: 'child-sized (1m)' },\n\t\t\t\t{ size: 10, scale: 1.0, label: 'tree-sized (10m)' },\n\t\t\t\t{ size: 100, scale: 1.0, label: 'building-sized (100m)' },\n\t\t\t\t{ size: 1000, scale: 1.0, label: 'medium (1km)' },\n\t\t\t\t{ size: 10000, scale: 1.0, label: 'city-sized (10km)' },\n\t\t\t\t{ size: 3400000, scale: 1.0, label: 'moon-sized (3,400 Km)' },\n\t\t\t\t{ size: 12000000, scale: 1.0, label: 'planet-sized (12,000 km)' },\n\t\t\t\t{ size: 1400000000, scale: 1.0, label: 'sun-sized (1,400,000 km)' },\n\t\t\t\t{ size: 7.47e12, scale: 1.0, label: 'solar system-sized (50Au)' },\n\t\t\t\t{ size: 9.4605284e15, scale: 1.0, label: 'gargantuan (1 light year)' },\n\t\t\t\t{ size: 3.08567758e16, scale: 1.0, label: 'ludicrous (1 parsec)' },\n\t\t\t\t{ size: 1e19, scale: 1.0, label: 'mind boggling (1000 light years)' }\n\t\t\t];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst scene = initScene( font );\n\n\t\t\t\t\t// Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer\n\t\t\t\t\tobjects.normal = initView( scene, 'normal', false );\n\t\t\t\t\tobjects.logzbuf = initView( scene, 'logzbuf', true );\n\n\t\t\t\t\tanimate();\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene\n\t\t\t\tborder = document.getElementById( 'renderer_border' );\n\t\t\t\tborder.addEventListener( 'pointerdown', onBorderPointerDown );\n\n\t\t\t\twindow.addEventListener( 'mousemove', onMouseMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.addEventListener( 'wheel', onMouseWheel );\n\n\t\t\t}\n\n\t\t\tfunction initView( scene, name, logDepthBuf ) {\n\n\t\t\t\tconst framecontainer = document.getElementById( 'container_' + name );\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, screensplit * SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true, logarithmicDepthBuffer: logDepthBuf } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\trenderer.domElement.id = 'renderer_' + name;\n\t\t\t\tframecontainer.appendChild( renderer.domElement );\n\n\t\t\t\treturn { container: framecontainer, renderer: renderer, scene: scene, camera: camera };\n\n\t\t\t}\n\n\t\t\tfunction initScene( font ) {\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x777777 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 100, 100, 100 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst materialargs = {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tspecular: 0x050505,\n\t\t\t\t\tshininess: 50,\n\t\t\t\t\temissive: 0x000000\n\t\t\t\t};\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.5, 24, 12 );\n\n\t\t\t\tfor ( let i = 0; i < labeldata.length; i ++ ) {\n\n\t\t\t\t\tconst scale = labeldata[ i ].scale || 1;\n\n\t\t\t\t\tconst labelgeo = new TextGeometry( labeldata[ i ].label, {\n\t\t\t\t\t\tfont: font,\n\t\t\t\t\t\tsize: labeldata[ i ].size,\n\t\t\t\t\t\tdepth: labeldata[ i ].size / 2\n\t\t\t\t\t} );\n\n\t\t\t\t\tlabelgeo.computeBoundingSphere();\n\n\t\t\t\t\t// center text\n\t\t\t\t\tlabelgeo.translate( - labelgeo.boundingSphere.radius, 0, 0 );\n\n\t\t\t\t\tmaterialargs.color = new THREE.Color().setHSL( Math.random(), 0.5, 0.5 );\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( materialargs );\n\n\t\t\t\t\tconst group = new THREE.Group();\n\t\t\t\t\tgroup.position.z = - labeldata[ i ].size * scale;\n\t\t\t\t\tscene.add( group );\n\n\t\t\t\t\tconst textmesh = new THREE.Mesh( labelgeo, material );\n\t\t\t\t\ttextmesh.scale.set( scale, scale, scale );\n\t\t\t\t\ttextmesh.position.z = - labeldata[ i ].size * scale;\n\t\t\t\t\ttextmesh.position.y = labeldata[ i ].size / 4 * scale;\n\t\t\t\t\tgroup.add( textmesh );\n\n\t\t\t\t\tconst dotmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tdotmesh.position.y = - labeldata[ i ].size / 4 * scale;\n\t\t\t\t\tdotmesh.scale.multiplyScalar( labeldata[ i ].size * scale );\n\t\t\t\t\tgroup.add( dotmesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t\tfunction updateRendererSizes() {\n\n\t\t\t\t// Recalculate size for both renderers when screen size or split location changes\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tscreensplit_right = 1 - screensplit;\n\n\t\t\t\tobjects.normal.renderer.setSize( screensplit * SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tobjects.normal.camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tobjects.normal.camera.updateProjectionMatrix();\n\t\t\t\tobjects.normal.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT );\n\t\t\t\tobjects.normal.container.style.width = ( screensplit * 100 ) + '%';\n\n\t\t\t\tobjects.logzbuf.renderer.setSize( screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tobjects.logzbuf.camera.aspect = screensplit_right * SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tobjects.logzbuf.camera.updateProjectionMatrix();\n\t\t\t\tobjects.logzbuf.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_WIDTH * screensplit, 0, SCREEN_WIDTH * screensplit_right, SCREEN_HEIGHT );\n\t\t\t\tobjects.logzbuf.container.style.width = ( screensplit_right * 100 ) + '%';\n\n\t\t\t\tborder.style.left = ( screensplit * 100 ) + '%';\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\t// Put some limits on zooming\n\t\t\t\tconst minzoom = labeldata[ 0 ].size * labeldata[ 0 ].scale * 1;\n\t\t\t\tconst maxzoom = labeldata[ labeldata.length - 1 ].size * labeldata[ labeldata.length - 1 ].scale * 100;\n\t\t\t\tlet damping = ( Math.abs( zoomspeed ) > minzoomspeed ? .95 : 1.0 );\n\n\t\t\t\t// Zoom out faster the further out you go\n\t\t\t\tconst zoom = THREE.MathUtils.clamp( Math.pow( Math.E, zoompos ), minzoom, maxzoom );\n\t\t\t\tzoompos = Math.log( zoom );\n\n\t\t\t\t// Slow down quickly at the zoom limits\n\t\t\t\tif ( ( zoom == minzoom && zoomspeed < 0 ) || ( zoom == maxzoom && zoomspeed > 0 ) ) {\n\n\t\t\t\t\tdamping = .85;\n\n\t\t\t\t}\n\n\t\t\t\tzoompos += zoomspeed;\n\t\t\t\tzoomspeed *= damping;\n\n\t\t\t\tobjects.normal.camera.position.x = Math.sin( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.position.y = Math.sin( .25 * Math.PI * ( mouse[ 1 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.position.z = Math.cos( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.lookAt( objects.normal.scene.position );\n\n\t\t\t\t// Clone camera settings across both scenes\n\t\t\t\tobjects.logzbuf.camera.position.copy( objects.normal.camera.position );\n\t\t\t\tobjects.logzbuf.camera.quaternion.copy( objects.normal.camera.quaternion );\n\n\t\t\t\t// Update renderer sizes if the split has changed\n\t\t\t\tif ( screensplit_right != 1 - screensplit ) {\n\n\t\t\t\t\tupdateRendererSizes();\n\n\t\t\t\t}\n\n\t\t\t\tobjects.normal.renderer.render( objects.normal.scene, objects.normal.camera );\n\t\t\t\tobjects.logzbuf.renderer.render( objects.logzbuf.scene, objects.logzbuf.camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tupdateRendererSizes();\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerDown() {\n\n\t\t\t\t// activate draggable window resizing bar\n\t\t\t\twindow.addEventListener( 'pointermove', onBorderPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', onBorderPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerMove( ev ) {\n\n\t\t\t\tscreensplit = Math.max( 0, Math.min( 1, ev.clientX / window.innerWidth ) );\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerUp() {\n\n\t\t\t\twindow.removeEventListener( 'pointermove', onBorderPointerMove );\n\t\t\t\twindow.removeEventListener( 'pointerup', onBorderPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onMouseMove( ev ) {\n\n\t\t\t\tmouse[ 0 ] = ev.clientX / window.innerWidth;\n\t\t\t\tmouse[ 1 ] = ev.clientY / window.innerHeight;\n\n\t\t\t}\n\n\t\t\tfunction onMouseWheel( ev ) {\n\n\t\t\t\tconst amount = ev.deltaY;\n\t\t\t\tif ( amount === 0 ) return;\n\t\t\t\tconst dir = amount / Math.abs( amount );\n\t\t\t\tzoomspeed = dir / 10;\n\n\t\t\t\t// Slow down default zoom speed after user starts zooming, to give them more control\n\t\t\t\tminzoomspeed = 0.001;\n\n\t\t\t}\n```\n\nThis example three.js - cameras - logarithmic depth buffer mousewheel to dolly out"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - clipping planes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - clipping planes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, startTime, object, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 16 );\n\n\t\t\t\tcamera.position.set( 0, 1.3, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst spotLight = new THREE.SpotLight( 0xffffff, 60 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.2;\n\t\t\t\tspotLight.position.set( 2, 3, 3 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 3;\n\t\t\t\tspotLight.shadow.camera.far = 10;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0x55505a, 3 );\n\t\t\t\tdirLight.position.set( 0, 3, 0 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 10;\n\n\t\t\t\tdirLight.shadow.camera.right = 1;\n\t\t\t\tdirLight.shadow.camera.left = - 1;\n\t\t\t\tdirLight.shadow.camera.top\t= 1;\n\t\t\t\tdirLight.shadow.camera.bottom = - 1;\n\n\t\t\t\tdirLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// ***** Clipping planes: *****\n\n\t\t\t\tconst localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );\n\t\t\t\tconst globalPlane = new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 0.1 );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x80ee10,\n\t\t\t\t\tshininess: 100,\n\t\t\t\t\tside: THREE.DoubleSide,\n\n\t\t\t\t\t// ***** Clipping setup (material): *****\n\t\t\t\t\tclippingPlanes: [ localPlane ],\n\t\t\t\t\tclipShadows: true,\n\n\t\t\t\t\talphaToCoverage: true,\n\n\t\t\t\t} );\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 0.4, 0.08, 95, 20 );\n\n\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\t\t\tobject.castShadow = true;\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 9, 9, 1, 1 ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xa0adaf, shininess: 150 } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// Renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// ***** Clipping setup (renderer): *****\n\t\t\t\tconst globalPlanes = [ globalPlane ],\n\t\t\t\t\tEmpty = Object.freeze( [] );\n\t\t\t\trenderer.clippingPlanes = Empty; // GUI sets it to globalPlanes\n\t\t\t\trenderer.localClippingEnabled = true;\n\n\t\t\t\t// Stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// Controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI(),\n\t\t\t\t\tprops = {\n\t\t\t\t\t\talphaToCoverage: true,\n\t\t\t\t\t},\n\t\t\t\t\tfolderLocal = gui.addFolder( 'Local Clipping' ),\n\t\t\t\t\tpropsLocal = {\n\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn renderer.localClippingEnabled;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\trenderer.localClippingEnabled = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Shadows'() {\n\n\t\t\t\t\t\t\treturn material.clipShadows;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Shadows'( v ) {\n\n\t\t\t\t\t\t\tmaterial.clipShadows = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Plane'() {\n\n\t\t\t\t\t\t\treturn localPlane.constant;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Plane'( v ) {\n\n\t\t\t\t\t\t\tlocalPlane.constant = v;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tfolderGlobal = gui.addFolder( 'Global Clipping' ),\n\t\t\t\t\tpropsGlobal = {\n\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn renderer.clippingPlanes !== Empty;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\trenderer.clippingPlanes = v ? globalPlanes : Empty;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Plane'() {\n\n\t\t\t\t\t\t\treturn globalPlane.constant;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Plane'( v ) {\n\n\t\t\t\t\t\t\tglobalPlane.constant = v;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\tgui.add( props, 'alphaToCoverage' ).onChange( function ( value ) {\n\n\t\t\t\t\tground.material.alphaToCoverage = value;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t\t\tmaterial.alphaToCoverage = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tfolderLocal.add( propsLocal, 'Enabled' );\n\t\t\t\tfolderLocal.add( propsLocal, 'Shadows' );\n\t\t\t\tfolderLocal.add( propsLocal, 'Plane', 0.3, 1.25 );\n\n\t\t\t\tfolderGlobal.add( propsGlobal, 'Enabled' );\n\t\t\t\tfolderGlobal.add( propsGlobal, 'Plane', - 0.4, 3 );\n\n\t\t\t\t// Start\n\n\t\t\t\tstartTime = Date.now();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst currentTime = Date.now();\n\t\t\t\tconst time = ( currentTime - startTime ) / 1000;\n\n\t\t\t\tobject.position.y = 0.8;\n\t\t\t\tobject.rotation.x = time * 0.5;\n\t\t\t\tobject.rotation.y = time * 0.2;\n\t\t\t\tobject.scale.setScalar( Math.cos( time ) * 0.125 + 0.875 );\n\n\t\t\t\tstats.begin();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.end();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - clipping planes - advanced"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - clipping planes - advanced:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tfunction planesFromMesh( vertices, indices ) {\n\n\t\t\t\t// creates a clipping volume from a convex triangular mesh\n\t\t\t\t// specified by the arrays 'vertices' and 'indices'\n\n\t\t\t\tconst n = indices.length / 3,\n\t\t\t\t\tresult = new Array( n );\n\n\t\t\t\tfor ( let i = 0, j = 0; i < n; ++ i, j += 3 ) {\n\n\t\t\t\t\tconst a = vertices[ indices[ j ] ],\n\t\t\t\t\t\tb = vertices[ indices[ j + 1 ] ],\n\t\t\t\t\t\tc = vertices[ indices[ j + 2 ] ];\n\n\t\t\t\t\tresult[ i ] = new THREE.Plane().\n\t\t\t\t\t\tsetFromCoplanarPoints( a, b, c );\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfunction createPlanes( n ) {\n\n\t\t\t\t// creates an array of n uninitialized plane objects\n\n\t\t\t\tconst result = new Array( n );\n\n\t\t\t\tfor ( let i = 0; i !== n; ++ i )\n\t\t\t\t\tresult[ i ] = new THREE.Plane();\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfunction assignTransformedPlanes( planesOut, planesIn, matrix ) {\n\n\t\t\t\t// sets an array of existing planes to transformed 'planesIn'\n\n\t\t\t\tfor ( let i = 0, n = planesIn.length; i !== n; ++ i )\n\t\t\t\t\tplanesOut[ i ].copy( planesIn[ i ] ).applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfunction cylindricalPlanes( n, innerRadius ) {\n\n\t\t\t\tconst result = createPlanes( n );\n\n\t\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\t\tconst plane = result[ i ],\n\t\t\t\t\t\tangle = i * Math.PI * 2 / n;\n\n\t\t\t\t\tplane.normal.set(\n\t\t\t\t\t\tMath.cos( angle ), 0, Math.sin( angle ) );\n\n\t\t\t\t\tplane.constant = innerRadius;\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tconst planeToMatrix = ( function () {\n\n\t\t\t\t// creates a matrix that aligns X/Y to a given plane\n\n\t\t\t\t// temporaries:\n\t\t\t\tconst xAxis = new THREE.Vector3(),\n\t\t\t\t\tyAxis = new THREE.Vector3(),\n\t\t\t\t\ttrans = new THREE.Vector3();\n\n\t\t\t\treturn function planeToMatrix( plane ) {\n\n\t\t\t\t\tconst zAxis = plane.normal,\n\t\t\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t\t\t// Hughes & Moeller '99\n\t\t\t\t\t// \"Building an Orthonormal Basis from a Unit Vector.\"\n\n\t\t\t\t\tif ( Math.abs( zAxis.x ) > Math.abs( zAxis.z ) ) {\n\n\t\t\t\t\t\tyAxis.set( - zAxis.y, zAxis.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tyAxis.set( 0, - zAxis.z, zAxis.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\txAxis.crossVectors( yAxis.normalize(), zAxis );\n\n\t\t\t\t\tplane.coplanarPoint( trans );\n\t\t\t\t\treturn matrix.set(\n\t\t\t\t\t\txAxis.x, yAxis.x, zAxis.x, trans.x,\n\t\t\t\t\t\txAxis.y, yAxis.y, zAxis.y, trans.y,\n\t\t\t\t\t\txAxis.z, yAxis.z, zAxis.z, trans.z,\n\t\t\t\t\t\t0,\t 0, 0, 1 );\n\n\t\t\t\t};\n\n\t\t\t} )();\n\n\n\t\t\t// A regular tetrahedron for the clipping volume:\n\n\t\t\tconst Vertices = [\n\t\t\t\t\tnew THREE.Vector3( + 1, 0, + Math.SQRT1_2 ),\n\t\t\t\t\tnew THREE.Vector3( - 1, 0, + Math.SQRT1_2 ),\n\t\t\t\t\tnew THREE.Vector3( 0, + 1, - Math.SQRT1_2 ),\n\t\t\t\t\tnew THREE.Vector3( 0, - 1, - Math.SQRT1_2 )\n\t\t\t\t],\n\n\t\t\t\tIndices = [\n\t\t\t\t\t0, 1, 2,\t0, 2, 3,\t0, 3, 1,\t1, 3, 2\n\t\t\t\t],\n\n\t\t\t\tPlanes = planesFromMesh( Vertices, Indices ),\n\t\t\t\tPlaneMatrices = Planes.map( planeToMatrix ),\n\n\t\t\t\tGlobalClippingPlanes = cylindricalPlanes( 5, 2.5 ),\n\n\t\t\t\tEmpty = Object.freeze( [] );\n\n\n\t\t\tlet camera, scene, renderer, startTime, stats,\n\n\t\t\t\tobject, clipMaterial,\n\t\t\t\tvolumeVisualization,\n\t\t\t\tglobalClippingPlanes;\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t36, window.innerWidth / window.innerHeight, 0.25, 16 );\n\n\t\t\t\tcamera.position.set( 0, 1.5, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff ) );\n\n\t\t\t\tconst spotLight = new THREE.SpotLight( 0xffffff, 60 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.2;\n\t\t\t\tspotLight.position.set( 2, 3, 3 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 3;\n\t\t\t\tspotLight.shadow.camera.far = 10;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tdirLight.position.set( 0, 2, 0 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 10;\n\n\t\t\t\tdirLight.shadow.camera.right = 1;\n\t\t\t\tdirLight.shadow.camera.left = - 1;\n\t\t\t\tdirLight.shadow.camera.top\t= 1;\n\t\t\t\tdirLight.shadow.camera.bottom = - 1;\n\n\t\t\t\tdirLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tclipMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xee0a10,\n\t\t\t\t\tshininess: 100,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t// Clipping setup:\n\t\t\t\t\tclippingPlanes: createPlanes( Planes.length ),\n\t\t\t\t\tclipShadows: true\n\t\t\t\t} );\n\n\t\t\t\tconst count = 5 * 5 * 5;\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 0.18, 0.18, 0.18 );\n\t\t\t\tobject = new THREE.InstancedMesh( geometry, clipMaterial, count );\n\t\t\t\tobject.castShadow = true;\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tfor ( let z = - 2; z <= 2; ++ z )\n\t\t\t\t\tfor ( let y = - 2; y <= 2; ++ y )\n\t\t\t\t\t\tfor ( let x = - 2; x <= 2; ++ x ) {\n\n\t\t\t\t\t\t\tmatrix.setPosition( x / 5, y / 5, z / 5 );\n\t\t\t\t\t\t\tobject.setMatrixAt( i ++, matrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\tscene.add( object );\n\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 3, 3, 1, 1 ),\n\n\t\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t\tvolumeVisualization = new THREE.Group();\n\t\t\t\tvolumeVisualization.visible = false;\n\n\t\t\t\tfor ( let i = 0, n = Planes.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( {\n\t\t\t\t\t\tcolor: color.setHSL( i / n, 0.5, 0.5 ).getHex(),\n\t\t\t\t\t\tside: THREE.DoubleSide,\n\n\t\t\t\t\t\topacity: 0.2,\n\t\t\t\t\t\ttransparent: true,\n\n\t\t\t\t\t\t// clip to the others to show the volume (wildly\n\t\t\t\t\t\t// intersecting transparent planes look bad)\n\t\t\t\t\t\tclippingPlanes: clipMaterial.clippingPlanes.\n\t\t\t\t\t\t\tfilter( function ( _, j ) {\n\n\t\t\t\t\t\t\t\treturn j !== i;\n\n\t\t\t\t\t\t\t} )\n\n\t\t\t\t\t\t// no need to enable shadow clipping - the plane\n\t\t\t\t\t\t// visualization does not cast shadows\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( planeGeometry, material );\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\n\t\t\t\t\tvolumeVisualization.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( volumeVisualization );\n\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry,\n\t\t\t\t\tnew THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tcolor: 0xa0adaf, shininess: 10 } ) );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.multiplyScalar( 3 );\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// Renderer\n\n\t\t\t\tconst container = document.body;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\t\t\t\t// Clipping setup:\n\t\t\t\tglobalClippingPlanes = createPlanes( GlobalClippingPlanes.length );\n\t\t\t\trenderer.clippingPlanes = Empty;\n\t\t\t\trenderer.localClippingEnabled = true;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// Stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// Controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 8;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI(),\n\t\t\t\t\tfolder = gui.addFolder( 'Local Clipping' ),\n\t\t\t\t\tprops = {\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn renderer.localClippingEnabled;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\trenderer.localClippingEnabled = v;\n\t\t\t\t\t\t\tif ( ! v ) volumeVisualization.visible = false;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Shadows'() {\n\n\t\t\t\t\t\t\treturn clipMaterial.clipShadows;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Shadows'( v ) {\n\n\t\t\t\t\t\t\tclipMaterial.clipShadows = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Visualize'() {\n\n\t\t\t\t\t\t\treturn volumeVisualization.visible;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Visualize'( v ) {\n\n\t\t\t\t\t\t\tif ( renderer.localClippingEnabled )\n\t\t\t\t\t\t\t\tvolumeVisualization.visible = v;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\tfolder.add( props, 'Enabled' );\n\t\t\t\tfolder.add( props, 'Shadows' );\n\t\t\t\tfolder.add( props, 'Visualize' ).listen();\n\n\t\t\t\tgui.addFolder( 'Global Clipping' ).\n\t\t\t\t\tadd( {\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn renderer.clippingPlanes !== Empty;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\trenderer.clippingPlanes = v ?\n\t\t\t\t\t\t\t\tglobalClippingPlanes : Empty;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 'Enabled' );\n\n\n\t\t\t\t// Start\n\n\t\t\t\tstartTime = Date.now();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction setObjectWorldMatrix( object, matrix ) {\n\n\t\t\t\t// set the orientation of an object based on a world matrix\n\n\t\t\t\tconst parent = object.parent;\n\t\t\t\tscene.updateMatrixWorld();\n\t\t\t\tobject.matrix.copy( parent.matrixWorld ).invert();\n\t\t\t\tobject.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tconst transform = new THREE.Matrix4(),\n\t\t\t\ttmpMatrix = new THREE.Matrix4();\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst currentTime = Date.now(),\n\t\t\t\t\ttime = ( currentTime - startTime ) / 1000;\n\n\t\t\t\tobject.position.y = 1;\n\t\t\t\tobject.rotation.x = time * 0.5;\n\t\t\t\tobject.rotation.y = time * 0.2;\n\n\t\t\t\tobject.updateMatrix();\n\t\t\t\ttransform.copy( object.matrix );\n\n\t\t\t\tconst bouncy = Math.cos( time * .5 ) * 0.5 + 0.7;\n\t\t\t\ttransform.multiply(\n\t\t\t\t\ttmpMatrix.makeScale( bouncy, bouncy, bouncy ) );\n\n\t\t\t\tassignTransformedPlanes(\n\t\t\t\t\tclipMaterial.clippingPlanes, Planes, transform );\n\n\t\t\t\tconst planeMeshes = volumeVisualization.children;\n\n\t\t\t\tfor ( let i = 0, n = planeMeshes.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttmpMatrix.multiplyMatrices( transform, PlaneMatrices[ i ] );\n\t\t\t\t\tsetObjectWorldMatrix( planeMeshes[ i ], tmpMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttransform.makeRotationY( time * 0.1 );\n\n\t\t\t\tassignTransformedPlanes( globalClippingPlanes, GlobalClippingPlanes, transform );\n\n\t\t\t\tstats.begin();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tinit();\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - clipIntersection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - clipIntersection:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst params = {\n\t\t\t\tclipIntersection: true,\n\t\t\t\tplaneConstant: 0,\n\t\t\t\tshowHelpers: false,\n\t\t\t\talphaToCoverage: true,\n\t\t\t};\n\n\t\t\tconst clipPlanes = [\n\t\t\t\tnew THREE.Plane( new THREE.Vector3( 1, 0, 0 ), 0 ),\n\t\t\t\tnew THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0 ),\n\t\t\t\tnew THREE.Plane( new THREE.Vector3( 0, 0, - 1 ), 0 )\n\t\t\t];\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.localClippingEnabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );\n\n\t\t\t\tcamera.position.set( - 1.5, 2.5, 3.0 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use only if there is no animation loop\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xffffff, 0x080808, 4.5 );\n\t\t\t\tlight.position.set( - 1.25, 1, 1.25 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\tconst group = new THREE.Group();\n\n\t\t\t\tfor ( let i = 1; i <= 30; i += 2 ) {\n\n\t\t\t\t\tconst geometry = new THREE.SphereGeometry( i / 30, 48, 24 );\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\n\t\t\t\t\t\tcolor: new THREE.Color().setHSL( Math.random(), 0.5, 0.5, THREE.SRGBColorSpace ),\n\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t\tclippingPlanes: clipPlanes,\n\t\t\t\t\t\tclipIntersection: params.clipIntersection,\n\t\t\t\t\t\talphaToCoverage: true,\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tgroup.add( new THREE.Mesh( geometry, material ) );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\t// helpers\n\n\t\t\t\tconst helpers = new THREE.Group();\n\t\t\t\thelpers.add( new THREE.PlaneHelper( clipPlanes[ 0 ], 2, 0xff0000 ) );\n\t\t\t\thelpers.add( new THREE.PlaneHelper( clipPlanes[ 1 ], 2, 0x00ff00 ) );\n\t\t\t\thelpers.add( new THREE.PlaneHelper( clipPlanes[ 2 ], 2, 0x0000ff ) );\n\t\t\t\thelpers.visible = false;\n\t\t\t\tscene.add( helpers );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'alphaToCoverage' ).onChange( function ( value ) {\n\n\t\t\t\t\tgroup.children.forEach( c => {\n\n\t\t\t\t\t\tc.material.alphaToCoverage = Boolean( value );\n\t\t\t\t\t\tc.material.needsUpdate = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'clipIntersection' ).name( 'clip intersection' ).onChange( function ( value ) {\n\n\t\t\t\t\tconst children = group.children;\n\n\t\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\t\tchildren[ i ].material.clipIntersection = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'planeConstant', - 1, 1 ).step( 0.01 ).name( 'plane constant' ).onChange( function ( value ) {\n\n\t\t\t\t\tfor ( let j = 0; j < clipPlanes.length; j ++ ) {\n\n\t\t\t\t\t\tclipPlanes[ j ].constant = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'showHelpers' ).name( 'show helpers' ).onChange( function ( value ) {\n\n\t\t\t\t\thelpers.visible = value;\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - clipping stencil"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - clipping stencil:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, object, stats;\n\t\t\tlet planes, planeObjects, planeHelpers;\n\t\t\tlet clock;\n\n\t\t\tconst params = {\n\n\t\t\t\tanimate: true,\n\t\t\t\tplaneX: {\n\n\t\t\t\t\tconstant: 0,\n\t\t\t\t\tnegated: false,\n\t\t\t\t\tdisplayHelper: false\n\n\t\t\t\t},\n\t\t\t\tplaneY: {\n\n\t\t\t\t\tconstant: 0,\n\t\t\t\t\tnegated: false,\n\t\t\t\t\tdisplayHelper: false\n\n\t\t\t\t},\n\t\t\t\tplaneZ: {\n\n\t\t\t\t\tconstant: 0,\n\t\t\t\t\tnegated: false,\n\t\t\t\t\tdisplayHelper: false\n\n\t\t\t\t}\n\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction createPlaneStencilGroup( geometry, plane, renderOrder ) {\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tconst baseMat = new THREE.MeshBasicMaterial();\n\t\t\t\tbaseMat.depthWrite = false;\n\t\t\t\tbaseMat.depthTest = false;\n\t\t\t\tbaseMat.colorWrite = false;\n\t\t\t\tbaseMat.stencilWrite = true;\n\t\t\t\tbaseMat.stencilFunc = THREE.AlwaysStencilFunc;\n\n\t\t\t\t// back faces\n\t\t\t\tconst mat0 = baseMat.clone();\n\t\t\t\tmat0.side = THREE.BackSide;\n\t\t\t\tmat0.clippingPlanes = [ plane ];\n\t\t\t\tmat0.stencilFail = THREE.IncrementWrapStencilOp;\n\t\t\t\tmat0.stencilZFail = THREE.IncrementWrapStencilOp;\n\t\t\t\tmat0.stencilZPass = THREE.IncrementWrapStencilOp;\n\n\t\t\t\tconst mesh0 = new THREE.Mesh( geometry, mat0 );\n\t\t\t\tmesh0.renderOrder = renderOrder;\n\t\t\t\tgroup.add( mesh0 );\n\n\t\t\t\t// front faces\n\t\t\t\tconst mat1 = baseMat.clone();\n\t\t\t\tmat1.side = THREE.FrontSide;\n\t\t\t\tmat1.clippingPlanes = [ plane ];\n\t\t\t\tmat1.stencilFail = THREE.DecrementWrapStencilOp;\n\t\t\t\tmat1.stencilZFail = THREE.DecrementWrapStencilOp;\n\t\t\t\tmat1.stencilZPass = THREE.DecrementWrapStencilOp;\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, mat1 );\n\t\t\t\tmesh1.renderOrder = renderOrder;\n\n\t\t\t\tgroup.add( mesh1 );\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 2, 2, 2 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 1.5 ) );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 5, 10, 7.5 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.right = 2;\n\t\t\t\tdirLight.shadow.camera.left = - 2;\n\t\t\t\tdirLight.shadow.camera.top\t= 2;\n\t\t\t\tdirLight.shadow.camera.bottom = - 2;\n\n\t\t\t\tdirLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tplanes = [\n\t\t\t\t\tnew THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 0 ),\n\t\t\t\t\tnew THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0 ),\n\t\t\t\t\tnew THREE.Plane( new THREE.Vector3( 0, 0, - 1 ), 0 )\n\t\t\t\t];\n\n\t\t\t\tplaneHelpers = planes.map( p => new THREE.PlaneHelper( p, 2, 0xffffff ) );\n\t\t\t\tplaneHelpers.forEach( ph => {\n\n\t\t\t\t\tph.visible = false;\n\t\t\t\t\tscene.add( ph );\n\n\t\t\t\t} );\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 0.4, 0.15, 220, 60 );\n\t\t\t\tobject = new THREE.Group();\n\t\t\t\tscene.add( object );\n\n\t\t\t\t// Set up clip plane rendering\n\t\t\t\tplaneObjects = [];\n\t\t\t\tconst planeGeom = new THREE.PlaneGeometry( 4, 4 );\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst poGroup = new THREE.Group();\n\t\t\t\t\tconst plane = planes[ i ];\n\t\t\t\t\tconst stencilGroup = createPlaneStencilGroup( geometry, plane, i + 1 );\n\n\t\t\t\t\t// plane is clipped by the other clipping planes\n\t\t\t\t\tconst planeMat =\n\t\t\t\t\t\tnew THREE.MeshStandardMaterial( {\n\n\t\t\t\t\t\t\tcolor: 0xE91E63,\n\t\t\t\t\t\t\tmetalness: 0.1,\n\t\t\t\t\t\t\troughness: 0.75,\n\t\t\t\t\t\t\tclippingPlanes: planes.filter( p => p !== plane ),\n\n\t\t\t\t\t\t\tstencilWrite: true,\n\t\t\t\t\t\t\tstencilRef: 0,\n\t\t\t\t\t\t\tstencilFunc: THREE.NotEqualStencilFunc,\n\t\t\t\t\t\t\tstencilFail: THREE.ReplaceStencilOp,\n\t\t\t\t\t\t\tstencilZFail: THREE.ReplaceStencilOp,\n\t\t\t\t\t\t\tstencilZPass: THREE.ReplaceStencilOp,\n\n\t\t\t\t\t\t} );\n\t\t\t\t\tconst po = new THREE.Mesh( planeGeom, planeMat );\n\t\t\t\t\tpo.onAfterRender = function ( renderer ) {\n\n\t\t\t\t\t\trenderer.clearStencil();\n\n\t\t\t\t\t};\n\n\t\t\t\t\tpo.renderOrder = i + 1.1;\n\n\t\t\t\t\tobject.add( stencilGroup );\n\t\t\t\t\tpoGroup.add( po );\n\t\t\t\t\tplaneObjects.push( po );\n\t\t\t\t\tscene.add( poGroup );\n\n\t\t\t\t}\n\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\n\t\t\t\t\tcolor: 0xFFC107,\n\t\t\t\t\tmetalness: 0.1,\n\t\t\t\t\troughness: 0.75,\n\t\t\t\t\tclippingPlanes: planes,\n\t\t\t\t\tclipShadows: true,\n\t\t\t\t\tshadowSide: THREE.DoubleSide,\n\n\t\t\t\t} );\n\n\t\t\t\t// add the color\n\t\t\t\tconst clippedColorFront = new THREE.Mesh( geometry, material );\n\t\t\t\tclippedColorFront.castShadow = true;\n\t\t\t\tclippedColorFront.renderOrder = 6;\n\t\t\t\tobject.add( clippedColorFront );\n\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 9, 9, 1, 1 ),\n\t\t\t\t\tnew THREE.ShadowMaterial( { color: 0x000000, opacity: 0.25, side: THREE.DoubleSide } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\n\t\t\t\tground.position.y = - 1;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// Renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, stencil: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setClearColor( 0x263238 );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.localClippingEnabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// Controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 20;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// GUI\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'animate' );\n\n\t\t\t\tconst planeX = gui.addFolder( 'planeX' );\n\t\t\t\tplaneX.add( params.planeX, 'displayHelper' ).onChange( v => planeHelpers[ 0 ].visible = v );\n\t\t\t\tplaneX.add( params.planeX, 'constant' ).min( - 1 ).max( 1 ).onChange( d => planes[ 0 ].constant = d );\n\t\t\t\tplaneX.add( params.planeX, 'negated' ).onChange( () => {\n\n\t\t\t\t\tplanes[ 0 ].negate();\n\t\t\t\t\tparams.planeX.constant = planes[ 0 ].constant;\n\n\t\t\t\t} );\n\t\t\t\tplaneX.open();\n\n\t\t\t\tconst planeY = gui.addFolder( 'planeY' );\n\t\t\t\tplaneY.add( params.planeY, 'displayHelper' ).onChange( v => planeHelpers[ 1 ].visible = v );\n\t\t\t\tplaneY.add( params.planeY, 'constant' ).min( - 1 ).max( 1 ).onChange( d => planes[ 1 ].constant = d );\n\t\t\t\tplaneY.add( params.planeY, 'negated' ).onChange( () => {\n\n\t\t\t\t\tplanes[ 1 ].negate();\n\t\t\t\t\tparams.planeY.constant = planes[ 1 ].constant;\n\n\t\t\t\t} );\n\t\t\t\tplaneY.open();\n\n\t\t\t\tconst planeZ = gui.addFolder( 'planeZ' );\n\t\t\t\tplaneZ.add( params.planeZ, 'displayHelper' ).onChange( v => planeHelpers[ 2 ].visible = v );\n\t\t\t\tplaneZ.add( params.planeZ, 'constant' ).min( - 1 ).max( 1 ).onChange( d => planes[ 2 ].constant = d );\n\t\t\t\tplaneZ.add( params.planeZ, 'negated' ).onChange( () => {\n\n\t\t\t\t\tplanes[ 2 ].negate();\n\t\t\t\t\tparams.planeZ.constant = planes[ 2 ].constant;\n\n\t\t\t\t} );\n\t\t\t\tplaneZ.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( params.animate ) {\n\n\t\t\t\t\tobject.rotation.x += delta * 0.5;\n\t\t\t\t\tobject.rotation.y += delta * 0.2;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < planeObjects.length; i ++ ) {\n\n\t\t\t\t\tconst plane = planes[ i ];\n\t\t\t\t\tconst po = planeObjects[ i ];\n\t\t\t\t\tplane.coplanarPoint( po.position );\n\t\t\t\t\tpo.lookAt(\n\t\t\t\t\t\tpo.position.x - plane.normal.x,\n\t\t\t\t\t\tpo.position.y - plane.normal.y,\n\t\t\t\t\t\tpo.position.z - plane.normal.z,\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tstats.begin();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - solid geometry with clip planes and stencil materials"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - decal splatter"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - decal splatter:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';\n\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tlet renderer, scene, camera, stats;\n\t\t\tlet mesh;\n\t\t\tlet raycaster;\n\t\t\tlet line;\n\n\t\t\tconst intersection = {\n\t\t\t\tintersects: false,\n\t\t\t\tpoint: new THREE.Vector3(),\n\t\t\t\tnormal: new THREE.Vector3()\n\t\t\t};\n\t\t\tconst mouse = new THREE.Vector2();\n\t\t\tconst intersects = [];\n\n\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\tconst decalDiffuse = textureLoader.load( 'textures/decal/decal-diffuse.png' );\n\t\t\tdecalDiffuse.colorSpace = THREE.SRGBColorSpace;\n\t\t\tconst decalNormal = textureLoader.load( 'textures/decal/decal-normal.jpg' );\n\n\t\t\tconst decalMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\tspecular: 0x444444,\n\t\t\t\tmap: decalDiffuse,\n\t\t\t\tnormalMap: decalNormal,\n\t\t\t\tnormalScale: new THREE.Vector2( 1, 1 ),\n\t\t\t\tshininess: 30,\n\t\t\t\ttransparent: true,\n\t\t\t\tdepthTest: true,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tpolygonOffset: true,\n\t\t\t\tpolygonOffsetFactor: - 4,\n\t\t\t\twireframe: false\n\t\t\t} );\n\n\t\t\tconst decals = [];\n\t\t\tlet mouseHelper;\n\t\t\tconst position = new THREE.Vector3();\n\t\t\tconst orientation = new THREE.Euler();\n\t\t\tconst size = new THREE.Vector3( 10, 10, 10 );\n\n\t\t\tconst params = {\n\t\t\t\tminScale: 10,\n\t\t\t\tmaxScale: 20,\n\t\t\t\trotate: true,\n\t\t\t\tclear: function () {\n\n\t\t\t\t\tremoveDecals();\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 120;\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 50;\n\t\t\t\tcontrols.maxDistance = 200;\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x666666 ) );\n\n\t\t\t\tconst dirLight1 = new THREE.DirectionalLight( 0xffddcc, 3 );\n\t\t\t\tdirLight1.position.set( 1, 0.75, 0.5 );\n\t\t\t\tscene.add( dirLight1 );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0xccccff, 3 );\n\t\t\t\tdirLight2.position.set( - 1, 0.75, - 0.5 );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );\n\n\t\t\t\tline = new THREE.Line( geometry, new THREE.LineBasicMaterial() );\n\t\t\t\tscene.add( line );\n\n\t\t\t\tloadLeePerrySmith();\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\tmouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );\n\t\t\t\tmouseHelper.visible = false;\n\t\t\t\tscene.add( mouseHelper );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tlet moved = false;\n\n\t\t\t\tcontrols.addEventListener( 'change', function () {\n\n\t\t\t\t\tmoved = true;\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'pointerdown', function () {\n\n\t\t\t\t\tmoved = false;\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'pointerup', function ( event ) {\n\n\t\t\t\t\tif ( moved === false ) {\n\n\t\t\t\t\t\tcheckIntersection( event.clientX, event.clientY );\n\n\t\t\t\t\t\tif ( intersection.intersects ) shoot();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\t\tif ( event.isPrimary ) {\n\n\t\t\t\t\t\tcheckIntersection( event.clientX, event.clientY );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction checkIntersection( x, y ) {\n\n\t\t\t\t\tif ( mesh === undefined ) return;\n\n\t\t\t\t\tmouse.x = ( x / window.innerWidth ) * 2 - 1;\n\t\t\t\t\tmouse.y = - ( y / window.innerHeight ) * 2 + 1;\n\n\t\t\t\t\traycaster.setFromCamera( mouse, camera );\n\t\t\t\t\traycaster.intersectObject( mesh, false, intersects );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tconst p = intersects[ 0 ].point;\n\t\t\t\t\t\tmouseHelper.position.copy( p );\n\t\t\t\t\t\tintersection.point.copy( p );\n\n\t\t\t\t\t\tconst normalMatrix = new THREE.Matrix3().getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\t\tconst n = intersects[ 0 ].face.normal.clone();\n\t\t\t\t\t\tn.applyNormalMatrix( normalMatrix );\n\t\t\t\t\t\tn.multiplyScalar( 10 );\n\t\t\t\t\t\tn.add( intersects[ 0 ].point );\n\n\t\t\t\t\t\tintersection.normal.copy( intersects[ 0 ].face.normal );\n\t\t\t\t\t\tmouseHelper.lookAt( n );\n\n\t\t\t\t\t\tconst positions = line.geometry.attributes.position;\n\t\t\t\t\t\tpositions.setXYZ( 0, p.x, p.y, p.z );\n\t\t\t\t\t\tpositions.setXYZ( 1, n.x, n.y, n.z );\n\t\t\t\t\t\tpositions.needsUpdate = true;\n\n\t\t\t\t\t\tintersection.intersects = true;\n\n\t\t\t\t\t\tintersects.length = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tintersection.intersects = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'minScale', 1, 30 );\n\t\t\t\tgui.add( params, 'maxScale', 1, 30 );\n\t\t\t\tgui.add( params, 'rotate' );\n\t\t\t\tgui.add( params, 'clear' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction loadLeePerrySmith() {\n\n\t\t\t\tconst map = textureLoader.load( 'models/gltf/LeePerrySmith/Map-COL.jpg' );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst specularMap = textureLoader.load( 'models/gltf/LeePerrySmith/Map-SPEC.jpg' );\n\t\t\t\tconst normalMap = textureLoader.load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\n\t\t\t\tloader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tspecular: 0x111111,\n\t\t\t\t\t\tmap: map,\n\t\t\t\t\t\tspecularMap: specularMap,\n\t\t\t\t\t\tnormalMap: normalMap,\n\t\t\t\t\t\tshininess: 25\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\tmesh.scale.multiplyScalar( 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction shoot() {\n\n\t\t\t\tposition.copy( intersection.point );\n\t\t\t\torientation.copy( mouseHelper.rotation );\n\n\t\t\t\tif ( params.rotate ) orientation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\tconst scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );\n\t\t\t\tsize.set( scale, scale, scale );\n\n\t\t\t\tconst material = decalMaterial.clone();\n\t\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t\t\tconst m = new THREE.Mesh( new DecalGeometry( mesh, position, orientation, size ), material );\n\t\t\t\tm.renderOrder = decals.length; // give decals a fixed render order\n\n\t\t\t\tdecals.push( m );\n\n\t\t\t\tmesh.attach( m );\n\n\t\t\t}\n\n\t\t\tfunction removeDecals() {\n\n\t\t\t\tdecals.forEach( function ( d ) {\n\n\t\t\t\t\tmesh.remove( d );\n\n\t\t\t\t} );\n\n\t\t\t\tdecals.length = 0;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - decal splatter click to shoot"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - Depth Texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - Depth Texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls, stats;\n\t\t\tlet target;\n\t\t\tlet postScene, postCamera, postMaterial;\n\n\t\t\tconst params = {\n\t\t\t\tformat: THREE.DepthFormat,\n\t\t\t\ttype: THREE.UnsignedShortType,\n\t\t\t\tsamples: 0,\n\t\t\t};\n\n\t\t\tconst formats = { DepthFormat: THREE.DepthFormat, DepthStencilFormat: THREE.DepthStencilFormat };\n\t\t\tconst types = { UnsignedShortType: THREE.UnsignedShortType, UnsignedIntType: THREE.UnsignedIntType, FloatType: THREE.FloatType };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 50 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t// Create a render target with depth texture\n\t\t\t\tsetupRenderTarget();\n\n\t\t\t\t// Our scene\n\t\t\t\tsetupScene();\n\n\t\t\t\t// Setup post-processing step\n\t\t\t\tsetupPost();\n\n\t\t\t\tonWindowResize();\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\n\t\t\t\tgui.add( params, 'format', formats ).onChange( setupRenderTarget );\n\t\t\t\tgui.add( params, 'type', types ).onChange( setupRenderTarget );\n\t\t\t\tgui.add( params, 'samples', 0, 16, 1 ).onChange( setupRenderTarget );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction setupRenderTarget() {\n\n\t\t\t\tif ( target ) target.dispose();\n\n\t\t\t\tconst format = parseInt( params.format );\n\t\t\t\tconst type = parseInt( params.type );\n\t\t\t\tconst samples = parseInt( params.samples );\n\n\t\t\t\tconst dpr = renderer.getPixelRatio();\n\t\t\t\ttarget = new THREE.WebGLRenderTarget( window.innerWidth * dpr, window.innerHeight * dpr );\n\t\t\t\ttarget.texture.minFilter = THREE.NearestFilter;\n\t\t\t\ttarget.texture.magFilter = THREE.NearestFilter;\n\t\t\t\ttarget.texture.generateMipmaps = false;\n\t\t\t\ttarget.stencilBuffer = ( format === THREE.DepthStencilFormat ) ? true : false;\n\t\t\t\ttarget.samples = samples;\n\n\t\t\t\ttarget.depthTexture = new THREE.DepthTexture();\n\t\t\t\ttarget.depthTexture.format = format;\n\t\t\t\ttarget.depthTexture.type = type;\n\n\t\t\t}\n\n\t\t\tfunction setupPost() {\n\n\t\t\t\t// Setup post processing stage\n\t\t\t\tpostCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\t\tpostMaterial = new THREE.ShaderMaterial( {\n\t\t\t\t\tvertexShader: document.querySelector( '#post-vert' ).textContent.trim(),\n\t\t\t\t\tfragmentShader: document.querySelector( '#post-frag' ).textContent.trim(),\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tcameraNear: { value: camera.near },\n\t\t\t\t\t\tcameraFar: { value: camera.far },\n\t\t\t\t\t\ttDiffuse: { value: null },\n\t\t\t\t\t\ttDepth: { value: null }\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tconst postPlane = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst postQuad = new THREE.Mesh( postPlane, postMaterial );\n\t\t\t\tpostScene = new THREE.Scene();\n\t\t\t\tpostScene.add( postQuad );\n\n\t\t\t}\n\n\t\t\tfunction setupScene() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 1, 0.3, 128, 64 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 'blue' } );\n\n\t\t\t\tconst count = 50;\n\t\t\t\tconst scale = 5;\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst r = Math.random() * 2.0 * Math.PI;\n\t\t\t\t\tconst z = ( Math.random() * 2.0 ) - 1.0;\n\t\t\t\t\tconst zScale = Math.sqrt( 1.0 - z * z ) * scale;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set(\n\t\t\t\t\t\tMath.cos( r ) * zScale,\n\t\t\t\t\t\tMath.sin( r ) * zScale,\n\t\t\t\t\t\tz * scale\n\t\t\t\t\t);\n\t\t\t\t\tmesh.rotation.set( Math.random(), Math.random(), Math.random() );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tconst dpr = renderer.getPixelRatio();\n\t\t\t\ttarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// render scene into target\n\t\t\t\trenderer.setRenderTarget( target );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// render post FX\n\t\t\t\tpostMaterial.uniforms.tDiffuse.value = target.texture;\n\t\t\t\tpostMaterial.uniforms.tDepth.value = target.depthTexture;\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.render( postScene, postCamera );\n\n\t\t\t\tcontrols.update(); // required because damping is enabled\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example threejs webgl - depth texture Stores render target depth in a texture attachment. Created by @mattdesl . Your browser does not support WEBGL_depth_texture . This demo will not work."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - effects - anaglyph"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - effects - anaglyph:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';\n\n\t\t\tlet container, camera, scene, renderer, effect;\n\n\t\t\tconst spheres = [];\n\n\t\t\tlet mouseX = 0;\n\t\t\tlet mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tconst path = 'textures/cube/pisa/';\n\t\t\t\tconst format = '.png';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.1, 32, 16 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = Math.random() * 10 - 5;\n\t\t\t\t\tmesh.position.y = Math.random() * 10 - 5;\n\t\t\t\t\tmesh.position.z = Math.random() * 10 - 5;\n\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tspheres.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst width = window.innerWidth || 2;\n\t\t\t\tconst height = window.innerHeight || 2;\n\n\t\t\t\teffect = new AnaglyphEffect( renderer );\n\t\t\t\teffect.setSize( width, height );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\teffect.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX ) / 100;\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) / 100;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = 0.0001 * Date.now();\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0, il = spheres.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst sphere = spheres[ i ];\n\n\t\t\t\t\tsphere.position.x = 5 * Math.cos( timer + i );\n\t\t\t\t\tsphere.position.y = 5 * Math.sin( timer + i * 1.1 );\n\n\t\t\t\t}\n\n\t\t\t\teffect.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - effects - anaglyph skybox by Paul Debevec"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - effects - ascii"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - effects - ascii:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\n\t\t\tlet camera, controls, scene, renderer, effect;\n\n\t\t\tlet sphere, plane;\n\n\t\t\tconst start = Date.now();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.y = 150;\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0, 0, 0 );\n\n\t\t\t\tconst pointLight1 = new THREE.PointLight( 0xffffff, 3, 0, 0 );\n\t\t\t\tpointLight1.position.set( 500, 500, 500 );\n\t\t\t\tscene.add( pointLight1 );\n\n\t\t\t\tconst pointLight2 = new THREE.PointLight( 0xffffff, 1, 0, 0 );\n\t\t\t\tpointLight2.position.set( - 500, - 500, - 500 );\n\t\t\t\tscene.add( pointLight2 );\n\n\t\t\t\tsphere = new THREE.Mesh( new THREE.SphereGeometry( 200, 20, 10 ), new THREE.MeshPhongMaterial( { flatShading: true } ) );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\t// Plane\n\n\t\t\t\tplane = new THREE.Mesh( new THREE.PlaneGeometry( 400, 400 ), new THREE.MeshBasicMaterial( { color: 0xe0e0e0 } ) );\n\t\t\t\tplane.position.y = - 200;\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\teffect = new AsciiEffect( renderer, ' .:-+*=%@#', { invert: true } );\n\t\t\t\teffect.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\teffect.domElement.style.color = 'white';\n\t\t\t\teffect.domElement.style.backgroundColor = 'black';\n\n\t\t\t\t// Special case: append effect.domElement, instead of renderer.domElement.\n\t\t\t\t// AsciiEffect creates a custom domElement (a div container) where the ASCII elements are placed.\n\n\t\t\t\tdocument.body.appendChild( effect.domElement );\n\n\t\t\t\tcontrols = new TrackballControls( camera, effect.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\teffect.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = Date.now() - start;\n\n\t\t\t\tsphere.position.y = Math.abs( Math.sin( timer * 0.002 ) ) * 150;\n\t\t\t\tsphere.rotation.x = timer * 0.0003;\n\t\t\t\tsphere.rotation.z = timer * 0.0002;\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\teffect.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - effects - ascii"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - effects - parallax barrier"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - effects - parallax barrier:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';\n\n\t\t\tlet container, camera, scene, renderer, effect;\n\n\t\t\tconst spheres = [];\n\n\t\t\tlet mouseX = 0;\n\t\t\tlet mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tconst path = 'textures/cube/pisa/';\n\t\t\t\tconst format = '.png';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.1, 32, 16 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = Math.random() * 10 - 5;\n\t\t\t\t\tmesh.position.y = Math.random() * 10 - 5;\n\t\t\t\t\tmesh.position.z = Math.random() * 10 - 5;\n\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tspheres.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst width = window.innerWidth || 2;\n\t\t\t\tconst height = window.innerHeight || 2;\n\n\t\t\t\teffect = new ParallaxBarrierEffect( renderer );\n\t\t\t\teffect.setSize( width, height );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\teffect.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX ) / 100;\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) / 100;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = 0.0001 * Date.now();\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0, il = spheres.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst sphere = spheres[ i ];\n\n\t\t\t\t\tsphere.position.x = 5 * Math.cos( timer + i );\n\t\t\t\t\tsphere.position.y = 5 * Math.sin( timer + i * 1.1 );\n\n\t\t\t\t}\n\n\t\t\t\teffect.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - effects - parallax barrier skybox by Paul Debevec"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - effects - stereo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - effects - stereo:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { StereoEffect } from 'three/addons/effects/StereoEffect.js';\n\n\t\t\tlet container, camera, scene, renderer, effect;\n\n\t\t\tconst spheres = [];\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );\n\t\t\t\tcamera.position.z = 3200;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/Park3Med/' )\n\t\t\t\t\t.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 100, 32, 16 );\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/Park3Med/' )\n\t\t\t\t\t.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );\n\t\t\t\ttextureCube.mapping = THREE.CubeRefractionMapping;\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.95 } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 10000 - 5000;\n\t\t\t\t\tmesh.position.y = Math.random() * 10000 - 5000;\n\t\t\t\t\tmesh.position.z = Math.random() * 10000 - 5000;\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tspheres.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\teffect = new StereoEffect( renderer );\n\t\t\t\teffect.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\teffect.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX ) * 10;\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) * 10;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = 0.0001 * Date.now();\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0, il = spheres.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst sphere = spheres[ i ];\n\n\t\t\t\t\tsphere.position.x = 5000 * Math.cos( timer + i );\n\t\t\t\t\tsphere.position.y = 5000 * Math.sin( timer + i * 1.1 );\n\n\t\t\t\t}\n\n\t\t\t\teffect.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - effects - stereo. skybox by Jochum Skoglund"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - framebuffer - texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - framebuffer - texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet line, sprite, texture;\n\n\t\t\tlet cameraOrtho, sceneOrtho;\n\n\t\t\tlet offset = 0;\n\n\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\tconst textureSize = 128 * dpr;\n\t\t\tconst vector = new THREE.Vector2();\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t//\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, width / height, 1, 1000 );\n\t\t\t\tcamera.position.z = 20;\n\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 10 );\n\t\t\t\tcameraOrtho.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tsceneOrtho = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst points = GeometryUtils.gosper( 8 );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst positionAttribute = new THREE.Float32BufferAttribute( points, 3 );\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.center();\n\n\t\t\t\tconst colorAttribute = new THREE.BufferAttribute( new Float32Array( positionAttribute.array.length ), 3 );\n\t\t\t\tcolorAttribute.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\tconst material = new THREE.LineBasicMaterial( { vertexColors: true } );\n\n\t\t\t\tline = new THREE.Line( geometry, material );\n\t\t\t\tline.scale.setScalar( 0.05 );\n\t\t\t\tscene.add( line );\n\n\t\t\t\t//\n\n\t\t\t\ttexture = new THREE.FramebufferTexture( textureSize, textureSize );\n\n\t\t\t\t//\n\n\t\t\t\tconst spriteMaterial = new THREE.SpriteMaterial( { map: texture } );\n\t\t\t\tsprite = new THREE.Sprite( spriteMaterial );\n\t\t\t\tsprite.scale.set( textureSize, textureSize, 1 );\n\t\t\t\tsceneOrtho.add( sprite );\n\n\t\t\t\tupdateSpritePosition();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst selection = document.getElementById( 'selection' );\n\t\t\t\tconst controls = new OrbitControls( camera, selection );\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = - width / 2;\n\t\t\t\tcameraOrtho.right = width / 2;\n\t\t\t\tcameraOrtho.top = height / 2;\n\t\t\t\tcameraOrtho.bottom = - height / 2;\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tupdateSpritePosition();\n\n\t\t\t}\n\n\t\t\tfunction updateSpritePosition() {\n\n\t\t\t\tconst halfWidth = window.innerWidth / 2;\n\t\t\t\tconst halfHeight = window.innerHeight / 2;\n\n\t\t\t\tconst halfImageWidth = textureSize / 2;\n\t\t\t\tconst halfImageHeight = textureSize / 2;\n\n\t\t\t\tsprite.position.set( - halfWidth + halfImageWidth, halfHeight - halfImageHeight, 1 );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst colorAttribute = line.geometry.getAttribute( 'color' );\n\t\t\t\tupdateColors( colorAttribute );\n\n\t\t\t\t// scene rendering\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// calculate start position for copying data\n\n\t\t\t\tvector.x = ( window.innerWidth * dpr / 2 ) - ( textureSize / 2 );\n\t\t\t\tvector.y = ( window.innerHeight * dpr / 2 ) - ( textureSize / 2 );\n\n\t\t\t\trenderer.copyFramebufferToTexture( texture, vector );\n\n\t\t\t\trenderer.clearDepth();\n\t\t\t\trenderer.render( sceneOrtho, cameraOrtho );\n\n\t\t\t}\n\n\t\t\tfunction updateColors( colorAttribute ) {\n\n\t\t\t\tconst l = colorAttribute.count;\n\n\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\tconst h = ( ( offset + i ) % l ) / l;\n\n\t\t\t\t\tcolor.setHSL( h, 1, 0.5 );\n\t\t\t\t\tcolorAttribute.setX( i, color.r );\n\t\t\t\t\tcolorAttribute.setY( i, color.g );\n\t\t\t\t\tcolorAttribute.setZ( i, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttribute.needsUpdate = true;\n\n\t\t\t\toffset -= 25;\n\n\t\t\t}\n```\n\nThis example three.js framebuffer to texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - geometries"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometries:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';\n\t\t\timport { plane, klein, mobius } from 'three/addons/geometries/ParametricFunctions.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.y = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tlet object, geometry;\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xcccccc, 1.5 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 2.5, 0, 0 );\n\t\t\t\tcamera.add( pointLight );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\tmap.wrapS = map.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmap.anisotropy = 16;\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { map: map, side: THREE.DoubleSide } );\n\n\t\t\t\t//\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.SphereGeometry( 75, 20, 10 ), material );\n\t\t\t\tobject.position.set( - 300, 0, 300 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.IcosahedronGeometry( 75 ), material );\n\t\t\t\tobject.position.set( - 100, 0, 300 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.OctahedronGeometry( 75 ), material );\n\t\t\t\tobject.position.set( 100, 0, 300 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.TetrahedronGeometry( 75 ), material );\n\t\t\t\tobject.position.set( 300, 0, 300 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t//\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100, 4, 4 ), material );\n\t\t\t\tobject.position.set( - 300, 0, 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100, 4, 4, 4 ), material );\n\t\t\t\tobject.position.set( - 100, 0, 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.CircleGeometry( 50, 20, 0, Math.PI * 2 ), material );\n\t\t\t\tobject.position.set( 100, 0, 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.RingGeometry( 10, 50, 20, 5, 0, Math.PI * 2 ), material );\n\t\t\t\tobject.position.set( 300, 0, 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t//\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.CylinderGeometry( 25, 75, 100, 40, 5 ), material );\n\t\t\t\tobject.position.set( - 300, 0, - 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst points = [];\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( Math.sin( i * 0.2 ) * Math.sin( i * 0.1 ) * 15 + 50, ( i - 5 ) * 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.LatheGeometry( points, 20 ), material );\n\t\t\t\tobject.position.set( - 100, 0, - 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.TorusGeometry( 50, 20, 20, 20 ), material );\n\t\t\t\tobject.position.set( 100, 0, - 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.TorusKnotGeometry( 50, 10, 50, 20 ), material );\n\t\t\t\tobject.position.set( 300, 0, - 100 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t//\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.CapsuleGeometry( 20, 50 ), material );\n\t\t\t\tobject.position.set( - 300, 0, - 300 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tgeometry = new ParametricGeometry( plane, 10, 10 );\n\t\t\t\tgeometry.scale( 100, 100, 100 );\n\t\t\t\tgeometry.center();\n\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\t\t\tobject.position.set( - 100, 0, - 300 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tgeometry = new ParametricGeometry( klein, 20, 20 );\n\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\t\t\tobject.position.set( 100, 0, - 300 );\n\t\t\t\tobject.scale.multiplyScalar( 5 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tgeometry = new ParametricGeometry( mobius, 20, 20 );\n\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\t\t\tobject.position.set( 300, 0, - 300 );\n\t\t\t\tobject.scale.multiplyScalar( 30 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.0001;\n\n\t\t\t\tcamera.position.x = Math.cos( timer ) * 800;\n\t\t\t\tcamera.position.z = Math.sin( timer ) * 800;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.rotation.x = timer * 5;\n\t\t\t\t\t\tobject.rotation.y = timer * 2.5;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - geometries"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - vertex colors"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - vertex colors:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 1800;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 0, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// shadow\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 128;\n\t\t\t\tcanvas.height = 128;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tconst gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );\n\t\t\t\tgradient.addColorStop( 0.1, 'rgba(210,210,210,1)' );\n\t\t\t\tgradient.addColorStop( 1, 'rgba(255,255,255,1)' );\n\n\t\t\t\tcontext.fillStyle = gradient;\n\t\t\t\tcontext.fillRect( 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconst shadowTexture = new THREE.CanvasTexture( canvas );\n\n\t\t\t\tconst shadowMaterial = new THREE.MeshBasicMaterial( { map: shadowTexture } );\n\t\t\t\tconst shadowGeo = new THREE.PlaneGeometry( 300, 300, 1, 1 );\n\n\t\t\t\tlet shadowMesh;\n\n\t\t\t\tshadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );\n\t\t\t\tshadowMesh.position.y = - 250;\n\t\t\t\tshadowMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\tshadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );\n\t\t\t\tshadowMesh.position.y = - 250;\n\t\t\t\tshadowMesh.position.x = - 400;\n\t\t\t\tshadowMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\tshadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );\n\t\t\t\tshadowMesh.position.y = - 250;\n\t\t\t\tshadowMesh.position.x = 400;\n\t\t\t\tshadowMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\tconst radius = 200;\n\n\t\t\t\tconst geometry1 = new THREE.IcosahedronGeometry( radius, 1 );\n\n\t\t\t\tconst count = geometry1.attributes.position.count;\n\t\t\t\tconst arrayType = ( typeof Float16Array !== 'undefined' ) ? Float16Array : Float32Array;\n\t\t\t\tgeometry1.setAttribute( 'color', new THREE.BufferAttribute( new arrayType( count * 3 ), 3 ) );\n\n\t\t\t\tconst geometry2 = geometry1.clone();\n\t\t\t\tconst geometry3 = geometry1.clone();\n\n\t\t\t\tconst color = new THREE.Color();\n\t\t\t\tconst positions1 = geometry1.attributes.position;\n\t\t\t\tconst positions2 = geometry2.attributes.position;\n\t\t\t\tconst positions3 = geometry3.attributes.position;\n\t\t\t\tconst colors1 = geometry1.attributes.color;\n\t\t\t\tconst colors2 = geometry2.attributes.color;\n\t\t\t\tconst colors3 = geometry3.attributes.color;\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tcolor.setHSL( ( positions1.getY( i ) / radius + 1 ) / 2, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors1.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setHSL( 0, ( positions2.getY( i ) / radius + 1 ) / 2, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors2.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setRGB( 1, 0.8 - ( positions3.getY( i ) / radius + 1 ) / 2, 0, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors3.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tflatShading: true,\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tshininess: 0\n\t\t\t\t} );\n\n\t\t\t\tconst wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );\n\n\t\t\t\tlet mesh = new THREE.Mesh( geometry1, material );\n\t\t\t\tlet wireframe = new THREE.Mesh( geometry1, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\t\t\t\tmesh.position.x = - 400;\n\t\t\t\tmesh.rotation.x = - 1.87;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry2, material );\n\t\t\t\twireframe = new THREE.Mesh( geometry2, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\t\t\t\tmesh.position.x = 400;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry3, material );\n\t\t\t\twireframe = new THREE.Mesh( geometry3, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - vertex colors"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - lookup table"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lookup table:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Lut } from 'three/addons/math/Lut.js';\n\n\t\t\tlet container;\n\n\t\t\tlet perpCamera, orthoCamera, renderer, lut;\n\n\t\t\tlet mesh, sprite;\n\t\t\tlet scene, uiScene;\n\n\t\t\tlet params;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tuiScene = new THREE.Scene();\n\n\t\t\t\tlut = new Lut();\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tperpCamera = new THREE.PerspectiveCamera( 60, width / height, 1, 100 );\n\t\t\t\tperpCamera.position.set( 0, 0, 10 );\n\t\t\t\tscene.add( perpCamera );\n\n\t\t\t\torthoCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 1, 2 );\n\t\t\t\torthoCamera.position.set( 0.5, 0, 1 );\n\n\t\t\t\tsprite = new THREE.Sprite( new THREE.SpriteMaterial( {\n\t\t\t\t\tmap: new THREE.CanvasTexture( lut.createCanvas() )\n\t\t\t\t} ) );\n\t\t\t\tsprite.material.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tsprite.scale.x = 0.125;\n\t\t\t\tuiScene.add( sprite );\n\n\t\t\t\tmesh = new THREE.Mesh( undefined, new THREE.MeshLambertMaterial( {\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tcolor: 0xF5F5F5,\n\t\t\t\t\tvertexColors: true\n\t\t\t\t} ) );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tparams\t= {\n\t\t\t\t\tcolorMap: 'rainbow',\n\t\t\t\t};\n\t\t\t\tloadModel( );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 3, 0, 0 );\n\t\t\t\tperpCamera.add( pointLight );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst controls = new OrbitControls( perpCamera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'colorMap', [ 'rainbow', 'cooltowarm', 'blackbody', 'grayscale' ] ).onChange( function () {\n\n\t\t\t\t\tupdateColors();\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tperpCamera.aspect = width / height;\n\t\t\t\tperpCamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( scene, perpCamera );\n\t\t\t\trenderer.render( uiScene, orthoCamera );\n\n\t\t\t}\n\n\t\t\tfunction loadModel( ) {\n\n\t\t\t\tconst loader = new THREE.BufferGeometryLoader();\n\t\t\t\tloader.load( 'models/json/pressure.json', function ( geometry ) {\n\n\t\t\t\t\tgeometry.center();\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\t// default color attribute\n\t\t\t\t\tconst colors = [];\n\n\t\t\t\t\tfor ( let i = 0, n = geometry.attributes.position.count; i < n; ++ i ) {\n\n\t\t\t\t\t\tcolors.push( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t\tmesh.geometry = geometry;\n\t\t\t\t\tupdateColors();\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction updateColors() {\n\n\t\t\t\tlut.setColorMap( params.colorMap );\n\n\t\t\t\tlut.setMax( 2000 );\n\t\t\t\tlut.setMin( 0 );\n\n\t\t\t\tconst geometry = mesh.geometry;\n\t\t\t\tconst pressures = geometry.attributes.pressure;\n\t\t\t\tconst colors = geometry.attributes.color;\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < pressures.array.length; i ++ ) {\n\n\t\t\t\t\tconst colorValue = pressures.array[ i ];\n\n\t\t\t\t\tcolor.copy( lut.getColor( colorValue ) ).convertSRGBToLinear();\n\n\t\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tcolors.needsUpdate = true;\n\n\t\t\t\tconst map = sprite.material.map;\n\t\t\t\tlut.updateCanvas( map.image );\n\t\t\t\tmap.needsUpdate = true;\n\n\t\t\t}\n```\n\nThis example three.js webgl - lookup table vertex color values from a range of data values"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - convex geometry"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - convex geometry:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tlet group, camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 15, 20, 30 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 20;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\t// ambient light\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x666666 ) );\n\n\t\t\t\t// point light\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 3, 0, 0 );\n\t\t\t\tcamera.add( light );\n\n\t\t\t\t// helper\n\n\t\t\t\tscene.add( new THREE.AxesHelper( 20 ) );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst texture = loader.load( 'textures/sprites/disc.png' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\t// points\n\n\t\t\t\tlet dodecahedronGeometry = new THREE.DodecahedronGeometry( 10 );\n\n\t\t\t\t// if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data\n\n\t\t\t\tdodecahedronGeometry.deleteAttribute( 'normal' );\n\t\t\t\tdodecahedronGeometry.deleteAttribute( 'uv' );\n\n\t\t\t\tdodecahedronGeometry = BufferGeometryUtils.mergeVertices( dodecahedronGeometry );\n\n\t\t\t\tconst vertices = [];\n\t\t\t\tconst positionAttribute = dodecahedronGeometry.getAttribute( 'position' );\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tconst vertex = new THREE.Vector3();\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tvertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\tconst pointsMaterial = new THREE.PointsMaterial( {\n\t\t\t\t\tcolor: 0x0080ff,\n\t\t\t\t\tmap: texture,\n\t\t\t\t\tsize: 1,\n\t\t\t\t\talphaTest: 0.5\n\t\t\t\t} );\n\n\t\t\t\tconst pointsGeometry = new THREE.BufferGeometry().setFromPoints( vertices );\n\n\t\t\t\tconst points = new THREE.Points( pointsGeometry, pointsMaterial );\n\t\t\t\tgroup.add( points );\n\n\t\t\t\t// convex hull\n\n\t\t\t\tconst meshMaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\topacity: 0.5,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tconst meshGeometry = new ConvexGeometry( vertices );\n\n\t\t\t\tconst mesh = new THREE.Mesh( meshGeometry, meshMaterial );\n\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tgroup.rotation.y += 0.005;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - convex geometry"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates geometry - csg"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js geometry - csg:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { SUBTRACTION, INTERSECTION, ADDITION, Brush, Evaluator } from 'three-bvh-csg';\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet baseBrush, brush;\n\t\t\tlet core;\n\t\t\tlet result, evaluator, wireframe;\n\n\t\t\tconst params = {\n\n\t\t\t\toperation: SUBTRACTION,\n\t\t\t\tuseGroups: true,\n\t\t\t\twireframe: false,\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// environment\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 1, 1, 1 ).normalize().multiplyScalar( 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xfce4ec );\n\n\t\t\t\t// lights\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0xffffff, 0xbfd4d2, 3 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 0.3 );\n\t\t\t\tdirectionalLight.position.set( 1, 4, 3 ).multiplyScalar( 3 );\n\t\t\t\tdirectionalLight.castShadow = true;\n\t\t\t\tdirectionalLight.shadow.mapSize.setScalar( 2048 );\n\t\t\t\tdirectionalLight.shadow.bias = - 1e-4;\n\t\t\t\tdirectionalLight.shadow.normalBias = 1e-4;\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// add shadow plane\n\t\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry(),\n\t\t\t\t\tnew THREE.ShadowMaterial( {\n\t\t\t\t\t\tcolor: 0xd81b60,\n\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t\topacity: 0.075,\n\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t} ),\n\t\t\t\t);\n\t\t\t\tplane.position.y = - 3;\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tplane.scale.setScalar( 10 );\n\t\t\t\tplane.receiveShadow = true;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// create brushes\n\t\t\t\tevaluator = new Evaluator();\n\n\t\t\t\tbaseBrush = new Brush(\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 2, 3 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tflatShading: true,\n\n\t\t\t\t\t\tpolygonOffset: true,\n\t\t\t\t\t\tpolygonOffsetUnits: 1,\n\t\t\t\t\t\tpolygonOffsetFactor: 1,\n\t\t\t\t\t} ),\n\t\t\t\t);\n\n\t\t\t\tbrush = new Brush(\n\t\t\t\t\tnew THREE.CylinderGeometry( 1, 1, 5, 45 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0x80cbc4,\n\n\t\t\t\t\t\tpolygonOffset: true,\n\t\t\t\t\t\tpolygonOffsetUnits: 1,\n\t\t\t\t\t\tpolygonOffsetFactor: 1,\n\n\t\t\t\t\t} ),\n\t\t\t\t);\n\n\t\t\t\tcore = new Brush(\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 0.15, 1 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tflatShading: true,\n\t\t\t\t\t\tcolor: 0xff9800,\n\t\t\t\t\t\temissive: 0xff9800,\n\t\t\t\t\t\temissiveIntensity: 0.35,\n\n\t\t\t\t\t\tpolygonOffset: true,\n\t\t\t\t\t\tpolygonOffsetUnits: 1,\n\t\t\t\t\t\tpolygonOffsetFactor: 1,\n\n\t\t\t\t\t} ),\n\t\t\t\t);\n\t\t\t\tcore.castShadow = true;\n\t\t\t\tscene.add( core );\n\n\t\t\t\t// create wireframe\n\t\t\t\twireframe = new THREE.Mesh(\n\t\t\t\t\tundefined,\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x009688, wireframe: true } ),\n\t\t\t\t);\n\t\t\t\tscene.add( wireframe );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 75;\n\n\t\t\t\t// set up gui\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'operation', { SUBTRACTION, INTERSECTION, ADDITION } );\n\t\t\t\tgui.add( params, 'wireframe' );\n\t\t\t\tgui.add( params, 'useGroups' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t}\n\n\t\t\tfunction updateCSG() {\n\n\t\t\t\tevaluator.useGroups = params.useGroups;\n\t\t\t\tresult = evaluator.evaluate( baseBrush, brush, params.operation, result );\n\n\t\t\t\tresult.castShadow = true;\n\t\t\t\tresult.receiveShadow = true;\n\t\t\t\tscene.add( result );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// update the transforms\n\t\t\t\tconst t = window.performance.now() + 9000;\n\t\t\t\tbaseBrush.rotation.x = t * 0.0001;\n\t\t\t\tbaseBrush.rotation.y = t * 0.00025;\n\t\t\t\tbaseBrush.rotation.z = t * 0.0005;\n\t\t\t\tbaseBrush.updateMatrixWorld();\n\n\t\t\t\tbrush.rotation.x = t * - 0.0002;\n\t\t\t\tbrush.rotation.y = t * - 0.0005;\n\t\t\t\tbrush.rotation.z = t * - 0.001;\n\n\t\t\t\tconst s = 0.5 + 0.5 * ( 1 + Math.sin( t * 0.001 ) );\n\t\t\t\tbrush.scale.set( s, 1, s );\n\t\t\t\tbrush.updateMatrixWorld();\n\n\t\t\t\t// update the csg\n\t\t\t\tupdateCSG();\n\n\t\t\t\twireframe.geometry = result.geometry;\n\t\t\t\twireframe.visible = params.wireframe;\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js bvh csg - three-bvh-csg See main project repository for more information and examples on constructive solid geometry."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - cube"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - cube:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/crate.gif' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.x += 0.005;\n\t\t\t\tmesh.rotation.y += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - extrude shapes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - extrude shapes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst info = document.createElement( 'div' );\n\t\t\t\tinfo.style.position = 'absolute';\n\t\t\t\tinfo.style.top = '10px';\n\t\t\t\tinfo.style.width = '100%';\n\t\t\t\tinfo.style.textAlign = 'center';\n\t\t\t\tinfo.style.color = '#fff';\n\t\t\t\tinfo.innerHTML = '<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> webgl - geometry extrude shapes';\n\t\t\t\tdocument.body.appendChild( info );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 500 );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 200;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x666666 ) );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 3, 0, 0 );\n\t\t\t\tlight.position.copy( camera.position );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\tconst closedSpline = new THREE.CatmullRomCurve3( [\n\t\t\t\t\tnew THREE.Vector3( - 60, - 100, 60 ),\n\t\t\t\t\tnew THREE.Vector3( - 60, 20, 60 ),\n\t\t\t\t\tnew THREE.Vector3( - 60, 120, 60 ),\n\t\t\t\t\tnew THREE.Vector3( 60, 20, - 60 ),\n\t\t\t\t\tnew THREE.Vector3( 60, - 100, - 60 )\n\t\t\t\t] );\n\n\t\t\t\tclosedSpline.curveType = 'catmullrom';\n\t\t\t\tclosedSpline.closed = true;\n\n\t\t\t\tconst extrudeSettings1 = {\n\t\t\t\t\tsteps: 100,\n\t\t\t\t\tbevelEnabled: false,\n\t\t\t\t\textrudePath: closedSpline\n\t\t\t\t};\n\n\n\t\t\t\tconst pts1 = [], count = 3;\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst l = 20;\n\n\t\t\t\t\tconst a = 2 * i / count * Math.PI;\n\n\t\t\t\t\tpts1.push( new THREE.Vector2( Math.cos( a ) * l, Math.sin( a ) * l ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst shape1 = new THREE.Shape( pts1 );\n\n\t\t\t\tconst geometry1 = new THREE.ExtrudeGeometry( shape1, extrudeSettings1 );\n\n\t\t\t\tconst material1 = new THREE.MeshLambertMaterial( { color: 0xb00000, wireframe: false } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry1, material1 );\n\n\t\t\t\tscene.add( mesh1 );\n\n\n\t\t\t\t//\n\n\n\t\t\t\tconst randomPoints = [];\n\n\t\t\t\tfor ( let i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\trandomPoints.push( new THREE.Vector3( ( i - 4.5 ) * 50, THREE.MathUtils.randFloat( - 50, 50 ), THREE.MathUtils.randFloat( - 50, 50 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst randomSpline = new THREE.CatmullRomCurve3( randomPoints );\n\n\t\t\t\t//\n\n\t\t\t\tconst extrudeSettings2 = {\n\t\t\t\t\tsteps: 200,\n\t\t\t\t\tbevelEnabled: false,\n\t\t\t\t\textrudePath: randomSpline\n\t\t\t\t};\n\n\n\t\t\t\tconst pts2 = [], numPts = 5;\n\n\t\t\t\tfor ( let i = 0; i < numPts * 2; i ++ ) {\n\n\t\t\t\t\tconst l = i % 2 == 1 ? 10 : 20;\n\n\t\t\t\t\tconst a = i / numPts * Math.PI;\n\n\t\t\t\t\tpts2.push( new THREE.Vector2( Math.cos( a ) * l, Math.sin( a ) * l ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst shape2 = new THREE.Shape( pts2 );\n\n\t\t\t\tconst geometry2 = new THREE.ExtrudeGeometry( shape2, extrudeSettings2 );\n\n\t\t\t\tconst material2 = new THREE.MeshLambertMaterial( { color: 0xff8000, wireframe: false } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry2, material2 );\n\n\t\t\t\tscene.add( mesh2 );\n\n\n\t\t\t\t//\n\n\t\t\t\tconst materials = [ material1, material2 ];\n\n\t\t\t\tconst extrudeSettings3 = {\n\t\t\t\t\tdepth: 20,\n\t\t\t\t\tsteps: 1,\n\t\t\t\t\tbevelEnabled: true,\n\t\t\t\t\tbevelThickness: 2,\n\t\t\t\t\tbevelSize: 4,\n\t\t\t\t\tbevelSegments: 1\n\t\t\t\t};\n\n\t\t\t\tconst geometry3 = new THREE.ExtrudeGeometry( shape2, extrudeSettings3 );\n\n\t\t\t\tconst mesh3 = new THREE.Mesh( geometry3, materials );\n\n\t\t\t\tmesh3.position.set( 50, 100, 50 );\n\n\t\t\t\tscene.add( mesh3 );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - spline extrusion"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - spline extrusion:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport * as Curves from 'three/addons/curves/CurveExtras.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer, splineCamera, cameraHelper, cameraEye;\n\n\t\t\tconst direction = new THREE.Vector3();\n\t\t\tconst binormal = new THREE.Vector3();\n\t\t\tconst normal = new THREE.Vector3();\n\t\t\tconst position = new THREE.Vector3();\n\t\t\tconst lookAt = new THREE.Vector3();\n\n\t\t\tconst pipeSpline = new THREE.CatmullRomCurve3( [\n\t\t\t\tnew THREE.Vector3( 0, 10, - 10 ), new THREE.Vector3( 10, 0, - 10 ),\n\t\t\t\tnew THREE.Vector3( 20, 0, 0 ), new THREE.Vector3( 30, 0, 10 ),\n\t\t\t\tnew THREE.Vector3( 30, 0, 20 ), new THREE.Vector3( 20, 0, 30 ),\n\t\t\t\tnew THREE.Vector3( 10, 0, 30 ), new THREE.Vector3( 0, 0, 30 ),\n\t\t\t\tnew THREE.Vector3( - 10, 10, 30 ), new THREE.Vector3( - 10, 20, 30 ),\n\t\t\t\tnew THREE.Vector3( 0, 30, 30 ), new THREE.Vector3( 10, 30, 30 ),\n\t\t\t\tnew THREE.Vector3( 20, 30, 15 ), new THREE.Vector3( 10, 30, 10 ),\n\t\t\t\tnew THREE.Vector3( 0, 30, 10 ), new THREE.Vector3( - 10, 20, 10 ),\n\t\t\t\tnew THREE.Vector3( - 10, 10, 10 ), new THREE.Vector3( 0, 0, 10 ),\n\t\t\t\tnew THREE.Vector3( 10, - 10, 10 ), new THREE.Vector3( 20, - 15, 10 ),\n\t\t\t\tnew THREE.Vector3( 30, - 15, 10 ), new THREE.Vector3( 40, - 15, 10 ),\n\t\t\t\tnew THREE.Vector3( 50, - 15, 10 ), new THREE.Vector3( 60, 0, 10 ),\n\t\t\t\tnew THREE.Vector3( 70, 0, 0 ), new THREE.Vector3( 80, 0, 0 ),\n\t\t\t\tnew THREE.Vector3( 90, 0, 0 ), new THREE.Vector3( 100, 0, 0 )\n\t\t\t] );\n\n\t\t\tconst sampleClosedSpline = new THREE.CatmullRomCurve3( [\n\t\t\t\tnew THREE.Vector3( 0, - 40, - 40 ),\n\t\t\t\tnew THREE.Vector3( 0, 40, - 40 ),\n\t\t\t\tnew THREE.Vector3( 0, 140, - 40 ),\n\t\t\t\tnew THREE.Vector3( 0, 40, 40 ),\n\t\t\t\tnew THREE.Vector3( 0, - 40, 40 )\n\t\t\t] );\n\n\t\t\tsampleClosedSpline.curveType = 'catmullrom';\n\t\t\tsampleClosedSpline.closed = true;\n\n\t\t\t// Keep a dictionary of Curve instances\n\t\t\tconst splines = {\n\t\t\t\tGrannyKnot: new Curves.GrannyKnot(),\n\t\t\t\tHeartCurve: new Curves.HeartCurve( 3.5 ),\n\t\t\t\tVivianiCurve: new Curves.VivianiCurve( 70 ),\n\t\t\t\tKnotCurve: new Curves.KnotCurve(),\n\t\t\t\tHelixCurve: new Curves.HelixCurve(),\n\t\t\t\tTrefoilKnot: new Curves.TrefoilKnot(),\n\t\t\t\tTorusKnot: new Curves.TorusKnot( 20 ),\n\t\t\t\tCinquefoilKnot: new Curves.CinquefoilKnot( 20 ),\n\t\t\t\tTrefoilPolynomialKnot: new Curves.TrefoilPolynomialKnot( 14 ),\n\t\t\t\tFigureEightPolynomialKnot: new Curves.FigureEightPolynomialKnot(),\n\t\t\t\tDecoratedTorusKnot4a: new Curves.DecoratedTorusKnot4a(),\n\t\t\t\tDecoratedTorusKnot4b: new Curves.DecoratedTorusKnot4b(),\n\t\t\t\tDecoratedTorusKnot5a: new Curves.DecoratedTorusKnot5a(),\n\t\t\t\tDecoratedTorusKnot5c: new Curves.DecoratedTorusKnot5c(),\n\t\t\t\tPipeSpline: pipeSpline,\n\t\t\t\tSampleClosedSpline: sampleClosedSpline\n\t\t\t};\n\n\t\t\tlet parent, tubeGeometry, mesh;\n\n\t\t\tconst params = {\n\t\t\t\tspline: 'GrannyKnot',\n\t\t\t\tscale: 4,\n\t\t\t\textrusionSegments: 100,\n\t\t\t\tradiusSegments: 3,\n\t\t\t\tclosed: true,\n\t\t\t\tanimationView: false,\n\t\t\t\tlookAhead: false,\n\t\t\t\tcameraHelper: false,\n\t\t\t};\n\n\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xff00ff } );\n\n\t\t\tconst wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.3, wireframe: true, transparent: true } );\n\n\t\t\tfunction addTube() {\n\n\t\t\t\tif ( mesh !== undefined ) {\n\n\t\t\t\t\tparent.remove( mesh );\n\t\t\t\t\tmesh.geometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tconst extrudePath = splines[ params.spline ];\n\n\t\t\t\ttubeGeometry = new THREE.TubeGeometry( extrudePath, params.extrusionSegments, 2, params.radiusSegments, params.closed );\n\n\t\t\t\taddGeometry( tubeGeometry );\n\n\t\t\t\tsetScale();\n\n\t\t\t}\n\n\t\t\tfunction setScale() {\n\n\t\t\t\tmesh.scale.set( params.scale, params.scale, params.scale );\n\n\t\t\t}\n\n\n\t\t\tfunction addGeometry( geometry ) {\n\n\t\t\t\t// 3D shape\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tconst wireframe = new THREE.Mesh( geometry, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\n\t\t\t\tparent.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction animateCamera() {\n\n\t\t\t\tcameraHelper.visible = params.cameraHelper;\n\t\t\t\tcameraEye.visible = params.cameraHelper;\n\n\t\t\t}\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 10000 );\n\t\t\t\tcamera.position.set( 0, 50, 500 );\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\t// light\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tlight.position.set( 0, 0, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// tube\n\n\t\t\t\tparent = new THREE.Object3D();\n\t\t\t\tscene.add( parent );\n\n\t\t\t\tsplineCamera = new THREE.PerspectiveCamera( 84, window.innerWidth / window.innerHeight, 0.01, 1000 );\n\t\t\t\tparent.add( splineCamera );\n\n\t\t\t\tcameraHelper = new THREE.CameraHelper( splineCamera );\n\t\t\t\tscene.add( cameraHelper );\n\n\t\t\t\taddTube();\n\n\t\t\t\t// debug camera\n\n\t\t\t\tcameraEye = new THREE.Mesh( new THREE.SphereGeometry( 5 ), new THREE.MeshBasicMaterial( { color: 0xdddddd } ) );\n\t\t\t\tparent.add( cameraEye );\n\n\t\t\t\tcameraHelper.visible = params.cameraHelper;\n\t\t\t\tcameraEye.visible = params.cameraHelper;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// dat.GUI\n\n\t\t\t\tconst gui = new GUI( { width: 285 } );\n\n\t\t\t\tconst folderGeometry = gui.addFolder( 'Geometry' );\n\t\t\t\tfolderGeometry.add( params, 'spline', Object.keys( splines ) ).onChange( function () {\n\n\t\t\t\t\taddTube();\n\n\t\t\t\t} );\n\t\t\t\tfolderGeometry.add( params, 'scale', 2, 10 ).step( 2 ).onChange( function () {\n\n\t\t\t\t\tsetScale();\n\n\t\t\t\t} );\n\t\t\t\tfolderGeometry.add( params, 'extrusionSegments', 50, 500 ).step( 50 ).onChange( function () {\n\n\t\t\t\t\taddTube();\n\n\t\t\t\t} );\n\t\t\t\tfolderGeometry.add( params, 'radiusSegments', 2, 12 ).step( 1 ).onChange( function () {\n\n\t\t\t\t\taddTube();\n\n\t\t\t\t} );\n\t\t\t\tfolderGeometry.add( params, 'closed' ).onChange( function () {\n\n\t\t\t\t\taddTube();\n\n\t\t\t\t} );\n\t\t\t\tfolderGeometry.open();\n\n\t\t\t\tconst folderCamera = gui.addFolder( 'Camera' );\n\t\t\t\tfolderCamera.add( params, 'animationView' ).onChange( function () {\n\n\t\t\t\t\tanimateCamera();\n\n\t\t\t\t} );\n\t\t\t\tfolderCamera.add( params, 'lookAhead' ).onChange( function () {\n\n\t\t\t\t\tanimateCamera();\n\n\t\t\t\t} );\n\t\t\t\tfolderCamera.add( params, 'cameraHelper' ).onChange( function () {\n\n\t\t\t\t\tanimateCamera();\n\n\t\t\t\t} );\n\t\t\t\tfolderCamera.open();\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 2000;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\t// animate camera along spline\n\n\t\t\t\tconst time = Date.now();\n\t\t\t\tconst looptime = 20 * 1000;\n\t\t\t\tconst t = ( time % looptime ) / looptime;\n\n\t\t\t\ttubeGeometry.parameters.path.getPointAt( t, position );\n\t\t\t\tposition.multiplyScalar( params.scale );\n\n\t\t\t\t// interpolation\n\n\t\t\t\tconst segments = tubeGeometry.tangents.length;\n\t\t\t\tconst pickt = t * segments;\n\t\t\t\tconst pick = Math.floor( pickt );\n\t\t\t\tconst pickNext = ( pick + 1 ) % segments;\n\n\t\t\t\tbinormal.subVectors( tubeGeometry.binormals[ pickNext ], tubeGeometry.binormals[ pick ] );\n\t\t\t\tbinormal.multiplyScalar( pickt - pick ).add( tubeGeometry.binormals[ pick ] );\n\n\t\t\t\ttubeGeometry.parameters.path.getTangentAt( t, direction );\n\t\t\t\tconst offset = 15;\n\n\t\t\t\tnormal.copy( binormal ).cross( direction );\n\n\t\t\t\t// we move on a offset on its binormal\n\n\t\t\t\tposition.add( normal.clone().multiplyScalar( offset ) );\n\n\t\t\t\tsplineCamera.position.copy( position );\n\t\t\t\tcameraEye.position.copy( position );\n\n\t\t\t\t// using arclength for stabilization in look ahead\n\n\t\t\t\ttubeGeometry.parameters.path.getPointAt( ( t + 30 / tubeGeometry.parameters.path.getLength() ) % 1, lookAt );\n\t\t\t\tlookAt.multiplyScalar( params.scale );\n\n\t\t\t\t// camera orientation 2 - up orientation via normal\n\n\t\t\t\tif ( ! params.lookAhead ) lookAt.copy( position ).add( direction );\n\t\t\t\tsplineCamera.matrix.lookAt( splineCamera.position, lookAt, normal );\n\t\t\t\tsplineCamera.quaternion.setFromRotationMatrix( splineCamera.matrix );\n\n\t\t\t\tcameraHelper.update();\n\n\t\t\t\trenderer.render( scene, params.animationView === true ? splineCamera : camera );\n\n\t\t\t}\n```\n\nThis example three.js - spline extrusion examples"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - minecraft"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - minecraft:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, controls, scene, renderer;\n\n\t\t\tconst worldWidth = 128, worldDepth = 128;\n\t\t\tconst worldHalfWidth = worldWidth / 2;\n\t\t\tconst worldHalfDepth = worldDepth / 2;\n\t\t\tconst data = generateHeight( worldWidth, worldDepth );\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );\n\t\t\t\tcamera.position.y = getY( worldHalfWidth, worldHalfDepth ) * 100 + 100;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\t// sides\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tconst pxGeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tpxGeometry.attributes.uv.array[ 1 ] = 0.5;\n\t\t\t\tpxGeometry.attributes.uv.array[ 3 ] = 0.5;\n\t\t\t\tpxGeometry.rotateY( Math.PI / 2 );\n\t\t\t\tpxGeometry.translate( 50, 0, 0 );\n\n\t\t\t\tconst nxGeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tnxGeometry.attributes.uv.array[ 1 ] = 0.5;\n\t\t\t\tnxGeometry.attributes.uv.array[ 3 ] = 0.5;\n\t\t\t\tnxGeometry.rotateY( - Math.PI / 2 );\n\t\t\t\tnxGeometry.translate( - 50, 0, 0 );\n\n\t\t\t\tconst pyGeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tpyGeometry.attributes.uv.array[ 5 ] = 0.5;\n\t\t\t\tpyGeometry.attributes.uv.array[ 7 ] = 0.5;\n\t\t\t\tpyGeometry.rotateX( - Math.PI / 2 );\n\t\t\t\tpyGeometry.translate( 0, 50, 0 );\n\n\t\t\t\tconst pzGeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tpzGeometry.attributes.uv.array[ 1 ] = 0.5;\n\t\t\t\tpzGeometry.attributes.uv.array[ 3 ] = 0.5;\n\t\t\t\tpzGeometry.translate( 0, 0, 50 );\n\n\t\t\t\tconst nzGeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tnzGeometry.attributes.uv.array[ 1 ] = 0.5;\n\t\t\t\tnzGeometry.attributes.uv.array[ 3 ] = 0.5;\n\t\t\t\tnzGeometry.rotateY( Math.PI );\n\t\t\t\tnzGeometry.translate( 0, 0, - 50 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometries = [];\n\n\t\t\t\tfor ( let z = 0; z < worldDepth; z ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < worldWidth; x ++ ) {\n\n\t\t\t\t\t\tconst h = getY( x, z );\n\n\t\t\t\t\t\tmatrix.makeTranslation(\n\t\t\t\t\t\t\tx * 100 - worldHalfWidth * 100,\n\t\t\t\t\t\t\th * 100,\n\t\t\t\t\t\t\tz * 100 - worldHalfDepth * 100\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst px = getY( x + 1, z );\n\t\t\t\t\t\tconst nx = getY( x - 1, z );\n\t\t\t\t\t\tconst pz = getY( x, z + 1 );\n\t\t\t\t\t\tconst nz = getY( x, z - 1 );\n\n\t\t\t\t\t\tgeometries.push( pyGeometry.clone().applyMatrix4( matrix ) );\n\n\t\t\t\t\t\tif ( ( px !== h && px !== h + 1 ) || x === 0 ) {\n\n\t\t\t\t\t\t\tgeometries.push( pxGeometry.clone().applyMatrix4( matrix ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ( nx !== h && nx !== h + 1 ) || x === worldWidth - 1 ) {\n\n\t\t\t\t\t\t\tgeometries.push( nxGeometry.clone().applyMatrix4( matrix ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ( pz !== h && pz !== h + 1 ) || z === worldDepth - 1 ) {\n\n\t\t\t\t\t\t\tgeometries.push( pzGeometry.clone().applyMatrix4( matrix ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ( nz !== h && nz !== h + 1 ) || z === 0 ) {\n\n\t\t\t\t\t\t\tgeometries.push( nzGeometry.clone().applyMatrix4( matrix ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = BufferGeometryUtils.mergeGeometries( geometries );\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/minecraft/atlas.png' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { map: texture, side: THREE.DoubleSide } ) );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xeeeeee, 3 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 12 );\n\t\t\t\tdirectionalLight.position.set( 1, 1, 0.5 ).normalize();\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new FirstPersonControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.movementSpeed = 1000;\n\t\t\t\tcontrols.lookSpeed = 0.125;\n\t\t\t\tcontrols.lookVertical = true;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction generateHeight( width, height ) {\n\n\t\t\t\tconst data = [], perlin = new ImprovedNoise(),\n\t\t\t\t\tsize = width * height, z = Math.random() * 100;\n\n\t\t\t\tlet quality = 2;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 ) for ( let i = 0; i < size; i ++ ) data[ i ] = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\t\tconst x = i % width, y = ( i / width ) | 0;\n\t\t\t\t\t\tdata[ i ] += perlin.noise( x / quality, y / quality, z ) * quality;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tquality *= 4;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getY( x, z ) {\n\n\t\t\t\treturn ( data[ x + z * worldWidth ] * 0.15 ) | 0;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcontrols.update( clock.getDelta() );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - minecraft demo. featuring painterly pack (left click: forward, right click: backward)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - NURBS"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - NURBS:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { NURBSCurve } from 'three/addons/curves/NURBSCurve.js';\n\t\t\timport { NURBSSurface } from 'three/addons/curves/NURBSSurface.js';\n\t\t\timport { NURBSVolume } from 'three/addons/curves/NURBSVolume.js';\n\t\t\timport { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet group;\n\n\t\t\tlet targetRotation = 0;\n\t\t\tlet targetRotationOnPointerDown = 0;\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerXOnPointerDown = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 0, 150, 750 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tgroup.position.y = 50;\n\t\t\t\tscene.add( group );\n\n\t\t\t\t// NURBS curve\n\n\t\t\t\tconst nurbsControlPoints = [];\n\t\t\t\tconst nurbsKnots = [];\n\t\t\t\tconst nurbsDegree = 3;\n\n\t\t\t\tfor ( let i = 0; i <= nurbsDegree; i ++ ) {\n\n\t\t\t\t\tnurbsKnots.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, j = 20; i < j; i ++ ) {\n\n\t\t\t\t\tnurbsControlPoints.push(\n\t\t\t\t\t\tnew THREE.Vector4(\n\t\t\t\t\t\t\tMath.random() * 400 - 200,\n\t\t\t\t\t\t\tMath.random() * 400,\n\t\t\t\t\t\t\tMath.random() * 400 - 200,\n\t\t\t\t\t\t\t1 // weight of control point: higher means stronger attraction\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tconst knot = ( i + 1 ) / ( j - nurbsDegree );\n\t\t\t\t\tnurbsKnots.push( THREE.MathUtils.clamp( knot, 0, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst nurbsCurve = new NURBSCurve( nurbsDegree, nurbsKnots, nurbsControlPoints );\n\n\t\t\t\tconst nurbsGeometry = new THREE.BufferGeometry();\n\t\t\t\tnurbsGeometry.setFromPoints( nurbsCurve.getPoints( 200 ) );\n\n\t\t\t\tconst nurbsMaterial = new THREE.LineBasicMaterial( { color: 0x333333 } );\n\n\t\t\t\tconst nurbsLine = new THREE.Line( nurbsGeometry, nurbsMaterial );\n\t\t\t\tnurbsLine.position.set( 0, - 100, 0 );\n\t\t\t\tgroup.add( nurbsLine );\n\n\t\t\t\tconst nurbsControlPointsGeometry = new THREE.BufferGeometry();\n\t\t\t\tnurbsControlPointsGeometry.setFromPoints( nurbsCurve.controlPoints );\n\n\t\t\t\tconst nurbsControlPointsMaterial = new THREE.LineBasicMaterial( { color: 0x333333, opacity: 0.25, transparent: true } );\n\n\t\t\t\tconst nurbsControlPointsLine = new THREE.Line( nurbsControlPointsGeometry, nurbsControlPointsMaterial );\n\t\t\t\tnurbsControlPointsLine.position.copy( nurbsLine.position );\n\t\t\t\tgroup.add( nurbsControlPointsLine );\n\n\t\t\t\t// NURBS surface\n\t\t\t\t{\n\n\t\t\t\t\tconst nsControlPoints = [\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew THREE.Vector4( - 200, - 200, 100, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( - 200, - 100, - 200, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( - 200, 100, 250, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( - 200, 200, - 100, 1 )\n\t\t\t\t\t\t],\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew THREE.Vector4( 0, - 200, 0, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( 0, - 100, - 100, 5 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( 0, 100, 150, 5 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( 0, 200, 0, 1 )\n\t\t\t\t\t\t],\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tnew THREE.Vector4( 200, - 200, - 100, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( 200, - 100, 200, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( 200, 100, - 250, 1 ),\n\t\t\t\t\t\t\tnew THREE.Vector4( 200, 200, 100, 1 )\n\t\t\t\t\t\t]\n\t\t\t\t\t];\n\t\t\t\t\tconst degree1 = 2;\n\t\t\t\t\tconst degree2 = 3;\n\t\t\t\t\tconst knots1 = [ 0, 0, 0, 1, 1, 1 ];\n\t\t\t\t\tconst knots2 = [ 0, 0, 0, 0, 1, 1, 1, 1 ];\n\t\t\t\t\tconst nurbsSurface = new NURBSSurface( degree1, degree2, knots1, knots2, nsControlPoints );\n\n\t\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\t\tmap.wrapS = map.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 16;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tfunction getSurfacePoint( u, v, target ) {\n\n\t\t\t\t\t\treturn nurbsSurface.getPoint( u, v, target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = new ParametricGeometry( getSurfacePoint, 20, 20 );\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, material );\n\t\t\t\t\tobject.position.set( - 400, 100, 0 );\n\t\t\t\t\tobject.scale.multiplyScalar( 1 );\n\t\t\t\t\tgroup.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t// NURBS volume\n\t\t\t\t{\n\n\t\t\t\t\tconst nsControlPoints = [\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, - 200, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, - 200, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, - 100, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, - 100, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, 100, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, 100, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, 200, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( - 200, 200, 200, 1 )\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, - 200, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, - 200, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, - 100, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, - 100, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, 100, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, 100, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, 200, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 0, 200, 200, 1 )\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, - 200, - 200, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, - 200, 200, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, - 100, 0, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, - 100, 100, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, 100, 0, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, 100, 100, 1 )\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, 200, 0, 1 ),\n\t\t\t\t\t\t\t\tnew THREE.Vector4( 200, 200, 100, 1 )\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t];\n\t\t\t\t\tconst degree1 = 2;\n\t\t\t\t\tconst degree2 = 3;\n\t\t\t\t\tconst degree3 = 1;\n\t\t\t\t\tconst knots1 = [ 0, 0, 0, 1, 1, 1 ];\n\t\t\t\t\tconst knots2 = [ 0, 0, 0, 0, 1, 1, 1, 1 ];\n\t\t\t\t\tconst knots3 = [ 0, 0, 1, 1 ];\n\t\t\t\t\tconst nurbsVolume = new NURBSVolume( degree1, degree2, degree3, knots1, knots2, knots3, nsControlPoints );\n\n\t\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\t\tmap.wrapS = map.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 16;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\t// Since ParametricGeometry() only support bi-variate parametric geometries\n\t\t\t\t\t// we create evaluation functions for different surfaces with one of the three\n\t\t\t\t\t// parameter values (u, v, w) kept constant and create multiple THREE.Mesh\n\t\t\t\t\t// objects one for each surface\n\t\t\t\t\tfunction getSurfacePointFront( u, v, target ) {\n\n\t\t\t\t\t\treturn nurbsVolume.getPoint( u, v, 0, target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction getSurfacePointMiddle( u, v, target ) {\n\n\t\t\t\t\t\treturn nurbsVolume.getPoint( u, v, 0.5, target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction getSurfacePointBack( u, v, target ) {\n\n\t\t\t\t\t\treturn nurbsVolume.getPoint( u, v, 1, target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction getSurfacePointTop( u, w, target ) {\n\n\t\t\t\t\t\treturn nurbsVolume.getPoint( u, 1, w, target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction getSurfacePointSide( v, w, target ) {\n\n\t\t\t\t\t\treturn nurbsVolume.getPoint( 0, v, w, target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometryFront = new ParametricGeometry( getSurfacePointFront, 20, 20 );\n\t\t\t\t\tconst materialFront = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );\n\t\t\t\t\tconst objectFront = new THREE.Mesh( geometryFront, materialFront );\n\t\t\t\t\tobjectFront.position.set( 400, 100, 0 );\n\t\t\t\t\tobjectFront.scale.multiplyScalar( 0.5 );\n\t\t\t\t\tgroup.add( objectFront );\n\n\t\t\t\t\tconst geometryMiddle = new ParametricGeometry( getSurfacePointMiddle, 20, 20 );\n\t\t\t\t\tconst materialMiddle = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );\n\t\t\t\t\tconst objectMiddle = new THREE.Mesh( geometryMiddle, materialMiddle );\n\t\t\t\t\tobjectMiddle.position.set( 400, 100, 0 );\n\t\t\t\t\tobjectMiddle.scale.multiplyScalar( 0.5 );\n\t\t\t\t\tgroup.add( objectMiddle );\n\n\t\t\t\t\tconst geometryBack = new ParametricGeometry( getSurfacePointBack, 20, 20 );\n\t\t\t\t\tconst materialBack = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );\n\t\t\t\t\tconst objectBack = new THREE.Mesh( geometryBack, materialBack );\n\t\t\t\t\tobjectBack.position.set( 400, 100, 0 );\n\t\t\t\t\tobjectBack.scale.multiplyScalar( 0.5 );\n\t\t\t\t\tgroup.add( objectBack );\n\n\t\t\t\t\tconst geometryTop = new ParametricGeometry( getSurfacePointTop, 20, 20 );\n\t\t\t\t\tconst materialTop = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );\n\t\t\t\t\tconst objectTop = new THREE.Mesh( geometryTop, materialTop );\n\t\t\t\t\tobjectTop.position.set( 400, 100, 0 );\n\t\t\t\t\tobjectTop.scale.multiplyScalar( 0.5 );\n\t\t\t\t\tgroup.add( objectTop );\n\n\t\t\t\t\tconst geometrySide = new ParametricGeometry( getSurfacePointSide, 20, 20 );\n\t\t\t\t\tconst materialSide = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );\n\t\t\t\t\tconst objectSide = new THREE.Mesh( geometrySide, materialSide );\n\t\t\t\t\tobjectSide.position.set( 400, 100, 0 );\n\t\t\t\t\tobjectSide.scale.multiplyScalar( 0.5 );\n\t\t\t\t\tgroup.add( objectSide );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerXOnPointerDown = event.clientX - windowHalfX;\n\t\t\t\ttargetRotationOnPointerDown = targetRotation;\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerX = event.clientX - windowHalfX;\n\n\t\t\t\ttargetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tdocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tgroup.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - NURBS curve and surface example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - shapes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - shapes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet group;\n\n\t\t\tlet targetRotation = 0;\n\t\t\tlet targetRotationOnPointerDown = 0;\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerXOnPointerDown = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 150, 500 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 2.5, 0, 0 );\n\t\t\t\tcamera.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tgroup.position.y = 50;\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst texture = loader.load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// it's necessary to apply these settings in order to correctly display the texture on a shape geometry\n\n\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.repeat.set( 0.008, 0.008 );\n\n\t\t\t\tfunction addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {\n\n\t\t\t\t\t// flat shape with texture\n\t\t\t\t\t// note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices\n\n\t\t\t\t\tlet geometry = new THREE.ShapeGeometry( shape );\n\n\t\t\t\t\tlet mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );\n\t\t\t\t\tmesh.position.set( x, y, z - 175 );\n\t\t\t\t\tmesh.rotation.set( rx, ry, rz );\n\t\t\t\t\tmesh.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t// flat shape\n\n\t\t\t\t\tgeometry = new THREE.ShapeGeometry( shape );\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );\n\t\t\t\t\tmesh.position.set( x, y, z - 125 );\n\t\t\t\t\tmesh.rotation.set( rx, ry, rz );\n\t\t\t\t\tmesh.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t// extruded shape\n\n\t\t\t\t\tgeometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );\n\t\t\t\t\tmesh.position.set( x, y, z - 75 );\n\t\t\t\t\tmesh.rotation.set( rx, ry, rz );\n\t\t\t\t\tmesh.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\taddLineShape( shape, color, x, y, z, rx, ry, rz, s );\n\n\t\t\t\t}\n\n\t\t\t\tfunction addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {\n\n\t\t\t\t\t// lines\n\n\t\t\t\t\tshape.autoClose = true;\n\n\t\t\t\t\tconst points = shape.getPoints();\n\t\t\t\t\tconst spacedPoints = shape.getSpacedPoints( 50 );\n\n\t\t\t\t\tconst geometryPoints = new THREE.BufferGeometry().setFromPoints( points );\n\t\t\t\t\tconst geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );\n\n\t\t\t\t\t// solid line\n\n\t\t\t\t\tlet line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );\n\t\t\t\t\tline.position.set( x, y, z - 25 );\n\t\t\t\t\tline.rotation.set( rx, ry, rz );\n\t\t\t\t\tline.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( line );\n\n\t\t\t\t\t// line from equidistance sampled points\n\n\t\t\t\t\tline = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: color } ) );\n\t\t\t\t\tline.position.set( x, y, z + 25 );\n\t\t\t\t\tline.rotation.set( rx, ry, rz );\n\t\t\t\t\tline.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( line );\n\n\t\t\t\t\t// vertices from real points\n\n\t\t\t\t\tlet particles = new THREE.Points( geometryPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );\n\t\t\t\t\tparticles.position.set( x, y, z + 75 );\n\t\t\t\t\tparticles.rotation.set( rx, ry, rz );\n\t\t\t\t\tparticles.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( particles );\n\n\t\t\t\t\t// equidistance sampled points\n\n\t\t\t\t\tparticles = new THREE.Points( geometrySpacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );\n\t\t\t\t\tparticles.position.set( x, y, z + 125 );\n\t\t\t\t\tparticles.rotation.set( rx, ry, rz );\n\t\t\t\t\tparticles.scale.set( s, s, s );\n\t\t\t\t\tgroup.add( particles );\n\n\t\t\t\t}\n\n\n\t\t\t\t// California\n\n\t\t\t\tconst californiaPts = [];\n\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 610, 320 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 450, 300 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 392, 392 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 266, 438 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 190, 570 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 190, 600 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 160, 620 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 160, 650 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 180, 640 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 165, 680 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 150, 670 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 90, 737 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 80, 795 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 50, 835 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 64, 870 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 60, 945 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 300, 945 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 300, 743 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 600, 473 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 626, 425 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 600, 370 ) );\n\t\t\t\tcaliforniaPts.push( new THREE.Vector2( 610, 320 ) );\n\n\t\t\t\tfor ( let i = 0; i < californiaPts.length; i ++ ) californiaPts[ i ].multiplyScalar( 0.25 );\n\n\t\t\t\tconst californiaShape = new THREE.Shape( californiaPts );\n\n\n\t\t\t\t// Triangle\n\n\t\t\t\tconst triangleShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 80, 20 )\n\t\t\t\t\t.lineTo( 40, 80 )\n\t\t\t\t\t.lineTo( 120, 80 )\n\t\t\t\t\t.lineTo( 80, 20 ); // close path\n\n\n\t\t\t\t// Heart\n\n\t\t\t\tconst x = 0, y = 0;\n\n\t\t\t\tconst heartShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( x + 25, y + 25 )\n\t\t\t\t\t.bezierCurveTo( x + 25, y + 25, x + 20, y, x, y )\n\t\t\t\t\t.bezierCurveTo( x - 30, y, x - 30, y + 35, x - 30, y + 35 )\n\t\t\t\t\t.bezierCurveTo( x - 30, y + 55, x - 10, y + 77, x + 25, y + 95 )\n\t\t\t\t\t.bezierCurveTo( x + 60, y + 77, x + 80, y + 55, x + 80, y + 35 )\n\t\t\t\t\t.bezierCurveTo( x + 80, y + 35, x + 80, y, x + 50, y )\n\t\t\t\t\t.bezierCurveTo( x + 35, y, x + 25, y + 25, x + 25, y + 25 );\n\n\n\t\t\t\t// Square\n\n\t\t\t\tconst sqLength = 80;\n\n\t\t\t\tconst squareShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 0, 0 )\n\t\t\t\t\t.lineTo( 0, sqLength )\n\t\t\t\t\t.lineTo( sqLength, sqLength )\n\t\t\t\t\t.lineTo( sqLength, 0 )\n\t\t\t\t\t.lineTo( 0, 0 );\n\n\t\t\t\t// Rounded rectangle\n\n\t\t\t\tconst roundedRectShape = new THREE.Shape();\n\n\t\t\t\t( function roundedRect( ctx, x, y, width, height, radius ) {\n\n\t\t\t\t\tctx.moveTo( x, y + radius );\n\t\t\t\t\tctx.lineTo( x, y + height - radius );\n\t\t\t\t\tctx.quadraticCurveTo( x, y + height, x + radius, y + height );\n\t\t\t\t\tctx.lineTo( x + width - radius, y + height );\n\t\t\t\t\tctx.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );\n\t\t\t\t\tctx.lineTo( x + width, y + radius );\n\t\t\t\t\tctx.quadraticCurveTo( x + width, y, x + width - radius, y );\n\t\t\t\t\tctx.lineTo( x + radius, y );\n\t\t\t\t\tctx.quadraticCurveTo( x, y, x, y + radius );\n\n\t\t\t\t} )( roundedRectShape, 0, 0, 50, 50, 20 );\n\n\n\t\t\t\t// Track\n\n\t\t\t\tconst trackShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 40, 40 )\n\t\t\t\t\t.lineTo( 40, 160 )\n\t\t\t\t\t.absarc( 60, 160, 20, Math.PI, 0, true )\n\t\t\t\t\t.lineTo( 80, 40 )\n\t\t\t\t\t.absarc( 60, 40, 20, 2 * Math.PI, Math.PI, true );\n\n\n\t\t\t\t// Circle\n\n\t\t\t\tconst circleRadius = 40;\n\t\t\t\tconst circleShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 0, circleRadius )\n\t\t\t\t\t.quadraticCurveTo( circleRadius, circleRadius, circleRadius, 0 )\n\t\t\t\t\t.quadraticCurveTo( circleRadius, - circleRadius, 0, - circleRadius )\n\t\t\t\t\t.quadraticCurveTo( - circleRadius, - circleRadius, - circleRadius, 0 )\n\t\t\t\t\t.quadraticCurveTo( - circleRadius, circleRadius, 0, circleRadius );\n\n\n\t\t\t\t// Fish\n\n\t\t\t\tconst fishShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( x, y )\n\t\t\t\t\t.quadraticCurveTo( x + 50, y - 80, x + 90, y - 10 )\n\t\t\t\t\t.quadraticCurveTo( x + 100, y - 10, x + 115, y - 40 )\n\t\t\t\t\t.quadraticCurveTo( x + 115, y, x + 115, y + 40 )\n\t\t\t\t\t.quadraticCurveTo( x + 100, y + 10, x + 90, y + 10 )\n\t\t\t\t\t.quadraticCurveTo( x + 50, y + 80, x, y );\n\n\n\t\t\t\t// Arc circle\n\n\t\t\t\tconst arcShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 50, 10 )\n\t\t\t\t\t.absarc( 10, 10, 40, 0, Math.PI * 2, false );\n\n\t\t\t\tconst holePath = new THREE.Path()\n\t\t\t\t\t.moveTo( 20, 10 )\n\t\t\t\t\t.absarc( 10, 10, 10, 0, Math.PI * 2, true );\n\n\t\t\t\tarcShape.holes.push( holePath );\n\n\n\t\t\t\t// Smiley\n\n\t\t\t\tconst smileyShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 80, 40 )\n\t\t\t\t\t.absarc( 40, 40, 40, 0, Math.PI * 2, false );\n\n\t\t\t\tconst smileyEye1Path = new THREE.Path()\n\t\t\t\t\t.moveTo( 35, 20 )\n\t\t\t\t\t.absellipse( 25, 20, 10, 10, 0, Math.PI * 2, true );\n\n\t\t\t\tconst smileyEye2Path = new THREE.Path()\n\t\t\t\t\t.moveTo( 65, 20 )\n\t\t\t\t\t.absarc( 55, 20, 10, 0, Math.PI * 2, true );\n\n\t\t\t\tconst smileyMouthPath = new THREE.Path()\n\t\t\t\t\t.moveTo( 20, 40 )\n\t\t\t\t\t.quadraticCurveTo( 40, 60, 60, 40 )\n\t\t\t\t\t.bezierCurveTo( 70, 45, 70, 50, 60, 60 )\n\t\t\t\t\t.quadraticCurveTo( 40, 80, 20, 60 )\n\t\t\t\t\t.quadraticCurveTo( 5, 50, 20, 40 );\n\n\t\t\t\tsmileyShape.holes.push( smileyEye1Path );\n\t\t\t\tsmileyShape.holes.push( smileyEye2Path );\n\t\t\t\tsmileyShape.holes.push( smileyMouthPath );\n\n\n\t\t\t\t// Spline shape\n\n\t\t\t\tconst splinepts = [];\n\t\t\t\tsplinepts.push( new THREE.Vector2( 70, 20 ) );\n\t\t\t\tsplinepts.push( new THREE.Vector2( 80, 90 ) );\n\t\t\t\tsplinepts.push( new THREE.Vector2( - 30, 70 ) );\n\t\t\t\tsplinepts.push( new THREE.Vector2( 0, 0 ) );\n\n\t\t\t\tconst splineShape = new THREE.Shape()\n\t\t\t\t\t.moveTo( 0, 0 )\n\t\t\t\t\t.splineThru( splinepts );\n\n\t\t\t\tconst extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };\n\n\t\t\t\t// addShape( shape, color, x, y, z, rx, ry,rz, s );\n\n\t\t\t\taddShape( californiaShape, extrudeSettings, 0xf08000, - 300, - 100, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( triangleShape, extrudeSettings, 0x8080f0, - 180, 0, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( roundedRectShape, extrudeSettings, 0x008000, - 150, 150, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( trackShape, extrudeSettings, 0x008080, 200, - 100, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( squareShape, extrudeSettings, 0x0040f0, 150, 100, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1 );\n\t\t\t\taddShape( circleShape, extrudeSettings, 0x00f000, 120, 250, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( fishShape, extrudeSettings, 0x404040, - 60, 200, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( smileyShape, extrudeSettings, 0xf000f0, - 200, 250, 0, 0, 0, Math.PI, 1 );\n\t\t\t\taddShape( arcShape, extrudeSettings, 0x804000, 150, 0, 0, 0, 0, 0, 1 );\n\t\t\t\taddShape( splineShape, extrudeSettings, 0x808080, - 50, - 100, 0, 0, 0, 0, 1 );\n\n\t\t\t\taddLineShape( arcShape.holes[ 0 ], 0x804000, 150, 0, 0, 0, 0, 0, 1 );\n\n\t\t\t\tfor ( let i = 0; i < smileyShape.holes.length; i += 1 ) {\n\n\t\t\t\t\taddLineShape( smileyShape.holes[ i ], 0xf000f0, - 200, 250, 0, 0, 0, Math.PI, 1 );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerXOnPointerDown = event.clientX - windowHalfX;\n\t\t\t\ttargetRotationOnPointerDown = targetRotation;\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerX = event.clientX - windowHalfX;\n\n\t\t\t\ttargetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tdocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tgroup.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example Simple procedurally-generated shapes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - catmull spline editor"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - catmull spline editor:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tconst splineHelperObjects = [];\n\t\t\tlet splinePointsLength = 4;\n\t\t\tconst positions = [];\n\t\t\tconst point = new THREE.Vector3();\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst pointer = new THREE.Vector2();\n\t\t\tconst onUpPosition = new THREE.Vector2();\n\t\t\tconst onDownPosition = new THREE.Vector2();\n\n\t\t\tconst geometry = new THREE.BoxGeometry( 20, 20, 20 );\n\t\t\tlet transformControl;\n\n\t\t\tconst ARC_SEGMENTS = 200;\n\n\t\t\tconst splines = {};\n\n\t\t\tconst params = {\n\t\t\t\tuniform: true,\n\t\t\t\ttension: 0.5,\n\t\t\t\tcentripetal: true,\n\t\t\t\tchordal: true,\n\t\t\t\taddPoint: addPoint,\n\t\t\t\tremovePoint: removePoint,\n\t\t\t\texportSpline: exportSpline\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 0, 250, 1000 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xf0f0f0, 3 ) );\n\t\t\t\tconst light = new THREE.SpotLight( 0xffffff, 4.5 );\n\t\t\t\tlight.position.set( 0, 1500, 200 );\n\t\t\t\tlight.angle = Math.PI * 0.2;\n\t\t\t\tlight.decay = 0;\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.near = 200;\n\t\t\t\tlight.shadow.camera.far = 2000;\n\t\t\t\tlight.shadow.bias = - 0.000222;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );\n\t\t\t\tplaneGeometry.rotateX( - Math.PI / 2 );\n\t\t\t\tconst planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );\n\n\t\t\t\tconst plane = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tplane.position.y = - 200;\n\t\t\t\tplane.receiveShadow = true;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tconst helper = new THREE.GridHelper( 2000, 100 );\n\t\t\t\thelper.position.y = - 199;\n\t\t\t\thelper.material.opacity = 0.25;\n\t\t\t\thelper.material.transparent = true;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'uniform' ).onChange( render );\n\t\t\t\tgui.add( params, 'tension', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tsplines.uniform.tension = value;\n\t\t\t\t\tupdateSplineOutline();\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'centripetal' ).onChange( render );\n\t\t\t\tgui.add( params, 'chordal' ).onChange( render );\n\t\t\t\tgui.add( params, 'addPoint' );\n\t\t\t\tgui.add( params, 'removePoint' );\n\t\t\t\tgui.add( params, 'exportSpline' );\n\t\t\t\tgui.open();\n\n\t\t\t\t// Controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.damping = 0.2;\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\ttransformControl = new TransformControls( camera, renderer.domElement );\n\t\t\t\ttransformControl.addEventListener( 'change', render );\n\t\t\t\ttransformControl.addEventListener( 'dragging-changed', function ( event ) {\n\n\t\t\t\t\tcontrols.enabled = ! event.value;\n\n\t\t\t\t} );\n\t\t\t\tscene.add( transformControl.getHelper() );\n\n\t\t\t\ttransformControl.addEventListener( 'objectChange', function () {\n\n\t\t\t\t\tupdateSplineOutline();\n\n\t\t\t\t} );\n\n\t\t\t\tdocument.addEventListener( 'pointerdown', onPointerDown );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t/*******\n\t\t\t\t * Curves\n\t\t\t\t *********/\n\n\t\t\t\tfor ( let i = 0; i < splinePointsLength; i ++ ) {\n\n\t\t\t\t\taddSplineObject( positions[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tpositions.length = 0;\n\n\t\t\t\tfor ( let i = 0; i < splinePointsLength; i ++ ) {\n\n\t\t\t\t\tpositions.push( splineHelperObjects[ i ].position );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ARC_SEGMENTS * 3 ), 3 ) );\n\n\t\t\t\tlet curve = new THREE.CatmullRomCurve3( positions );\n\t\t\t\tcurve.curveType = 'catmullrom';\n\t\t\t\tcurve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\topacity: 0.35\n\t\t\t\t} ) );\n\t\t\t\tcurve.mesh.castShadow = true;\n\t\t\t\tsplines.uniform = curve;\n\n\t\t\t\tcurve = new THREE.CatmullRomCurve3( positions );\n\t\t\t\tcurve.curveType = 'centripetal';\n\t\t\t\tcurve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {\n\t\t\t\t\tcolor: 0x00ff00,\n\t\t\t\t\topacity: 0.35\n\t\t\t\t} ) );\n\t\t\t\tcurve.mesh.castShadow = true;\n\t\t\t\tsplines.centripetal = curve;\n\n\t\t\t\tcurve = new THREE.CatmullRomCurve3( positions );\n\t\t\t\tcurve.curveType = 'chordal';\n\t\t\t\tcurve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {\n\t\t\t\t\tcolor: 0x0000ff,\n\t\t\t\t\topacity: 0.35\n\t\t\t\t} ) );\n\t\t\t\tcurve.mesh.castShadow = true;\n\t\t\t\tsplines.chordal = curve;\n\n\t\t\t\tfor ( const k in splines ) {\n\n\t\t\t\t\tconst spline = splines[ k ];\n\t\t\t\t\tscene.add( spline.mesh );\n\n\t\t\t\t}\n\n\t\t\t\tload( [ new THREE.Vector3( 289.76843686945404, 452.51481137238443, 56.10018915737797 ),\n\t\t\t\t\tnew THREE.Vector3( - 53.56300074753207, 171.49711742836848, - 14.495472686253045 ),\n\t\t\t\t\tnew THREE.Vector3( - 91.40118730204415, 176.4306956436485, - 6.958271935582161 ),\n\t\t\t\t\tnew THREE.Vector3( - 383.785318791128, 491.1365363371675, 47.869296953772746 ) ] );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction addSplineObject( position ) {\n\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );\n\t\t\t\tconst object = new THREE.Mesh( geometry, material );\n\n\t\t\t\tif ( position ) {\n\n\t\t\t\t\tobject.position.copy( position );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.position.x = Math.random() * 1000 - 500;\n\t\t\t\t\tobject.position.y = Math.random() * 600;\n\t\t\t\t\tobject.position.z = Math.random() * 800 - 400;\n\n\t\t\t\t}\n\n\t\t\t\tobject.castShadow = true;\n\t\t\t\tobject.receiveShadow = true;\n\t\t\t\tscene.add( object );\n\t\t\t\tsplineHelperObjects.push( object );\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction addPoint() {\n\n\t\t\t\tsplinePointsLength ++;\n\n\t\t\t\tpositions.push( addSplineObject().position );\n\n\t\t\t\tupdateSplineOutline();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction removePoint() {\n\n\t\t\t\tif ( splinePointsLength <= 4 ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst point = splineHelperObjects.pop();\n\t\t\t\tsplinePointsLength --;\n\t\t\t\tpositions.pop();\n\n\t\t\t\tif ( transformControl.object === point ) transformControl.detach();\n\t\t\t\tscene.remove( point );\n\n\t\t\t\tupdateSplineOutline();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction updateSplineOutline() {\n\n\t\t\t\tfor ( const k in splines ) {\n\n\t\t\t\t\tconst spline = splines[ k ];\n\n\t\t\t\t\tconst splineMesh = spline.mesh;\n\t\t\t\t\tconst position = splineMesh.geometry.attributes.position;\n\n\t\t\t\t\tfor ( let i = 0; i < ARC_SEGMENTS; i ++ ) {\n\n\t\t\t\t\t\tconst t = i / ( ARC_SEGMENTS - 1 );\n\t\t\t\t\t\tspline.getPoint( t, point );\n\t\t\t\t\t\tposition.setXYZ( i, point.x, point.y, point.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction exportSpline() {\n\n\t\t\t\tconst strplace = [];\n\n\t\t\t\tfor ( let i = 0; i < splinePointsLength; i ++ ) {\n\n\t\t\t\t\tconst p = splineHelperObjects[ i ].position;\n\t\t\t\t\tstrplace.push( `new THREE.Vector3(${p.x}, ${p.y}, ${p.z})` );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.log( strplace.join( ',\\n' ) );\n\t\t\t\tconst code = '[' + ( strplace.join( ',\\n\\t' ) ) + ']';\n\t\t\t\tprompt( 'copy and paste code', code );\n\n\t\t\t}\n\n\t\t\tfunction load( new_positions ) {\n\n\t\t\t\twhile ( new_positions.length > positions.length ) {\n\n\t\t\t\t\taddPoint();\n\n\t\t\t\t}\n\n\t\t\t\twhile ( new_positions.length < positions.length ) {\n\n\t\t\t\t\tremovePoint();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < positions.length; i ++ ) {\n\n\t\t\t\t\tpositions[ i ].copy( new_positions[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tupdateSplineOutline();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tsplines.uniform.mesh.visible = params.uniform;\n\t\t\t\tsplines.centripetal.mesh.visible = params.centripetal;\n\t\t\t\tsplines.chordal.mesh.visible = params.chordal;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tonDownPosition.x = event.clientX;\n\t\t\t\tonDownPosition.y = event.clientY;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp( event ) {\n\n\t\t\t\tonUpPosition.x = event.clientX;\n\t\t\t\tonUpPosition.y = event.clientY;\n\n\t\t\t\tif ( onDownPosition.distanceTo( onUpPosition ) === 0 ) {\n\n\t\t\t\t\ttransformControl.detach();\n\t\t\t\t\trender();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( splineHelperObjects, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst object = intersects[ 0 ].object;\n\n\t\t\t\t\tif ( object !== transformControl.object ) {\n\n\t\t\t\t\t\ttransformControl.attach( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n```\n\nThis example three.js - geometry - catmull spline editor"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - teapot buffer geometry"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - teapot buffer geometry:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet cameraControls;\n\t\t\tlet effectController;\n\t\t\tconst teapotSize = 300;\n\t\t\tlet ambientLight, light;\n\n\t\t\tlet tess = - 1;\t// force initialization\n\t\t\tlet bBottom;\n\t\t\tlet bLid;\n\t\t\tlet bBody;\n\t\t\tlet bFitLid;\n\t\t\tlet bNonBlinn;\n\t\t\tlet shading;\n\n\t\t\tlet teapot, textureCube;\n\t\t\tconst materials = {};\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst canvasWidth = window.innerWidth;\n\t\t\t\tconst canvasHeight = window.innerHeight;\n\n\t\t\t\t// CAMERA\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 80000 );\n\t\t\t\tcamera.position.set( - 600, 550, 1300 );\n\n\t\t\t\t// LIGHTS\n\t\t\t\tambientLight = new THREE.AmbientLight( 0x7c7c7c, 2.0 );\n\n\t\t\t\tlight = new THREE.DirectionalLight( 0xFFFFFF, 2.0 );\n\t\t\t\tlight.position.set( 0.32, 0.39, 0.7 );\n\n\t\t\t\t// RENDERER\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( canvasWidth, canvasHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// EVENTS\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// CONTROLS\n\t\t\t\tcameraControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcameraControls.addEventListener( 'change', render );\n\n\t\t\t\t// TEXTURE MAP\n\t\t\t\tconst textureMap = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\ttextureMap.wrapS = textureMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttextureMap.anisotropy = 16;\n\t\t\t\ttextureMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// REFLECTION MAP\n\t\t\t\tconst path = 'textures/cube/pisa/';\n\t\t\t\tconst urls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\n\t\t\t\ttextureCube = new THREE.CubeTextureLoader().setPath( path ).load( urls );\n\n\t\t\t\tmaterials[ 'wireframe' ] = new THREE.MeshBasicMaterial( { wireframe: true } );\n\t\t\t\tmaterials[ 'flat' ] = new THREE.MeshPhongMaterial( { specular: 0x000000, flatShading: true, side: THREE.DoubleSide } );\n\t\t\t\tmaterials[ 'smooth' ] = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );\n\t\t\t\tmaterials[ 'glossy' ] = new THREE.MeshPhongMaterial( { color: 0xc0c0c0, specular: 0x404040, shininess: 300, side: THREE.DoubleSide } );\n\t\t\t\tmaterials[ 'textured' ] = new THREE.MeshPhongMaterial( { map: textureMap, side: THREE.DoubleSide } );\n\t\t\t\tmaterials[ 'reflective' ] = new THREE.MeshPhongMaterial( { envMap: textureCube, side: THREE.DoubleSide } );\n\n\t\t\t\t// scene itself\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xAAAAAA );\n\n\t\t\t\tscene.add( ambientLight );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// GUI\n\t\t\t\tsetupGui();\n\n\t\t\t}\n\n\t\t\t// EVENT HANDLERS\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst canvasWidth = window.innerWidth;\n\t\t\t\tconst canvasHeight = window.innerHeight;\n\n\t\t\t\trenderer.setSize( canvasWidth, canvasHeight );\n\n\t\t\t\tcamera.aspect = canvasWidth / canvasHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction setupGui() {\n\n\t\t\t\teffectController = {\n\t\t\t\t\tnewTess: 15,\n\t\t\t\t\tbottom: true,\n\t\t\t\t\tlid: true,\n\t\t\t\t\tbody: true,\n\t\t\t\t\tfitLid: false,\n\t\t\t\t\tnonblinn: false,\n\t\t\t\t\tnewShading: 'glossy'\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( effectController, 'newTess', [ 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50 ] ).name( 'Tessellation Level' ).onChange( render );\n\t\t\t\tgui.add( effectController, 'lid' ).name( 'display lid' ).onChange( render );\n\t\t\t\tgui.add( effectController, 'body' ).name( 'display body' ).onChange( render );\n\t\t\t\tgui.add( effectController, 'bottom' ).name( 'display bottom' ).onChange( render );\n\t\t\t\tgui.add( effectController, 'fitLid' ).name( 'snug lid' ).onChange( render );\n\t\t\t\tgui.add( effectController, 'nonblinn' ).name( 'original scale' ).onChange( render );\n\t\t\t\tgui.add( effectController, 'newShading', [ 'wireframe', 'flat', 'smooth', 'glossy', 'textured', 'reflective' ] ).name( 'Shading' ).onChange( render );\n\n\t\t\t}\n\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( effectController.newTess !== tess ||\n\t\t\t\t\teffectController.bottom !== bBottom ||\n\t\t\t\t\teffectController.lid !== bLid ||\n\t\t\t\t\teffectController.body !== bBody ||\n\t\t\t\t\teffectController.fitLid !== bFitLid ||\n\t\t\t\t\teffectController.nonblinn !== bNonBlinn ||\n\t\t\t\t\teffectController.newShading !== shading ) {\n\n\t\t\t\t\ttess = effectController.newTess;\n\t\t\t\t\tbBottom = effectController.bottom;\n\t\t\t\t\tbLid = effectController.lid;\n\t\t\t\t\tbBody = effectController.body;\n\t\t\t\t\tbFitLid = effectController.fitLid;\n\t\t\t\t\tbNonBlinn = effectController.nonblinn;\n\t\t\t\t\tshading = effectController.newShading;\n\n\t\t\t\t\tcreateNewTeapot();\n\n\t\t\t\t}\n\n\t\t\t\t// skybox is rendered separately, so that it is always behind the teapot.\n\t\t\t\tif ( shading === 'reflective' ) {\n\n\t\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.background = null;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\t// Whenever the teapot changes, the scene is rebuilt from scratch (not much to it).\n\t\t\tfunction createNewTeapot() {\n\n\t\t\t\tif ( teapot !== undefined ) {\n\n\t\t\t\t\tteapot.geometry.dispose();\n\t\t\t\t\tscene.remove( teapot );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new TeapotGeometry( teapotSize,\n\t\t\t\t\ttess,\n\t\t\t\t\teffectController.bottom,\n\t\t\t\t\teffectController.lid,\n\t\t\t\t\teffectController.body,\n\t\t\t\t\teffectController.fitLid,\n\t\t\t\t\t! effectController.nonblinn );\n\n\t\t\t\tteapot = new THREE.Mesh( geometry, materials[ shading ] );\n\n\t\t\t\tscene.add( teapot );\n\n\t\t\t}\n```\n\nThis example three.js - the Utah Teapot from Udacity Interactive 3D Graphics"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - terrain + fog"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - terrain + fog:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet mesh, texture;\n\n\t\t\tconst worldWidth = 256, worldDepth = 256;\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xefd1b5 );\n\t\t\t\tscene.fog = new THREE.FogExp2( 0xefd1b5, 0.0025 );\n\n\t\t\t\tconst data = generateHeight( worldWidth, worldDepth );\n\n\t\t\t\tcamera.position.set( 100, 800, - 800 );\n\t\t\t\tcamera.lookAt( - 100, 810, - 800 );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst vertices = geometry.attributes.position.array;\n\n\t\t\t\tfor ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {\n\n\t\t\t\t\tvertices[ j + 1 ] = data[ i ] * 10;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = new THREE.CanvasTexture( generateTexture( data, worldWidth, worldDepth ) );\n\t\t\t\ttexture.wrapS = THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new FirstPersonControls( camera, renderer.domElement );\n\t\t\t\tcontrols.movementSpeed = 150;\n\t\t\t\tcontrols.lookSpeed = 0.1;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction generateHeight( width, height ) {\n\n\t\t\t\tlet seed = Math.PI / 4;\n\t\t\t\twindow.Math.random = function () {\n\n\t\t\t\t\tconst x = Math.sin( seed ++ ) * 10000;\n\t\t\t\t\treturn x - Math.floor( x );\n\n\t\t\t\t};\n\n\t\t\t\tconst size = width * height, data = new Uint8Array( size );\n\t\t\t\tconst perlin = new ImprovedNoise(), z = Math.random() * 100;\n\n\t\t\t\tlet quality = 1;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\t\tconst x = i % width, y = ~ ~ ( i / width );\n\t\t\t\t\t\tdata[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tquality *= 5;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction generateTexture( data, width, height ) {\n\n\t\t\t\tlet context, image, imageData, shade;\n\n\t\t\t\tconst vector3 = new THREE.Vector3( 0, 0, 0 );\n\n\t\t\t\tconst sun = new THREE.Vector3( 1, 1, 1 );\n\t\t\t\tsun.normalize();\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tcontext = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = '#000';\n\t\t\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\t\t\timage = context.getImageData( 0, 0, canvas.width, canvas.height );\n\t\t\t\timageData = image.data;\n\n\t\t\t\tfor ( let i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {\n\n\t\t\t\t\tvector3.x = data[ j - 2 ] - data[ j + 2 ];\n\t\t\t\t\tvector3.y = 2;\n\t\t\t\t\tvector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];\n\t\t\t\t\tvector3.normalize();\n\n\t\t\t\t\tshade = vector3.dot( sun );\n\n\t\t\t\t\timageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );\n\t\t\t\t\timageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );\n\t\t\t\t\timageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t\t// Scaled 4x\n\n\t\t\t\tconst canvasScaled = document.createElement( 'canvas' );\n\t\t\t\tcanvasScaled.width = width * 4;\n\t\t\t\tcanvasScaled.height = height * 4;\n\n\t\t\t\tcontext = canvasScaled.getContext( '2d' );\n\t\t\t\tcontext.scale( 4, 4 );\n\t\t\t\tcontext.drawImage( canvas, 0, 0 );\n\n\t\t\t\timage = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );\n\t\t\t\timageData = image.data;\n\n\t\t\t\tfor ( let i = 0, l = imageData.length; i < l; i += 4 ) {\n\n\t\t\t\t\tconst v = ~ ~ ( Math.random() * 5 );\n\n\t\t\t\t\timageData[ i ] += v;\n\t\t\t\t\timageData[ i + 1 ] += v;\n\t\t\t\t\timageData[ i + 2 ] += v;\n\n\t\t\t\t}\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t\treturn canvasScaled;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\n\t\t\tfunction render() {\n\n\t\t\t\tcontrols.update( clock.getDelta() );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl terrain + fog demo (left click: forward, right click: backward)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - terrain"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - terrain:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, controls, scene, renderer;\n\n\t\t\tlet mesh, texture;\n\n\t\t\tconst worldWidth = 256, worldDepth = 256,\n\t\t\t\tworldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;\n\n\t\t\tlet helper;\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst pointer = new THREE.Vector2();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\t\t\t\tcontainer.innerHTML = '';\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 10, 20000 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1000;\n\t\t\t\tcontrols.maxDistance = 10000;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\t//\n\n\t\t\t\tconst data = generateHeight( worldWidth, worldDepth );\n\n\t\t\t\tcontrols.target.y = data[ worldHalfWidth + worldHalfDepth * worldWidth ] + 500;\n\t\t\t\tcamera.position.y = controls.target.y + 2000;\n\t\t\t\tcamera.position.x = 2000;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst vertices = geometry.attributes.position.array;\n\n\t\t\t\tfor ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {\n\n\t\t\t\t\tvertices[ j + 1 ] = data[ i ] * 10;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\ttexture = new THREE.CanvasTexture( generateTexture( data, worldWidth, worldDepth ) );\n\t\t\t\ttexture.wrapS = THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst geometryHelper = new THREE.ConeGeometry( 20, 100, 3 );\n\t\t\t\tgeometryHelper.translate( 0, 50, 0 );\n\t\t\t\tgeometryHelper.rotateX( Math.PI / 2 );\n\t\t\t\thelper = new THREE.Mesh( geometryHelper, new THREE.MeshNormalMaterial() );\n\t\t\t\tscene.add( helper );\n\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction generateHeight( width, height ) {\n\n\t\t\t\tconst size = width * height, data = new Uint8Array( size ),\n\t\t\t\t\tperlin = new ImprovedNoise(), z = Math.random() * 100;\n\n\t\t\t\tlet quality = 1;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\t\tconst x = i % width, y = ~ ~ ( i / width );\n\t\t\t\t\t\tdata[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tquality *= 5;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction generateTexture( data, width, height ) {\n\n\t\t\t\t// bake lighting into texture\n\n\t\t\t\tlet context, image, imageData, shade;\n\n\t\t\t\tconst vector3 = new THREE.Vector3( 0, 0, 0 );\n\n\t\t\t\tconst sun = new THREE.Vector3( 1, 1, 1 );\n\t\t\t\tsun.normalize();\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tcontext = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = '#000';\n\t\t\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\t\t\timage = context.getImageData( 0, 0, canvas.width, canvas.height );\n\t\t\t\timageData = image.data;\n\n\t\t\t\tfor ( let i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {\n\n\t\t\t\t\tvector3.x = data[ j - 2 ] - data[ j + 2 ];\n\t\t\t\t\tvector3.y = 2;\n\t\t\t\t\tvector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];\n\t\t\t\t\tvector3.normalize();\n\n\t\t\t\t\tshade = vector3.dot( sun );\n\n\t\t\t\t\timageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );\n\t\t\t\t\timageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );\n\t\t\t\t\timageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t\t// Scaled 4x\n\n\t\t\t\tconst canvasScaled = document.createElement( 'canvas' );\n\t\t\t\tcanvasScaled.width = width * 4;\n\t\t\t\tcanvasScaled.height = height * 4;\n\n\t\t\t\tcontext = canvasScaled.getContext( '2d' );\n\t\t\t\tcontext.scale( 4, 4 );\n\t\t\t\tcontext.drawImage( canvas, 0, 0 );\n\n\t\t\t\timage = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );\n\t\t\t\timageData = image.data;\n\n\t\t\t\tfor ( let i = 0, l = imageData.length; i < l; i += 4 ) {\n\n\t\t\t\t\tconst v = ~ ~ ( Math.random() * 5 );\n\n\t\t\t\t\timageData[ i ] += v;\n\t\t\t\t\timageData[ i + 1 ] += v;\n\t\t\t\t\timageData[ i + 2 ] += v;\n\n\t\t\t\t}\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t\treturn canvasScaled;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\t// See if the ray from the camera into the world hits one of our meshes\n\t\t\t\tconst intersects = raycaster.intersectObject( mesh );\n\n\t\t\t\t// Toggle rotation bool for meshes that we clicked\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\thelper.position.set( 0, 0, 0 );\n\t\t\t\t\thelper.lookAt( intersects[ 0 ].face.normal );\n\n\t\t\t\t\thelper.position.copy( intersects[ 0 ].point );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - webgl terrain raycasting demo"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - geometry - text"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - geometry - text:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tTHREE.Cache.enabled = true;\n\n\t\t\tlet container;\n\n\t\t\tlet camera, cameraTarget, scene, renderer;\n\n\t\t\tlet group, textMesh1, textMesh2, textGeo, materials;\n\n\t\t\tlet firstLetter = true;\n\n\t\t\tlet text = 'three.js',\n\n\t\t\t\tbevelEnabled = true,\n\n\t\t\t\tfont = undefined,\n\n\t\t\t\tfontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif\n\t\t\t\tfontWeight = 'bold'; // normal bold\n\n\t\t\tconst depth = 20,\n\t\t\t\tsize = 70,\n\t\t\t\thover = 30,\n\n\t\t\t\tcurveSegments = 4,\n\n\t\t\t\tbevelThickness = 2,\n\t\t\t\tbevelSize = 1.5;\n\n\t\t\tconst mirror = true;\n\n\t\t\tconst fontMap = {\n\n\t\t\t\t'helvetiker': 0,\n\t\t\t\t'optimer': 1,\n\t\t\t\t'gentilis': 2,\n\t\t\t\t'droid/droid_sans': 3,\n\t\t\t\t'droid/droid_serif': 4\n\n\t\t\t};\n\n\t\t\tconst weightMap = {\n\n\t\t\t\t'regular': 0,\n\t\t\t\t'bold': 1\n\n\t\t\t};\n\n\t\t\tconst reverseFontMap = [];\n\t\t\tconst reverseWeightMap = [];\n\n\t\t\tfor ( const i in fontMap ) reverseFontMap[ fontMap[ i ] ] = i;\n\t\t\tfor ( const i in weightMap ) reverseWeightMap[ weightMap[ i ] ] = i;\n\n\t\t\tlet targetRotation = 0;\n\t\t\tlet targetRotationOnPointerDown = 0;\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerXOnPointerDown = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\n\t\t\tlet fontIndex = 1;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );\n\t\t\t\tcamera.position.set( 0, 400, 700 );\n\n\t\t\t\tcameraTarget = new THREE.Vector3( 0, 150, 0 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x000000 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 250, 1400 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 0.4 );\n\t\t\t\tdirLight.position.set( 0, 0, 1 ).normalize();\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 4.5, 0, 0 );\n\t\t\t\tpointLight.color.setHSL( Math.random(), 1, 0.5 );\n\t\t\t\tpointLight.position.set( 0, 100, 90 );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tmaterials = [\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xffffff } ) // side\n\t\t\t\t];\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tgroup.position.y = 100;\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\tloadFont();\n\n\t\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10000, 10000 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )\n\t\t\t\t);\n\t\t\t\tplane.position.y = 100;\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\tdocument.addEventListener( 'keypress', onDocumentKeyPress );\n\t\t\t\tdocument.addEventListener( 'keydown', onDocumentKeyDown );\n\n\t\t\t\t//\n\n\t\t\t\tconst params = {\n\t\t\t\t\tchangeColor: function () {\n\n\t\t\t\t\t\tpointLight.color.setHSL( Math.random(), 1, 0.5 );\n\n\t\t\t\t\t},\n\t\t\t\t\tchangeFont: function () {\n\n\t\t\t\t\t\tfontIndex ++;\n\n\t\t\t\t\t\tfontName = reverseFontMap[ fontIndex % reverseFontMap.length ];\n\n\t\t\t\t\t\tloadFont();\n\n\t\t\t\t\t},\n\t\t\t\t\tchangeWeight: function () {\n\n\t\t\t\t\t\tif ( fontWeight === 'bold' ) {\n\n\t\t\t\t\t\t\tfontWeight = 'regular';\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfontWeight = 'bold';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadFont();\n\n\t\t\t\t\t},\n\t\t\t\t\tchangeBevel: function () {\n\n\t\t\t\t\t\tbevelEnabled = ! bevelEnabled;\n\n\t\t\t\t\t\trefreshText();\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'changeColor' ).name( 'change color' );\n\t\t\t\tgui.add( params, 'changeFont' ).name( 'change font' );\n\t\t\t\tgui.add( params, 'changeWeight' ).name( 'change weight' );\n\t\t\t\tgui.add( params, 'changeBevel' ).name( 'change bevel' );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onDocumentKeyDown( event ) {\n\n\t\t\t\tif ( firstLetter ) {\n\n\t\t\t\t\tfirstLetter = false;\n\t\t\t\t\ttext = '';\n\n\t\t\t\t}\n\n\t\t\t\tconst keyCode = event.keyCode;\n\n\t\t\t\t// backspace\n\n\t\t\t\tif ( keyCode == 8 ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\ttext = text.substring( 0, text.length - 1 );\n\t\t\t\t\trefreshText();\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onDocumentKeyPress( event ) {\n\n\t\t\t\tconst keyCode = event.which;\n\n\t\t\t\t// backspace\n\n\t\t\t\tif ( keyCode == 8 ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst ch = String.fromCharCode( keyCode );\n\t\t\t\t\ttext += ch;\n\n\t\t\t\t\trefreshText();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction loadFont() {\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/' + fontName + '_' + fontWeight + '.typeface.json', function ( response ) {\n\n\t\t\t\t\tfont = response;\n\n\t\t\t\t\trefreshText();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction createText() {\n\n\t\t\t\ttextGeo = new TextGeometry( text, {\n\n\t\t\t\t\tfont: font,\n\n\t\t\t\t\tsize: size,\n\t\t\t\t\tdepth: depth,\n\t\t\t\t\tcurveSegments: curveSegments,\n\n\t\t\t\t\tbevelThickness: bevelThickness,\n\t\t\t\t\tbevelSize: bevelSize,\n\t\t\t\t\tbevelEnabled: bevelEnabled\n\n\t\t\t\t} );\n\n\t\t\t\ttextGeo.computeBoundingBox();\n\n\t\t\t\tconst centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );\n\n\t\t\t\ttextMesh1 = new THREE.Mesh( textGeo, materials );\n\n\t\t\t\ttextMesh1.position.x = centerOffset;\n\t\t\t\ttextMesh1.position.y = hover;\n\t\t\t\ttextMesh1.position.z = 0;\n\n\t\t\t\ttextMesh1.rotation.x = 0;\n\t\t\t\ttextMesh1.rotation.y = Math.PI * 2;\n\n\t\t\t\tgroup.add( textMesh1 );\n\n\t\t\t\tif ( mirror ) {\n\n\t\t\t\t\ttextMesh2 = new THREE.Mesh( textGeo, materials );\n\n\t\t\t\t\ttextMesh2.position.x = centerOffset;\n\t\t\t\t\ttextMesh2.position.y = - hover;\n\t\t\t\t\ttextMesh2.position.z = depth;\n\n\t\t\t\t\ttextMesh2.rotation.x = Math.PI;\n\t\t\t\t\ttextMesh2.rotation.y = Math.PI * 2;\n\n\t\t\t\t\tgroup.add( textMesh2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction refreshText() {\n\n\t\t\t\tgroup.remove( textMesh1 );\n\t\t\t\tif ( mirror ) group.remove( textMesh2 );\n\n\t\t\t\tif ( ! text ) return;\n\n\t\t\t\tcreateText();\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerXOnPointerDown = event.clientX - windowHalfX;\n\t\t\t\ttargetRotationOnPointerDown = targetRotation;\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerX = event.clientX - windowHalfX;\n\n\t\t\t\ttargetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tdocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tgroup.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( cameraTarget );\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - procedural 3D text type to enter new text, drag to spin the text"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - simple text from json"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - simple text from json:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init( ) {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 0, - 400, 600 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst color = 0x006699;\n\n\t\t\t\t\tconst matDark = new THREE.LineBasicMaterial( {\n\t\t\t\t\t\tcolor: color,\n\t\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst matLite = new THREE.MeshBasicMaterial( {\n\t\t\t\t\t\tcolor: color,\n\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t\topacity: 0.4,\n\t\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst message = '   Three.js\\nSimple text.';\n\n\t\t\t\t\tconst shapes = font.generateShapes( message, 100 );\n\n\t\t\t\t\tconst geometry = new THREE.ShapeGeometry( shapes );\n\n\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\tconst xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );\n\n\t\t\t\t\tgeometry.translate( xMid, 0, 0 );\n\n\t\t\t\t\t// make shape ( N.B. edge view not visible )\n\n\t\t\t\t\tconst text = new THREE.Mesh( geometry, matLite );\n\t\t\t\t\ttext.position.z = - 150;\n\t\t\t\t\tscene.add( text );\n\n\t\t\t\t\t// make line shape ( N.B. edge view remains visible )\n\n\t\t\t\t\tconst holeShapes = [];\n\n\t\t\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tif ( shape.holes && shape.holes.length > 0 ) {\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < shape.holes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst hole = shape.holes[ j ];\n\t\t\t\t\t\t\t\tholeShapes.push( hole );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshapes.push( ...holeShapes );\n\n\t\t\t\t\tconst lineText = new THREE.Object3D();\n\n\t\t\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tconst points = shape.getPoints();\n\t\t\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( points );\n\n\t\t\t\t\t\tgeometry.translate( xMid, 0, 0 );\n\n\t\t\t\t\t\tconst lineMesh = new THREE.Line( geometry, matDark );\n\t\t\t\t\t\tlineText.add( lineMesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( lineText );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} ); //end load function\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t} // end init\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - simple text from json fonts"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - simple text from json"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - simple text from json:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { SVGLoader } from 'three/addons/loaders/SVGLoader.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init( ) {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 0, - 400, 600 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst color = new THREE.Color( 0x006699 );\n\n\t\t\t\t\tconst matDark = new THREE.MeshBasicMaterial( {\n\t\t\t\t\t\tcolor: color,\n\t\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst matLite = new THREE.MeshBasicMaterial( {\n\t\t\t\t\t\tcolor: color,\n\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t\topacity: 0.4,\n\t\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst message = '   Three.js\\nStroke text.';\n\n\t\t\t\t\tconst shapes = font.generateShapes( message, 100 );\n\n\t\t\t\t\tconst geometry = new THREE.ShapeGeometry( shapes );\n\n\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\tconst xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );\n\n\t\t\t\t\tgeometry.translate( xMid, 0, 0 );\n\n\t\t\t\t\t// make shape ( N.B. edge view not visible )\n\n\t\t\t\t\tconst text = new THREE.Mesh( geometry, matLite );\n\t\t\t\t\ttext.position.z = - 150;\n\t\t\t\t\tscene.add( text );\n\n\t\t\t\t\t// make line shape ( N.B. edge view remains visible )\n\n\t\t\t\t\tconst holeShapes = [];\n\n\t\t\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tif ( shape.holes && shape.holes.length > 0 ) {\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < shape.holes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst hole = shape.holes[ j ];\n\t\t\t\t\t\t\t\tholeShapes.push( hole );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshapes.push( ...holeShapes );\n\n\t\t\t\t\tconst style = SVGLoader.getStrokeStyle( 5, color.getStyle() );\n\n\t\t\t\t\tconst strokeText = new THREE.Group();\n\n\t\t\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tconst points = shape.getPoints();\n\n\t\t\t\t\t\tconst geometry = SVGLoader.pointsToStroke( points, style );\n\n\t\t\t\t\t\tgeometry.translate( xMid, 0, 0 );\n\n\t\t\t\t\t\tconst strokeMesh = new THREE.Mesh( geometry, matDark );\n\t\t\t\t\t\tstrokeText.add( strokeMesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( strokeText );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} ); //end load function\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t} // end init\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - simple text from json fonts"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - helpers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - helpers:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';\n\t\t\timport { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';\n\n\t\t\tlet scene, renderer;\n\t\t\tlet camera, light;\n\t\t\tlet vnh;\n\t\t\tlet vth;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\tlight.position.set( 200, 100, 150 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tscene.add( new THREE.PointLightHelper( light, 15 ) );\n\n\t\t\t\tconst gridHelper = new THREE.GridHelper( 400, 40, 0x0000ff, 0x808080 );\n\t\t\t\tgridHelper.position.y = - 150;\n\t\t\t\tgridHelper.position.x = - 150;\n\t\t\t\tscene.add( gridHelper );\n\n\t\t\t\tconst polarGridHelper = new THREE.PolarGridHelper( 200, 16, 8, 64, 0x0000ff, 0x808080 );\n\t\t\t\tpolarGridHelper.position.y = - 150;\n\t\t\t\tpolarGridHelper.position.x = 200;\n\t\t\t\tscene.add( polarGridHelper );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\n\t\t\t\t\tmesh.geometry.computeTangents(); // generates bad data due to degenerate UVs\n\n\t\t\t\t\tconst group = new THREE.Group();\n\t\t\t\t\tgroup.scale.multiplyScalar( 50 );\n\t\t\t\t\tscene.add( group );\n\n\t\t\t\t\t// To make sure that the matrixWorld is up to date for the boxhelpers\n\t\t\t\t\tgroup.updateMatrixWorld( true );\n\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\tvnh = new VertexNormalsHelper( mesh, 5 );\n\t\t\t\t\tscene.add( vnh );\n\n\t\t\t\t\tvth = new VertexTangentsHelper( mesh, 5 );\n\t\t\t\t\tscene.add( vth );\n\n\t\t\t\t\tscene.add( new THREE.BoxHelper( mesh ) );\n\n\t\t\t\t\tconst wireframe = new THREE.WireframeGeometry( mesh.geometry );\n\t\t\t\t\tlet line = new THREE.LineSegments( wireframe );\n\t\t\t\t\tline.material.depthTest = false;\n\t\t\t\t\tline.material.opacity = 0.25;\n\t\t\t\t\tline.material.transparent = true;\n\t\t\t\t\tline.position.x = 4;\n\t\t\t\t\tgroup.add( line );\n\t\t\t\t\tscene.add( new THREE.BoxHelper( line ) );\n\n\t\t\t\t\tconst edges = new THREE.EdgesGeometry( mesh.geometry );\n\t\t\t\t\tline = new THREE.LineSegments( edges );\n\t\t\t\t\tline.material.depthTest = false;\n\t\t\t\t\tline.material.opacity = 0.25;\n\t\t\t\t\tline.material.transparent = true;\n\t\t\t\t\tline.position.x = - 4;\n\t\t\t\t\tgroup.add( line );\n\t\t\t\t\tscene.add( new THREE.BoxHelper( line ) );\n\n\t\t\t\t\tscene.add( new THREE.BoxHelper( group ) );\n\t\t\t\t\tscene.add( new THREE.BoxHelper( scene ) );\n\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = - performance.now() * 0.0003;\n\n\t\t\t\tcamera.position.x = 400 * Math.cos( time );\n\t\t\t\tcamera.position.z = 400 * Math.sin( time );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tlight.position.x = Math.sin( time * 1.7 ) * 300;\n\t\t\t\tlight.position.y = Math.cos( time * 1.5 ) * 400;\n\t\t\t\tlight.position.z = Math.cos( time * 1.3 ) * 300;\n\n\t\t\t\tif ( vnh ) vnh.update();\n\t\t\t\tif ( vth ) vth.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - helpers"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - instancing - Morph Target Animations"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing - Morph Target Animations:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\t\n\t\t\tlet camera, scene, renderer, stats, mesh, mixer, dummy;\n\n\t\t\tconst offset = 5000;\n\n\t\t\tconst timeOffsets = new Float32Array( 1024 );\n\n\t\t\tfor ( let i = 0; i < 1024; i ++ ) {\n\n\t\t\t\ttimeOffsets[ i ] = Math.random() * 3;\n\n\t\t\t}\n\n\t\t\tconst clock = new THREE.Clock( true );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 10000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.background = new THREE.Color( 0x99DDFF );\n\n\t\t\t\tscene.fog = new THREE.Fog( 0x99DDFF, 5000, 10000 );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\n\t\t\t\tlight.position.set( 200, 1000, 50 );\n\n\t\t\t\tlight.castShadow = true;\n\n\t\t\t\tlight.shadow.camera.left = - 5000;\n\t\t\t\tlight.shadow.camera.right = 5000;\n\t\t\t\tlight.shadow.camera.top = 5000;\n\t\t\t\tlight.shadow.camera.bottom = - 5000;\n\t\t\t\tlight.shadow.camera.far = 2000;\n\n\t\t\t\tlight.shadow.bias = - 0.01;\n\n\t\t\t\tlight.shadow.camera.updateProjectionMatrix();\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst hemi = new THREE.HemisphereLight( 0x99DDFF, 0x669933, 1 / 3 );\n\n\t\t\t\tscene.add( hemi );\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 1000000, 1000000 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( { color: 0x669933, depthWrite: true } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\n\t\t\t\tloader.load( 'models/gltf/Horse.glb', function ( glb ) {\n\n\t\t\t\t\tdummy = glb.scene.children[ 0 ];\n\n\t\t\t\t\tmesh = new THREE.InstancedMesh( dummy.geometry, dummy.material, 1024 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\n\t\t\t\t\tfor ( let x = 0, i = 0; x < 32; x ++ ) {\n\n\t\t\t\t\t\tfor ( let y = 0; y < 32; y ++ ) {\n\n\t\t\t\t\t\t\tdummy.position.set( offset - 300 * x + 200 * Math.random(), 0, offset - 300 * y );\n\n\t\t\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t\t\t\tmesh.setColorAt( i, new THREE.Color( `hsl(${Math.random() * 360}, 50%, 66%)` ) );\n\n\t\t\t\t\t\t\ti ++;\n\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( glb.scene );\n\n\t\t\t\t\tconst action = mixer.clipAction( glb.animations[ 0 ] );\n\n\t\t\t\t\taction.play();\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\t\tconst r = 3000;\n\t\t\t\tcamera.position.set( Math.sin( time / 10 ) * r, 1500 + 1000 * Math.cos( time / 5 ), Math.cos( time / 10 ) * r );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 1024; i ++ ) {\n\n\t\t\t\t\t\tmixer.setTime( time + timeOffsets[ i ] );\n\n\t\t\t\t\t\tmesh.setMorphAt( i, dummy );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.morphTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl instancing morph in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing - Morph Target Animations:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\t\n\t\t\tlet camera, scene, renderer, stats, mesh, mixer, dummy;\n\n\t\t\tconst offset = 5000;\n\n\t\t\tconst timeOffsets = new Float32Array( 1024 );\n\n\t\t\tfor ( let i = 0; i < 1024; i ++ ) {\n\n\t\t\t\ttimeOffsets[ i ] = Math.random() * 3;\n\n\t\t\t}\n\n\t\t\tconst clock = new THREE.Clock( true );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 10000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.background = new THREE.Color( 0x99DDFF );\n\n\t\t\t\tscene.fog = new THREE.Fog( 0x99DDFF, 5000, 10000 );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\n\t\t\t\tlight.position.set( 200, 1000, 50 );\n\n\t\t\t\tlight.castShadow = true;\n\n\t\t\t\tlight.shadow.camera.left = - 5000;\n\t\t\t\tlight.shadow.camera.right = 5000;\n\t\t\t\tlight.shadow.camera.top = 5000;\n\t\t\t\tlight.shadow.camera.bottom = - 5000;\n\t\t\t\tlight.shadow.camera.far = 2000;\n\n\t\t\t\tlight.shadow.bias = - 0.01;\n\n\t\t\t\tlight.shadow.camera.updateProjectionMatrix();\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst hemi = new THREE.HemisphereLight( 0x99DDFF, 0x669933, 1 / 3 );\n\n\t\t\t\tscene.add( hemi );\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 1000000, 1000000 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( { color: 0x669933, depthWrite: true } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\n\t\t\t\tloader.load( 'models/gltf/Horse.glb', function ( glb ) {\n\n\t\t\t\t\tdummy = glb.scene.children[ 0 ];\n\n\t\t\t\t\tmesh = new THREE.InstancedMesh( dummy.geometry, dummy.material, 1024 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\n\t\t\t\t\tfor ( let x = 0, i = 0; x < 32; x ++ ) {\n\n\t\t\t\t\t\tfor ( let y = 0; y < 32; y ++ ) {\n\n\t\t\t\t\t\t\tdummy.position.set( offset - 300 * x + 200 * Math.random(), 0, offset - 300 * y );\n\n\t\t\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t\t\t\tmesh.setColorAt( i, new THREE.Color( `hsl(${Math.random() * 360}, 50%, 66%)` ) );\n\n\t\t\t\t\t\t\ti ++;\n\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( glb.scene );\n\n\t\t\t\t\tconst action = mixer.clipAction( glb.animations[ 0 ] );\n\n\t\t\t\t\taction.play();\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\t\tconst r = 3000;\n\t\t\t\tcamera.position.set( Math.sin( time / 10 ) * r, 1500 + 1000 * Math.cos( time / 5 ), Math.cos( time / 10 ) * r );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 1024; i ++ ) {\n\n\t\t\t\t\t\tmixer.setTime( time + timeOffsets[ i ] );\n\n\t\t\t\t\t\tmesh.setMorphAt( i, dummy );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.morphTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - instancing - dynamic"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing - dynamic:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\n\t\t\tlet camera, scene, renderer, timer, mesh;\n\n\t\t\tconst amount = 100;\n\n\t\t\tconst count = Math.pow( amount, 2 );\n\t\t\tconst dummy = new THREE.Object3D();\n\n\t\t\tconst seeds = [];\n\t\t\tconst baseColors = [];\n\n\t\t\tconst color = new THREE.Color();\n\t\t\tconst colors = [ new THREE.Color( 0x00ffff ), new THREE.Color( 0xffff00 ), new THREE.Color( 0xff00ff ) ];\n\t\t\tconst animation = { t: 0 };\n\t\t\tlet currentColorIndex = 0;\n\t\t\tlet nextColorIndex = 1;\n\n\t\t\tconst maxDistance = 75;\n\t\t\tconst cameraTarget = new THREE.Vector3();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 10, 10, 10 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xadd8e6 );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst texture = loader.load( 'textures/edge3.jpg' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { map: texture } );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, count );\n\t\t\t\tmesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst offset = ( amount - 1 ) / 2;\n\n\t\t\t\tfor ( let x = 0; x < amount; x ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z < amount; z ++ ) {\n\n\t\t\t\t\t\tdummy.position.set( offset - x, 0, offset - z );\n\t\t\t\t\t\tdummy.scale.set( 1, 2, 1 );\n\n\t\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\t\tcolor.setHSL( 1, 0.5 + ( Math.random() * 0.5 ), 0.5 + ( Math.random() * 0.5 ) );\n\t\t\t\t\t\tbaseColors.push( color.getHex() );\n\n\t\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\t\t\t\t\t\tmesh.setColorAt( i, color.multiply( colors[ 0 ] ) );\n\n\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\tseeds.push( Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tsetInterval( startTween, 3000 );\n\n\t\t\t}\n\n\t\t\tfunction startTween() {\n\n\t\t\t\t// tween for animating color transition\n\t\t\t\n\t\t\t\tnew TWEEN.Tween( animation )\n\t\t\t\t\t.to( {\n\t\t\t\t\t\tt: 1\n\t\t\t\t\t}, 2000 )\n\t\t\t\t\t.easing( TWEEN.Easing.Sinusoidal.In )\n\t\t\t\t\t.onComplete( () => {\n\n\t\t\t\t\t\tanimation.t = 0;\n\n\t\t\t\t\t\tcurrentColorIndex = nextColorIndex;\n\t\t\t\t\t\tnextColorIndex ++;\n\n\t\t\t\t\t\tif ( nextColorIndex >= colors.length ) nextColorIndex = 0;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.start();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\tconst time = timer.getElapsed();\n\n\t\t\t\tTWEEN.update();\n\n\t\t\t\t// animate camera\n\n\t\t\t\tcamera.position.x = Math.sin( time / 4 ) * 10;\n\t\t\t\tcamera.position.z = Math.cos( time / 4 ) * 10;\n\t\t\t\tcamera.position.y = 8 + Math.cos( time / 2 ) * 2;\n\n\t\t\t\tcameraTarget.x = Math.sin( time / 4 ) * - 8;\n\t\t\t\tcameraTarget.z = Math.cos( time / 2 ) * - 8;\n\n\t\t\t\tcamera.lookAt( cameraTarget );\n\n\t\t\t\tcamera.up.x = Math.sin( time / 400 );\n\n\t\t\t\t// animate instance positions and colors\n\n\t\t\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\t\t\tmesh.getMatrixAt( i, dummy.matrix );\n\t\t\t\t\tdummy.matrix.decompose( dummy.position, dummy.quaternion, dummy.scale );\n\n\t\t\t\t\tdummy.position.y = Math.abs( Math.sin( ( time + seeds[ i ] ) * 2 + seeds[ i ] ) );\n\n\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tif ( animation.t > 0 ) {\n\n\t\t\t\t\t\tconst currentColor = colors[ currentColorIndex ];\n\t\t\t\t\t\tconst nextColor = colors[ nextColorIndex ];\n\t\t\t\n\t\t\t\t\t\tconst f = dummy.position.length() / maxDistance;\n\n\t\t\t\t\t\tif ( f <= animation.t ) {\n\n\t\t\t\t\t\t\tcolor.set( baseColors[ i ] ).multiply( nextColor );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcolor.set( baseColors[ i ] ).multiply( currentColor );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmesh.setColorAt( i, color );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\t\t\t\tif ( animation.t > 0 ) mesh.instanceColor.needsUpdate = true;\n\t\t\t\n\t\t\t\tmesh.computeBoundingSphere();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - instancing - dynamic Based on Cubescape by oosmoxiecode"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - instancing - performance"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing - performance:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\tlet container, stats, gui, guiStatsEl;\n\t\tlet camera, controls, scene, renderer, material;\n\n\t\t// gui\n\n\t\tconst Method = {\n\t\t\tINSTANCED: 'INSTANCED',\n\t\t\tMERGED: 'MERGED',\n\t\t\tNAIVE: 'NAIVE'\n\t\t};\n\n\t\tconst api = {\n\t\t\tmethod: Method.INSTANCED,\n\t\t\tcount: 1000\n\t\t};\n\n\t\t//\n\n\t\tinit();\n\t\tinitMesh();\n\n\t\t//\n\n\t\tfunction clean() {\n\n\t\t\tconst meshes = [];\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isMesh ) meshes.push( object );\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tmesh.material.dispose();\n\t\t\t\tmesh.geometry.dispose();\n\n\t\t\t\tscene.remove( mesh );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst randomizeMatrix = function () {\n\n\t\t\tconst position = new THREE.Vector3();\n\t\t\tconst quaternion = new THREE.Quaternion();\n\t\t\tconst scale = new THREE.Vector3();\n\n\t\t\treturn function ( matrix ) {\n\n\t\t\t\tposition.x = Math.random() * 40 - 20;\n\t\t\t\tposition.y = Math.random() * 40 - 20;\n\t\t\t\tposition.z = Math.random() * 40 - 20;\n\n\t\t\t\tquaternion.random();\n\n\t\t\t\tscale.x = scale.y = scale.z = Math.random() * 1;\n\n\t\t\t\tmatrix.compose( position, quaternion, scale );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction initMesh() {\n\n\t\t\tclean();\n\n\t\t\t// make instances\n\t\t\tnew THREE.BufferGeometryLoader()\n\t\t\t\t.setPath( 'models/json/' )\n\t\t\t\t.load( 'suzanne_buffergeometry.json', function ( geometry ) {\n\n\t\t\t\t\tmaterial = new THREE.MeshNormalMaterial();\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconsole.time( api.method + ' (build)' );\n\n\t\t\t\t\tswitch ( api.method ) {\n\n\t\t\t\t\t\tcase Method.INSTANCED:\n\t\t\t\t\t\t\tmakeInstanced( geometry );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase Method.MERGED:\n\t\t\t\t\t\t\tmakeMerged( geometry );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase Method.NAIVE:\n\t\t\t\t\t\t\tmakeNaive( geometry );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.timeEnd( api.method + ' (build)' );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tfunction makeInstanced( geometry ) {\n\n\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\tconst mesh = new THREE.InstancedMesh( geometry, material, api.count );\n\n\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\trandomizeMatrix( matrix );\n\t\t\t\tmesh.setMatrixAt( i, matrix );\n\n\t\t\t}\n\n\t\t\tscene.add( mesh );\n\n\t\t\t//\n\n\t\t\tconst geometryByteLength = getGeometryByteLength( geometry );\n\n\t\t\tguiStatsEl.innerHTML = [\n\n\t\t\t\t'<i>GPU draw calls</i>: 1',\n\t\t\t\t'<i>GPU memory</i>: ' + formatBytes( api.count * 16 + geometryByteLength, 2 )\n\n\t\t\t].join( '<br/>' );\n\n\t\t}\n\n\t\tfunction makeMerged( geometry ) {\n\n\t\t\tconst geometries = [];\n\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\trandomizeMatrix( matrix );\n\n\t\t\t\tconst instanceGeometry = geometry.clone();\n\t\t\t\tinstanceGeometry.applyMatrix4( matrix );\n\n\t\t\t\tgeometries.push( instanceGeometry );\n\n\t\t\t}\n\n\t\t\tconst mergedGeometry = BufferGeometryUtils.mergeGeometries( geometries );\n\n\t\t\tscene.add( new THREE.Mesh( mergedGeometry, material ) );\n\n\t\t\t//\n\n\t\t\tguiStatsEl.innerHTML = [\n\n\t\t\t\t'<i>GPU draw calls</i>: 1',\n\t\t\t\t'<i>GPU memory</i>: ' + formatBytes( getGeometryByteLength( mergedGeometry ), 2 )\n\n\t\t\t].join( '<br/>' );\n\n\t\t}\n\n\t\tfunction makeNaive( geometry ) {\n\n\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\trandomizeMatrix( matrix );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.applyMatrix4( matrix );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst geometryByteLength = getGeometryByteLength( geometry );\n\n\t\t\tguiStatsEl.innerHTML = [\n\n\t\t\t\t'<i>GPU draw calls</i>: ' + api.count,\n\t\t\t\t'<i>GPU memory</i>: ' + formatBytes( api.count * 16 + geometryByteLength, 2 )\n\n\t\t\t].join( '<br/>' );\n\n\t\t}\n\n\t\tfunction init() {\n\n\t\t\tconst width = window.innerWidth;\n\t\t\tconst height = window.innerHeight;\n\n\t\t\t// camera\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 70, width / height, 1, 100 );\n\t\t\tcamera.position.z = 30;\n\n\t\t\t// renderer\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( width, height );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer = document.getElementById( 'container' );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t// scene\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t// controls\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.autoRotate = true;\n\n\t\t\t// stats\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t// gui\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( api, 'method', Method ).onChange( initMesh );\n\t\t\tgui.add( api, 'count', 1, 10000 ).step( 1 ).onChange( initMesh );\n\n\t\t\tconst perfFolder = gui.addFolder( 'Performance' );\n\n\t\t\tguiStatsEl = document.createElement( 'div' );\n\t\t\tguiStatsEl.classList.add( 'gui-stats' );\n\n\t\t\tperfFolder.$children.appendChild( guiStatsEl );\n\t\t\tperfFolder.open();\n\n\t\t\t// listeners\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tObject.assign( window, { scene } );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onWindowResize() {\n\n\t\t\tconst width = window.innerWidth;\n\t\t\tconst height = window.innerHeight;\n\n\t\t\tcamera.aspect = width / height;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( width, height );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tcontrols.update();\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update();\n\n\t\t}\n\n\t\t//\n\n\t\tfunction getGeometryByteLength( geometry ) {\n\n\t\t\tlet total = 0;\n\n\t\t\tif ( geometry.index ) total += geometry.index.array.byteLength;\n\n\t\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\t\ttotal += geometry.attributes[ name ].array.byteLength;\n\n\t\t\t}\n\n\t\t\treturn total;\n\n\t\t}\n\n\t\t// Source: https://stackoverflow.com/a/18650828/1314762\n\t\tfunction formatBytes( bytes, decimals ) {\n\n\t\t\tif ( bytes === 0 ) return '0 bytes';\n\n\t\t\tconst k = 1024;\n\t\t\tconst dm = decimals < 0 ? 0 : decimals;\n\t\t\tconst sizes = [ 'bytes', 'KB', 'MB' ];\n\n\t\t\tconst i = Math.floor( Math.log( bytes ) / Math.log( k ) );\n\n\t\t\treturn parseFloat( ( bytes / Math.pow( k, i ) ).toFixed( dm ) ) + ' ' + sizes[ i ];\n\n\t\t}\n```\n\nThis example three.js webgl - instancing - performance"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - instancing - raycast"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing - raycast:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls, stats;\n\n\t\t\tlet mesh;\n\t\t\tconst amount = parseInt( window.location.search.slice( 1 ) ) || 10;\n\t\t\tconst count = Math.pow( amount, 3 );\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst mouse = new THREE.Vector2( 1, 1 );\n\n\t\t\tconst color = new THREE.Color();\n\t\t\tconst white = new THREE.Color().setHex( 0xffffff );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( amount, amount, amount );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xffffff, 0x888888, 3 );\n\t\t\t\tlight.position.set( 0, 1, 0 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 0.5, 3 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff } );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, count );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst offset = ( amount - 1 ) / 2;\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tfor ( let x = 0; x < amount; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < amount; y ++ ) {\n\n\t\t\t\t\t\tfor ( let z = 0; z < amount; z ++ ) {\n\n\t\t\t\t\t\t\tmatrix.setPosition( offset - x, offset - y, offset - z );\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, matrix );\n\t\t\t\t\t\t\tmesh.setColorAt( i, color );\n\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( mesh, 'count', 0, count );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onMouseMove( event ) {\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\tconst intersection = raycaster.intersectObject( mesh );\n\n\t\t\t\tif ( intersection.length > 0 ) {\n\n\t\t\t\t\tconst instanceId = intersection[ 0 ].instanceId;\n\n\t\t\t\t\tmesh.getColorAt( instanceId, color );\n\n\t\t\t\t\tif ( color.equals( white ) ) {\n\n\t\t\t\t\t\tmesh.setColorAt( instanceId, color.setHex( Math.random() * 0xffffff ) );\n\n\t\t\t\t\t\tmesh.instanceColor.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - instancing - scatter"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing - scatter:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tconst api = {\n\n\t\t\t\tcount: 2000,\n\t\t\t\tdistribution: 'random',\n\t\t\t\tresample: resample,\n\t\t\t\tsurfaceColor: 0xFFF784,\n\t\t\t\tbackgroundColor: 0xE39469,\n\n\t\t\t};\n\n\t\t\tlet stemMesh, blossomMesh;\n\t\t\tlet stemGeometry, blossomGeometry;\n\t\t\tlet stemMaterial, blossomMaterial;\n\n\t\t\tlet sampler;\n\t\t\tconst count = api.count;\n\t\t\tconst ages = new Float32Array( count );\n\t\t\tconst scales = new Float32Array( count );\n\t\t\tconst dummy = new THREE.Object3D();\n\n\t\t\tconst _position = new THREE.Vector3();\n\t\t\tconst _normal = new THREE.Vector3();\n\t\t\tconst _scale = new THREE.Vector3();\n\n\t\t\t// let surfaceGeometry = new THREE.BoxGeometry( 10, 10, 10 ).toNonIndexed();\n\t\t\tconst surfaceGeometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 ).toNonIndexed();\n\t\t\tconst surfaceMaterial = new THREE.MeshLambertMaterial( { color: api.surfaceColor, wireframe: false } );\n\t\t\tconst surface = new THREE.Mesh( surfaceGeometry, surfaceMaterial );\n\n\t\t\t// Source: https://gist.github.com/gre/1650294\n\t\t\tconst easeOutCubic = function ( t ) {\n\n\t\t\t\treturn ( -- t ) * t * t + 1;\n\n\t\t\t};\n\n\t\t\t// Scaling curve causes particles to grow quickly, ease gradually into full scale, then\n\t\t\t// disappear quickly. More of the particle's lifetime is spent around full scale.\n\t\t\tconst scaleCurve = function ( t ) {\n\n\t\t\t\treturn Math.abs( easeOutCubic( ( t > 0.5 ? 1 - t : t ) * 2 ) );\n\n\t\t\t};\n\n\t\t\tconst loader = new GLTFLoader();\n\n\t\t\tloader.load( './models/gltf/Flower/Flower.glb', function ( gltf ) {\n\n\t\t\t\tconst _stemMesh = gltf.scene.getObjectByName( 'Stem' );\n\t\t\t\tconst _blossomMesh = gltf.scene.getObjectByName( 'Blossom' );\n\n\t\t\t\tstemGeometry = _stemMesh.geometry.clone();\n\t\t\t\tblossomGeometry = _blossomMesh.geometry.clone();\n\n\t\t\t\tconst defaultTransform = new THREE.Matrix4()\n\t\t\t\t\t.makeRotationX( Math.PI )\n\t\t\t\t\t.multiply( new THREE.Matrix4().makeScale( 7, 7, 7 ) );\n\n\t\t\t\tstemGeometry.applyMatrix4( defaultTransform );\n\t\t\t\tblossomGeometry.applyMatrix4( defaultTransform );\n\n\t\t\t\tstemMaterial = _stemMesh.material;\n\t\t\t\tblossomMaterial = _blossomMesh.material;\n\n\t\t\t\tstemMesh = new THREE.InstancedMesh( stemGeometry, stemMaterial, count );\n\t\t\t\tblossomMesh = new THREE.InstancedMesh( blossomGeometry, blossomMaterial, count );\n\n\t\t\t\t// Assign random colors to the blossoms.\n\t\t\t\tconst color = new THREE.Color();\n\t\t\t\tconst blossomPalette = [ 0xF20587, 0xF2D479, 0xF2C879, 0xF2B077, 0xF24405 ];\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tcolor.setHex( blossomPalette[ Math.floor( Math.random() * blossomPalette.length ) ] );\n\t\t\t\t\tblossomMesh.setColorAt( i, color );\n\n\t\t\t\t}\n\n\t\t\t\t// Instance matrices will be updated every frame.\n\t\t\t\tstemMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\tblossomMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\n\t\t\t\tresample();\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 25, 25, 25 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( api.backgroundColor );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xAA8899, 2.5, 0, 0 );\n\t\t\t\tpointLight.position.set( 50, - 25, 75 );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( stemMesh );\n\t\t\t\tscene.add( blossomMesh );\n\n\t\t\t\tscene.add( surface );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( api, 'count', 0, count ).onChange( function () {\n\n\t\t\t\t\tstemMesh.count = api.count;\n\t\t\t\t\tblossomMesh.count = api.count;\n\n\t\t\t\t} );\n\n\t\t\t\t// gui.addColor( api, 'backgroundColor' ).onChange( function () {\n\n\t\t\t\t// \tscene.background.setHex( api.backgroundColor );\n\n\t\t\t\t// } );\n\n\t\t\t\t// gui.addColor( api, 'surfaceColor' ).onChange( function () {\n\n\t\t\t\t// \tsurfaceMaterial.color.setHex( api.surfaceColor );\n\n\t\t\t\t// } );\n\n\t\t\t\tgui.add( api, 'distribution' ).options( [ 'random', 'weighted' ] ).onChange( resample );\n\t\t\t\tgui.add( api, 'resample' );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction resample() {\n\n\t\t\t\tconst vertexCount = surface.geometry.getAttribute( 'position' ).count;\n\n\t\t\t\tconsole.info( 'Sampling ' + count + ' points from a surface with ' + vertexCount + ' vertices...' );\n\n\t\t\t\t//\n\n\t\t\t\tconsole.time( '.build()' );\n\n\t\t\t\tsampler = new MeshSurfaceSampler( surface )\n\t\t\t\t\t.setWeightAttribute( api.distribution === 'weighted' ? 'uv' : null )\n\t\t\t\t\t.build();\n\n\t\t\t\tconsole.timeEnd( '.build()' );\n\n\t\t\t\t//\n\n\t\t\t\tconsole.time( '.sample()' );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tages[ i ] = Math.random();\n\t\t\t\t\tscales[ i ] = scaleCurve( ages[ i ] );\n\n\t\t\t\t\tresampleParticle( i );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.timeEnd( '.sample()' );\n\n\t\t\t\tstemMesh.instanceMatrix.needsUpdate = true;\n\t\t\t\tblossomMesh.instanceMatrix.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction resampleParticle( i ) {\n\n\t\t\t\tsampler.sample( _position, _normal );\n\t\t\t\t_normal.add( _position );\n\n\t\t\t\tdummy.position.copy( _position );\n\t\t\t\tdummy.scale.set( scales[ i ], scales[ i ], scales[ i ] );\n\t\t\t\tdummy.lookAt( _normal );\n\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\tstemMesh.setMatrixAt( i, dummy.matrix );\n\t\t\t\tblossomMesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t}\n\n\t\t\tfunction updateParticle( i ) {\n\n\t\t\t\t// Update lifecycle.\n\n\t\t\t\tages[ i ] += 0.005;\n\n\t\t\t\tif ( ages[ i ] >= 1 ) {\n\n\t\t\t\t\tages[ i ] = 0.001;\n\t\t\t\t\tscales[ i ] = scaleCurve( ages[ i ] );\n\n\t\t\t\t\tresampleParticle( i );\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// Update scale.\n\n\t\t\t\tconst prevScale = scales[ i ];\n\t\t\t\tscales[ i ] = scaleCurve( ages[ i ] );\n\t\t\t\t_scale.set( scales[ i ] / prevScale, scales[ i ] / prevScale, scales[ i ] / prevScale );\n\n\t\t\t\t// Update transform.\n\n\t\t\t\tstemMesh.getMatrixAt( i, dummy.matrix );\n\t\t\t\tdummy.matrix.scale( _scale );\n\t\t\t\tstemMesh.setMatrixAt( i, dummy.matrix );\n\t\t\t\tblossomMesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( stemMesh && blossomMesh ) {\n\n\t\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\t\tscene.rotation.x = Math.sin( time / 4 );\n\t\t\t\t\tscene.rotation.y = Math.sin( time / 2 );\n\n\t\t\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\t\t\tupdateParticle( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstemMesh.instanceMatrix.needsUpdate = true;\n\t\t\t\t\tblossomMesh.instanceMatrix.needsUpdate = true;\n\n\t\t\t\t\tstemMesh.computeBoundingSphere();\n\t\t\t\t\tblossomMesh.computeBoundingSphere();\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - interactive - buffergeometry"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive - buffergeometry:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet raycaster, pointer;\n\n\t\t\tlet mesh, line;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x444444, 3 ) );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffffff, 4.5 );\n\t\t\t\tlight2.position.set( 0, - 1, 0 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst triangles = 5000;\n\n\t\t\t\tlet geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = new Float32Array( triangles * 3 * 3 );\n\t\t\t\tconst normals = new Float32Array( triangles * 3 * 3 );\n\t\t\t\tconst colors = new Float32Array( triangles * 3 * 3 );\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst n = 800, n2 = n / 2;\t// triangles spread in the cube\n\t\t\t\tconst d = 120, d2 = d / 2;\t// individual triangle size\n\n\t\t\t\tconst pA = new THREE.Vector3();\n\t\t\t\tconst pB = new THREE.Vector3();\n\t\t\t\tconst pC = new THREE.Vector3();\n\n\t\t\t\tconst cb = new THREE.Vector3();\n\t\t\t\tconst ab = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < positions.length; i += 9 ) {\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tconst ax = x + Math.random() * d - d2;\n\t\t\t\t\tconst ay = y + Math.random() * d - d2;\n\t\t\t\t\tconst az = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst bx = x + Math.random() * d - d2;\n\t\t\t\t\tconst by = y + Math.random() * d - d2;\n\t\t\t\t\tconst bz = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst cx = x + Math.random() * d - d2;\n\t\t\t\t\tconst cy = y + Math.random() * d - d2;\n\t\t\t\t\tconst cz = z + Math.random() * d - d2;\n\n\t\t\t\t\tpositions[ i ] = ax;\n\t\t\t\t\tpositions[ i + 1 ] = ay;\n\t\t\t\t\tpositions[ i + 2 ] = az;\n\n\t\t\t\t\tpositions[ i + 3 ] = bx;\n\t\t\t\t\tpositions[ i + 4 ] = by;\n\t\t\t\t\tpositions[ i + 5 ] = bz;\n\n\t\t\t\t\tpositions[ i + 6 ] = cx;\n\t\t\t\t\tpositions[ i + 7 ] = cy;\n\t\t\t\t\tpositions[ i + 8 ] = cz;\n\n\t\t\t\t\t// flat face normals\n\n\t\t\t\t\tpA.set( ax, ay, az );\n\t\t\t\t\tpB.set( bx, by, bz );\n\t\t\t\t\tpC.set( cx, cy, cz );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\tconst nx = cb.x;\n\t\t\t\t\tconst ny = cb.y;\n\t\t\t\t\tconst nz = cb.z;\n\n\t\t\t\t\tnormals[ i ] = nx;\n\t\t\t\t\tnormals[ i + 1 ] = ny;\n\t\t\t\t\tnormals[ i + 2 ] = nz;\n\n\t\t\t\t\tnormals[ i + 3 ] = nx;\n\t\t\t\t\tnormals[ i + 4 ] = ny;\n\t\t\t\t\tnormals[ i + 5 ] = nz;\n\n\t\t\t\t\tnormals[ i + 6 ] = nx;\n\t\t\t\t\tnormals[ i + 7 ] = ny;\n\t\t\t\t\tnormals[ i + 8 ] = nz;\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tconst vx = ( x / n ) + 0.5;\n\t\t\t\t\tconst vy = ( y / n ) + 0.5;\n\t\t\t\t\tconst vz = ( z / n ) + 0.5;\n\n\t\t\t\t\tcolor.setRGB( vx, vy, vz );\n\n\t\t\t\t\tcolors[ i ] = color.r;\n\t\t\t\t\tcolors[ i + 1 ] = color.g;\n\t\t\t\t\tcolors[ i + 2 ] = color.b;\n\n\t\t\t\t\tcolors[ i + 3 ] = color.r;\n\t\t\t\t\tcolors[ i + 4 ] = color.g;\n\t\t\t\t\tcolors[ i + 5 ] = color.b;\n\n\t\t\t\t\tcolors[ i + 6 ] = color.r;\n\t\t\t\t\tcolors[ i + 7 ] = color.g;\n\t\t\t\t\tcolors[ i + 8 ] = color.b;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tlet material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xaaaaaa, specular: 0xffffff, shininess: 250,\n\t\t\t\t\tside: THREE.DoubleSide, vertexColors: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\tpointer = new THREE.Vector2();\n\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 4 * 3 ), 3 ) );\n\n\t\t\t\tmaterial = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true } );\n\n\t\t\t\tline = new THREE.Line( geometry, material );\n\t\t\t\tscene.add( line );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tmesh.rotation.x = time * 0.15;\n\t\t\t\tmesh.rotation.y = time * 0.25;\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObject( mesh );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst intersect = intersects[ 0 ];\n\t\t\t\t\tconst face = intersect.face;\n\n\t\t\t\t\tconst linePosition = line.geometry.attributes.position;\n\t\t\t\t\tconst meshPosition = mesh.geometry.attributes.position;\n\n\t\t\t\t\tlinePosition.copyAt( 0, meshPosition, face.a );\n\t\t\t\t\tlinePosition.copyAt( 1, meshPosition, face.b );\n\t\t\t\t\tlinePosition.copyAt( 2, meshPosition, face.c );\n\t\t\t\t\tlinePosition.copyAt( 3, meshPosition, face.a );\n\n\t\t\t\t\tmesh.updateMatrix();\n\n\t\t\t\t\tline.geometry.applyMatrix4( mesh.matrix );\n\n\t\t\t\t\tline.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tline.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - interactive - buffergeometry"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive cubes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive cubes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, raycaster, renderer;\n\n\t\t\tlet INTERSECTED;\n\t\t\tlet theta = 0;\n\n\t\t\tconst pointer = new THREE.Vector2();\n\t\t\tconst radius = 5;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\t\tfor ( let i = 0; i < 2000; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 40 - 20;\n\t\t\t\t\tobject.position.y = Math.random() * 40 - 20;\n\t\t\t\t\tobject.position.z = Math.random() * 40 - 20;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t}\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttheta += 0.1;\n\n\t\t\t\tcamera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.y = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// find intersections\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( scene.children, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tif ( INTERSECTED != intersects[ 0 ].object ) {\n\n\t\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\t\tINTERSECTED = intersects[ 0 ].object;\n\t\t\t\t\t\tINTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();\n\t\t\t\t\t\tINTERSECTED.material.emissive.setHex( 0xff0000 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\tINTERSECTED = null;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - interactive cubes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive cubes (gpu)"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive cubes (gpu):\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet pickingTexture, pickingScene;\n\t\t\tlet highlightBox;\n\n\t\t\tconst pickingData = [];\n\n\t\t\tconst pointer = new THREE.Vector2();\n\t\t\tconst offset = new THREE.Vector3( 10, 10, 10 );\n\t\t\tconst clearColor = new THREE.Color();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 500, 2000 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst defaultMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tflatShading: true,\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tshininess: 0\n\t\t\t\t} );\n\n\t\t\t\t// set up the picking texture to use a 32 bit integer so we can write and read integer ids from it\n\t\t\t\tpickingScene = new THREE.Scene();\n\t\t\t\tpickingTexture = new THREE.WebGLRenderTarget( 1, 1, {\n\n\t\t\t\t\ttype: THREE.IntType,\n\t\t\t\t\tformat: THREE.RGBAIntegerFormat,\n\t\t\t\t\tinternalFormat: 'RGBA32I',\n\n\t\t\t\t} );\n\t\t\t\tconst pickingMaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tglslVersion: THREE.GLSL3,\n\n\t\t\t\t\tvertexShader: /* glsl */`\n\t\t\t\t\t\tattribute int id;\n\t\t\t\t\t\tflat varying int vid;\n\t\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t\tvid = id;\n\t\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t`,\n\n\t\t\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t\t\tlayout(location = 0) out int out_id;\n\t\t\t\t\t\tflat varying int vid;\n\n\t\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t\tout_id = vid;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t`,\n\n\t\t\t\t} );\n\n\t\t\t\tfunction applyId( geometry, id ) {\n\n\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\tconst array = new Int16Array( position.count );\n\t\t\t\t\tarray.fill( id );\n\n\t\t\t\t\tconst bufferAttribute = new THREE.Int16BufferAttribute( array, 1, false );\n\t\t\t\t\tbufferAttribute.gpuType = THREE.IntType;\n\t\t\t\t\tgeometry.setAttribute( 'id', bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tfunction applyVertexColors( geometry, color ) {\n\n\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\tconst colors = [];\n\n\t\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = [];\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst quaternion = new THREE.Quaternion();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < 5000; i ++ ) {\n\n\t\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\t\t\tconst position = new THREE.Vector3();\n\t\t\t\t\tposition.x = Math.random() * 10000 - 5000;\n\t\t\t\t\tposition.y = Math.random() * 6000 - 3000;\n\t\t\t\t\tposition.z = Math.random() * 8000 - 4000;\n\n\t\t\t\t\tconst rotation = new THREE.Euler();\n\t\t\t\t\trotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\trotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\trotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tconst scale = new THREE.Vector3();\n\t\t\t\t\tscale.x = Math.random() * 200 + 100;\n\t\t\t\t\tscale.y = Math.random() * 200 + 100;\n\t\t\t\t\tscale.z = Math.random() * 200 + 100;\n\n\t\t\t\t\tquaternion.setFromEuler( rotation );\n\t\t\t\t\tmatrix.compose( position, quaternion, scale );\n\n\t\t\t\t\tgeometry.applyMatrix4( matrix );\n\n\t\t\t\t\t// give the geometry's vertices a random color to be displayed and an integer\n\t\t\t\t\t// identifier as a vertex attribute so boxes can be identified after being merged.\n\t\t\t\t\tapplyVertexColors( geometry, color.setHex( Math.random() * 0xffffff ) );\n\t\t\t\t\tapplyId( geometry, i );\n\n\t\t\t\t\tgeometries.push( geometry );\n\n\t\t\t\t\tpickingData[ i ] = {\n\n\t\t\t\t\t\tposition: position,\n\t\t\t\t\t\trotation: rotation,\n\t\t\t\t\t\tscale: scale\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tconst mergedGeometry = BufferGeometryUtils.mergeGeometries( geometries );\n\t\t\t\tscene.add( new THREE.Mesh( mergedGeometry, defaultMaterial ) );\n\t\t\t\tpickingScene.add( new THREE.Mesh( mergedGeometry, pickingMaterial ) );\n\n\t\t\t\thighlightBox = new THREE.Mesh(\n\t\t\t\t\tnew THREE.BoxGeometry(),\n\t\t\t\t\tnew THREE.MeshLambertMaterial( { color: 0xffff00 } )\n\t\t\t\t);\n\t\t\t\tscene.add( highlightBox );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.rotateSpeed = 1.0;\n\t\t\t\tcontrols.zoomSpeed = 1.2;\n\t\t\t\tcontrols.panSpeed = 0.8;\n\t\t\t\tcontrols.noZoom = false;\n\t\t\t\tcontrols.noPan = false;\n\t\t\t\tcontrols.staticMoving = true;\n\t\t\t\tcontrols.dynamicDampingFactor = 0.3;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\trenderer.domElement.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onPointerMove( e ) {\n\n\t\t\t\tpointer.x = e.clientX;\n\t\t\t\tpointer.y = e.clientY;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction pick() {\n\n\t\t\t\t// render the picking scene off-screen\n\t\t\t\t// set the view offset to represent just a single pixel under the mouse\n\t\t\t\tconst dpr = window.devicePixelRatio;\n\t\t\t\tcamera.setViewOffset(\n\t\t\t\t\trenderer.domElement.width, renderer.domElement.height,\n\t\t\t\t\tMath.floor( pointer.x * dpr ), Math.floor( pointer.y * dpr ),\n\t\t\t\t\t1, 1\n\t\t\t\t);\n\n\t\t\t\t// render the scene\n\t\t\t\trenderer.setRenderTarget( pickingTexture );\n\n\t\t\t\t// clear the background to - 1 meaning no item was hit\n\t\t\t\tclearColor.setRGB( - 1, - 1, - 1 );\n\t\t\t\trenderer.setClearColor( clearColor );\n\t\t\t\trenderer.render( pickingScene, camera );\n\n\t\t\t\t// Restore active render target to canvas\n\t\t\t\trenderer.setRenderTarget( null );\n\n\t\t\t\t// clear the view offset so rendering returns to normal\n\t\t\t\tcamera.clearViewOffset();\n\n\t\t\t\t// create buffer for reading single pixel\n\t\t\t\tconst pixelBuffer = new Int32Array( 4 );\n\n\t\t\t\t// read the pixel\n\t\t\t\trenderer\n\t\t\t\t\t.readRenderTargetPixelsAsync( pickingTexture, 0, 0, 1, 1, pixelBuffer )\n\t\t\t\t\t.then( () => {\n\n\t\t\t\t\t\tconst id = pixelBuffer[ 0 ];\n\t\t\t\t\t\tif ( id !== - 1 ) {\n\n\t\t\t\t\t\t\t// move our highlightBox so that it surrounds the picked object\n\t\t\t\t\t\t\tconst data = pickingData[ id ];\n\t\t\t\t\t\t\thighlightBox.position.copy( data.position );\n\t\t\t\t\t\t\thighlightBox.rotation.copy( data.rotation );\n\t\t\t\t\t\t\thighlightBox.scale.copy( data.scale ).add( offset );\n\t\t\t\t\t\t\thighlightBox.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thighlightBox.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpick();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - gpu picking"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive cubes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive cubes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, raycaster, renderer;\n\n\t\t\tlet theta = 0;\n\t\t\tlet INTERSECTED;\n\n\t\t\tconst pointer = new THREE.Vector2();\n\t\t\tconst radius = 25;\n\t\t\tconst frustumSize = 50;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 0.1, 100 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\t\tfor ( let i = 0; i < 2000; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 40 - 20;\n\t\t\t\t\tobject.position.y = Math.random() * 40 - 20;\n\t\t\t\t\tobject.position.z = Math.random() * 40 - 20;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t}\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.left = - frustumSize * aspect / 2;\n\t\t\t\tcamera.right = frustumSize * aspect / 2;\n\t\t\t\tcamera.top = frustumSize / 2;\n\t\t\t\tcamera.bottom = - frustumSize / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttheta += 0.1;\n\n\t\t\t\tcamera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.y = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// find intersections\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( scene.children, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tif ( INTERSECTED != intersects[ 0 ].object ) {\n\n\t\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\t\tINTERSECTED = intersects[ 0 ].object;\n\t\t\t\t\t\tINTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();\n\t\t\t\t\t\tINTERSECTED.material.emissive.setHex( 0xff0000 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\tINTERSECTED = null;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - interactive cubes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive lines"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive lines:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, raycaster, renderer, parentTransform, sphereInter;\n\n\t\t\tconst pointer = new THREE.Vector2();\n\t\t\tconst radius = 100;\n\t\t\tlet theta = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst info = document.createElement( 'div' );\n\t\t\t\tinfo.style.position = 'absolute';\n\t\t\t\tinfo.style.top = '10px';\n\t\t\t\tinfo.style.width = '100%';\n\t\t\t\tinfo.style.textAlign = 'center';\n\t\t\t\tinfo.innerHTML = '<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> webgl - interactive lines';\n\t\t\t\tcontainer.appendChild( info );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 5 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\n\n\t\t\t\tsphereInter = new THREE.Mesh( geometry, material );\n\t\t\t\tsphereInter.visible = false;\n\t\t\t\tscene.add( sphereInter );\n\n\t\t\t\tconst lineGeometry = new THREE.BufferGeometry();\n\t\t\t\tconst points = [];\n\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst direction = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tdirection.x += Math.random() - 0.5;\n\t\t\t\t\tdirection.y += Math.random() - 0.5;\n\t\t\t\t\tdirection.z += Math.random() - 0.5;\n\t\t\t\t\tdirection.normalize().multiplyScalar( 10 );\n\n\t\t\t\t\tpoint.add( direction );\n\t\t\t\t\tpoints.push( point.x, point.y, point.z );\n\n\t\t\t\t}\n\n\t\t\t\tlineGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( points, 3 ) );\n\n\t\t\t\tparentTransform = new THREE.Object3D();\n\t\t\t\tparentTransform.position.x = Math.random() * 40 - 20;\n\t\t\t\tparentTransform.position.y = Math.random() * 40 - 20;\n\t\t\t\tparentTransform.position.z = Math.random() * 40 - 20;\n\n\t\t\t\tparentTransform.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\tparentTransform.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\tparentTransform.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\tparentTransform.scale.x = Math.random() + 0.5;\n\t\t\t\tparentTransform.scale.y = Math.random() + 0.5;\n\t\t\t\tparentTransform.scale.z = Math.random() + 0.5;\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tlet object;\n\n\t\t\t\t\tconst lineMaterial = new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\t\t\t\tif ( Math.random() > 0.5 ) {\n\n\t\t\t\t\t\tobject = new THREE.Line( lineGeometry, lineMaterial );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.LineSegments( lineGeometry, lineMaterial );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.position.x = Math.random() * 400 - 200;\n\t\t\t\t\tobject.position.y = Math.random() * 400 - 200;\n\t\t\t\t\tobject.position.z = Math.random() * 400 - 200;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\n\t\t\t\t\tparentTransform.add( object );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( parentTransform );\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\t\t\t\traycaster.params.Line.threshold = 3;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttheta += 0.1;\n\n\t\t\t\tcamera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.y = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// find intersections\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( parentTransform.children, true );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tsphereInter.visible = true;\n\t\t\t\t\tsphereInter.position.copy( intersects[ 0 ].point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphereInter.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive particles:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet particles;\n\n\t\t\tconst PARTICLE_SIZE = 20;\n\n\t\t\tlet raycaster, intersects;\n\t\t\tlet pointer, INTERSECTED;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 250;\n\n\t\t\t\t//\n\n\t\t\t\tlet boxGeometry = new THREE.BoxGeometry( 200, 200, 200, 16, 16, 16 );\n\n\t\t\t\t// if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data\n\n\t\t\t\tboxGeometry.deleteAttribute( 'normal' );\n\t\t\t\tboxGeometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxGeometry = BufferGeometryUtils.mergeVertices( boxGeometry );\n\n\t\t\t\t//\n\n\t\t\t\tconst positionAttribute = boxGeometry.getAttribute( 'position' );\n\n\t\t\t\tconst colors = [];\n\t\t\t\tconst sizes = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tcolor.setHSL( 0.01 + 0.1 * ( i / l ), 1.0, 0.5 );\n\t\t\t\t\tcolor.toArray( colors, i * 3 );\n\n\t\t\t\t\tsizes[ i ] = PARTICLE_SIZE * 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'customColor', new THREE.Float32BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tcolor: { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\t\tpointTexture: { value: new THREE.TextureLoader().load( 'textures/sprites/disc.png' ) },\n\t\t\t\t\t\talphaTest: { value: 0.9 }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tparticles = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\t\t\t\tpointer = new THREE.Vector2();\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tparticles.rotation.x += 0.0005;\n\t\t\t\tparticles.rotation.y += 0.001;\n\n\t\t\t\tconst geometry = particles.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tintersects = raycaster.intersectObject( particles );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tif ( INTERSECTED != intersects[ 0 ].index ) {\n\n\t\t\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;\n\n\t\t\t\t\t\tINTERSECTED = intersects[ 0 ].index;\n\n\t\t\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 1.25;\n\t\t\t\t\t\tattributes.size.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( INTERSECTED !== null ) {\n\n\t\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;\n\t\t\t\t\tattributes.size.needsUpdate = true;\n\t\t\t\t\tINTERSECTED = null;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - interactive - particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive - raycasting - points"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive - raycasting - points:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\t\t\tlet pointclouds;\n\t\t\tlet raycaster;\n\t\t\tlet intersection = null;\n\t\t\tlet spheresIndex = 0;\n\t\t\tlet clock;\n\t\t\tlet toggle = 0;\n\n\t\t\tconst pointer = new THREE.Vector2();\n\t\t\tconst spheres = [];\n\n\t\t\tconst threshold = 0.1;\n\t\t\tconst pointSize = 0.05;\n\t\t\tconst width = 80;\n\t\t\tconst length = 160;\n\t\t\tconst rotateY = new THREE.Matrix4().makeRotationY( 0.005 );\n\n\t\t\tinit();\n\n\t\t\tfunction generatePointCloudGeometry( color, width, length ) {\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst numPoints = width * length;\n\n\t\t\t\tconst positions = new Float32Array( numPoints * 3 );\n\t\t\t\tconst colors = new Float32Array( numPoints * 3 );\n\n\t\t\t\tlet k = 0;\n\n\t\t\t\tfor ( let i = 0; i < width; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < length; j ++ ) {\n\n\t\t\t\t\t\tconst u = i / width;\n\t\t\t\t\t\tconst v = j / length;\n\t\t\t\t\t\tconst x = u - 0.5;\n\t\t\t\t\t\tconst y = ( Math.cos( u * Math.PI * 4 ) + Math.sin( v * Math.PI * 8 ) ) / 20;\n\t\t\t\t\t\tconst z = v - 0.5;\n\n\t\t\t\t\t\tpositions[ 3 * k ] = x;\n\t\t\t\t\t\tpositions[ 3 * k + 1 ] = y;\n\t\t\t\t\t\tpositions[ 3 * k + 2 ] = z;\n\n\t\t\t\t\t\tconst intensity = ( y + 0.1 ) * 5;\n\t\t\t\t\t\tcolors[ 3 * k ] = color.r * intensity;\n\t\t\t\t\t\tcolors[ 3 * k + 1 ] = color.g * intensity;\n\t\t\t\t\t\tcolors[ 3 * k + 2 ] = color.b * intensity;\n\n\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction generatePointcloud( color, width, length ) {\n\n\t\t\t\tconst geometry = generatePointCloudGeometry( color, width, length );\n\t\t\t\tconst material = new THREE.PointsMaterial( { size: pointSize, vertexColors: true } );\n\n\t\t\t\treturn new THREE.Points( geometry, material );\n\n\t\t\t}\n\n\t\t\tfunction generateIndexedPointcloud( color, width, length ) {\n\n\t\t\t\tconst geometry = generatePointCloudGeometry( color, width, length );\n\t\t\t\tconst numPoints = width * length;\n\t\t\t\tconst indices = new Uint16Array( numPoints );\n\n\t\t\t\tlet k = 0;\n\n\t\t\t\tfor ( let i = 0; i < width; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < length; j ++ ) {\n\n\t\t\t\t\t\tindices[ k ] = k;\n\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\n\t\t\t\tconst material = new THREE.PointsMaterial( { size: pointSize, vertexColors: true } );\n\n\t\t\t\treturn new THREE.Points( geometry, material );\n\n\t\t\t}\n\n\t\t\tfunction generateIndexedWithOffsetPointcloud( color, width, length ) {\n\n\t\t\t\tconst geometry = generatePointCloudGeometry( color, width, length );\n\t\t\t\tconst numPoints = width * length;\n\t\t\t\tconst indices = new Uint16Array( numPoints );\n\n\t\t\t\tlet k = 0;\n\n\t\t\t\tfor ( let i = 0; i < width; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < length; j ++ ) {\n\n\t\t\t\t\t\tindices[ k ] = k;\n\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t\tconst material = new THREE.PointsMaterial( { size: pointSize, vertexColors: true } );\n\n\t\t\t\treturn new THREE.Points( geometry, material );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 10, 10, 10 );\n\t\t\t\tcamera.lookAt( scene.position );\n\t\t\t\tcamera.updateMatrix();\n\n\t\t\t\t//\n\n\t\t\t\tconst pcBuffer = generatePointcloud( new THREE.Color( 1, 0, 0 ), width, length );\n\t\t\t\tpcBuffer.scale.set( 5, 10, 10 );\n\t\t\t\tpcBuffer.position.set( - 5, 0, 0 );\n\t\t\t\tscene.add( pcBuffer );\n\n\t\t\t\tconst pcIndexed = generateIndexedPointcloud( new THREE.Color( 0, 1, 0 ), width, length );\n\t\t\t\tpcIndexed.scale.set( 5, 10, 10 );\n\t\t\t\tpcIndexed.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( pcIndexed );\n\n\t\t\t\tconst pcIndexedOffset = generateIndexedWithOffsetPointcloud( new THREE.Color( 0, 1, 1 ), width, length );\n\t\t\t\tpcIndexedOffset.scale.set( 5, 10, 10 );\n\t\t\t\tpcIndexedOffset.position.set( 5, 0, 0 );\n\t\t\t\tscene.add( pcIndexedOffset );\n\n\t\t\t\tpointclouds = [ pcBuffer, pcIndexed, pcIndexedOffset ];\n\n\t\t\t\t//\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );\n\t\t\t\tconst sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\n\n\t\t\t\tfor ( let i = 0; i < 40; i ++ ) {\n\n\t\t\t\t\tconst sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );\n\t\t\t\t\tscene.add( sphere );\n\t\t\t\t\tspheres.push( sphere );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\t\t\t\traycaster.params.Points.threshold = threshold;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcamera.applyMatrix4( rotateY );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersections = raycaster.intersectObjects( pointclouds, false );\n\t\t\t\tintersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;\n\n\t\t\t\tif ( toggle > 0.02 && intersection !== null ) {\n\n\t\t\t\t\tspheres[ spheresIndex ].position.copy( intersection.point );\n\t\t\t\t\tspheres[ spheresIndex ].scale.set( 1, 1, 1 );\n\t\t\t\t\tspheresIndex = ( spheresIndex + 1 ) % spheres.length;\n\n\t\t\t\t\ttoggle = 0;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < spheres.length; i ++ ) {\n\n\t\t\t\t\tconst sphere = spheres[ i ];\n\t\t\t\t\tsphere.scale.multiplyScalar( 0.98 );\n\t\t\t\t\tsphere.scale.clampScalar( 0.01, 1 );\n\n\t\t\t\t}\n\n\t\t\t\ttoggle += clock.getDelta();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - interactive - raycasting - points"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - interactive - voxel painter"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - interactive - voxel painter:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet plane;\n\t\t\tlet pointer, raycaster, isShiftDown = false;\n\n\t\t\tlet rollOverMesh, rollOverMaterial;\n\t\t\tlet cubeGeo, cubeMaterial;\n\n\t\t\tconst objects = [];\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 500, 800, 1300 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\t// roll-over helpers\n\n\t\t\t\tconst rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );\n\t\t\t\trollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );\n\t\t\t\trollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );\n\t\t\t\tscene.add( rollOverMesh );\n\n\t\t\t\t// cubes\n\n\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/square-outline-textured.png' );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tcubeGeo = new THREE.BoxGeometry( 50, 50, 50 );\n\t\t\t\tcubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, map: map } );\n\n\t\t\t\t// grid\n\n\t\t\t\tconst gridHelper = new THREE.GridHelper( 1000, 20 );\n\t\t\t\tscene.add( gridHelper );\n\n\t\t\t\t//\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\t\t\t\tpointer = new THREE.Vector2();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 1000, 1000 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tplane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tobjects.push( plane );\n\n\t\t\t\t// lights\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0x606060, 3 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 1, 0.75, 0.5 ).normalize();\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerdown', onPointerDown );\n\t\t\t\tdocument.addEventListener( 'keydown', onDocumentKeyDown );\n\t\t\t\tdocument.addEventListener( 'keyup', onDocumentKeyUp );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( objects, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst intersect = intersects[ 0 ];\n\n\t\t\t\t\trollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );\n\t\t\t\t\trollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );\n\n\t\t\t\t\trender();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tpointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( objects, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst intersect = intersects[ 0 ];\n\n\t\t\t\t\t// delete cube\n\n\t\t\t\t\tif ( isShiftDown ) {\n\n\t\t\t\t\t\tif ( intersect.object !== plane ) {\n\n\t\t\t\t\t\t\tscene.remove( intersect.object );\n\n\t\t\t\t\t\t\tobjects.splice( objects.indexOf( intersect.object ), 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// create cube\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst voxel = new THREE.Mesh( cubeGeo, cubeMaterial );\n\t\t\t\t\t\tvoxel.position.copy( intersect.point ).add( intersect.face.normal );\n\t\t\t\t\t\tvoxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );\n\t\t\t\t\t\tscene.add( voxel );\n\n\t\t\t\t\t\tobjects.push( voxel );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trender();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onDocumentKeyDown( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\tcase 16: isShiftDown = true; break;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onDocumentKeyUp( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\tcase 16: isShiftDown = false; break;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - voxel painter - webgl click : add voxel, shift + click : remove voxel"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - lensflares"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lensflares:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { FlyControls } from 'three/addons/controls/FlyControls.js';\n\t\t\timport { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 15000 );\n\t\t\t\tcamera.position.z = 250;\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color().setHSL( 0.51, 0.4, 0.01, THREE.SRGBColorSpace );\n\t\t\t\tscene.fog = new THREE.Fog( scene.background, 3500, 15000 );\n\n\t\t\t\t// world\n\n\t\t\t\tconst s = 250;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( s, s, s );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0xffffff, shininess: 50 } );\n\n\t\t\t\tfor ( let i = 0; i < 3000; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = 8000 * ( 2.0 * Math.random() - 1.0 );\n\t\t\t\t\tmesh.position.y = 8000 * ( 2.0 * Math.random() - 1.0 );\n\t\t\t\t\tmesh.position.z = 8000 * ( 2.0 * Math.random() - 1.0 );\n\n\t\t\t\t\tmesh.rotation.x = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.y = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.z = Math.random() * Math.PI;\n\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tmesh.updateMatrix();\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\n\t\t\t\t// lights\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 0.15 );\n\t\t\t\tdirLight.position.set( 0, - 1, 0 ).normalize();\n\t\t\t\tdirLight.color.setHSL( 0.1, 0.7, 0.5 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// lensflares\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst textureFlare0 = textureLoader.load( 'textures/lensflare/lensflare0.png' );\n\t\t\t\tconst textureFlare3 = textureLoader.load( 'textures/lensflare/lensflare3.png' );\n\n\t\t\t\taddLight( 0.55, 0.9, 0.5, 5000, 0, - 1000 );\n\t\t\t\taddLight( 0.08, 0.8, 0.5, 0, 0, - 1000 );\n\t\t\t\taddLight( 0.995, 0.5, 0.9, 5000, 5000, - 1000 );\n\n\t\t\t\tfunction addLight( h, s, l, x, y, z ) {\n\n\t\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 1.5, 2000, 0 );\n\t\t\t\t\tlight.color.setHSL( h, s, l );\n\t\t\t\t\tlight.position.set( x, y, z );\n\t\t\t\t\tscene.add( light );\n\n\t\t\t\t\tconst lensflare = new Lensflare();\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare0, 700, 0, light.color ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 60, 0.6 ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 70, 0.7 ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 120, 0.9 ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 70, 1 ) );\n\t\t\t\t\tlight.add( lensflare );\n\n\t\t\t\t}\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new FlyControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.movementSpeed = 2500;\n\t\t\t\tcontrols.domElement = container;\n\t\t\t\tcontrols.rollSpeed = Math.PI / 6;\n\t\t\t\tcontrols.autoForward = false;\n\t\t\t\tcontrols.dragToLook = false;\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// events\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tcontrols.update( delta );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - lensflares textures from ro.me fly with WASD/RF/QE + mouse"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - light probe"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - light probe:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n\n\t\t\timport { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';\n\n\t\t\tlet mesh, renderer, scene, camera;\n\n\t\t\tlet gui;\n\n\t\t\tlet lightProbe;\n\t\t\tlet directionalLight;\n\n\t\t\t// linear color space\n\t\t\tconst API = {\n\t\t\t\tlightProbeIntensity: 1.0,\n\t\t\t\tdirectionalLightIntensity: 0.6,\n\t\t\t\tenvMapIntensity: 1\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// tone mapping\n\t\t\t\trenderer.toneMapping = THREE.NoToneMapping;\n\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 30 );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// probe\n\t\t\t\tlightProbe = new THREE.LightProbe();\n\t\t\t\tscene.add( lightProbe );\n\n\t\t\t\t// light\n\t\t\t\tdirectionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );\n\t\t\t\tdirectionalLight.position.set( 10, 10, 10 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// envmap\n\t\t\t\tconst genCubeUrls = function ( prefix, postfix ) {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tprefix + 'px' + postfix, prefix + 'nx' + postfix,\n\t\t\t\t\t\tprefix + 'py' + postfix, prefix + 'ny' + postfix,\n\t\t\t\t\t\tprefix + 'pz' + postfix, prefix + 'nz' + postfix\n\t\t\t\t\t];\n\n\t\t\t\t};\n\n\t\t\t\tconst urls = genCubeUrls( 'textures/cube/pisa/', '.png' );\n\n\t\t\t\tnew THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {\n\n\t\t\t\t\tscene.background = cubeTexture;\n\n\t\t\t\t\tlightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );\n\t\t\t\t\tlightProbe.intensity = API.lightProbeIntensity;\n\t\t\t\t\tlightProbe.position.set( - 10, 0, 0 ); // position not used in scene lighting calculations (helper honors the position, however)\n\n\t\t\t\t\tconst geometry = new THREE.SphereGeometry( 5, 64, 32 );\n\t\t\t\t\t//const geometry = new THREE.TorusKnotGeometry( 4, 1.5, 256, 32, 2, 3 );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\tmetalness: 0,\n\t\t\t\t\t\troughness: 0,\n\t\t\t\t\t\tenvMap: cubeTexture,\n\t\t\t\t\t\tenvMapIntensity: API.envMapIntensity,\n\t\t\t\t\t} );\n\n\t\t\t\t\t// mesh\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t// helper\n\t\t\t\t\tconst helper = new LightProbeHelper( lightProbe, 1 );\n\t\t\t\t\tscene.add( helper );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\n\t\t\t\t// gui\n\t\t\t\tgui = new GUI( { title: 'Intensity' } );\n\n\t\t\t\tgui.add( API, 'lightProbeIntensity', 0, 1, 0.02 )\n\t\t\t\t\t.name( 'light probe' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tlightProbe.intensity = API.lightProbeIntensity; render();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( API, 'directionalLightIntensity', 0, 1, 0.02 )\n\t\t\t\t\t.name( 'directional light' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tdirectionalLight.intensity = API.directionalLightIntensity; render();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( API, 'envMapIntensity', 0, 1, 0.02 )\n\t\t\t\t\t.name( 'envMap' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmesh.material.envMapIntensity = API.envMapIntensity; render();\n\n\t\t\t\t\t} );\n\n\t\t\t\t// listener\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - light probe"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - light probe from cubeCamera"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - light probe from cubeCamera:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';\n\t\t\timport { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n\n\t\t\tlet renderer, scene, camera, cubeCamera;\n\n\t\t\tlet lightProbe;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 30 );\n\n\t\t\t\tconst cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );\n\n\t\t\t\tcubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// probe\n\t\t\t\tlightProbe = new THREE.LightProbe();\n\t\t\t\tscene.add( lightProbe );\n\n\t\t\t\t// envmap\n\t\t\t\tconst genCubeUrls = function ( prefix, postfix ) {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tprefix + 'px' + postfix, prefix + 'nx' + postfix,\n\t\t\t\t\t\tprefix + 'py' + postfix, prefix + 'ny' + postfix,\n\t\t\t\t\t\tprefix + 'pz' + postfix, prefix + 'nz' + postfix\n\t\t\t\t\t];\n\n\t\t\t\t};\n\n\t\t\t\tconst urls = genCubeUrls( 'textures/cube/pisa/', '.png' );\n\n\t\t\t\tnew THREE.CubeTextureLoader().load( urls, async function ( cubeTexture ) {\n\n\t\t\t\t\tscene.background = cubeTexture;\n\n\t\t\t\t\tcubeCamera.update( renderer, scene );\n\n\t\t\t\t\tconst probe = await LightProbeGenerator.fromCubeRenderTarget( renderer, cubeRenderTarget );\n\n\t\t\t\t\tlightProbe.copy( probe );\n\n\t\t\t\t\tscene.add( new LightProbeHelper( lightProbe, 5 ) );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t// listener\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - light probe from cubeCamera"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - lights - hemisphere light"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lights - hemisphere light:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tconst mixers = [];\n\t\t\tlet stats;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.set( 0, 0, 250 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color().setHSL( 0.6, 0, 1 );\n\t\t\t\tscene.fog = new THREE.Fog( scene.background, 1, 5000 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );\n\t\t\t\themiLight.color.setHSL( 0.6, 1, 0.6 );\n\t\t\t\themiLight.groundColor.setHSL( 0.095, 1, 0.75 );\n\t\t\t\themiLight.position.set( 0, 50, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );\n\t\t\t\tscene.add( hemiLightHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.color.setHSL( 0.1, 1, 0.95 );\n\t\t\t\tdirLight.position.set( - 1, 1.75, 1 );\n\t\t\t\tdirLight.position.multiplyScalar( 30 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tdirLight.castShadow = true;\n\n\t\t\t\tdirLight.shadow.mapSize.width = 2048;\n\t\t\t\tdirLight.shadow.mapSize.height = 2048;\n\n\t\t\t\tconst d = 50;\n\n\t\t\t\tdirLight.shadow.camera.left = - d;\n\t\t\t\tdirLight.shadow.camera.right = d;\n\t\t\t\tdirLight.shadow.camera.top = d;\n\t\t\t\tdirLight.shadow.camera.bottom = - d;\n\n\t\t\t\tdirLight.shadow.camera.far = 3500;\n\t\t\t\tdirLight.shadow.bias = - 0.0001;\n\n\t\t\t\tconst dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );\n\t\t\t\tscene.add( dirLightHelper );\n\n\t\t\t\t// GROUND\n\n\t\t\t\tconst groundGeo = new THREE.PlaneGeometry( 10000, 10000 );\n\t\t\t\tconst groundMat = new THREE.MeshLambertMaterial( { color: 0xffffff } );\n\t\t\t\tgroundMat.color.setHSL( 0.095, 1, 0.75 );\n\n\t\t\t\tconst ground = new THREE.Mesh( groundGeo, groundMat );\n\t\t\t\tground.position.y = - 33;\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// SKYDOME\n\n\t\t\t\tconst vertexShader = document.getElementById( 'vertexShader' ).textContent;\n\t\t\t\tconst fragmentShader = document.getElementById( 'fragmentShader' ).textContent;\n\t\t\t\tconst uniforms = {\n\t\t\t\t\t'topColor': { value: new THREE.Color( 0x0077ff ) },\n\t\t\t\t\t'bottomColor': { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\t'offset': { value: 33 },\n\t\t\t\t\t'exponent': { value: 0.6 }\n\t\t\t\t};\n\t\t\t\tuniforms[ 'topColor' ].value.copy( hemiLight.color );\n\n\t\t\t\tscene.fog.color.copy( uniforms[ 'bottomColor' ].value );\n\n\t\t\t\tconst skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );\n\t\t\t\tconst skyMat = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: vertexShader,\n\t\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\t\tside: THREE.BackSide\n\t\t\t\t} );\n\n\t\t\t\tconst sky = new THREE.Mesh( skyGeo, skyMat );\n\t\t\t\tscene.add( sky );\n\n\t\t\t\t// MODEL\n\n\t\t\t\tconst loader = new GLTFLoader();\n\n\t\t\t\tloader.load( 'models/gltf/Flamingo.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\n\t\t\t\t\tconst s = 0.35;\n\t\t\t\t\tmesh.scale.set( s, s, s );\n\t\t\t\t\tmesh.position.y = 15;\n\t\t\t\t\tmesh.rotation.y = - 1;\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tconst mixer = new THREE.AnimationMixer( mesh );\n\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();\n\t\t\t\t\tmixers.push( mixer );\n\n\t\t\t\t} );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\n\t\t\t\t// STATS\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst params = {\n\t\t\t\t\ttoggleHemisphereLight: function () {\n\n\t\t\t\t\t\themiLight.visible = ! hemiLight.visible;\n\t\t\t\t\t\themiLightHelper.visible = ! hemiLightHelper.visible;\n\n\t\t\t\t\t},\n\t\t\t\t\ttoggleDirectionalLight: function () {\n\n\t\t\t\t\t\tdirLight.visible = ! dirLight.visible;\n\t\t\t\t\t\tdirLightHelper.visible = ! dirLightHelper.visible;\n\n\t\t\t\t\t},\n\t\t\t\t\tshadowIntensity: 1\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'toggleHemisphereLight' ).name( 'toggle hemisphere light' );\n\t\t\t\tgui.add( params, 'toggleDirectionalLight' ).name( 'toggle directional light' );\n\t\t\t\tgui.add( params, 'shadowIntensity', 0, 1 ).name( 'shadow intensity' ).onChange( ( value ) => {\n\n\t\t\t\t\tdirLight.shadow.intensity = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( let i = 0; i < mixers.length; i ++ ) {\n\n\t\t\t\t\tmixers[ i ].update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl hemisphere light example flamingo by mirada from ro.me"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - lights - physical lights"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lights - physical lights:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;\n\t\t\tlet ballMat, cubeMat, floorMat;\n\n\t\t\tlet previousShadowMap = false;\n\n\n\t\t\t// ref for lumens: http://www.power-sure.com/lumens.htm\n\t\t\tconst bulbLuminousPowers = {\n\t\t\t\t'110000 lm (1000W)': 110000,\n\t\t\t\t'3500 lm (300W)': 3500,\n\t\t\t\t'1700 lm (100W)': 1700,\n\t\t\t\t'800 lm (60W)': 800,\n\t\t\t\t'400 lm (40W)': 400,\n\t\t\t\t'180 lm (25W)': 180,\n\t\t\t\t'20 lm (4W)': 20,\n\t\t\t\t'Off': 0\n\t\t\t};\n\n\t\t\t// ref for solar irradiances: https://en.wikipedia.org/wiki/Lux\n\t\t\tconst hemiLuminousIrradiances = {\n\t\t\t\t'0.0001 lx (Moonless Night)': 0.0001,\n\t\t\t\t'0.002 lx (Night Airglow)': 0.002,\n\t\t\t\t'0.5 lx (Full Moon)': 0.5,\n\t\t\t\t'3.4 lx (City Twilight)': 3.4,\n\t\t\t\t'50 lx (Living Room)': 50,\n\t\t\t\t'100 lx (Very Overcast)': 100,\n\t\t\t\t'350 lx (Office Room)': 350,\n\t\t\t\t'400 lx (Sunrise/Sunset)': 400,\n\t\t\t\t'1000 lx (Overcast)': 1000,\n\t\t\t\t'18000 lx (Daylight)': 18000,\n\t\t\t\t'50000 lx (Direct Sun)': 50000\n\t\t\t};\n\n\t\t\tconst params = {\n\t\t\t\tshadows: true,\n\t\t\t\texposure: 0.68,\n\t\t\t\tbulbPower: Object.keys( bulbLuminousPowers )[ 4 ],\n\t\t\t\themiIrradiance: Object.keys( hemiLuminousIrradiances )[ 0 ]\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.x = - 4;\n\t\t\t\tcamera.position.z = 4;\n\t\t\t\tcamera.position.y = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst bulbGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );\n\t\t\t\tbulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );\n\n\t\t\t\tbulbMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\temissive: 0xffffee,\n\t\t\t\t\temissiveIntensity: 1,\n\t\t\t\t\tcolor: 0x000000\n\t\t\t\t} );\n\t\t\t\tbulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );\n\t\t\t\tbulbLight.position.set( 0, 2, 0 );\n\t\t\t\tbulbLight.castShadow = true;\n\t\t\t\tscene.add( bulbLight );\n\n\t\t\t\themiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tfloorMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\troughness: 0.8,\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tmetalness: 0.2,\n\t\t\t\t\tbumpScale: 1\n\t\t\t\t} );\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_diffuse.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 10, 24 );\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tfloorMat.map = map;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_bump.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 10, 24 );\n\t\t\t\t\tfloorMat.bumpMap = map;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_roughness.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 10, 24 );\n\t\t\t\t\tfloorMat.roughnessMap = map;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tcubeMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\troughness: 0.7,\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tbumpScale: 1,\n\t\t\t\t\tmetalness: 0.2\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/brick_diffuse.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 1, 1 );\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tcubeMat.map = map;\n\t\t\t\t\tcubeMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/brick_bump.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 1, 1 );\n\t\t\t\t\tcubeMat.bumpMap = map;\n\t\t\t\t\tcubeMat.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tballMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\troughness: 0.5,\n\t\t\t\t\tmetalness: 1.0\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/planets/earth_atmos_2048.jpg', function ( map ) {\n\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tballMat.map = map;\n\t\t\t\t\tballMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/planets/earth_specular_2048.jpg', function ( map ) {\n\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tballMat.metalnessMap = map;\n\t\t\t\t\tballMat.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 20, 20 );\n\t\t\t\tconst floorMesh = new THREE.Mesh( floorGeometry, floorMat );\n\t\t\t\tfloorMesh.receiveShadow = true;\n\t\t\t\tfloorMesh.rotation.x = - Math.PI / 2.0;\n\t\t\t\tscene.add( floorMesh );\n\n\t\t\t\tconst ballGeometry = new THREE.SphereGeometry( 0.25, 32, 32 );\n\t\t\t\tconst ballMesh = new THREE.Mesh( ballGeometry, ballMat );\n\t\t\t\tballMesh.position.set( 1, 0.25, 1 );\n\t\t\t\tballMesh.rotation.y = Math.PI;\n\t\t\t\tballMesh.castShadow = true;\n\t\t\t\tscene.add( ballMesh );\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );\n\t\t\t\tconst boxMesh = new THREE.Mesh( boxGeometry, cubeMat );\n\t\t\t\tboxMesh.position.set( - 0.5, 0.25, - 1 );\n\t\t\t\tboxMesh.castShadow = true;\n\t\t\t\tscene.add( boxMesh );\n\n\t\t\t\tconst boxMesh2 = new THREE.Mesh( boxGeometry, cubeMat );\n\t\t\t\tboxMesh2.position.set( 0, 0.25, - 5 );\n\t\t\t\tboxMesh2.castShadow = true;\n\t\t\t\tscene.add( boxMesh2 );\n\n\t\t\t\tconst boxMesh3 = new THREE.Mesh( boxGeometry, cubeMat );\n\t\t\t\tboxMesh3.position.set( 7, 0.25, 0 );\n\t\t\t\tboxMesh3.castShadow = true;\n\t\t\t\tscene.add( boxMesh3 );\n\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 20;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );\n\t\t\t\tgui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );\n\t\t\t\tgui.add( params, 'exposure', 0, 1 );\n\t\t\t\tgui.add( params, 'shadows' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.\n\t\t\t\trenderer.shadowMap.enabled = params.shadows;\n\t\t\t\tbulbLight.castShadow = params.shadows;\n\n\t\t\t\tif ( params.shadows !== previousShadowMap ) {\n\n\t\t\t\t\tballMat.needsUpdate = true;\n\t\t\t\t\tcubeMat.needsUpdate = true;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\t\t\t\t\tpreviousShadowMap = params.shadows;\n\n\t\t\t\t}\n\n\t\t\t\tbulbLight.power = bulbLuminousPowers[ params.bulbPower ];\n\t\t\t\tbulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface\n\n\t\t\t\themiLight.intensity = hemiLuminousIrradiances[ params.hemiIrradiance ];\n\t\t\t\tconst time = Date.now() * 0.0005;\n\n\t\t\t\tbulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Physically accurate incandescent bulb by Ben Houston Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter. Reinhard inline tonemapping with real-world light falloff (decay = 2)."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - lights - spotlight"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lights - spotlight:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tlet spotLight, lightHelper;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 7, 4, 1 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 0.15 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst loader = new THREE.TextureLoader().setPath( 'textures/' );\n\t\t\t\tconst filenames = [ 'disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg' ];\n\n\t\t\t\tconst textures = { none: null };\n\n\t\t\t\tfor ( let i = 0; i < filenames.length; i ++ ) {\n\n\t\t\t\t\tconst filename = filenames[ i ];\n\n\t\t\t\t\tconst texture = loader.load( filename );\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\ttextures[ filename ] = texture;\n\n\t\t\t\t}\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xffffff, 100 );\n\t\t\t\tspotLight.position.set( 2.5, 5, 2.5 );\n\t\t\t\tspotLight.angle = Math.PI / 6;\n\t\t\t\tspotLight.penumbra = 1;\n\t\t\t\tspotLight.decay = 2;\n\t\t\t\tspotLight.distance = 0;\n\t\t\t\tspotLight.map = textures[ 'disturb.jpg' ];\n\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tspotLight.shadow.camera.near = 1;\n\t\t\t\tspotLight.shadow.camera.far = 10;\n\t\t\t\tspotLight.shadow.focus = 1;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tlightHelper = new THREE.SpotLightHelper( spotLight );\n\t\t\t\tscene.add( lightHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xbcbcbc } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.position.set( 0, - 1, 0 );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tnew PLYLoader().load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {\n\n\t\t\t\t\tgeometry.scale( 0.0024, 0.0024, 0.0024 );\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.rotation.y = - Math.PI / 2;\n\t\t\t\t\tmesh.position.y = 0.8;\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst params = {\n\t\t\t\t\tmap: textures[ 'disturb.jpg' ],\n\t\t\t\t\tcolor: spotLight.color.getHex(),\n\t\t\t\t\tintensity: spotLight.intensity,\n\t\t\t\t\tdistance: spotLight.distance,\n\t\t\t\t\tangle: spotLight.angle,\n\t\t\t\t\tpenumbra: spotLight.penumbra,\n\t\t\t\t\tdecay: spotLight.decay,\n\t\t\t\t\tfocus: spotLight.shadow.focus,\n\t\t\t\t\tshadows: true\n\t\t\t\t};\n\n\t\t\t\tgui.add( params, 'map', textures ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.map = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'color' ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.color.setHex( val );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'intensity', 0, 500 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.intensity = val;\n\n\t\t\t\t} );\n\n\n\t\t\t\tgui.add( params, 'distance', 0, 20 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.distance = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.angle = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.penumbra = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.decay = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.shadow.focus = val;\n\n\t\t\t\t} );\n\n\n\t\t\t\tgui.add( params, 'shadows' ).onChange( function ( val ) {\n\n\t\t\t\t\trenderer.shadowMap.enabled = val;\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.material ) {\n\n\t\t\t\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 3000;\n\n\t\t\t\tspotLight.position.x = Math.cos( time ) * 2.5;\n\t\t\t\tspotLight.position.z = Math.sin( time ) * 2.5;\n\n\t\t\t\tlightHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - spotlight"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - lights - spot light"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lights - spot light:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\tconst matFloor = new THREE.MeshPhongMaterial( { color: 0x808080 } );\n\t\t\tconst matBox = new THREE.MeshPhongMaterial( { color: 0xaaaaaa } );\n\n\t\t\tconst geoFloor = new THREE.PlaneGeometry( 100, 100 );\n\t\t\tconst geoBox = new THREE.BoxGeometry( 0.3, 0.1, 0.2 );\n\n\t\t\tconst mshFloor = new THREE.Mesh( geoFloor, matFloor );\n\t\t\tmshFloor.rotation.x = - Math.PI * 0.5;\n\t\t\tconst mshBox = new THREE.Mesh( geoBox, matBox );\n\n\t\t\tconst ambient = new THREE.AmbientLight( 0x444444 );\n\n\t\t\tconst spotLight1 = createSpotlight( 0xFF7F00 );\n\t\t\tconst spotLight2 = createSpotlight( 0x00FF7F );\n\t\t\tconst spotLight3 = createSpotlight( 0x7F00FF );\n\n\t\t\tlet lightHelper1, lightHelper2, lightHelper3;\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\tcamera.position.set( 4.6, 2.2, - 2.1 );\n\n\t\t\t\tspotLight1.position.set( 1.5, 4, 4.5 );\n\t\t\t\tspotLight2.position.set( 0, 4, 3.5 );\n\t\t\t\tspotLight3.position.set( - 1.5, 4, 4.5 );\n\n\t\t\t\tlightHelper1 = new THREE.SpotLightHelper( spotLight1 );\n\t\t\t\tlightHelper2 = new THREE.SpotLightHelper( spotLight2 );\n\t\t\t\tlightHelper3 = new THREE.SpotLightHelper( spotLight3 );\n\n\t\t\t\tmshFloor.receiveShadow = true;\n\t\t\t\tmshFloor.position.set( 0, - 0.05, 0 );\n\n\t\t\t\tmshBox.castShadow = true;\n\t\t\t\tmshBox.receiveShadow = true;\n\t\t\t\tmshBox.position.set( 0, 0.5, 0 );\n\n\t\t\t\tscene.add( mshFloor );\n\t\t\t\tscene.add( mshBox );\n\t\t\t\tscene.add( ambient );\n\t\t\t\tscene.add( spotLight1, spotLight2, spotLight3 );\n\t\t\t\tscene.add( lightHelper1, lightHelper2, lightHelper3 );\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.update();\n\n\t\t\t}\n\n\t\t\tfunction createSpotlight( color ) {\n\n\t\t\t\tconst newObj = new THREE.SpotLight( color, 10 );\n\n\t\t\t\tnewObj.castShadow = true;\n\t\t\t\tnewObj.angle = 0.3;\n\t\t\t\tnewObj.penumbra = 0.2;\n\t\t\t\tnewObj.decay = 2;\n\t\t\t\tnewObj.distance = 50;\n\n\t\t\t\treturn newObj;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction tween( light ) {\n\n\t\t\t\tnew TWEEN.Tween( light ).to( {\n\t\t\t\t\tangle: ( Math.random() * 0.7 ) + 0.1,\n\t\t\t\t\tpenumbra: Math.random() + 1\n\t\t\t\t}, Math.random() * 3000 + 2000 )\n\t\t\t\t\t.easing( TWEEN.Easing.Quadratic.Out ).start();\n\n\t\t\t\tnew TWEEN.Tween( light.position ).to( {\n\t\t\t\t\tx: ( Math.random() * 3 ) - 1.5,\n\t\t\t\t\ty: ( Math.random() * 1 ) + 1.5,\n\t\t\t\t\tz: ( Math.random() * 3 ) - 1.5\n\t\t\t\t}, Math.random() * 3000 + 2000 )\n\t\t\t\t\t.easing( TWEEN.Easing.Quadratic.Out ).start();\n\n\t\t\t}\n\n\t\t\tfunction updateTweens() {\n\n\t\t\t\ttween( spotLight1 );\n\t\t\t\ttween( spotLight2 );\n\t\t\t\ttween( spotLight3 );\n\n\t\t\t\tsetTimeout( updateTweens, 5000 );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tTWEEN.update();\n\n\t\t\t\tif ( lightHelper1 ) lightHelper1.update();\n\t\t\t\tif ( lightHelper2 ) lightHelper2.update();\n\t\t\t\tif ( lightHelper3 ) lightHelper3.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tinit();\n\t\t\tupdateTweens();\n```\n\nThis example three.js - SpotLights by Master James"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - lights - rect area light"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lights - rect area light:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';\n\t\t\timport { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet stats, meshKnot;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animation );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 5, - 15 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tRectAreaLightUniformsLib.init();\n\n\t\t\t\tconst rectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );\n\t\t\t\trectLight1.position.set( - 5, 5, 5 );\n\t\t\t\tscene.add( rectLight1 );\n\n\t\t\t\tconst rectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );\n\t\t\t\trectLight2.position.set( 0, 5, 5 );\n\t\t\t\tscene.add( rectLight2 );\n\n\t\t\t\tconst rectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );\n\t\t\t\trectLight3.position.set( 5, 5, 5 );\n\t\t\t\tscene.add( rectLight3 );\n\n\t\t\t\tscene.add( new RectAreaLightHelper( rectLight1 ) );\n\t\t\t\tscene.add( new RectAreaLightHelper( rectLight2 ) );\n\t\t\t\tscene.add( new RectAreaLightHelper( rectLight3 ) );\n\n\t\t\t\tconst geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );\n\t\t\t\tconst matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );\n\t\t\t\tconst mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );\n\t\t\t\tscene.add( mshStdFloor );\n\n\t\t\t\tconst geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );\n\t\t\t\tconst matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );\n\t\t\t\tmeshKnot = new THREE.Mesh( geoKnot, matKnot );\n\t\t\t\tmeshKnot.position.set( 0, 5, 0 );\n\t\t\t\tscene.add( meshKnot );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.copy( meshKnot.position );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcamera.aspect = ( window.innerWidth / window.innerHeight );\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animation( time ) {\n\n\t\t\t\tmeshKnot.rotation.y = time / 1000;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - THREE.RectAreaLight by abelnation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - lines - colors"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lines - colors:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 33, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst hilbertPoints = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 200.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );\n\n\t\t\t\tconst geometry1 = new THREE.BufferGeometry();\n\t\t\t\tconst geometry2 = new THREE.BufferGeometry();\n\t\t\t\tconst geometry3 = new THREE.BufferGeometry();\n\n\t\t\t\tconst subdivisions = 6;\n\n\t\t\t\tlet vertices = [];\n\t\t\t\tlet colors1 = [];\n\t\t\t\tlet colors2 = [];\n\t\t\t\tlet colors3 = [];\n\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( hilbertPoints );\n\n\t\t\t\tfor ( let i = 0; i < hilbertPoints.length * subdivisions; i ++ ) {\n\n\t\t\t\t\tconst t = i / ( hilbertPoints.length * subdivisions );\n\t\t\t\t\tspline.getPoint( t, point );\n\n\t\t\t\t\tvertices.push( point.x, point.y, point.z );\n\n\t\t\t\t\tcolor.setHSL( 0.6, 1.0, Math.max( 0, - point.x / 200 ) + 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors1.push( color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setHSL( 0.9, 1.0, Math.max( 0, - point.y / 200 ) + 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors2.push( color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setHSL( i / ( hilbertPoints.length * subdivisions ), 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors3.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry1.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry2.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry3.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tgeometry1.setAttribute( 'color', new THREE.Float32BufferAttribute( colors1, 3 ) );\n\t\t\t\tgeometry2.setAttribute( 'color', new THREE.Float32BufferAttribute( colors2, 3 ) );\n\t\t\t\tgeometry3.setAttribute( 'color', new THREE.Float32BufferAttribute( colors3, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry4 = new THREE.BufferGeometry();\n\t\t\t\tconst geometry5 = new THREE.BufferGeometry();\n\t\t\t\tconst geometry6 = new THREE.BufferGeometry();\n\n\t\t\t\tvertices = [];\n\t\t\t\tcolors1 = [];\n\t\t\t\tcolors2 = [];\n\t\t\t\tcolors3 = [];\n\n\t\t\t\tfor ( let i = 0; i < hilbertPoints.length; i ++ ) {\n\n\t\t\t\t\tconst point = hilbertPoints[ i ];\n\n\t\t\t\t\tvertices.push( point.x, point.y, point.z );\n\n\t\t\t\t\tcolor.setHSL( 0.6, 1.0, Math.max( 0, ( 200 - hilbertPoints[ i ].x ) / 400 ) * 0.5 + 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors1.push( color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setHSL( 0.3, 1.0, Math.max( 0, ( 200 + hilbertPoints[ i ].x ) / 400 ) * 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors2.push( color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setHSL( i / hilbertPoints.length, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors3.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry4.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry5.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry6.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tgeometry4.setAttribute( 'color', new THREE.Float32BufferAttribute( colors1, 3 ) );\n\t\t\t\tgeometry5.setAttribute( 'color', new THREE.Float32BufferAttribute( colors2, 3 ) );\n\t\t\t\tgeometry6.setAttribute( 'color', new THREE.Float32BufferAttribute( colors3, 3 ) );\n\n\t\t\t\t// Create lines and add to scene\n\n\t\t\t\tconst material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: true } );\n\n\t\t\t\tlet line, p;\n\t\t\t\tconst scale = 0.3, d = 225;\n\n\t\t\t\tconst parameters = [\n\t\t\t\t\t[ material, scale * 1.5, [ - d, - d / 2, 0 ], geometry1 ],\n\t\t\t\t\t[ material, scale * 1.5, [ 0, - d / 2, 0 ], geometry2 ],\n\t\t\t\t\t[ material, scale * 1.5, [ d, - d / 2, 0 ], geometry3 ],\n\n\t\t\t\t\t[ material, scale * 1.5, [ - d, d / 2, 0 ], geometry4 ],\n\t\t\t\t\t[ material, scale * 1.5, [ 0, d / 2, 0 ], geometry5 ],\n\t\t\t\t\t[ material, scale * 1.5, [ d, d / 2, 0 ], geometry6 ],\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\t\tp = parameters[ i ];\n\t\t\t\t\tline = new THREE.Line( p[ 3 ], p[ 0 ] );\n\t\t\t\t\tline.scale.x = line.scale.y = line.scale.z = p[ 1 ];\n\t\t\t\t\tline.position.x = p[ 2 ][ 0 ];\n\t\t\t\t\tline.position.y = p[ 2 ][ 1 ];\n\t\t\t\t\tline.position.z = p[ 2 ][ 2 ];\n\t\t\t\t\tscene.add( line );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.style.touchAction = 'none';\n\t\t\t\tdocument.body.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY + 200 - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst time = Date.now() * 0.0005;\n\n\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\tconst object = scene.children[ i ];\n\n\t\t\t\t\tif ( object.isLine ) {\n\n\t\t\t\t\t\tobject.rotation.y = time * ( i % 2 ? 1 : - 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - color lines Hilbert curve thanks to Thomas Diewald"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - dashed lines"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - dashed lines:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\t\t\tconst objects = [];\n\n\t\t\tconst WIDTH = window.innerWidth, HEIGHT = window.innerHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, WIDTH / HEIGHT, 1, 200 );\n\t\t\t\tcamera.position.z = 150;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x111111 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x111111, 150, 200 );\n\n\t\t\t\tconst subdivisions = 6;\n\t\t\t\tconst recursion = 1;\n\n\t\t\t\tconst points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 25.0, recursion, 0, 1, 2, 3, 4, 5, 6, 7 );\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( points );\n\n\t\t\t\tconst samples = spline.getPoints( points.length * subdivisions );\n\t\t\t\tconst geometrySpline = new THREE.BufferGeometry().setFromPoints( samples );\n\n\t\t\t\tconst line = new THREE.Line( geometrySpline, new THREE.LineDashedMaterial( { color: 0xffffff, dashSize: 1, gapSize: 0.5 } ) );\n\t\t\t\tline.computeLineDistances();\n\n\t\t\t\tobjects.push( line );\n\t\t\t\tscene.add( line );\n\n\t\t\t\tconst geometryBox = box( 50, 50, 50 );\n\n\t\t\t\tconst lineSegments = new THREE.LineSegments( geometryBox, new THREE.LineDashedMaterial( { color: 0xffaa00, dashSize: 3, gapSize: 1 } ) );\n\t\t\t\tlineSegments.computeLineDistances();\n\n\t\t\t\tobjects.push( lineSegments );\n\t\t\t\tscene.add( lineSegments );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( WIDTH, HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction box( width, height, depth ) {\n\n\t\t\t\twidth = width * 0.5,\n\t\t\t\theight = height * 0.5,\n\t\t\t\tdepth = depth * 0.5;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst position = [];\n\n\t\t\t\tposition.push(\n\t\t\t\t\t- width, - height, - depth,\n\t\t\t\t\t- width, height, - depth,\n\n\t\t\t\t\t- width, height, - depth,\n\t\t\t\t\twidth, height, - depth,\n\n\t\t\t\t\twidth, height, - depth,\n\t\t\t\t\twidth, - height, - depth,\n\n\t\t\t\t\twidth, - height, - depth,\n\t\t\t\t\t- width, - height, - depth,\n\n\t\t\t\t\t- width, - height, depth,\n\t\t\t\t\t- width, height, depth,\n\n\t\t\t\t\t- width, height, depth,\n\t\t\t\t\twidth, height, depth,\n\n\t\t\t\t\twidth, height, depth,\n\t\t\t\t\twidth, - height, depth,\n\n\t\t\t\t\twidth, - height, depth,\n\t\t\t\t\t- width, - height, depth,\n\n\t\t\t\t\t- width, - height, - depth,\n\t\t\t\t\t- width, - height, depth,\n\n\t\t\t\t\t- width, height, - depth,\n\t\t\t\t\t- width, height, depth,\n\n\t\t\t\t\twidth, height, - depth,\n\t\t\t\t\twidth, height, depth,\n\n\t\t\t\t\twidth, - height, - depth,\n\t\t\t\t\twidth, - height, depth\n\t\t\t\t );\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isLine ) {\n\n\t\t\t\t\t\tobject.rotation.x = 0.25 * time;\n\t\t\t\t\t\tobject.rotation.y = 0.25 * time;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - dashed lines example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - lines - fat"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lines - fat:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'stats-gl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Line2 } from 'three/addons/lines/Line2.js';\n\t\t\timport { LineMaterial } from 'three/addons/lines/LineMaterial.js';\n\t\t\timport { LineGeometry } from 'three/addons/lines/LineGeometry.js';\n\t\t\timport * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n\n\t\t\tlet line, renderer, scene, camera, camera2, controls;\n\t\t\tlet line1;\n\t\t\tlet matLine, matLineBasic, matLineDashed;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\n\t\t\t// viewport\n\t\t\tlet insetWidth;\n\t\t\tlet insetHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 40, 0, 60 );\n\n\t\t\t\tcamera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );\n\t\t\t\tcamera2.position.copy( camera.position );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\n\t\t\t\t// Position and THREE.Color Data\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );\n\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( points );\n\t\t\t\tconst divisions = Math.round( 12 * points.length );\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0, l = divisions; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = i / l;\n\n\t\t\t\t\tspline.getPoint( t, point );\n\t\t\t\t\tpositions.push( point.x, point.y, point.z );\n\n\t\t\t\t\tcolor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\n\t\t\t\t// Line2 ( LineGeometry, LineMaterial )\n\n\t\t\t\tconst geometry = new LineGeometry();\n\t\t\t\tgeometry.setPositions( positions );\n\t\t\t\tgeometry.setColors( colors );\n\n\t\t\t\tmatLine = new LineMaterial( {\n\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tlinewidth: 5, // in world units with size attenuation, pixels otherwise\n\t\t\t\t\tvertexColors: true,\n\n\t\t\t\t\tdashed: false,\n\t\t\t\t\talphaToCoverage: true,\n\n\t\t\t\t} );\n\n\t\t\t\tline = new Line2( geometry, matLine );\n\t\t\t\tline.computeLineDistances();\n\t\t\t\tline.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( line );\n\n\n\t\t\t\t// THREE.Line ( THREE.BufferGeometry, THREE.LineBasicMaterial ) - rendered with gl.LINE_STRIP\n\n\t\t\t\tconst geo = new THREE.BufferGeometry();\n\t\t\t\tgeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\tmatLineBasic = new THREE.LineBasicMaterial( { vertexColors: true } );\n\t\t\t\tmatLineDashed = new THREE.LineDashedMaterial( { vertexColors: true, scale: 2, dashSize: 1, gapSize: 1 } );\n\n\t\t\t\tline1 = new THREE.Line( geo, matLineBasic );\n\t\t\t\tline1.computeLineDistances();\n\t\t\t\tline1.visible = false;\n\t\t\t\tscene.add( line1 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tstats = new Stats( { horizontal: false, trackGPU: true } );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tinsetWidth = window.innerHeight / 4; // square\n\t\t\t\tinsetHeight = window.innerHeight / 4;\n\n\t\t\t\tcamera2.aspect = insetWidth / insetHeight;\n\t\t\t\tcamera2.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// main scene\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t\t\trenderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// inset scene\n\n\t\t\t\trenderer.setClearColor( 0x222222, 1 );\n\n\t\t\t\trenderer.clearDepth(); // important!\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 20, 20, insetWidth, insetHeight );\n\n\t\t\t\trenderer.setViewport( 20, 20, insetWidth, insetHeight );\n\n\t\t\t\tcamera2.position.copy( camera.position );\n\t\t\t\tcamera2.quaternion.copy( camera.quaternion );\n\n\t\t\t\trenderer.render( scene, camera2 );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tconst param = {\n\t\t\t\t\t'line type': 0,\n\t\t\t\t\t'world units': false,\n\t\t\t\t\t'width': 5,\n\t\t\t\t\t'alphaToCoverage': true,\n\t\t\t\t\t'dashed': false,\n\t\t\t\t\t'dash scale': 1,\n\t\t\t\t\t'dash / gap': 1\n\t\t\t\t};\n\n\t\t\t\tgui.add( param, 'line type', { 'LineGeometry': 0, 'gl.LINE': 1 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tline.visible = true;\n\n\t\t\t\t\t\t\tline1.visible = false;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tline.visible = false;\n\n\t\t\t\t\t\t\tline1.visible = true;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'world units' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.worldUnits = val;\n\t\t\t\t\tmatLine.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'width', 1, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.linewidth = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'alphaToCoverage' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.alphaToCoverage = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dashed' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashed = val;\n\t\t\t\t\tline1.material = val ? matLineDashed : matLineBasic;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash scale', 0.5, 2, 0.1 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashScale = val;\n\t\t\t\t\tmatLineDashed.scale = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tmatLine.dashSize = 2;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 2;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 2;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 2;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - fat lines"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - lines - fat"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lines - fat:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'stats-gl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { LineMaterial } from 'three/addons/lines/LineMaterial.js';\n\t\t\timport { LineSegments2 } from 'three/addons/lines/LineSegments2.js';\n\t\t\timport { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';\n\t\t\timport { Line2 } from 'three/addons/lines/Line2.js';\n\t\t\timport { LineGeometry } from 'three/addons/lines/LineGeometry.js';\n\n\t\t\tlet line, thresholdLine, segments, thresholdSegments;\n\t\t\tlet renderer, scene, camera, controls;\n\t\t\tlet sphereInter, sphereOnLine;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\t\t\tlet clock;\n\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tconst pointer = new THREE.Vector2( Infinity, Infinity );\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\n\t\t\traycaster.params.Line2 = {};\n\t\t\traycaster.params.Line2.threshold = 0;\n\n\t\t\tconst matLine = new LineMaterial( {\n\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tlinewidth: 1, // in world units with size attenuation, pixels otherwise\n\t\t\t\tworldUnits: true,\n\t\t\t\tvertexColors: true,\n\n\t\t\t\talphaToCoverage: true,\n\n\t\t\t} );\n\n\t\t\tconst matThresholdLine = new LineMaterial( {\n\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tlinewidth: matLine.linewidth, // in world units with size attenuation, pixels otherwise\n\t\t\t\tworldUnits: true,\n\t\t\t\t// vertexColors: true,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.2,\n\t\t\t\tdepthTest: false,\n\t\t\t\tvisible: false,\n\n\t\t\t} );\n\n\t\t\tconst params = {\n\n\t\t\t\t'line type': 0,\n\t\t\t\t'world units': matLine.worldUnits,\n\t\t\t\t'visualize threshold': matThresholdLine.visible,\n\t\t\t\t'width': matLine.linewidth,\n\t\t\t\t'alphaToCoverage': matLine.alphaToCoverage,\n\t\t\t\t'threshold': raycaster.params.Line2.threshold,\n\t\t\t\t'translation': raycaster.params.Line2.threshold,\n\t\t\t\t'animate': true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 40, 0, 60 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.25, 8, 4 );\n\t\t\t\tconst sphereInterMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, depthTest: false } );\n\t\t\t\tconst sphereOnLineMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, depthTest: false } );\n\n\t\t\t\tsphereInter = new THREE.Mesh( sphereGeometry, sphereInterMaterial );\n\t\t\t\tsphereOnLine = new THREE.Mesh( sphereGeometry, sphereOnLineMaterial );\n\t\t\t\tsphereInter.visible = false;\n\t\t\t\tsphereOnLine.visible = false;\n\t\t\t\tsphereInter.renderOrder = 10;\n\t\t\t\tsphereOnLine.renderOrder = 10;\n\t\t\t\tscene.add( sphereInter );\n\t\t\t\tscene.add( sphereOnLine );\n\n\t\t\t\t// Position and THREE.Color Data\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\t\t\t\tconst points = [];\n\t\t\t\tfor ( let i = - 50; i < 50; i ++ ) {\n\n\t\t\t\t\tconst t = i / 3;\n\t\t\t\t\tpoints.push( new THREE.Vector3( t * Math.sin( 2 * t ), t, t * Math.cos( 2 * t ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( points );\n\t\t\t\tconst divisions = Math.round( 3 * points.length );\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0, l = divisions; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = i / l;\n\n\t\t\t\t\tspline.getPoint( t, point );\n\t\t\t\t\tpositions.push( point.x, point.y, point.z );\n\n\t\t\t\t\tcolor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tconst lineGeometry = new LineGeometry();\n\t\t\t\tlineGeometry.setPositions( positions );\n\t\t\t\tlineGeometry.setColors( colors );\n\n\t\t\t\tconst segmentsGeometry = new LineSegmentsGeometry();\n\t\t\t\tsegmentsGeometry.setPositions( positions );\n\t\t\t\tsegmentsGeometry.setColors( colors );\n\n\t\t\t\tsegments = new LineSegments2( segmentsGeometry, matLine );\n\t\t\t\tsegments.computeLineDistances();\n\t\t\t\tsegments.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( segments );\n\t\t\t\tsegments.visible = false;\n\n\t\t\t\tthresholdSegments = new LineSegments2( segmentsGeometry, matThresholdLine );\n\t\t\t\tthresholdSegments.computeLineDistances();\n\t\t\t\tthresholdSegments.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( thresholdSegments );\n\t\t\t\tthresholdSegments.visible = false;\n\n\t\t\t\tline = new Line2( lineGeometry, matLine );\n\t\t\t\tline.computeLineDistances();\n\t\t\t\tline.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( line );\n\n\t\t\t\tthresholdLine = new Line2( lineGeometry, matThresholdLine );\n\t\t\t\tthresholdLine.computeLineDistances();\n\t\t\t\tthresholdLine.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( thresholdLine );\n\n\t\t\t\tconst geo = new THREE.BufferGeometry();\n\t\t\t\tgeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tstats = new Stats( { horizontal: false, trackGPU: true } );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\t\t\t\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tconst obj = line.visible ? line : segments;\n\t\t\t\tthresholdLine.position.copy( line.position );\n\t\t\t\tthresholdLine.quaternion.copy( line.quaternion );\n\t\t\t\tthresholdSegments.position.copy( segments.position );\n\t\t\t\tthresholdSegments.quaternion.copy( segments.quaternion );\n\n\t\t\t\tif ( params.animate ) {\n\n\t\t\t\t\tline.rotation.y += delta * 0.1;\n\n\t\t\t\t\tsegments.rotation.y = line.rotation.y;\n\n\t\t\t\t}\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObject( obj );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tsphereInter.visible = true;\n\t\t\t\t\tsphereOnLine.visible = true;\n\n\t\t\t\t\tsphereInter.position.copy( intersects[ 0 ].point );\n\t\t\t\t\tsphereOnLine.position.copy( intersects[ 0 ].pointOnLine );\n\n\t\t\t\t\tconst index = intersects[ 0 ].faceIndex;\n\t\t\t\t\tconst colors = obj.geometry.getAttribute( 'instanceColorStart' );\n\n\t\t\t\t\tcolor.fromBufferAttribute( colors, index );\n\n\t\t\t\t\tsphereInter.material.color.copy( color ).offsetHSL( 0.3, 0, 0 );\n\t\t\t\t\tsphereOnLine.material.color.copy( color ).offsetHSL( 0.7, 0, 0 );\n\n\t\t\t\t\trenderer.domElement.style.cursor = 'crosshair';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphereInter.visible = false;\n\t\t\t\t\tsphereOnLine.visible = false;\n\t\t\t\t\trenderer.domElement.style.cursor = '';\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction switchLine( val ) {\n\n\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tline.visible = true;\n\t\t\t\t\t\tthresholdLine.visible = true;\n\n\t\t\t\t\t\tsegments.visible = false;\n\t\t\t\t\t\tthresholdSegments.visible = false;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tline.visible = false;\n\t\t\t\t\t\tthresholdLine.visible = false;\n\n\t\t\t\t\t\tsegments.visible = true;\n\t\t\t\t\t\tthresholdSegments.visible = true;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( params, 'line type', { 'LineGeometry': 0, 'LineSegmentsGeometry': 1 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitchLine( val );\n\n\t\t\t\t} ).setValue( 1 );\n\n\t\t\t\tgui.add( params, 'world units' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.worldUnits = val;\n\t\t\t\t\tmatLine.needsUpdate = true;\n\n\t\t\t\t\tmatThresholdLine.worldUnits = val;\n\t\t\t\t\tmatThresholdLine.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'visualize threshold' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatThresholdLine.visible = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'width', 1, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.linewidth = val;\n\t\t\t\t\tmatThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'alphaToCoverage' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.alphaToCoverage = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'threshold', 0, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\traycaster.params.Line2.threshold = val;\n\t\t\t\t\tmatThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'translation', 0, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tline.position.x = val;\n\t\t\t\t\tsegments.position.x = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'animate' );\n\n\t\t\t}\n```\n\nThis example three.js - fat lines raycasting"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - lines - fat - wireframe"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lines - fat - wireframe:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { LineMaterial } from 'three/addons/lines/LineMaterial.js';\n\t\t\timport { Wireframe } from 'three/addons/lines/Wireframe.js';\n\t\t\timport { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';\n\n\t\t\tlet wireframe, renderer, scene, camera, camera2, controls;\n\t\t\tlet wireframe1;\n\t\t\tlet matLine, matLineBasic, matLineDashed;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\n\t\t\t// viewport\n\t\t\tlet insetWidth;\n\t\t\tlet insetHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 50, 0, 50 );\n\n\t\t\t\tcamera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );\n\t\t\t\tcamera2.position.copy( camera.position );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\n\t\t\t\t// Wireframe ( WireframeGeometry2, LineMaterial )\n\n\t\t\t\tlet geo = new THREE.IcosahedronGeometry( 20, 1 );\n\n\t\t\t\tconst geometry = new WireframeGeometry2( geo );\n\n\t\t\t\tmatLine = new LineMaterial( {\n\n\t\t\t\t\tcolor: 0x4080ff,\n\t\t\t\t\tlinewidth: 5, // in pixels\n\t\t\t\t\tdashed: false\n\n\t\t\t\t} );\n\n\t\t\t\twireframe = new Wireframe( geometry, matLine );\n\t\t\t\twireframe.computeLineDistances();\n\t\t\t\twireframe.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( wireframe );\n\n\n\t\t\t\t// Line ( THREE.WireframeGeometry, THREE.LineBasicMaterial ) - rendered with gl.LINE\n\n\t\t\t\tgeo = new THREE.WireframeGeometry( geo );\n\n\t\t\t\tmatLineBasic = new THREE.LineBasicMaterial( { color: 0x4080ff } );\n\t\t\t\tmatLineDashed = new THREE.LineDashedMaterial( { scale: 2, dashSize: 1, gapSize: 1 } );\n\n\t\t\t\twireframe1 = new THREE.LineSegments( geo, matLineBasic );\n\t\t\t\twireframe1.computeLineDistances();\n\t\t\t\twireframe1.visible = false;\n\t\t\t\tscene.add( wireframe1 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tinsetWidth = window.innerHeight / 4; // square\n\t\t\t\tinsetHeight = window.innerHeight / 4;\n\n\t\t\t\tcamera2.aspect = insetWidth / insetHeight;\n\t\t\t\tcamera2.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// main scene\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t\t\trenderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// inset scene\n\n\t\t\t\trenderer.setClearColor( 0x222222, 1 );\n\n\t\t\t\trenderer.clearDepth(); // important!\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 20, 20, insetWidth, insetHeight );\n\n\t\t\t\trenderer.setViewport( 20, 20, insetWidth, insetHeight );\n\n\t\t\t\tcamera2.position.copy( camera.position );\n\t\t\t\tcamera2.quaternion.copy( camera.quaternion );\n\n\t\t\t\trenderer.render( scene, camera2 );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tconst param = {\n\t\t\t\t\t'line type': 0,\n\t\t\t\t\t'width (px)': 5,\n\t\t\t\t\t'dashed': false,\n\t\t\t\t\t'dash scale': 1,\n\t\t\t\t\t'dash / gap': 1\n\t\t\t\t};\n\n\n\t\t\t\tgui.add( param, 'line type', { 'LineGeometry': 0, 'gl.LINE': 1 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\twireframe.visible = true;\n\n\t\t\t\t\t\t\twireframe1.visible = false;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\twireframe.visible = false;\n\n\t\t\t\t\t\t\twireframe1.visible = true;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'width (px)', 1, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.linewidth = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dashed' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashed = val;\n\n\t\t\t\t\t// dashed is implemented as a defines -- not as a uniform. this could be changed.\n\t\t\t\t\t// ... or THREE.LineDashedMaterial could be implemented as a separate material\n\t\t\t\t\t// temporary hack - renderer should do this eventually\n\t\t\t\t\tif ( val ) matLine.defines.USE_DASH = ''; else delete matLine.defines.USE_DASH;\n\t\t\t\t\tmatLine.needsUpdate = true;\n\n\t\t\t\t\twireframe1.material = val ? matLineDashed : matLineBasic;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash scale', 0.5, 1, 0.1 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashScale = val;\n\t\t\t\t\tmatLineDashed.scale = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tmatLine.dashSize = 2;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 2;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 2;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 2;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - fat lines"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - Rhino 3DM loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - Rhino 3DM loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Rhino3dmLoader } from 'three/addons/loaders/3DMLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, gui;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tTHREE.Object3D.DEFAULT_UP.set( 0, 0, 1 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 26, - 40, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 6 );\n\t\t\t\tdirectionalLight.position.set( 0, 0, 2 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tconst loader = new Rhino3dmLoader();\n\t\t\t\t//generally, use this for the Library Path: https://cdn.jsdelivr.net/npm/rhino3dm@8.0.1\n\t\t\t\tloader.setLibraryPath( 'jsm/libs/rhino3dm/' );\n\t\t\t\tloader.load( 'models/3dm/Rhino_Logo.3dm', function ( object ) {\n\n\t\t\t\t\tscene.add( object );\n\t\t\t\t\tinitGUI( object.userData.layers );\n\n\t\t\t\t\t// hide spinner\n\t\t\t\t\tdocument.getElementById( 'loader' ).style.display = 'none';\n\n\t\t\t\t}, function ( progress ) {\n\n\t\t\t\t\tconsole.log( ( progress.loaded / progress.total * 100 ) + '%' );\n\n\t\t\t\t}, function ( error ) {\n\n\t\t\t\t\tconsole.log( error );\n\n\t\t\t\t} );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', resize );\n\n\t\t\t}\n\n\t\t\tfunction resize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction initGUI( layers ) {\n\n\t\t\t\tgui = new GUI( { title: 'layers' } );\n\n\t\t\t\tfor ( let i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\t\tconst layer = layers[ i ];\n\t\t\t\t\tgui.add( layer, 'visible' ).name( layer.name ).onChange( function ( val ) {\n\n\t\t\t\t\t\tconst name = this.object.name;\n\n\t\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\t\tif ( child.userData.hasOwnProperty( 'attributes' ) ) {\n\n\t\t\t\t\t\t\t\tif ( 'layerIndex' in child.userData.attributes ) {\n\n\t\t\t\t\t\t\t\t\tconst layerName = layers[ child.userData.attributes.layerIndex ].name;\n\n\t\t\t\t\t\t\t\t\tif ( layerName === name ) {\n\n\t\t\t\t\t\t\t\t\t\tchild.visible = val;\n\t\t\t\t\t\t\t\t\t\tlayer.visible = val;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - Rhino 3DM loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - 3DS loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - 3DS loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { TDSLoader } from 'three/addons/loaders/TDSLoader.js';\n\n\t\t\tlet container, controls;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 3 ) );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffeedd, 3 );\n\t\t\t\tdirectionalLight.position.set( 0, 0, 2 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t//3ds files dont store normal maps\n\t\t\t\tconst normal = new THREE.TextureLoader().load( 'models/3ds/portalgun/textures/normal.jpg' );\n\n\t\t\t\tconst loader = new TDSLoader( );\n\t\t\t\tloader.setResourcePath( 'models/3ds/portalgun/textures/' );\n\t\t\t\tloader.load( 'models/3ds/portalgun/portalgun.3ds', function ( object ) {\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tchild.material.specular.setScalar( 0.1 );\n\t\t\t\t\t\t\tchild.material.normalMap = normal;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', resize );\n\n\t\t\t}\n\n\t\t\tfunction resize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 3DS loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates loader - 3d tiles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js loader - 3d tiles:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\n\t\t\timport { TilesRenderer, GlobeControls } from '3d-tiles-renderer';\n\t\t\timport { CesiumIonAuthPlugin, GLTFExtensionsPlugin, TilesFadePlugin, UpdateOnChangePlugin } from '3d-tiles-renderer/plugins';\n\n\t\t\t// Ion key provided by Cesium for use on threejs.org\n\t\t\t// A personal Cesium Ion key can be used for development.\n\t\t\tconst ION_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiMTFiZTRmZS1mMWIxLTQ5YzYtYjA4Zi0xYTE0MjFmYzQ5OGYiLCJpZCI6MjY3NzgzLCJpYXQiOjE3MzY0NzQxMDh9.ppGPgpse1lq7QeNyljX7THUyK5w1x_4HksSHSlhe5sY';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet tiles, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 1, 1, 1 ).normalize().multiplyScalar( 10 );\n\t\t\t\tcamera.position.set( - 8000000, 10000000, - 14720000 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// loader\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\n\t\t\t\t// tiles\n\t\t\t\ttiles = new TilesRenderer();\n\t\t\t\ttiles.registerPlugin( new CesiumIonAuthPlugin( { apiToken: ION_KEY, assetId: '2275207', autoRefreshToken: true } ) );\n\t\t\t\ttiles.registerPlugin( new GLTFExtensionsPlugin( { dracoLoader } ) );\n\t\t\t\ttiles.registerPlugin( new TilesFadePlugin() );\n\t\t\t\ttiles.registerPlugin( new UpdateOnChangePlugin() );\n\t\t\t\ttiles.setCamera( camera );\n\t\t\t\ttiles.setResolutionFromRenderer( camera, renderer );\n\t\t\t\tscene.add( tiles.group );\n\n\t\t\t\t// rotate the globe so the north pole is up\n\t\t\t\ttiles.group.rotation.x = - Math.PI / 2;\n\n\t\t\t\t// controls\n\t\t\t\tcontrols = new GlobeControls( scene, camera, renderer.domElement, tiles );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\ttiles.setResolutionFromRenderer( camera, renderer );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\ttiles.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js 3d tiles - 3d-tiles-renderer See main project repository for more information and examples on loading 3d tiles and other tiled data formats. Google Photorealistic Tiles token courtesy of Cesium Ion ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - 3MF"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 3MF:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, object, loader, controls;\n\n\t\t\tconst params = {\n\t\t\t\tasset: 'cube_gears'\n\t\t\t};\n\n\t\t\tconst assets = [\n\t\t\t\t'cube_gears',\n\t\t\t\t'facecolors',\n\t\t\t\t'multipletextures',\n\t\t\t\t'vertexcolors'\n\t\t\t];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x333333 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 500 );\n\n\t\t\t\t// Z is up for objects intended to be 3D printed.\n\n\t\t\t\tcamera.up.set( 0, 0, 1 );\n\t\t\t\tcamera.position.set( - 100, - 250, 100 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 50;\n\t\t\t\tcontrols.maxDistance = 400;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 0.6 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 2 );\n\t\t\t\tlight.position.set( - 1, - 2.5, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst manager = new THREE.LoadingManager();\n\n\t\t\t\tmanager.onLoad = function () {\n\n\t\t\t\t\tconst aabb = new THREE.Box3().setFromObject( object );\n\t\t\t\t\tconst center = aabb.getCenter( new THREE.Vector3() );\n\n\t\t\t\t\tobject.position.x += ( object.position.x - center.x );\n\t\t\t\t\tobject.position.y += ( object.position.y - center.y );\n\t\t\t\t\tobject.position.z += ( object.position.z - center.z );\n\n\t\t\t\t\tcontrols.reset();\n\n\t\t\t\t\tscene.add( object );\n\t\t\t\t\trender();\n\n\t\t\t\t};\n\n\t\t\t\tloader = new ThreeMFLoader( manager );\n\t\t\t\tloadAsset( params.asset );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'asset', assets ).onChange( function ( value ) {\n\n\t\t\t\t\tloadAsset( value );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction loadAsset( asset ) {\n\n\t\t\t\tloader.load( 'models/3mf/' + asset + '.3mf', function ( group ) {\n\n\t\t\t\t\tif ( object ) {\n\n\t\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\t\tif ( child.material ) child.material.dispose();\n\t\t\t\t\t\t\tif ( child.material && child.material.map ) child.material.map.dispose();\n\t\t\t\t\t\t\tif ( child.geometry ) child.geometry.dispose();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tscene.remove( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tobject = group;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js 3MF File format 3MF loader test by technohippy"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - 3MF"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 3MF:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 10, 500 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 500 );\n\t\t\t\tcamera.position.set( - 50, 40, 50 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\t\themiLight.position.set( 0, 100, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 0, 40, 50 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 50;\n\t\t\t\tdirLight.shadow.camera.bottom = - 25;\n\t\t\t\tdirLight.shadow.camera.left = - 25;\n\t\t\t\tdirLight.shadow.camera.right = 25;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 200;\n\t\t\t\tdirLight.shadow.mapSize.set( 1024, 1024 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst manager = new THREE.LoadingManager();\n\n\t\t\t\tconst loader = new ThreeMFLoader( manager );\n\t\t\t\tloader.load( './models/3mf/truck.3mf', function ( object ) {\n\n\t\t\t\t\tobject.rotation.set( - Math.PI / 2, 0, 0 ); // z-up conversion\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tchild.castShadow = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tmanager.onLoad = function () {\n\n\t\t\t\t\trender();\n\n\t\t\t\t};\n\n\t\t\t\t//\n\n\t\t\t\tconst ground = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.position.y = 11;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 50;\n\t\t\t\tcontrols.maxDistance = 200;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.target.set( 0, 20, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 3MF file with materials"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - AMF"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - AMF:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { AMFLoader } from 'three/addons/loaders/AMFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x999999 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x999999 ) );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 500 );\n\n\t\t\t\t// Z is up for objects intended to be 3D printed.\n\n\t\t\t\tcamera.up.set( 0, 0, 1 );\n\t\t\t\tcamera.position.set( 0, - 9, 6 );\n\n\t\t\t\tcamera.add( new THREE.PointLight( 0xffffff, 250 ) );\n\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 50, 50, 0xffffff, 0x555555 );\n\t\t\t\tgrid.rotateOnAxis( new THREE.Vector3( 1, 0, 0 ), 90 * ( Math.PI / 180 ) );\n\t\t\t\tscene.add( grid );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst loader = new AMFLoader();\n\t\t\t\tloader.load( './models/amf/rook.amf', function ( amfobject ) {\n\n\t\t\t\t\tscene.add( amfobject );\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.target.set( 0, 0, 2 );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - AMF loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - BVHLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - BVHLoader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { BVHLoader } from 'three/addons/loaders/BVHLoader.js';\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet mixer;\n\n\t\t\tinit();\n\n\t\t\tconst loader = new BVHLoader();\n\t\t\tloader.load( 'models/bvh/pirouette.bvh', function ( result ) {\n\n\t\t\t\tconst skeletonHelper = new THREE.SkeletonHelper( result.skeleton.bones[ 0 ] );\n\n\t\t\t\tscene.add( result.skeleton.bones[ 0 ] );\n\t\t\t\tscene.add( skeletonHelper );\n\n\t\t\t\t// play animation\n\t\t\t\tmixer = new THREE.AnimationMixer( result.skeleton.bones[ 0 ] );\n\t\t\t\tmixer.clipAction( result.clip ).play();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 200, 300 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xeeeeee );\n\n\t\t\t\tscene.add( new THREE.GridHelper( 400, 10 ) );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 300;\n\t\t\t\tcontrols.maxDistance = 700;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - BVH Loader animation from http://mocap.cs.cmu.edu/"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - collada"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - collada:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';\n\n\t\t\tlet container, stats, clock;\n\t\t\tlet camera, scene, renderer, elf;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.set( 8, 10, 8 );\n\t\t\t\tcamera.lookAt( 0, 3, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// loading manager\n\n\t\t\t\tconst loadingManager = new THREE.LoadingManager( function () {\n\n\t\t\t\t\tscene.add( elf );\n\n\t\t\t\t} );\n\n\t\t\t\t// collada\n\n\t\t\t\tconst loader = new ColladaLoader( loadingManager );\n\t\t\t\tloader.load( './models/collada/elf/elf.dae', function ( collada ) {\n\n\t\t\t\t\telf = collada.scene;\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\t\tdirectionalLight.position.set( 1, 1, 0 ).normalize();\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( elf !== undefined ) {\n\n\t\t\t\t\telf.rotation.z += delta * 0.5;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js collada loader Elf Girl by halloween , CC Attribution"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - collada - kinematics"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - collada - kinematics:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\t\t\timport { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet dae;\n\n\t\t\tlet kinematics;\n\t\t\tlet kinematicsTween;\n\t\t\tconst tweenParameters = {};\n\n\t\t\tconst loader = new ColladaLoader();\n\t\t\tloader.load( './models/collada/abb_irb52_7_120.dae', function ( collada ) {\n\n\t\t\t\tdae = collada.scene;\n\n\t\t\t\tdae.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t// model does not have normals\n\t\t\t\t\t\tchild.material.flatShading = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tdae.scale.x = dae.scale.y = dae.scale.z = 10.0;\n\t\t\t\tdae.updateMatrix();\n\n\t\t\t\tkinematics = collada.kinematics;\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 2, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Grid\n\n\t\t\t\tconst grid = new THREE.GridHelper( 20, 20, 0xc1c1c1, 0x8d8d8d );\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// Add the COLLADA\n\n\t\t\t\tscene.add( dae );\n\n\t\t\t\t// Lights\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xfff7f7, 0x494966, 3 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tsetupTween();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction setupTween() {\n\n\t\t\t\tconst duration = THREE.MathUtils.randInt( 1000, 5000 );\n\n\t\t\t\tconst target = {};\n\n\t\t\t\tfor ( const prop in kinematics.joints ) {\n\n\t\t\t\t\tif ( kinematics.joints.hasOwnProperty( prop ) ) {\n\n\t\t\t\t\t\tif ( ! kinematics.joints[ prop ].static ) {\n\n\t\t\t\t\t\t\tconst joint = kinematics.joints[ prop ];\n\n\t\t\t\t\t\t\tconst old = tweenParameters[ prop ];\n\n\t\t\t\t\t\t\tconst position = old ? old : joint.zeroPosition;\n\n\t\t\t\t\t\t\ttweenParameters[ prop ] = position;\n\n\t\t\t\t\t\t\ttarget[ prop ] = THREE.MathUtils.randInt( joint.limits.min, joint.limits.max );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tkinematicsTween = new TWEEN.Tween( tweenParameters ).to( target, duration ).easing( TWEEN.Easing.Quadratic.Out );\n\n\t\t\t\tkinematicsTween.onUpdate( function ( object ) {\n\n\t\t\t\t\tfor ( const prop in kinematics.joints ) {\n\n\t\t\t\t\t\tif ( kinematics.joints.hasOwnProperty( prop ) ) {\n\n\t\t\t\t\t\t\tif ( ! kinematics.joints[ prop ].static ) {\n\n\t\t\t\t\t\t\t\tkinematics.setJointValue( prop, object[ prop ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tkinematicsTween.start();\n\n\t\t\t\tsetTimeout( setupTween, duration );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tTWEEN.update();\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.0001;\n\n\t\t\t\tcamera.position.x = Math.cos( timer ) * 20;\n\t\t\t\tcamera.position.y = 10;\n\t\t\t\tcamera.position.z = Math.sin( timer ) * 20;\n\n\t\t\t\tcamera.lookAt( 0, 5, 0 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js collada loader - kinematics robot from collada robots"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - collada - skinning"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - collada - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, stats, clock, controls;\n\t\t\tlet camera, scene, renderer, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 15, 10, - 15 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// collada\n\n\t\t\t\tconst loader = new ColladaLoader();\n\t\t\t\tloader.load( './models/collada/stormtrooper/stormtrooper.dae', function ( collada ) {\n\n\t\t\t\t\tconst avatar = collada.scene;\n\t\t\t\t\tconst animations = avatar.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( avatar );\n\t\t\t\t\tmixer.clipAction( animations[ 0 ] ).play();\n\n\t\t\t\t\tscene.add( avatar );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gridHelper = new THREE.GridHelper( 10, 20, 0xc1c1c1, 0x8d8d8d );\n\t\t\t\tscene.add( gridHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 1.5, 1, - 1.5 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.screenSpacePanning = true;\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 40;\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer !== undefined ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js collada loader - skinning Dancing Stormtrooper by StrykerDoesAnimation , CC Attribution"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl loader collada skinning in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - collada - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, stats, clock, controls;\n\t\t\tlet camera, scene, renderer, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 15, 10, - 15 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// collada\n\n\t\t\t\tconst loader = new ColladaLoader();\n\t\t\t\tloader.load( './models/collada/stormtrooper/stormtrooper.dae', function ( collada ) {\n\n\t\t\t\t\tconst avatar = collada.scene;\n\t\t\t\t\tconst animations = avatar.animations;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( avatar );\n\t\t\t\t\tmixer.clipAction( animations[ 0 ] ).play();\n\n\t\t\t\t\tscene.add( avatar );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gridHelper = new THREE.GridHelper( 10, 20, 0xc1c1c1, 0x8d8d8d );\n\t\t\t\tscene.add( gridHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 1.5, 1, - 1.5 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.screenSpacePanning = true;\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 40;\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer !== undefined ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js collada loader - skinning Dancing Stormtrooper by StrykerDoesAnimation , CC Attribution"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - Draco loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - Draco loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\tlet camera, scene, renderer;\n\n\t\tconst container = document.querySelector( '#container' );\n\n\t\t// Configure and create Draco decoder.\n\t\tconst dracoLoader = new DRACOLoader();\n\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 15 );\n\t\t\tcamera.position.set( 3, 0.25, 3 );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x443333 );\n\t\t\tscene.fog = new THREE.Fog( 0x443333, 1, 4 );\n\n\t\t\t// Ground\n\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\tnew THREE.PlaneGeometry( 8, 8 ),\n\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xcbcbcb, specular: 0x101010 } )\n\t\t\t);\n\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\tplane.position.y = 0.03;\n\t\t\tplane.receiveShadow = true;\n\t\t\tscene.add( plane );\n\n\t\t\t// Lights\n\t\t\tconst hemiLight = new THREE.HemisphereLight( 0x8d7c7c, 0x494966, 3 );\n\t\t\tscene.add( hemiLight );\n\n\t\t\tconst spotLight = new THREE.SpotLight();\n\t\t\tspotLight.intensity = 7;\n\t\t\tspotLight.angle = Math.PI / 16;\n\t\t\tspotLight.penumbra = 0.5;\n\t\t\tspotLight.castShadow = true;\n\t\t\tspotLight.position.set( - 1, 1, 1 );\n\t\t\tscene.add( spotLight );\n\n\t\t\tdracoLoader.load( 'models/draco/bunny.drc', function ( geometry ) {\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xa5a5a5 } );\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// Release decoder resources.\n\t\t\t\tdracoLoader.dispose();\n\n\t\t\t} );\n\n\t\t\t// renderer\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst timer = Date.now() * 0.0003;\n\n\t\t\tcamera.position.x = Math.sin( timer ) * 0.5;\n\t\t\tcamera.position.z = Math.cos( timer ) * 0.5;\n\t\t\tcamera.lookAt( 0, 0.1, 0 );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js - DRACO loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - FBX loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - FBX loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { FBXLoader } from 'three/addons/loaders/FBXLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst manager = new THREE.LoadingManager();\n\n\t\t\tlet camera, scene, renderer, stats, object, loader, guiMorphsFolder;\n\t\t\tlet mixer;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst params = {\n\t\t\t\tasset: 'Samba Dancing'\n\t\t\t};\n\n\t\t\tconst assets = [\n\t\t\t\t'Samba Dancing',\n\t\t\t\t'morph_test',\n\t\t\t\t'monkey',\n\t\t\t\t'monkey_embedded_texture'\n\t\t\t];\n\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 100, 200, 300 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 5 );\n\t\t\t\themiLight.position.set( 0, 200, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 5 );\n\t\t\t\tdirLight.position.set( 0, 200, 100 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.top = 180;\n\t\t\t\tdirLight.shadow.camera.bottom = - 100;\n\t\t\t\tdirLight.shadow.camera.left = - 120;\n\t\t\t\tdirLight.shadow.camera.right = 120;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// ground\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\t\t\t\n\t\t\t\tloader = new FBXLoader( manager );\n\t\t\t\tloadAsset( params.asset );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 100, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'asset', assets ).onChange( function ( value ) {\n\n\t\t\t\t\tloadAsset( value );\n\n\t\t\t\t} );\n\n\t\t\t\tguiMorphsFolder = gui.addFolder( 'Morphs' ).hide();\n\n\t\t\t}\n\n\t\t\tfunction loadAsset( asset ) {\n\n\t\t\t\tloader.load( 'models/fbx/' + asset + '.fbx', function ( group ) {\n\n\t\t\t\t\tif ( object ) {\n\n\t\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\t\tif ( child.isSkinnedMesh ) {\n\n\t\t\t\t\t\t\t\tchild.skeleton.dispose();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( child.material ) {\n\n\t\t\t\t\t\t\t\tconst materials = Array.isArray( child.material ) ? child.material : [ child.material ];\n\t\t\t\t\t\t\t\tmaterials.forEach( material => {\n\n\t\t\t\t\t\t\t\t\tif ( material.map ) material.map.dispose();\n\t\t\t\t\t\t\t\t\tmaterial.dispose();\n\t\t\t\n\t\t\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t\t\tif ( child.geometry ) child.geometry.dispose();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tscene.remove( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tobject = group;\n\n\t\t\t\t\tif ( object.animations && object.animations.length ) {\n\n\t\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\t\tconst action = mixer.clipAction( object.animations[ 0 ] );\n\t\t\t\t\t\taction.play();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmixer = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tguiMorphsFolder.children.forEach( ( child ) => child.destroy() );\n\t\t\t\t\tguiMorphsFolder.hide();\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\n\t\t\t\t\t\t\tif ( child.morphTargetDictionary ) {\n\n\t\t\t\t\t\t\t\tguiMorphsFolder.show();\n\t\t\t\t\t\t\t\tconst meshFolder = guiMorphsFolder.addFolder( child.name || child.uuid );\n\t\t\t\t\t\t\t\tObject.keys( child.morphTargetDictionary ).forEach( ( key ) => {\n\t\t\t\n\t\t\t\t\t\t\t\t\tmeshFolder.add( child.morphTargetInfluences, child.morphTargetDictionary[ key ], 0, 1, 0.01 );\n\t\t\t\n\t\t\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - FBXLoader Character and animation from Mixamo"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - FBX loader - Nurbs"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - FBX loader - Nurbs:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { FBXLoader } from 'three/addons/loaders/FBXLoader.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 2, 18, 28 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// grid\n\t\t\t\tconst gridHelper = new THREE.GridHelper( 28, 28, 0x303030, 0x303030 );\n\t\t\t\tscene.add( gridHelper );\n\n\t\t\t\t// stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// model\n\t\t\t\tconst loader = new FBXLoader();\n\t\t\t\tloader.load( 'models/fbx/nurbs.fbx', function ( object ) {\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 12, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - FBXLoader - Nurbs"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - GCode loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - GCode loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GCodeLoader } from 'three/addons/loaders/GCodeLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 70 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst loader = new GCodeLoader();\n\t\t\t\tloader.load( 'models/gcode/benchy.gcode', function ( object ) {\n\n\t\t\t\t\tobject.position.set( - 100, - 20, 100 );\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 100;\n\n\t\t\t\twindow.addEventListener( 'resize', resize );\n\n\t\t\t}\n\n\t\t\tfunction resize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GCode loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmet.gltf', async function ( gltf ) {\n\n\t\t\t\t\t\t\tconst model = gltf.scene;\n\n\t\t\t\t\t\t\t// wait until the model can be added to the scene without blocking due to shader compilation\n\n\t\t\t\t\t\t\tawait renderer.compileAsync( model, camera, scene );\n\n\t\t\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\t\t\trender();\n\t\t\t\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader Battle Damaged Sci-fi Helmet by theblueturtle_ Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + EXT_texture_avif"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + EXT_texture_avif:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 1.5, 4, 9 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf6eedc );\n\n\t\t\t\t//\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\t\tloader.setPath( 'models/gltf/AVIFTest/' );\n\t\t\t\tloader.load( 'forest_house.glb', function ( gltf ) {\n\n\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + EXT_texture_avif Forest House by peachyroyalty"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + compressed"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + compressed:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 0, 100, 0 );\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbbbbbb );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\t\t\t\tenvironment.dispose();\n\n\t\t\t\tconst grid = new THREE.GridHelper( 500, 10, 0xffffff, 0xffffff );\n\t\t\t\tgrid.material.opacity = 0.5;\n\t\t\t\tgrid.material.depthWrite = false;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\tconst ktx2Loader = new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupport( renderer );\n\n\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\tloader.setKTX2Loader( ktx2Loader );\n\t\t\t\tloader.setMeshoptDecoder( MeshoptDecoder );\n\t\t\t\tloader.load( 'coffeemat.glb', function ( gltf ) {\n\n\t\t\t\t\t// coffeemat.glb was produced from the source scene using gltfpack:\n\t\t\t\t\t// gltfpack -i coffeemat/scene.gltf -o coffeemat.glb -cc -tc\n\t\t\t\t\t// The resulting model uses EXT_meshopt_compression (for geometry) and KHR_texture_basisu (for texture compression using ETC1S/BasisLZ)\n\n\t\t\t\t\tgltf.scene.position.y = 8;\n\n\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 400;\n\t\t\t\tcontrols.maxDistance = 1000;\n\t\t\t\tcontrols.target.set( 10, 90, - 16 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + compression extensions Coffeemat by Roman Red"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + Dispersion"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + Dispersion:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit().then( render );\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 5 );\n\t\t\t\tcamera.position.set( 0.1, 0.05, 0.15 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\n\t\t\t\tconst env = pmremGenerator.fromScene( environment ).texture;\n\t\t\t\tscene.background = env;\n\t\t\t\tscene.environment = env;\n\t\t\t\tenvironment.dispose();\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/DispersionTest.glb' );\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + KHR_materials_dispersion"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + Instancing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + Instancing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 0.90, 0.41, - 0.89 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF-instancing/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmetGpuInstancing.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 0.2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0.25, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + EXT_mesh_gpu_instancing Battle Damaged Sci-fi Helmet by theblueturtle_ Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + Iridescence"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + Iridescence:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\n\t\t\tinit().catch( function ( err ) {\n\n\t\t\t\tconsole.error( err );\n\n\t\t\t} );\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.05, 20 );\n\t\t\t\tcamera.position.set( 0.35, 0.05, 0.35 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 0.5;\n\t\t\t\tcontrols.target.set( 0, 0.2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );\n\n\t\t\t\tconst [ texture, gltf ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'venice_sunset_1k.hdr' ),\n\t\t\t\t\tgltfLoader.loadAsync( 'IridescenceLamp.glb' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + KHR_materials_iridescence Iridescence Lamp from glTF-Sample-Models Venice Sunset from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + Sheen"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + Sheen:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 20 );\n\t\t\t\tcamera.position.set( - 0.75, 0.7, 1.25 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// model\n\n\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t.setPath( 'models/gltf/' )\n\t\t\t\t\t.load( 'SheenChair.glb', function ( gltf ) {\n\n\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\tconst object = gltf.scene.getObjectByName( 'SheenChair_fabric' );\n\n\t\t\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t\t\tgui.add( object.material, 'sheen', 0, 1 );\n\t\t\t\t\t\tgui.open();\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.background = new THREE.Color( 0xbbbbbb );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0.35, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update(); // required if damping enabled\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + KHR_materials_sheen Sheen Chair from glTF-Sample-Models"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + transmission"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + transmission:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\tlet camera, scene, renderer, controls, clock, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( 0, 0.4, 0.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.backgroundBlurriness = 0.35;\n\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t\t\t.setPath( 'models/gltf/' )\n\t\t\t\t\t\t\t.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) )\n\t\t\t\t\t\t\t.load( 'IridescentDishWithOlives.glb', function ( gltf ) {\n\n\t\t\t\t\t\t\t\tmixer = new THREE.AnimationMixer( gltf.scene );\n\t\t\t\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 0.75;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.5;\n\t\t\t\tcontrols.maxDistance = 1;\n\t\t\t\tcontrols.target.set( 0, 0.1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( mixer ) mixer.update( clock.getDelta() );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + KHR_materials_transmission Iridescent Dish With Olives by Eric Chadwick Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + variants"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + variants:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet gui;\n\n\t\t\tconst state = { variant: 'midnight' };\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( 2.5, 1.5, 3.0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'quarry_01_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/MaterialsVariantsShoe/glTF/' );\n\t\t\t\t\t\tloader.load( 'MaterialsVariantsShoe.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tgltf.scene.scale.set( 10.0, 10.0, 10.0 );\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\t// GUI\n\t\t\t\t\t\t\tgui = new GUI();\n\n\t\t\t\t\t\t\t// Details of the KHR_materials_variants extension used here can be found below\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n\t\t\t\t\t\t\tconst parser = gltf.parser;\n\t\t\t\t\t\t\tconst variantsExtension = gltf.userData.gltfExtensions[ 'KHR_materials_variants' ];\n\t\t\t\t\t\t\tconst variants = variantsExtension.variants.map( ( variant ) => variant.name );\n\t\t\t\t\t\t\tconst variantsCtrl = gui.add( state, 'variant', variants ).name( 'Variant' );\n\n\t\t\t\t\t\t\tselectVariant( scene, parser, variantsExtension, state.variant );\n\n\t\t\t\t\t\t\tvariantsCtrl.onChange( ( value ) => selectVariant( scene, parser, variantsExtension, value ) );\n\n\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0.5, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction selectVariant( scene, parser, extension, variantName ) {\n\n\t\t\t\tconst variantIndex = extension.variants.findIndex( ( v ) => v.name.includes( variantName ) );\n\n\t\t\t\tscene.traverse( async ( object ) => {\n\n\t\t\t\t\tif ( ! object.isMesh || ! object.userData.gltfExtensions ) return;\n\n\t\t\t\t\tconst meshVariantDef = object.userData.gltfExtensions[ 'KHR_materials_variants' ];\n\n\t\t\t\t\tif ( ! meshVariantDef ) return;\n\n\t\t\t\t\tif ( ! object.userData.originalMaterial ) {\n\n\t\t\t\t\t\tobject.userData.originalMaterial = object.material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mapping = meshVariantDef.mappings\n\t\t\t\t\t\t.find( ( mapping ) => mapping.variants.includes( variantIndex ) );\n\n\t\t\t\t\tif ( mapping ) {\n\n\t\t\t\t\t\tobject.material = await parser.getDependency( 'material', mapping.material );\n\t\t\t\t\t\tparser.assignFinalMaterial( object );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.material = object.userData.originalMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + KHR_materials_variants Materials Variants Shoe by Shopify, Inc Quarry from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - GLTFloader + Anisotropy"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader + Anisotropy:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.35;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( - 0.35, - 0.2, 0.35 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, - 0.08, 0.11 );\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 2;\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader().setPath( 'textures/equirectangular/' );\n\t\t\t\tconst gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );\n\n\t\t\t\tconst [ texture, gltf ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'royal_esplanade_1k.hdr' ),\n\t\t\t\t\tgltfLoader.loadAsync( 'AnisotropyBarnLamp.glb' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\trender();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - GLTFLoader + KHR_materials_anisotropy Anisotropy Barn Lamp from glTF-Sample-Models Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - IFCLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - IFCLoader:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { IFCLoader } from 'web-ifc-three';\n\t\t\timport { IFCSPACE } from 'web-ifc';\n\n\t\t\tlet scene, camera, renderer;\n\n\t\t\tasync function init() {\n\n\t\t\t\t//Scene\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x8cc7de );\n\n\t\t\t\t//Camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\t\tcamera.position.z = - 70;\n\t\t\t\tcamera.position.y = 25;\n\t\t\t\tcamera.position.x = 90;\n\n\t\t\t\t//Initial cube\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff } );\n\t\t\t\tconst cube = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( cube );\n\n\t\t\t\t//Lights\n\t\t\t\tconst directionalLight1 = new THREE.DirectionalLight( 0xffeeff, 2.5 );\n\t\t\t\tdirectionalLight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( directionalLight1 );\n\n\t\t\t\tconst directionalLight2 = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\t\tdirectionalLight2.position.set( - 1, 0.5, - 1 );\n\t\t\t\tscene.add( directionalLight2 );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffee, 0.75 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\t//Setup IFC Loader\n\t\t\t\tconst ifcLoader = new IFCLoader();\n\t\t\t\tawait ifcLoader.ifcManager.setWasmPath( 'https://cdn.jsdelivr.net/npm/web-ifc@0.0.36/', true );\n\n\t\t\t\tawait ifcLoader.ifcManager.parser.setupOptionalCategories( {\n\t\t\t\t\t[ IFCSPACE ]: false,\n\t\t\t\t} );\n\n\t\t\t\tawait ifcLoader.ifcManager.applyWebIfcConfig( {\n\t\t\t\t\tUSE_FAST_BOOLS: true\n\t\t\t\t} );\n\n\t\t\t\tifcLoader.load( 'models/ifc/rac_advanced_sample_project.ifc', function ( model ) {\n\n\t\t\t\t\tscene.add( model.mesh );\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//Renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//Controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js - See main project repository for more information and BIM tools."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loader - ImageBitmap"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loader - ImageBitmap:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet group, cubes;\n\n\t\t\tinit();\n\n\t\t\tfunction addImageBitmap() {\n\n\t\t\t\tnew THREE.ImageBitmapLoader()\n\t\t\t\t\t.load( 'textures/planets/earth_atmos_2048.jpg?' + performance.now(), function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new THREE.CanvasTexture( imageBitmap );\n\t\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\t\t// ImageBitmap should be disposed when done with it.\n\n\t\t\t\t\t\ttexture.onUpdate = disposeImageBitmap;\n\n\t\t\t\t\t\taddCube( material );\n\n\t\t\t\t\t}, function ( p ) {\n\n\t\t\t\t\t\tconsole.log( p );\n\n\t\t\t\t\t}, function ( e ) {\n\n\t\t\t\t\t\tconsole.log( e );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction addImage() {\n\n\t\t\t\tnew THREE.ImageLoader()\n\t\t\t\t\t.setCrossOrigin( '*' )\n\t\t\t\t\t.load( 'textures/planets/earth_atmos_2048.jpg?' + performance.now(), function ( image ) {\n\n\t\t\t\t\t\tconst texture = new THREE.CanvasTexture( image );\n\t\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xff8888, map: texture } );\n\t\t\t\t\t\taddCube( material );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\tfunction addCube( material ) {\n\n\t\t\t\tconst cube = new THREE.Mesh( geometry, material );\n\t\t\t\tcube.position.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );\n\t\t\t\tcube.rotation.set( Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI );\n\t\t\t\tcubes.add( cube );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );\n\t\t\t\tcamera.position.set( 0, 4, 7 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tgroup.add( new THREE.GridHelper( 4, 12, 0x888888, 0x444444 ) );\n\n\t\t\t\tcubes = new THREE.Group();\n\t\t\t\tgroup.add( cubes );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// TESTS\n\n\t\t\t\tsetTimeout( addImage, 300 );\n\t\t\t\tsetTimeout( addImage, 600 );\n\t\t\t\tsetTimeout( addImage, 900 );\n\t\t\t\tsetTimeout( addImageBitmap, 1300 );\n\t\t\t\tsetTimeout( addImageBitmap, 1600 );\n\t\t\t\tsetTimeout( addImageBitmap, 1900 );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tgroup.rotation.y = performance.now() / 3000;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction disposeImageBitmap( texture ) {\n\n\t\t\t\ttexture.source.data.close();\n\t\t\t\ttexture.onUpdate = null; // make sure this callback is executed only once per texture\n\n\t\t\t}\n```\n\nThis example three.js - Texture loader using ImageBitmap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - KMZLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - KMZLoader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { KMZLoader } from 'three/addons/loaders/KMZLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x999999 );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0.5, 1.0, 0.5 ).normalize();\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 500 );\n\n\t\t\t\tcamera.position.y = 5;\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 50, 50, 0xffffff, 0x7b7b7b );\n\t\t\t\tscene.add( grid );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst loader = new KMZLoader();\n\t\t\t\tloader.load( './models/kmz/Box.kmz', function ( kmz ) {\n\n\t\t\t\t\tkmz.scene.position.y = 0.5;\n\t\t\t\t\tscene.add( kmz.scene );\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - KMZLoader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - LDrawLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - LDrawLoader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n\t\t\timport { LDrawUtils } from 'three/addons/utils/LDrawUtils.js';\n\t\t\timport { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';\n\n\t\t\tlet container, progressBarDiv;\n\n\t\t\tlet camera, scene, renderer, controls, gui, guiData;\n\n\t\t\tlet model;\n\n\t\t\tconst ldrawPath = 'models/ldraw/officialLibrary/';\n\n\t\t\tconst modelFileList = {\n\t\t\t\t'Car': 'models/car.ldr_Packed.mpd',\n\t\t\t\t'Lunar Vehicle': 'models/1621-1-LunarMPVVehicle.mpd_Packed.mpd',\n\t\t\t\t'Radar Truck': 'models/889-1-RadarTruck.mpd_Packed.mpd',\n\t\t\t\t'Trailer': 'models/4838-1-MiniVehicles.mpd_Packed.mpd',\n\t\t\t\t'Bulldozer': 'models/4915-1-MiniConstruction.mpd_Packed.mpd',\n\t\t\t\t'Helicopter': 'models/4918-1-MiniFlyers.mpd_Packed.mpd',\n\t\t\t\t'Plane': 'models/5935-1-IslandHopper.mpd_Packed.mpd',\n\t\t\t\t'Lighthouse': 'models/30023-1-Lighthouse.ldr_Packed.mpd',\n\t\t\t\t'X-Wing mini': 'models/30051-1-X-wingFighter-Mini.mpd_Packed.mpd',\n\t\t\t\t'AT-ST mini': 'models/30054-1-AT-ST-Mini.mpd_Packed.mpd',\n\t\t\t\t'AT-AT mini': 'models/4489-1-AT-AT-Mini.mpd_Packed.mpd',\n\t\t\t\t'Shuttle': 'models/4494-1-Imperial Shuttle-Mini.mpd_Packed.mpd',\n\t\t\t\t'TIE Interceptor': 'models/6965-1-TIEIntercep_4h4MXk5.mpd_Packed.mpd',\n\t\t\t\t'Star fighter': 'models/6966-1-JediStarfighter-Mini.mpd_Packed.mpd',\n\t\t\t\t'X-Wing': 'models/7140-1-X-wingFighter.mpd_Packed.mpd',\n\t\t\t\t'AT-ST': 'models/10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd'\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 150, 200, 250 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// scene\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xdeebed );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment() ).texture;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t//\n\n\t\t\t\tguiData = {\n\t\t\t\t\tmodelFileName: modelFileList[ 'Car' ],\n\t\t\t\t\tdisplayLines: true,\n\t\t\t\t\tconditionalLines: true,\n\t\t\t\t\tsmoothNormals: true,\n\t\t\t\t\tbuildingStep: 0,\n\t\t\t\t\tnoBuildingSteps: 'No steps.',\n\t\t\t\t\tflatColors: false,\n\t\t\t\t\tmergeModel: false\n\t\t\t\t};\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tprogressBarDiv = document.createElement( 'div' );\n\t\t\t\tprogressBarDiv.innerText = 'Loading...';\n\t\t\t\tprogressBarDiv.style.fontSize = '3em';\n\t\t\t\tprogressBarDiv.style.color = '#888';\n\t\t\t\tprogressBarDiv.style.display = 'block';\n\t\t\t\tprogressBarDiv.style.position = 'absolute';\n\t\t\t\tprogressBarDiv.style.top = '50%';\n\t\t\t\tprogressBarDiv.style.width = '100%';\n\t\t\t\tprogressBarDiv.style.textAlign = 'center';\n\n\n\t\t\t\t// load materials and then the model\n\n\t\t\t\treloadObject( true );\n\n\t\t\t}\n\n\t\t\tfunction updateObjectsVisibility() {\n\n\t\t\t\tmodel.traverse( c => {\n\n\t\t\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\t\t\tc.visible = guiData.conditionalLines;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tc.visible = guiData.displayLines;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( c.isGroup ) {\n\n\t\t\t\t\t\t// Hide objects with building step > gui setting\n\t\t\t\t\t\tc.visible = c.userData.buildingStep <= guiData.buildingStep;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction reloadObject( resetCamera ) {\n\n\t\t\t\tif ( model ) {\n\n\t\t\t\t\tscene.remove( model );\n\n\t\t\t\t}\n\n\t\t\t\tmodel = null;\n\n\t\t\t\tupdateProgressBar( 0 );\n\t\t\t\tshowProgressBar();\n\n\t\t\t\t// only smooth when not rendering with flat colors to improve processing time\n\t\t\t\tconst lDrawLoader = new LDrawLoader();\n\t\t\t\tlDrawLoader.setConditionalLineMaterial( LDrawConditionalLineMaterial );\n\t\t\t\tlDrawLoader.smoothNormals = guiData.smoothNormals && ! guiData.flatColors;\n\t\t\t\tlDrawLoader\n\t\t\t\t\t.setPath( ldrawPath )\n\t\t\t\t\t.load( guiData.modelFileName, function ( group2 ) {\n\n\t\t\t\t\t\tif ( model ) {\n\n\t\t\t\t\t\t\tscene.remove( model );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel = group2;\n\n\t\t\t\t\t\t// demonstrate how to use convert to flat colors to better mimic the lego instructions look\n\t\t\t\t\t\tif ( guiData.flatColors ) {\n\n\t\t\t\t\t\t\tfunction convertMaterial( material ) {\n\n\t\t\t\t\t\t\t\tconst newMaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\t\t\t\tnewMaterial.color.copy( material.color );\n\t\t\t\t\t\t\t\tnewMaterial.polygonOffset = material.polygonOffset;\n\t\t\t\t\t\t\t\tnewMaterial.polygonOffsetUnits = material.polygonOffsetUnits;\n\t\t\t\t\t\t\t\tnewMaterial.polygonOffsetFactor = material.polygonOffsetFactor;\n\t\t\t\t\t\t\t\tnewMaterial.opacity = material.opacity;\n\t\t\t\t\t\t\t\tnewMaterial.transparent = material.transparent;\n\t\t\t\t\t\t\t\tnewMaterial.depthWrite = material.depthWrite;\n\t\t\t\t\t\t\t\tnewMaterial.toneMapped = false;\n\n\t\t\t\t\t\t\t\treturn newMaterial;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodel.traverse( c => {\n\n\t\t\t\t\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\t\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\t\t\t\t\t\tc.material = c.material.map( convertMaterial );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tc.material = convertMaterial( c.material );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge model geometries by material\n\t\t\t\t\t\tif ( guiData.mergeModel ) model = LDrawUtils.mergeObject( model );\n\n\t\t\t\t\t\t// Convert from LDraw coordinates: rotate 180 degrees around OX\n\t\t\t\t\t\tmodel.rotation.x = Math.PI;\n\n\t\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\t\tguiData.buildingStep = model.userData.numBuildingSteps - 1;\n\n\t\t\t\t\t\tupdateObjectsVisibility();\n\n\t\t\t\t\t\t// Adjust camera and light\n\n\t\t\t\t\t\tconst bbox = new THREE.Box3().setFromObject( model );\n\t\t\t\t\t\tconst size = bbox.getSize( new THREE.Vector3() );\n\t\t\t\t\t\tconst radius = Math.max( size.x, Math.max( size.y, size.z ) ) * 0.5;\n\n\t\t\t\t\t\tif ( resetCamera ) {\n\n\t\t\t\t\t\t\tcontrols.target0.copy( bbox.getCenter( new THREE.Vector3() ) );\n\t\t\t\t\t\t\tcontrols.position0.set( - 2.3, 1, 2 ).multiplyScalar( radius ).add( controls.target0 );\n\t\t\t\t\t\t\tcontrols.reset();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcreateGUI();\n\n\t\t\t\t\t\thideProgressBar();\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tif ( gui ) {\n\n\t\t\t\t\tgui.destroy();\n\n\t\t\t\t}\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( guiData, 'modelFileName', modelFileList ).name( 'Model' ).onFinishChange( function () {\n\n\t\t\t\t\treloadObject( true );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( guiData, 'flatColors' ).name( 'Flat Colors' ).onChange( function () {\n\n\t\t\t\t\treloadObject( false );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( guiData, 'mergeModel' ).name( 'Merge model' ).onChange( function () {\n\n\t\t\t\t\treloadObject( false );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( model.userData.numBuildingSteps > 1 ) {\n\n\t\t\t\t\tgui.add( guiData, 'buildingStep', 0, model.userData.numBuildingSteps - 1 ).step( 1 ).name( 'Building step' ).onChange( updateObjectsVisibility );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgui.add( guiData, 'noBuildingSteps' ).name( 'Building step' ).onChange( updateObjectsVisibility );\n\n\t\t\t\t}\n\n\t\t\t\tgui.add( guiData, 'smoothNormals' ).name( 'Smooth Normals' ).onChange( function changeNormals() {\n\n\t\t\t\t\treloadObject( false );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( guiData, 'displayLines' ).name( 'Display Lines' ).onChange( updateObjectsVisibility );\n\t\t\t\tgui.add( guiData, 'conditionalLines' ).name( 'Conditional Lines' ).onChange( updateObjectsVisibility );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onProgress( xhr ) {\n\n\t\t\t\tif ( xhr.lengthComputable ) {\n\n\t\t\t\t\tupdateProgressBar( xhr.loaded / xhr.total );\n\n\t\t\t\t\tconsole.log( Math.round( xhr.loaded / xhr.total * 100 ) + '% downloaded' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onError( error ) {\n\n\t\t\t\tconst message = 'Error loading model';\n\t\t\t\tprogressBarDiv.innerText = message;\n\t\t\t\tconsole.log( message );\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t\tfunction showProgressBar() {\n\n\t\t\t\tdocument.body.appendChild( progressBarDiv );\n\n\t\t\t}\n\n\t\t\tfunction hideProgressBar() {\n\n\t\t\t\tdocument.body.removeChild( progressBarDiv );\n\n\t\t\t}\n\n\t\t\tfunction updateProgressBar( fraction ) {\n\n\t\t\t\tprogressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';\n\n\t\t\t}\n```\n\nThis example three.js - LDrawLoader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - LWOLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - LWOLoader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { LWOLoader } from 'three/addons/loaders/LWOLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 200 );\n\t\t\t\tcamera.position.set( 0.7, 14.6, - 43.2 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xc1c1c1, 3 );\n\t\t\t\tlight1.position.set( 0, 200, - 100 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 200, 20, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.3;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\tconst loader = new LWOLoader();\n\t\t\t\tloader.load( 'models/lwo/Objects/LWO3/Demo.lwo', function ( object ) {\n\n\t\t\t\t\tconst phong = object.meshes[ 0 ];\n\t\t\t\t\tphong.position.set( 2, 12, 0 );\n\n\t\t\t\t\tconst standard = object.meshes[ 1 ];\n\t\t\t\t\tstandard.position.set( - 2, 12, 0 );\n\n\t\t\t\t\tconst rocket = object.meshes[ 2 ];\n\t\t\t\t\trocket.position.set( 0, 10.5, 1 );\n\n\t\t\t\t\tscene.add( phong, standard, rocket );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( - 1.33, 10, 6.7 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - LWOLoader Lightwave Object loader by Discover three.js Models by on the z - Environment images from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - morphtargets - MD2"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morphtargets - MD2:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { MD2Character } from 'three/addons/misc/MD2Character.js';\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\tlet container, camera, scene, renderer;\n\n\t\t\tlet character;\n\n\t\t\tlet gui;\n\n\t\t\tconst playbackConfig = {\n\n\t\t\t\tspeed: 1.0,\n\t\t\t\twireframe: false\n\n\t\t\t};\n\n\t\t\tlet controls;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 2, 4 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2.5, 10 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x666666 ) );\n\n\t\t\t\tconst light1 = new THREE.SpotLight( 0xffffff, 150 );\n\t\t\t\tlight1.position.set( 2, 5, 10 );\n\t\t\t\tlight1.angle = 0.5;\n\t\t\t\tlight1.penumbra = 0.5;\n\n\t\t\t\tlight1.castShadow = true;\n\t\t\t\tlight1.shadow.mapSize.width = 1024;\n\t\t\t\tlight1.shadow.mapSize.height = 1024;\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( light1.shadow.camera ) );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.SpotLight( 0xffffff, 150 );\n\t\t\t\tlight2.position.set( - 1, 3.5, 3.5 );\n\t\t\t\tlight2.angle = 0.5;\n\t\t\t\tlight2.penumbra = 0.5;\n\n\t\t\t\tlight2.castShadow = true;\n\t\t\t\tlight2.shadow.mapSize.width = 1024;\n\t\t\t\tlight2.shadow.mapSize.height = 1024;\n\n\t\t\t\t// scene.add( new THREE.CameraHelper( light2.shadow.camera ) );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//  GROUND\n\n\t\t\t\tconst gt = new THREE.TextureLoader().load( 'textures/terrain/grasslight-big.jpg' );\n\t\t\t\tconst gg = new THREE.PlaneGeometry( 20, 20 );\n\t\t\t\tconst gm = new THREE.MeshPhongMaterial( { color: 0xffffff, map: gt } );\n\n\t\t\t\tconst ground = new THREE.Mesh( gg, gm );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.material.map.repeat.set( 8, 8 );\n\t\t\t\tground.material.map.wrapS = ground.material.map.wrapT = THREE.RepeatWrapping;\n\t\t\t\tground.material.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\n\t\t\t\t// STATS\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// GUI\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( playbackConfig, 'speed', 0, 2 ).onChange( function () {\n\n\t\t\t\t\tcharacter.setPlaybackRate( playbackConfig.speed );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( playbackConfig, 'wireframe' ).onChange( function () {\n\n\t\t\t\t\tcharacter.setWireframe( playbackConfig.wireframe );\n\n\t\t\t\t} );\n\n\t\t\t\t// CHARACTER\n\n\t\t\t\tconst config = {\n\n\t\t\t\t\tbaseUrl: 'models/md2/ratamahatta/',\n\n\t\t\t\t\tbody: 'ratamahatta.md2',\n\t\t\t\t\tskins: [ 'ratamahatta.png', 'ctf_b.png', 'ctf_r.png', 'dead.png', 'gearwhore.png' ],\n\t\t\t\t\tweapons: [[ 'weapon.md2', 'weapon.png' ],\n\t\t\t\t\t\t\t\t [ 'w_bfg.md2', 'w_bfg.png' ],\n\t\t\t\t\t\t\t\t [ 'w_blaster.md2', 'w_blaster.png' ],\n\t\t\t\t\t\t\t\t [ 'w_chaingun.md2', 'w_chaingun.png' ],\n\t\t\t\t\t\t\t\t [ 'w_glauncher.md2', 'w_glauncher.png' ],\n\t\t\t\t\t\t\t\t [ 'w_hyperblaster.md2', 'w_hyperblaster.png' ],\n\t\t\t\t\t\t\t\t [ 'w_machinegun.md2', 'w_machinegun.png' ],\n\t\t\t\t\t\t\t\t [ 'w_railgun.md2', 'w_railgun.png' ],\n\t\t\t\t\t\t\t\t [ 'w_rlauncher.md2', 'w_rlauncher.png' ],\n\t\t\t\t\t\t\t\t [ 'w_shotgun.md2', 'w_shotgun.png' ],\n\t\t\t\t\t\t\t\t [ 'w_sshotgun.md2', 'w_sshotgun.png' ]\n\t\t\t\t\t]\n\n\t\t\t\t};\n\n\t\t\t\tcharacter = new MD2Character();\n\t\t\t\tcharacter.scale = 0.03;\n\n\t\t\t\tcharacter.onLoadComplete = function () {\n\n\t\t\t\t\tsetupSkinsGUI( character );\n\t\t\t\t\tsetupWeaponsGUI( character );\n\t\t\t\t\tsetupGUIAnimations( character );\n\n\t\t\t\t\tcharacter.setAnimation( character.meshBody.geometry.animations[ 0 ].name );\n\n\t\t\t\t};\n\n\t\t\t\tcharacter.loadParts( config );\n\n\t\t\t\tscene.add( character.root );\n\n\t\t\t}\n\n\t\t\t// EVENT HANDLERS\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t// GUI\n\n\t\t\tfunction labelize( text ) {\n\n\t\t\t\tconst parts = text.split( '.' );\n\n\t\t\t\tif ( parts.length > 1 ) {\n\n\t\t\t\t\tparts.length -= 1;\n\t\t\t\t\treturn parts.join( '.' );\n\n\t\t\t\t}\n\n\t\t\t\treturn text;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction setupWeaponsGUI( character ) {\n\n\t\t\t\tconst folder = gui.addFolder( 'Weapons' );\n\n\t\t\t\tconst generateCallback = function ( index ) {\n\n\t\t\t\t\treturn function () {\n\n\t\t\t\t\t\tcharacter.setWeapon( index );\n\t\t\t\t\t\tcharacter.setWireframe( playbackConfig.wireframe );\n\n\t\t\t\t\t};\n\n\t\t\t\t};\n\n\t\t\t\tconst guiItems = [];\n\n\t\t\t\tfor ( let i = 0; i < character.weapons.length; i ++ ) {\n\n\t\t\t\t\tconst name = character.weapons[ i ].name;\n\n\t\t\t\t\tplaybackConfig[ name ] = generateCallback( i );\n\t\t\t\t\tguiItems[ i ] = folder.add( playbackConfig, name ).name( labelize( name ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction setupSkinsGUI( character ) {\n\n\t\t\t\tconst folder = gui.addFolder( 'Skins' );\n\n\t\t\t\tconst generateCallback = function ( index ) {\n\n\t\t\t\t\treturn function () {\n\n\t\t\t\t\t\tcharacter.setSkin( index );\n\n\t\t\t\t\t};\n\n\t\t\t\t};\n\n\t\t\t\tconst guiItems = [];\n\n\t\t\t\tfor ( let i = 0; i < character.skinsBody.length; i ++ ) {\n\n\t\t\t\t\tconst name = character.skinsBody[ i ].name;\n\n\t\t\t\t\tplaybackConfig[ name ] = generateCallback( i );\n\t\t\t\t\tguiItems[ i ] = folder.add( playbackConfig, name ).name( labelize( name ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction setupGUIAnimations( character ) {\n\n\t\t\t\tconst folder = gui.addFolder( 'Animations' );\n\n\t\t\t\tconst generateCallback = function ( animationClip ) {\n\n\t\t\t\t\treturn function () {\n\n\t\t\t\t\t\tcharacter.setAnimation( animationClip.name );\n\n\t\t\t\t\t};\n\n\t\t\t\t};\n\n\t\t\t\tconst guiItems = [];\n\t\t\t\tconst animations = character.meshBody.geometry.animations;\n\n\t\t\t\tfor ( let i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tconst clip = animations[ i ];\n\n\t\t\t\t\tplaybackConfig[ clip.name ] = generateCallback( clip );\n\t\t\t\t\tguiItems[ i ] = folder.add( playbackConfig, clip.name, clip.name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tcharacter.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - MD2 Loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - morphtargets - MD2 controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morphtargets - MD2 controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { MD2CharacterComplex } from 'three/addons/misc/MD2CharacterComplex.js';\n\t\t\timport { Gyroscope } from 'three/addons/misc/Gyroscope.js';\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst characters = [];\n\t\t\tlet nCharacters = 0;\n\n\t\t\tlet cameraControls;\n\n\t\t\tconst controls = {\n\n\t\t\t\tmoveForward: false,\n\t\t\t\tmoveBackward: false,\n\t\t\t\tmoveLeft: false,\n\t\t\t\tmoveRight: false\n\n\t\t\t};\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );\n\t\t\t\tcamera.position.set( 0, 150, 1300 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\t\t\t\tscene.fog = new THREE.Fog( 0xffffff, 1000, 4000 );\n\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x666666, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 7 );\n\t\t\t\tlight.position.set( 200, 450, 500 );\n\n\t\t\t\tlight.castShadow = true;\n\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 512;\n\n\t\t\t\tlight.shadow.camera.near = 100;\n\t\t\t\tlight.shadow.camera.far = 1200;\n\n\t\t\t\tlight.shadow.camera.left = - 1000;\n\t\t\t\tlight.shadow.camera.right = 1000;\n\t\t\t\tlight.shadow.camera.top = 350;\n\t\t\t\tlight.shadow.camera.bottom = - 350;\n\n\t\t\t\tscene.add( light );\n\t\t\t\t// scene.add( new THREE.CameraHelper( light.shadow.camera ) );\n\n\n\t\t\t\t//  GROUND\n\n\t\t\t\tconst gt = new THREE.TextureLoader().load( 'textures/terrain/grasslight-big.jpg' );\n\t\t\t\tconst gg = new THREE.PlaneGeometry( 16000, 16000 );\n\t\t\t\tconst gm = new THREE.MeshPhongMaterial( { color: 0xffffff, map: gt } );\n\n\t\t\t\tconst ground = new THREE.Mesh( gg, gm );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.material.map.repeat.set( 64, 64 );\n\t\t\t\tground.material.map.wrapS = THREE.RepeatWrapping;\n\t\t\t\tground.material.map.wrapT = THREE.RepeatWrapping;\n\t\t\t\tground.material.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t// note that because the ground does not cast a shadow, .castShadow is left false\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\t// STATS\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\t\t\t\tdocument.addEventListener( 'keyup', onKeyUp );\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tcameraControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcameraControls.target.set( 0, 50, 0 );\n\t\t\t\tcameraControls.update();\n\n\t\t\t\t// CHARACTER\n\n\t\t\t\tconst configOgro = {\n\n\t\t\t\t\tbaseUrl: 'models/md2/ogro/',\n\n\t\t\t\t\tbody: 'ogro.md2',\n\t\t\t\t\tskins: [ 'grok.jpg', 'ogrobase.png', 'arboshak.png', 'ctf_r.png', 'ctf_b.png', 'darkam.png', 'freedom.png',\n\t\t\t\t\t\t\t 'gib.png', 'gordogh.png', 'igdosh.png', 'khorne.png', 'nabogro.png',\n\t\t\t\t\t\t\t 'sharokh.png' ],\n\t\t\t\t\tweapons: [[ 'weapon.md2', 'weapon.jpg' ]],\n\t\t\t\t\tanimations: {\n\t\t\t\t\t\tmove: 'run',\n\t\t\t\t\t\tidle: 'stand',\n\t\t\t\t\t\tjump: 'jump',\n\t\t\t\t\t\tattack: 'attack',\n\t\t\t\t\t\tcrouchMove: 'cwalk',\n\t\t\t\t\t\tcrouchIdle: 'cstand',\n\t\t\t\t\t\tcrouchAttach: 'crattack'\n\t\t\t\t\t},\n\n\t\t\t\t\twalkSpeed: 350,\n\t\t\t\t\tcrouchSpeed: 175\n\n\t\t\t\t};\n\n\t\t\t\tconst nRows = 1;\n\t\t\t\tconst nSkins = configOgro.skins.length;\n\n\t\t\t\tnCharacters = nSkins * nRows;\n\n\t\t\t\tfor ( let i = 0; i < nCharacters; i ++ ) {\n\n\t\t\t\t\tconst character = new MD2CharacterComplex();\n\t\t\t\t\tcharacter.scale = 3;\n\t\t\t\t\tcharacter.controls = controls;\n\t\t\t\t\tcharacters.push( character );\n\n\t\t\t\t}\n\n\t\t\t\tconst baseCharacter = new MD2CharacterComplex();\n\t\t\t\tbaseCharacter.scale = 3;\n\n\t\t\t\tbaseCharacter.onLoadComplete = function () {\n\n\t\t\t\t\tlet k = 0;\n\n\t\t\t\t\tfor ( let j = 0; j < nRows; j ++ ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < nSkins; i ++ ) {\n\n\t\t\t\t\t\t\tconst cloneCharacter = characters[ k ];\n\n\t\t\t\t\t\t\tcloneCharacter.shareParts( baseCharacter );\n\n\t\t\t\t\t\t\t// cast and receive shadows\n\t\t\t\t\t\t\tcloneCharacter.enableShadows( true );\n\n\t\t\t\t\t\t\tcloneCharacter.setWeapon( 0 );\n\t\t\t\t\t\t\tcloneCharacter.setSkin( i );\n\n\t\t\t\t\t\t\tcloneCharacter.root.position.x = ( i - nSkins / 2 ) * 150;\n\t\t\t\t\t\t\tcloneCharacter.root.position.z = j * 250;\n\n\t\t\t\t\t\t\tscene.add( cloneCharacter.root );\n\n\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst gyro = new Gyroscope();\n\t\t\t\t\tgyro.add( camera );\n\t\t\t\t\tgyro.add( light, light.target );\n\n\t\t\t\t\tcharacters[ Math.floor( nSkins / 2 ) ].root.add( gyro );\n\n\t\t\t\t};\n\n\t\t\t\tbaseCharacter.loadParts( configOgro );\n\n\t\t\t}\n\n\t\t\t// EVENT HANDLERS\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\tcase 'ArrowUp':\n\t\t\t\t\tcase 'KeyW': controls.moveForward = true; break;\n\n\t\t\t\t\tcase 'ArrowDown':\n\t\t\t\t\tcase 'KeyS': controls.moveBackward = true; break;\n\n\t\t\t\t\tcase 'ArrowLeft':\n\t\t\t\t\tcase 'KeyA': controls.moveLeft = true; break;\n\n\t\t\t\t\tcase 'ArrowRight':\n\t\t\t\t\tcase 'KeyD': controls.moveRight = true; break;\n\n\t\t\t\t\t// case 'KeyC': controls.crouch = true; break;\n\t\t\t\t\t// case 'Space': controls.jump = true; break;\n\t\t\t\t\t// case 'ControlLeft':\n\t\t\t\t\t// case 'ControlRight': controls.attack = true; break;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onKeyUp( event ) {\n\n\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\tcase 'ArrowUp':\n\t\t\t\t\tcase 'KeyW': controls.moveForward = false; break;\n\n\t\t\t\t\tcase 'ArrowDown':\n\t\t\t\t\tcase 'KeyS': controls.moveBackward = false; break;\n\n\t\t\t\t\tcase 'ArrowLeft':\n\t\t\t\t\tcase 'KeyA': controls.moveLeft = false; break;\n\n\t\t\t\t\tcase 'ArrowRight':\n\t\t\t\t\tcase 'KeyD': controls.moveRight = false; break;\n\n\t\t\t\t\t// case 'KeyC': controls.crouch = false; break;\n\t\t\t\t\t// case 'Space': controls.jump = false; break;\n\t\t\t\t\t// case 'ControlLeft':\n\t\t\t\t\t// case 'ControlRight': controls.attack = false; break;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( let i = 0; i < nCharacters; i ++ ) {\n\n\t\t\t\t\tcharacters[ i ].update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - MD2 Loader use arrows to control characters, mouse for camera"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates WebGL - MDDLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL - MDDLoader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { MDDLoader } from 'three/addons/loaders/MDDLoader.js';\n\n\t\t\tlet camera, scene, renderer, mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 8, 8, 8 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new MDDLoader();\n\t\t\t\tloader.load( 'models/mdd/cube.mdd', function ( result ) {\n\n\t\t\t\t\tconst morphTargets = result.morphTargets;\n\t\t\t\t\tconst clip = result.clip;\n\t\t\t\t\t// clip.optimize(); // optional\n\n\t\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\t\tgeometry.morphAttributes.position = morphTargets; // apply morph targets\n\n\t\t\t\t\tconst material = new THREE.MeshNormalMaterial();\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\t\t\t\t\tmixer.clipAction( clip ).play(); // use clip\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - MDDLoader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - NRRD loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - NRRD loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { NRRDLoader } from 'three/addons/loaders/NRRDLoader.js';\n\t\t\timport { VTKLoader } from 'three/addons/loaders/VTKLoader.js';\n\n\t\t\tlet stats,\n\t\t\t\tcamera,\n\t\t\t\tcontrols,\n\t\t\t\tscene,\n\t\t\t\trenderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// light\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x000000, 3 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tdirLight.position.set( 200, 200, 200 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst loader = new NRRDLoader();\n\t\t\t\tloader.load( 'models/nrrd/I.nrrd', function ( volume ) {\n\n\t\t\t\t\t//box helper to see the extend of the volume\n\t\t\t\t\tconst geometry = new THREE.BoxGeometry( volume.xLength, volume.yLength, volume.zLength );\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n\t\t\t\t\tconst cube = new THREE.Mesh( geometry, material );\n\t\t\t\t\tcube.visible = false;\n\t\t\t\t\tconst box = new THREE.BoxHelper( cube );\n\t\t\t\t\tscene.add( box );\n\t\t\t\t\tbox.applyMatrix4( volume.matrix );\n\t\t\t\t\tscene.add( cube );\n\n\t\t\t\t\t//z plane\n\t\t\t\t\tconst sliceZ = volume.extractSlice( 'z', Math.floor( volume.RASDimensions[ 2 ] / 4 ) );\n\t\t\t\t\tscene.add( sliceZ.mesh );\n\n\t\t\t\t\t//y plane\n\t\t\t\t\tconst sliceY = volume.extractSlice( 'y', Math.floor( volume.RASDimensions[ 1 ] / 2 ) );\n\t\t\t\t\tscene.add( sliceY.mesh );\n\n\t\t\t\t\t//x plane\n\t\t\t\t\tconst sliceX = volume.extractSlice( 'x', Math.floor( volume.RASDimensions[ 0 ] / 2 ) );\n\t\t\t\t\tscene.add( sliceX.mesh );\n\n\t\t\t\t\tgui.add( sliceX, 'index', 0, volume.RASDimensions[ 0 ], 1 ).name( 'indexX' ).onChange( function () {\n\n\t\t\t\t\t\tsliceX.repaint.call( sliceX );\n\n\t\t\t\t\t} );\n\t\t\t\t\tgui.add( sliceY, 'index', 0, volume.RASDimensions[ 1 ], 1 ).name( 'indexY' ).onChange( function () {\n\n\t\t\t\t\t\tsliceY.repaint.call( sliceY );\n\n\t\t\t\t\t} );\n\t\t\t\t\tgui.add( sliceZ, 'index', 0, volume.RASDimensions[ 2 ], 1 ).name( 'indexZ' ).onChange( function () {\n\n\t\t\t\t\t\tsliceZ.repaint.call( sliceZ );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tgui.add( volume, 'lowerThreshold', volume.min, volume.max, 1 ).name( 'Lower Threshold' ).onChange( function () {\n\n\t\t\t\t\t\tvolume.repaintAllSlices();\n\n\t\t\t\t\t} );\n\t\t\t\t\tgui.add( volume, 'upperThreshold', volume.min, volume.max, 1 ).name( 'Upper Threshold' ).onChange( function () {\n\n\t\t\t\t\t\tvolume.repaintAllSlices();\n\n\t\t\t\t\t} );\n\t\t\t\t\tgui.add( volume, 'windowLow', volume.min, volume.max, 1 ).name( 'Window Low' ).onChange( function () {\n\n\t\t\t\t\t\tvolume.repaintAllSlices();\n\n\t\t\t\t\t} );\n\t\t\t\t\tgui.add( volume, 'windowHigh', volume.min, volume.max, 1 ).name( 'Window High' ).onChange( function () {\n\n\t\t\t\t\t\tvolume.repaintAllSlices();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tconst vtkmaterial = new THREE.MeshLambertMaterial( { wireframe: false, side: THREE.DoubleSide, color: 0xff0000 } );\n\n\t\t\t\tconst vtkloader = new VTKLoader();\n\t\t\t\tvtkloader.load( 'models/vtk/liver.vtk', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, vtkmaterial );\n\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\tconst visibilityControl = {\n\t\t\t\t\t\tvisible: true\n\t\t\t\t\t};\n\t\t\t\t\tgui.add( visibilityControl, 'visible' ).name( 'Model Visible' ).onChange( function () {\n\n\t\t\t\t\t\tmesh.visible = visibilityControl.visible;\n\t\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 500;\n\t\t\t\tcontrols.rotateSpeed = 5.0;\n\t\t\t\tcontrols.zoomSpeed = 5;\n\t\t\t\tcontrols.panSpeed = 2;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - NRRD format loader test"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - OBJ/MTL loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - OBJ/MTL loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 20 );\n\t\t\t\tcamera.position.z = 2.5;\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 15 );\n\t\t\t\tcamera.add( pointLight );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// model\n\n\t\t\t\tconst mtlLoader = new MTLLoader().setPath( 'models/obj/male02/' );\n\t\t\t\tconst materials = await mtlLoader.loadAsync( 'male02.mtl' );\n\t\t\t\tmaterials.preload();\n\n\t\t\t\tconst objLoader = new OBJLoader().setPath( 'models/obj/male02/' );\n\t\t\t\tobjLoader.setMaterials( materials ); // optional since OBJ asstes can be loaded without an accompanying MTL file\n\n\t\t\t\tconst object = await objLoader.loadAsync( 'male02.obj' );\n\n\t\t\t\tobject.position.y = - 0.95;\n\t\t\t\tobject.scale.setScalar( 0.01 );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 5;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - OBJ/MTL loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - PCD"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - PCD:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { PCDLoader } from 'three/addons/loaders/PCDLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.01, 40 );\n\t\t\t\tcamera.position.set( 0, 0, 1 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 0.5;\n\t\t\t\tcontrols.maxDistance = 10;\n\n\t\t\t\t//scene.add( new THREE.AxesHelper( 1 ) );\n\n\t\t\t\tconst loader = new PCDLoader();\n\n\t\t\t\tconst loadPointCloud = function ( file ) {\n\n\t\t\t\t\tloader.load( './models/pcd/' + file, function ( points ) {\n\n\t\t\t\t\t\tpoints.geometry.center();\n\t\t\t\t\t\tpoints.geometry.rotateX( Math.PI );\n\t\t\t\t\t\tpoints.name = file;\n\t\t\t\t\t\tscene.add( points );\n\n\t\t\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t\t\tgui.add( points.material, 'size', 0.001, 0.01 ).onChange( render );\n\t\t\t\t\t\tgui.addColor( points.material, 'color' ).onChange( render );\n\t\t\t\t\t\tgui.add( points, 'name', [\n\t\t\t\t\t\t\t'ascii/simple.pcd',\n\t\t\t\t\t\t\t'binary/Zaghetto.pcd',\n\t\t\t\t\t\t\t'binary/Zaghetto_8bit.pcd',\n\t\t\t\t\t\t\t'binary_compressed/pcl_logo.pcd',\n\t\t\t\t\t\t] ).name( 'type' ).onChange( e => {\n\n\t\t\t\t\t\t\tgui.destroy();\n\t\t\t\t\t\t\tscene.remove( points );\n\t\t\t\t\t\t\tloadPointCloud( e );\n\t\t\t\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tgui.open();\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\t};\n\n\t\t\t\tloadPointCloud( 'binary/Zaghetto.pcd' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js PCD File format"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - molecules"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - molecules:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { PDBLoader } from 'three/addons/loaders/PDBLoader.js';\n\t\t\timport { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, labelRenderer;\n\t\t\tlet controls;\n\n\t\t\tlet root;\n\n\t\t\tconst MOLECULES = {\n\t\t\t\t'Ethanol': 'ethanol.pdb',\n\t\t\t\t'Aspirin': 'aspirin.pdb',\n\t\t\t\t'Caffeine': 'caffeine.pdb',\n\t\t\t\t'Nicotine': 'nicotine.pdb',\n\t\t\t\t'LSD': 'lsd.pdb',\n\t\t\t\t'Cocaine': 'cocaine.pdb',\n\t\t\t\t'Cholesterol': 'cholesterol.pdb',\n\t\t\t\t'Lycopene': 'lycopene.pdb',\n\t\t\t\t'Glucose': 'glucose.pdb',\n\t\t\t\t'Aluminium oxide': 'Al2O3.pdb',\n\t\t\t\t'Cubane': 'cubane.pdb',\n\t\t\t\t'Copper': 'cu.pdb',\n\t\t\t\t'Fluorite': 'caf2.pdb',\n\t\t\t\t'Salt': 'nacl.pdb',\n\t\t\t\t'YBCO superconductor': 'ybco.pdb',\n\t\t\t\t'Buckyball': 'buckyball.pdb',\n\t\t\t\t'Graphite': 'graphite.pdb'\n\t\t\t};\n\n\t\t\tconst params = {\n\t\t\t\tmolecule: 'caffeine.pdb'\n\t\t\t};\n\n\t\t\tconst loader = new PDBLoader();\n\t\t\tconst offset = new THREE.Vector3();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.z = 1000;\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tlight2.position.set( - 1, - 1, 1 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\troot = new THREE.Group();\n\t\t\t\tscene.add( root );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.getElementById( 'container' ).appendChild( renderer.domElement );\n\n\t\t\t\tlabelRenderer = new CSS2DRenderer();\n\t\t\t\tlabelRenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tlabelRenderer.domElement.style.position = 'absolute';\n\t\t\t\tlabelRenderer.domElement.style.top = '0px';\n\t\t\t\tlabelRenderer.domElement.style.pointerEvents = 'none';\n\t\t\t\tdocument.getElementById( 'container' ).appendChild( labelRenderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 500;\n\t\t\t\tcontrols.maxDistance = 2000;\n\n\t\t\t\t//\n\n\t\t\t\tloadMolecule( params.molecule );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'molecule', MOLECULES ).onChange( loadMolecule );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction loadMolecule( model ) {\n\n\t\t\t\tconst url = 'models/pdb/' + model;\n\n\t\t\t\twhile ( root.children.length > 0 ) {\n\n\t\t\t\t\tconst object = root.children[ 0 ];\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( url, function ( pdb ) {\n\n\t\t\t\t\tconst geometryAtoms = pdb.geometryAtoms;\n\t\t\t\t\tconst geometryBonds = pdb.geometryBonds;\n\t\t\t\t\tconst json = pdb.json;\n\n\t\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\t\tconst sphereGeometry = new THREE.IcosahedronGeometry( 1, 3 );\n\n\t\t\t\t\tgeometryAtoms.computeBoundingBox();\n\t\t\t\t\tgeometryAtoms.boundingBox.getCenter( offset ).negate();\n\n\t\t\t\t\tgeometryAtoms.translate( offset.x, offset.y, offset.z );\n\t\t\t\t\tgeometryBonds.translate( offset.x, offset.y, offset.z );\n\n\t\t\t\t\tlet positions = geometryAtoms.getAttribute( 'position' );\n\t\t\t\t\tconst colors = geometryAtoms.getAttribute( 'color' );\n\n\t\t\t\t\tconst position = new THREE.Vector3();\n\t\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\t\tfor ( let i = 0; i < positions.count; i ++ ) {\n\n\t\t\t\t\t\tposition.x = positions.getX( i );\n\t\t\t\t\t\tposition.y = positions.getY( i );\n\t\t\t\t\t\tposition.z = positions.getZ( i );\n\n\t\t\t\t\t\tcolor.r = colors.getX( i );\n\t\t\t\t\t\tcolor.g = colors.getY( i );\n\t\t\t\t\t\tcolor.b = colors.getZ( i );\n\n\t\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: color } );\n\n\t\t\t\t\t\tconst object = new THREE.Mesh( sphereGeometry, material );\n\t\t\t\t\t\tobject.position.copy( position );\n\t\t\t\t\t\tobject.position.multiplyScalar( 75 );\n\t\t\t\t\t\tobject.scale.multiplyScalar( 25 );\n\t\t\t\t\t\troot.add( object );\n\n\t\t\t\t\t\tconst atom = json.atoms[ i ];\n\n\t\t\t\t\t\tconst text = document.createElement( 'div' );\n\t\t\t\t\t\ttext.className = 'label';\n\t\t\t\t\t\ttext.style.color = 'rgb(' + atom[ 3 ][ 0 ] + ',' + atom[ 3 ][ 1 ] + ',' + atom[ 3 ][ 2 ] + ')';\n\t\t\t\t\t\ttext.textContent = atom[ 4 ];\n\n\t\t\t\t\t\tconst label = new CSS2DObject( text );\n\t\t\t\t\t\tlabel.position.copy( object.position );\n\t\t\t\t\t\troot.add( label );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpositions = geometryBonds.getAttribute( 'position' );\n\n\t\t\t\t\tconst start = new THREE.Vector3();\n\t\t\t\t\tconst end = new THREE.Vector3();\n\n\t\t\t\t\tfor ( let i = 0; i < positions.count; i += 2 ) {\n\n\t\t\t\t\t\tstart.x = positions.getX( i );\n\t\t\t\t\t\tstart.y = positions.getY( i );\n\t\t\t\t\t\tstart.z = positions.getZ( i );\n\n\t\t\t\t\t\tend.x = positions.getX( i + 1 );\n\t\t\t\t\t\tend.y = positions.getY( i + 1 );\n\t\t\t\t\t\tend.z = positions.getZ( i + 1 );\n\n\t\t\t\t\t\tstart.multiplyScalar( 75 );\n\t\t\t\t\t\tend.multiplyScalar( 75 );\n\n\t\t\t\t\t\tconst object = new THREE.Mesh( boxGeometry, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\t\t\tobject.position.copy( start );\n\t\t\t\t\t\tobject.position.lerp( end, 0.5 );\n\t\t\t\t\t\tobject.scale.set( 5, 5, start.distanceTo( end ) );\n\t\t\t\t\t\tobject.lookAt( end );\n\t\t\t\t\t\troot.add( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tlabelRenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst time = Date.now() * 0.0004;\n\n\t\t\t\troot.rotation.x = time;\n\t\t\t\troot.rotation.y = time * 0.7;\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tlabelRenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - molecules"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - PLY"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - PLY:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, cameraTarget, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 15 );\n\t\t\t\tcamera.position.set( 3, 0.15, 3 );\n\n\t\t\t\tcameraTarget = new THREE.Vector3( 0, - 0.1, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x72645b );\n\t\t\t\tscene.fog = new THREE.Fog( 0x72645b, 2, 15 );\n\n\n\t\t\t\t// Ground\n\n\t\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 40, 40 ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xcbcbcb, specular: 0x474747 } )\n\t\t\t\t);\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tplane.position.y = - 0.5;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tplane.receiveShadow = true;\n\n\n\t\t\t\t// PLY file\n\n\t\t\t\tconst loader = new PLYLoader();\n\t\t\t\tloader.load( './models/ply/ascii/dolphins.ply', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0x009cff, flatShading: true } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.y = - 0.2;\n\t\t\t\t\tmesh.position.z = 0.3;\n\t\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.001 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\tloader.load( './models/ply/binary/Lucy100k.ply', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0x009cff, flatShading: true } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = - 0.2;\n\t\t\t\t\tmesh.position.y = - 0.02;\n\t\t\t\t\tmesh.position.z = - 0.2;\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.0006 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x8d7c7c, 0x494966, 3 ) );\n\n\t\t\t\taddShadowedLight( 1, 1, 1, 0xffffff, 3.5 );\n\t\t\t\taddShadowedLight( 0.5, 1, - 1, 0xffd500, 3 );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// resize\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction addShadowedLight( x, y, z, color, intensity ) {\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( color, intensity );\n\t\t\t\tdirectionalLight.position.set( x, y, z );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tdirectionalLight.castShadow = true;\n\n\t\t\t\tconst d = 1;\n\t\t\t\tdirectionalLight.shadow.camera.left = - d;\n\t\t\t\tdirectionalLight.shadow.camera.right = d;\n\t\t\t\tdirectionalLight.shadow.camera.top = d;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - d;\n\n\t\t\t\tdirectionalLight.shadow.camera.near = 1;\n\t\t\t\tdirectionalLight.shadow.camera.far = 4;\n\n\t\t\t\tdirectionalLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirectionalLight.shadow.mapSize.height = 1024;\n\n\t\t\t\tdirectionalLight.shadow.bias = - 0.001;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.0005;\n\n\t\t\t\tcamera.position.x = Math.sin( timer ) * 2.5;\n\t\t\t\tcamera.position.z = Math.cos( timer ) * 2.5;\n\n\t\t\t\tcamera.lookAt( cameraTarget );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - PLY loader test by Wei Meng . Image from John Burkardt"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - STL"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - STL:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { STLLoader } from 'three/addons/loaders/STLLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, cameraTarget, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 15 );\n\t\t\t\tcamera.position.set( 3, 0.15, 3 );\n\n\t\t\t\tcameraTarget = new THREE.Vector3( 0, - 0.25, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x72645b );\n\t\t\t\tscene.fog = new THREE.Fog( 0x72645b, 2, 15 );\n\n\t\t\t\t// Ground\n\n\t\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 40, 40 ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xcbcbcb, specular: 0x474747 } )\n\t\t\t\t);\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tplane.position.y = - 0.5;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tplane.receiveShadow = true;\n\n\n\t\t\t\t// ASCII file\n\n\t\t\t\tconst loader = new STLLoader();\n\t\t\t\tloader.load( './models/stl/ascii/slotted_disk.stl', function ( geometry ) {\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xff9c7c, specular: 0x494949, shininess: 200 } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.set( 0, - 0.25, 0.6 );\n\t\t\t\t\tmesh.rotation.set( 0, - Math.PI / 2, 0 );\n\t\t\t\t\tmesh.scale.set( 0.5, 0.5, 0.5 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\n\t\t\t\t// Binary files\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xd5d5d5, specular: 0x494949, shininess: 200 } );\n\n\t\t\t\tloader.load( './models/stl/binary/pr2_head_pan.stl', function ( geometry ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.set( 0, - 0.37, - 0.6 );\n\t\t\t\t\tmesh.rotation.set( - Math.PI / 2, 0, 0 );\n\t\t\t\t\tmesh.scale.set( 2, 2, 2 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\tloader.load( './models/stl/binary/pr2_head_tilt.stl', function ( geometry ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.set( 0.136, - 0.37, - 0.6 );\n\t\t\t\t\tmesh.rotation.set( - Math.PI / 2, 0.3, 0 );\n\t\t\t\t\tmesh.scale.set( 2, 2, 2 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// Colored binary STL\n\t\t\t\tloader.load( './models/stl/binary/colored.stl', function ( geometry ) {\n\n\t\t\t\t\tlet meshMaterial = material;\n\n\t\t\t\t\tif ( geometry.hasColors ) {\n\n\t\t\t\t\t\tmeshMaterial = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, meshMaterial );\n\n\t\t\t\t\tmesh.position.set( 0.5, 0.2, 0 );\n\t\t\t\t\tmesh.rotation.set( - Math.PI / 2, Math.PI / 2, 0 );\n\t\t\t\t\tmesh.scale.set( 0.3, 0.3, 0.3 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x8d7c7c, 0x494966, 3 ) );\n\n\t\t\t\taddShadowedLight( 1, 1, 1, 0xffffff, 3.5 );\n\t\t\t\taddShadowedLight( 0.5, 1, - 1, 0xffd500, 3 );\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction addShadowedLight( x, y, z, color, intensity ) {\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( color, intensity );\n\t\t\t\tdirectionalLight.position.set( x, y, z );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tdirectionalLight.castShadow = true;\n\n\t\t\t\tconst d = 1;\n\t\t\t\tdirectionalLight.shadow.camera.left = - d;\n\t\t\t\tdirectionalLight.shadow.camera.right = d;\n\t\t\t\tdirectionalLight.shadow.camera.top = d;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - d;\n\n\t\t\t\tdirectionalLight.shadow.camera.near = 1;\n\t\t\t\tdirectionalLight.shadow.camera.far = 4;\n\n\t\t\t\tdirectionalLight.shadow.bias = - 0.002;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.0005;\n\n\t\t\t\tcamera.position.x = Math.cos( timer ) * 3;\n\t\t\t\tcamera.position.z = Math.sin( timer ) * 3;\n\n\t\t\t\tcamera.lookAt( cameraTarget );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - STL loader test by aleeper . PR2 head from www.ros.org"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - svg loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - svg loader:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { SVGLoader } from 'three/addons/loaders/SVGLoader.js';\n\n\t\t\tlet renderer, scene, camera, gui, guiData;\n\n\t\t\tinit();\n\n\t\t\t//\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 200 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.screenSpacePanning = true;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tguiData = {\n\t\t\t\t\tcurrentURL: 'models/svg/tiger.svg',\n\t\t\t\t\tdrawFillShapes: true,\n\t\t\t\t\tdrawStrokes: true,\n\t\t\t\t\tfillShapesWireframe: false,\n\t\t\t\t\tstrokesWireframe: false\n\t\t\t\t};\n\n\t\t\t\tloadSVG( guiData.currentURL );\n\n\t\t\t\tcreateGUI();\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tif ( gui ) gui.destroy();\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( guiData, 'currentURL', {\n\n\t\t\t\t\t'Tiger': 'models/svg/tiger.svg',\n\t\t\t\t\t'Joins and caps': 'models/svg/lineJoinsAndCaps.svg',\n\t\t\t\t\t'Hexagon': 'models/svg/hexagon.svg',\n\t\t\t\t\t'Energy': 'models/svg/energy.svg',\n\t\t\t\t\t'Test 1': 'models/svg/tests/1.svg',\n\t\t\t\t\t'Test 2': 'models/svg/tests/2.svg',\n\t\t\t\t\t'Test 3': 'models/svg/tests/3.svg',\n\t\t\t\t\t'Test 4': 'models/svg/tests/4.svg',\n\t\t\t\t\t'Test 5': 'models/svg/tests/5.svg',\n\t\t\t\t\t'Test 6': 'models/svg/tests/6.svg',\n\t\t\t\t\t'Test 7': 'models/svg/tests/7.svg',\n\t\t\t\t\t'Test 8': 'models/svg/tests/8.svg',\n\t\t\t\t\t'Test 9': 'models/svg/tests/9.svg',\n\t\t\t\t\t'Units': 'models/svg/tests/units.svg',\n\t\t\t\t\t'Ordering': 'models/svg/tests/ordering.svg',\n\t\t\t\t\t'Defs': 'models/svg/tests/testDefs/Svg-defs.svg',\n\t\t\t\t\t'Defs2': 'models/svg/tests/testDefs/Svg-defs2.svg',\n\t\t\t\t\t'Defs3': 'models/svg/tests/testDefs/Wave-defs.svg',\n\t\t\t\t\t'Defs4': 'models/svg/tests/testDefs/defs4.svg',\n\t\t\t\t\t'Defs5': 'models/svg/tests/testDefs/defs5.svg',\n\t\t\t\t\t'Style CSS inside defs': 'models/svg/style-css-inside-defs.svg',\n\t\t\t\t\t'Multiple CSS classes': 'models/svg/multiple-css-classes.svg',\n\t\t\t\t\t'Zero Radius': 'models/svg/zero-radius.svg',\n\t\t\t\t\t'Styles in svg tag': 'models/svg/tests/styles.svg',\n\t\t\t\t\t'Round join': 'models/svg/tests/roundJoinPrecisionIssue.svg',\n\t\t\t\t\t'Ellipse Transformations': 'models/svg/tests/ellipseTransform.svg',\n\t\t\t\t\t'singlePointTest': 'models/svg/singlePointTest.svg',\n\t\t\t\t\t'singlePointTest2': 'models/svg/singlePointTest2.svg',\n\t\t\t\t\t'singlePointTest3': 'models/svg/singlePointTest3.svg',\n\t\t\t\t\t'emptyPath': 'models/svg/emptyPath.svg',\n\n\t\t\t\t} ).name( 'SVG File' ).onChange( update );\n\n\t\t\t\tgui.add( guiData, 'drawStrokes' ).name( 'Draw strokes' ).onChange( update );\n\n\t\t\t\tgui.add( guiData, 'drawFillShapes' ).name( 'Draw fill shapes' ).onChange( update );\n\n\t\t\t\tgui.add( guiData, 'strokesWireframe' ).name( 'Wireframe strokes' ).onChange( update );\n\n\t\t\t\tgui.add( guiData, 'fillShapesWireframe' ).name( 'Wireframe fill shapes' ).onChange( update );\n\n\t\t\t\tfunction update() {\n\n\t\t\t\t\tloadSVG( guiData.currentURL );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction loadSVG( url ) {\n\n\t\t\t\t//\n\n\t\t\t\tif ( scene ) disposeScene( scene );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xb0b0b0 );\n\n\t\t\t\t//\n\n\t\t\t\tconst helper = new THREE.GridHelper( 160, 10, 0x8d8d8d, 0xc1c1c1 );\n\t\t\t\thelper.rotation.x = Math.PI / 2;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new SVGLoader();\n\n\t\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\t\tconst group = new THREE.Group();\n\t\t\t\t\tgroup.scale.multiplyScalar( 0.25 );\n\t\t\t\t\tgroup.position.x = - 70;\n\t\t\t\t\tgroup.position.y = 70;\n\t\t\t\t\tgroup.scale.y *= - 1;\n\n\t\t\t\t\tlet renderOrder = 0;\n\n\t\t\t\t\tfor ( const path of data.paths ) {\n\n\t\t\t\t\t\tconst fillColor = path.userData.style.fill;\n\n\t\t\t\t\t\tif ( guiData.drawFillShapes && fillColor !== undefined && fillColor !== 'none' ) {\n\n\t\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( {\n\t\t\t\t\t\t\t\tcolor: new THREE.Color().setStyle( fillColor ),\n\t\t\t\t\t\t\t\topacity: path.userData.style.fillOpacity,\n\t\t\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\t\t\twireframe: guiData.fillShapesWireframe\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tconst shapes = SVGLoader.createShapes( path );\n\n\t\t\t\t\t\t\tfor ( const shape of shapes ) {\n\n\t\t\t\t\t\t\t\tconst geometry = new THREE.ShapeGeometry( shape );\n\t\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\t\tmesh.renderOrder = renderOrder ++;\n\n\t\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst strokeColor = path.userData.style.stroke;\n\n\t\t\t\t\t\tif ( guiData.drawStrokes && strokeColor !== undefined && strokeColor !== 'none' ) {\n\n\t\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( {\n\t\t\t\t\t\t\t\tcolor: new THREE.Color().setStyle( strokeColor ),\n\t\t\t\t\t\t\t\topacity: path.userData.style.strokeOpacity,\n\t\t\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\t\t\twireframe: guiData.strokesWireframe\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tfor ( const subPath of path.subPaths ) {\n\n\t\t\t\t\t\t\t\tconst geometry = SVGLoader.pointsToStroke( subPath.getPoints(), path.userData.style );\n\n\t\t\t\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\t\t\tmesh.renderOrder = renderOrder ++;\n\n\t\t\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( group );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction disposeScene( scene ) {\n\n\t\t\t\tscene.traverse( function ( object ) {\n\t\t\t\n\t\t\t\t\tif ( object.isMesh || object.isLine ) {\n\n\t\t\t\t\t\tobject.geometry.dispose();\n\t\t\t\t\t\tobject.material.dispose();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - SVGLoader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - compressed textures"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - compressed textures:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { DDSLoader } from 'three/addons/loaders/DDSLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tconst meshes = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.y = - 2;\n\t\t\t\tcamera.position.z = 16;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 2, 2, 2 );\n\n\t\t\t\t/*\n\t\t\t\tThis is how compressed textures are supposed to be used:\n\n\t\t\t\tDXT1 - RGB - opaque textures\n\t\t\t\tDXT3 - RGBA - transparent textures with sharp alpha transitions\n\t\t\t\tDXT5 - RGBA - transparent textures with full alpha range\n\t\t\t\t*/\n\n\t\t\t\tconst loader = new DDSLoader();\n\n\t\t\t\tconst map1 = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );\n\t\t\t\tmap1.minFilter = map1.magFilter = THREE.LinearFilter;\n\t\t\t\tmap1.anisotropy = 4;\n\t\t\t\tmap1.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst map2 = loader.load( 'textures/compressed/disturb_dxt1_mip.dds' );\n\t\t\t\tmap2.anisotropy = 4;\n\t\t\t\tmap2.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst map3 = loader.load( 'textures/compressed/hepatica_dxt3_mip.dds' );\n\t\t\t\tmap3.anisotropy = 4;\n\t\t\t\tmap3.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst map4 = loader.load( 'textures/compressed/explosion_dxt5_mip.dds' );\n\t\t\t\tmap4.anisotropy = 4;\n\t\t\t\tmap4.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst map5 = loader.load( 'textures/compressed/disturb_argb_nomip.dds' );\n\t\t\t\tmap5.minFilter = map5.magFilter = THREE.LinearFilter;\n\t\t\t\tmap5.anisotropy = 4;\n\t\t\t\tmap5.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst map6 = loader.load( 'textures/compressed/disturb_argb_mip.dds' );\n\t\t\t\tmap6.anisotropy = 4;\n\t\t\t\tmap6.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst map7 = loader.load( 'textures/compressed/disturb_dx10_bc6h_signed_nomip.dds' );\n\t\t\t\tmap7.anisotropy = 4;\n\n\t\t\t\tconst map8 = loader.load( 'textures/compressed/disturb_dx10_bc6h_signed_mip.dds' );\n\t\t\t\tmap8.anisotropy = 4;\n\n\t\t\t\tconst map9 = loader.load( 'textures/compressed/disturb_dx10_bc6h_unsigned_nomip.dds' );\n\t\t\t\tmap9.anisotropy = 4;\n\n\t\t\t\tconst map10 = loader.load( 'textures/compressed/disturb_dx10_bc6h_unsigned_mip.dds' );\n\t\t\t\tmap10.anisotropy = 4;\n\n\t\t\t\tconst map11 = loader.load( 'textures/wave_normals_24bit_uncompressed.dds' );\n\t\t\t\tmap11.anisotropy = 4;\n\n\t\t\t\tconst cubemap1 = loader.load( 'textures/compressed/Mountains.dds', function ( texture ) {\n\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tmaterial1.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst cubemap2 = loader.load( 'textures/compressed/Mountains_argb_mip.dds', function ( texture ) {\n\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tmaterial5.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst cubemap3 = loader.load( 'textures/compressed/Mountains_argb_nomip.dds', function ( texture ) {\n\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tmaterial6.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { map: map1, envMap: cubemap1 } );\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: map2 } );\n\t\t\t\tconst material3 = new THREE.MeshBasicMaterial( { map: map3, alphaTest: 0.5, side: THREE.DoubleSide } );\n\t\t\t\tconst material4 = new THREE.MeshBasicMaterial( { map: map4, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );\n\t\t\t\tconst material5 = new THREE.MeshBasicMaterial( { envMap: cubemap2 } );\n\t\t\t\tconst material6 = new THREE.MeshBasicMaterial( { envMap: cubemap3 } );\n\t\t\t\tconst material7 = new THREE.MeshBasicMaterial( { map: map5 } );\n\t\t\t\tconst material8 = new THREE.MeshBasicMaterial( { map: map6 } );\n\t\t\t\tconst material9 = new THREE.MeshBasicMaterial( { map: map7 } );\n\t\t\t\tconst material10 = new THREE.MeshBasicMaterial( { map: map8 } );\n\t\t\t\tconst material11 = new THREE.MeshBasicMaterial( { map: map9 } );\n\t\t\t\tconst material12 = new THREE.MeshBasicMaterial( { map: map10 } );\n\t\t\t\tconst material13 = new THREE.MeshBasicMaterial( { map: map11, transparent: true } );\n\n\t\t\t\tlet mesh = new THREE.Mesh( new THREE.TorusGeometry(), material1 );\n\t\t\t\tmesh.position.x = - 10;\n\t\t\t\tmesh.position.y = - 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh.position.x = - 6;\n\t\t\t\tmesh.position.y = - 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material3 );\n\t\t\t\tmesh.position.x = - 6;\n\t\t\t\tmesh.position.y = 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material4 );\n\t\t\t\tmesh.position.x = - 10;\n\t\t\t\tmesh.position.y = 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material5 );\n\t\t\t\tmesh.position.x = - 2;\n\t\t\t\tmesh.position.y = 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material6 );\n\t\t\t\tmesh.position.x = - 2;\n\t\t\t\tmesh.position.y = - 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material7 );\n\t\t\t\tmesh.position.x = 2;\n\t\t\t\tmesh.position.y = - 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material8 );\n\t\t\t\tmesh.position.x = 2;\n\t\t\t\tmesh.position.y = 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material9 );\n\t\t\t\tmesh.position.x = 6;\n\t\t\t\tmesh.position.y = - 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material10 );\n\t\t\t\tmesh.position.x = 6;\n\t\t\t\tmesh.position.y = 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material11 );\n\t\t\t\tmesh.position.x = 10;\n\t\t\t\tmesh.position.y = - 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material12 );\n\t\t\t\tmesh.position.x = 10;\n\t\t\t\tmesh.position.y = 2;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material13 );\n\t\t\t\tmesh.position.x = - 10;\n\t\t\t\tmesh.position.y = - 6;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\t\tmesh.rotation.x = time;\n\t\t\t\t\tmesh.rotation.y = time;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl - compressed textures leaf texture by lauris71 , explosion texture by bart"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - EXR texture loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - EXR texture loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n\n\t\t\tconst params = {\n\t\t\t\texposure: 2.0\n\t\t\t};\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 1 );\n\n\t\t\t\tnew EXRLoader()\n\t\t\t\t\t.load( 'textures/memorial.exr', function ( texture, textureData ) {\n\n\t\t\t\t\t\t// memorial.exr is NPOT\n\n\t\t\t\t\t\t//console.log( textureData );\n\t\t\t\t\t\t//console.log( texture );\n\n\t\t\t\t\t\t// EXRLoader sets these default settings\n\t\t\t\t\t\t//texture.generateMipmaps = false;\n\t\t\t\t\t\t//texture.minFilter = LinearFilter;\n\t\t\t\t\t\t//texture.magFilter = LinearFilter;\n\n\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\t\tconst quad = new THREE.PlaneGeometry( 1.5 * textureData.width / textureData.height, 1.5 );\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( quad, material );\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'exposure', 0, 4, 0.01 ).onChange( render );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl EXR texture loader example Image courtesy of Paul Debevec ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - UltraHDR texture loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - UltraHDR texture loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tconst params = {\n\t\t\t\tautoRotate: true,\n\t\t\t\tmetalness: 1.0,\n\t\t\t\troughness: 0.0,\n\t\t\t\texposure: 1.0,\n\t\t\t\tresolution: '2k',\n\t\t\t\ttype: 'HalfFloatType'\n\t\t\t};\n\n\t\t\tlet renderer, scene, camera, controls, torusMesh, loader;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\trenderer.setAnimationLoop( render );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\ttorusMesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.4, 128, 128, 1, 3 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( { roughness: params.roughness, metalness: params.metalness } )\n\t\t\t\t );\n\t\t\t\tscene.add( torusMesh );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t50,\n\t\t\t\t\twindow.innerWidth / window.innerHeight,\n\t\t\t\t\t1,\n\t\t\t\t\t500\n\t\t\t\t);\n\t\t\t\tcamera.position.set( 0.0, 0.0, - 6.0 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\n\t\t\t\tloader = new UltraHDRLoader();\n\t\t\t\tloader.setDataType( THREE.FloatType );\n\n\t\t\t\tconst loadEnvironment = function ( resolution = '2k', type = 'HalfFloatType' ) {\n\n\t\t\t\t\tloader.setDataType( THREE[ type ] );\n\n\t\t\t\t\tloader.load( `textures/equirectangular/spruit_sunrise_${resolution}.hdr.jpg`, function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t} );\n\n\t\t\t\t};\n\n\t\t\t\tloadEnvironment( params.resolution, params.type );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'autoRotate' );\n\t\t\t\tgui.add( params, 'metalness', 0, 1, 0.01 );\n\t\t\t\tgui.add( params, 'roughness', 0, 1, 0.01 );\n\t\t\t\tgui.add( params, 'exposure', 0, 4, 0.01 );\n\t\t\t\tgui.add( params, 'resolution', [ '2k', '4k' ] ).onChange( ( value ) => {\n\n\t\t\t\t\tloadEnvironment( value, params.type );\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'type', [ 'HalfFloatType', 'FloatType' ] ).onChange( ( value ) => {\n\n\t\t\t\t\tloadEnvironment( params.resolution, value );\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttorusMesh.material.roughness = params.roughness;\n\t\t\t\ttorusMesh.material.metalness = params.metalness;\n\n\t\t\t\tif ( params.autoRotate ) {\n\n\t\t\t\t\ttorusMesh.rotation.y += 0.005;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - UltraHDR texture loader Converted from hdr with converter ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - HDR texture loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - HDR texture loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tconst params = {\n\t\t\t\texposure: 2.0\n\t\t\t};\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 1 );\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.load( 'textures/memorial.hdr', function ( texture, textureData ) {\n\n\t\t\t\t\t\t//console.log( textureData );\n\t\t\t\t\t\t//console.log( texture );\n\n\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\t\tconst quad = new THREE.PlaneGeometry( 1.5 * textureData.width / textureData.height, 1.5 );\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( quad, material );\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'exposure', 0, 4, 0.01 ).onChange( render );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl HDR (RGBE) texture loader example Image courtesy of Paul Debevec ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - compressed textures"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - compressed textures:\n\n```javascript\nimport * as THREE from 'three';\n\n\timport { KTXLoader } from 'three/addons/loaders/KTXLoader.js';\n\n\t/*\n\tThis is how compressed textures are supposed to be used:\n\n\tbest for desktop:\n\tBC1(DXT1) - opaque textures\n\tBC3(DXT5) - transparent textures with full alpha range\n\n\tbest for iOS:\n\tPVR2, PVR4 - opaque textures or alpha\n\n\tbest for Android:\n\tETC1 - opaque textures\n\tASTC_4x4, ASTC8x8 - transparent textures with full alpha range\n\t*/\n\n\tlet camera, scene, renderer;\n\tconst meshes = [];\n\n\tinit();\n\n\tfunction init() {\n\n\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\trenderer.setAnimationLoop( animate );\n\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\tconst formats = {\n\t\t\tastc: renderer.extensions.has( 'WEBGL_compressed_texture_astc' ),\n\t\t\tetc1: renderer.extensions.has( 'WEBGL_compressed_texture_etc1' ),\n\t\t\ts3tc: renderer.extensions.has( 'WEBGL_compressed_texture_s3tc' ),\n\t\t\tpvrtc: renderer.extensions.has( 'WEBGL_compressed_texture_pvrtc' )\n\t\t};\n\n\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\tcamera.position.z = 1000;\n\n\t\tscene = new THREE.Scene();\n\n\t\tconst geometry = new THREE.BoxGeometry( 200, 200, 200 );\n\t\tlet material1, material2;\n\n\t\t// TODO: add cubemap support\n\t\tconst loader = new KTXLoader();\n\n\t\tif ( formats.pvrtc ) {\n\n\t\t\tmaterial1 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/disturb_PVR2bpp.ktx' )\n\t\t\t} );\n\t\t\tmaterial1.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\tmaterial2 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/lensflare_PVR4bpp.ktx' ),\n\t\t\t\tdepthTest: false,\n\t\t\t\ttransparent: true,\n\t\t\t\tside: THREE.DoubleSide\n\t\t\t} );\n\t\t\tmaterial2.map.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material1 ) );\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material2 ) );\n\n\t\t}\n\n\t\tif ( formats.s3tc ) {\n\n\t\t\tmaterial1 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/disturb_BC1.ktx' )\n\t\t\t} );\n\t\t\tmaterial1.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\tmaterial2 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/lensflare_BC3.ktx' ),\n\t\t\t\tdepthTest: false,\n\t\t\t\ttransparent: true,\n\t\t\t\tside: THREE.DoubleSide\n\t\t\t} );\n\t\t\tmaterial2.map.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material1 ) );\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material2 ) );\n\n\t\t}\n\n\t\tif ( formats.etc1 ) {\n\n\t\t\tmaterial1 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/disturb_ETC1.ktx' )\n\t\t\t} );\n\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material1 ) );\n\n\t\t}\n\n\t\tif ( formats.astc ) {\n\n\t\t\tmaterial1 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/disturb_ASTC4x4.ktx' )\n\t\t\t} );\n\t\t\tmaterial1.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\tmaterial2 = new THREE.MeshBasicMaterial( {\n\t\t\t\tmap: loader.load( 'textures/compressed/lensflare_ASTC8x8.ktx' ),\n\t\t\t\tdepthTest: false,\n\t\t\t\ttransparent: true,\n\t\t\t\tside: THREE.DoubleSide\n\t\t\t} );\n\t\t\tmaterial2.map.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material1 ) );\n\t\t\tmeshes.push( new THREE.Mesh( geometry, material2 ) );\n\n\t\t}\n\n\t\tlet x = - meshes.length / 2 * 150;\n\t\tfor ( let i = 0; i < meshes.length; ++ i, x += 300 ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tmesh.position.x = x;\n\t\t\tmesh.position.y = 0;\n\t\t\tscene.add( mesh );\n\n\t\t}\n\n\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t}\n\n\tfunction onWindowResize() {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}\n\n\tfunction animate() {\n\n\t\tconst time = Date.now() * 0.001;\n\n\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tmesh.rotation.x = time;\n\t\t\tmesh.rotation.y = time;\n\n\t\t}\n\n\t\trenderer.render( scene, camera );\n\n\t}\n```\n\nThis example three.js - webgl - compressed KTX textures Khronos Texture is a lightweight file format for OpenGL"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - KTX2 texture loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - KTX2 texture loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\n\t\t\tlet canvas, renderer;\n\n\t\t\tconst scenes = [];\n\n\t\t\tconst sections = [\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Uncompressed',\n\t\t\t\t\tdescription: 'Uncompressed formats (rgba8, rgba16, rgba32) load as THREE.DataTexture objects.'\n\t\t\t\t\t\t+ ' Lossless, easy to read/write, uncompressed on GPU, optionally compressed over the network.',\n\t\t\t\t\ttextures: [\n\t\t\t\t\t\t{ path: '2d_rgba8.ktx2' },\n\t\t\t\t\t\t{ path: '2d_rgba8_linear.ktx2' },\n\t\t\t\t\t\t{ path: '2d_rgba16_linear.ktx2' },\n\t\t\t\t\t\t{ path: '2d_rgba32_linear.ktx2' },\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Compressed',\n\t\t\t\t\tdescription: 'Compressed formats (ASTC, BCn, ...) load as THREE.CompressedTexture objects,'\n\t\t\t\t\t\t+ ' reducing memory cost. Requires native support on the device GPU: no single compressed'\n\t\t\t\t\t\t+ ' format is supported on every device.',\n\t\t\t\t\ttextures: [\n\t\t\t\t\t\t{ path: '2d_astc4x4.ktx2' },\n\t\t\t\t\t\t{ path: '2d_etc1.ktx2' },\n\t\t\t\t\t\t{ path: '2d_etc2.ktx2' },\n\t\t\t\t\t\t{ path: '2d_bc1.ktx2' },\n\t\t\t\t\t\t{ path: '2d_bc3.ktx2' },\n\t\t\t\t\t\t// { path: '2d_bc5.ktx2' },\n\t\t\t\t\t\t{ path: '2d_bc7.ktx2' },\n\t\t\t\t\t]\n\t\t\t\t},\n\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Universal',\n\t\t\t\t\tdescription: 'Basis Universal textures are specialized intermediate formats supporting fast'\n\t\t\t\t\t\t+ ' runtime transcoding into other GPU texture compression formats. After transcoding,'\n\t\t\t\t\t\t+ ' universal textures can be used on any device at reduced memory cost.',\n\t\t\t\t\ttextures: [\n\t\t\t\t\t\t{ path: '2d_etc1s.ktx2' },\n\t\t\t\t\t\t{ path: '2d_uastc.ktx2' },\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t]\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcanvas = document.getElementById( 'c' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { canvas, antialias: true } );\n\t\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\n\t\t\t\tconst loader = new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.setPath( 'textures/ktx2/' )\n\t\t\t\t\t.detectSupport( renderer );\n\n\t\t\t\tconst geometry = flipY( new THREE.PlaneGeometry( 1, 1 ) );\n\n\t\t\t\tconst content = document.getElementById( 'content' );\n\n\t\t\t\tfor ( const section of sections ) {\n\n\t\t\t\t\tconst sectionElement = document.createElement( 'section' );\n\n\t\t\t\t\tconst sectionHeader = document.createElement( 'h2' );\n\t\t\t\t\tsectionHeader.textContent = section.title;\n\t\t\t\t\tsectionElement.appendChild( sectionHeader );\n\n\t\t\t\t\tconst sectionDescription = document.createElement( 'p' );\n\t\t\t\t\tsectionDescription.className = 'description';\n\t\t\t\t\tsectionDescription.textContent = section.description;\n\t\t\t\t\tsectionElement.appendChild( sectionDescription );\n\n\t\t\t\t\tfor ( const { path, supported } of section.textures ) {\n\n\t\t\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\t\t\t// make a list item\n\t\t\t\t\t\tconst element = document.createElement( 'div' );\n\t\t\t\t\t\telement.className = 'list-item';\n\n\t\t\t\t\t\tconst sceneElement = document.createElement( 'div' );\n\t\t\t\t\t\telement.appendChild( sceneElement );\n\n\t\t\t\t\t\tconst labelElement = document.createElement( 'div' );\n\t\t\t\t\t\tlabelElement.innerText = 'file: ' + path;\n\t\t\t\t\t\telement.appendChild( labelElement );\n\n\t\t\t\t\t\t// the element that represents the area we want to render the scene\n\t\t\t\t\t\tscene.userData.element = sceneElement;\n\t\t\t\t\t\tsectionElement.appendChild( element );\n\n\t\t\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, 1, 1, 10 );\n\t\t\t\t\t\tcamera.position.z = 2;\n\t\t\t\t\t\tscene.userData.camera = camera;\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tconst texture = await loader.loadAsync( supported === false ? 'fail_load.ktx2' : path );\n\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({ map: texture }) );\n\n\t\t\t\t\t\t\tlabelElement.innerText += '\\ncolorSpace: ' + texture.colorSpace;\n\n\t\t\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\t\t\tscenes.push( scene );\n\n\t\t\t\t\t\t} catch (e) {\n\n\t\t\t\t\t\t\tconsole.error( `Failed to load ${path}`, e );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent.appendChild( sectionElement );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\n\t\t\t}\n\n\t\t\tfunction updateSize() {\n\n\t\t\t\tconst width = canvas.clientWidth;\n\t\t\t\tconst height = canvas.clientHeight;\n\n\t\t\t\tif ( canvas.width !== width || canvas.height !== height ) {\n\n\t\t\t\t\trenderer.setSize( width, height, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/** Rewrite UVs for `flipY=false` textures. */\n\t\t\tfunction flipY( geometry ) {\n\n\t\t\t\tconst uv = geometry.attributes.uv;\n\n\t\t\t\tfor ( let i = 0; i < uv.count; i ++ ) {\n\n\t\t\t\t\tuv.setY( i, 1 - uv.getY( i ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tupdateSize();\n\n\t\t\t\tcanvas.style.transform = `translateY(${window.scrollY}px)`;\n\n\t\t\t\trenderer.setClearColor( 0xffffff );\n\t\t\t\trenderer.setScissorTest( false );\n\t\t\t\trenderer.clear();\n\n\t\t\t\trenderer.setClearColor( 0xe0e0e0 );\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\tscenes.forEach( function ( scene ) {\n\n\t\t\t\t\t// get the element that is a place holder for where we want to\n\t\t\t\t\t// draw the scene\n\t\t\t\t\tconst element = scene.userData.element;\n\n\t\t\t\t\t// get its position relative to the page's viewport\n\t\t\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\t\t\t// check if it's offscreen. If so skip it\n\t\t\t\t\tif ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||\n\t\t\t\t\t\t rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {\n\n\t\t\t\t\t\treturn; // it's off screen\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// set the viewport\n\t\t\t\t\tconst width = rect.right - rect.left;\n\t\t\t\t\tconst height = rect.bottom - rect.top;\n\t\t\t\t\tconst left = rect.left;\n\t\t\t\t\tconst bottom = renderer.domElement.clientHeight - rect.bottom;\n\n\t\t\t\t\trenderer.setViewport( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissor( left, bottom, width, height );\n\n\t\t\t\t\tconst camera = scene.userData.camera;\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - KTX2 texture loader - webgl"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - lottie loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - lottie loader:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\t\timport { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';\n\t\t\timport { LottieLoader } from 'three/addons/loaders/LottieLoader.js';\n\n\t\t\timport lottie from 'https://cdn.jsdelivr.net/npm/lottie-web@5.12.2/+esm';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.z = 2.5;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x111111 );\n\n\t\t\t\t// lottie\n\n\t\t\t\tconst loader = new THREE.FileLoader();\n\t\t\t\tloader.setResponseType( 'json' );\n\t\t\t\tloader.load( 'textures/lottie/24017-lottie-logo-animation.json', function ( data ) {\n\n\t\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\t\tcontainer.style.width = data.w + 'px';\n\t\t\t\t\tcontainer.style.height = data.h + 'px';\n\t\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t\tconst animation = lottie.loadAnimation( {\n\t\t\t\t\t\tcontainer: container,\n\t\t\t\t\t\tanimType: 'canvas',\n\t\t\t\t\t\tloop: true,\n\t\t\t\t\t\tautoplay: true,\n\t\t\t\t\t\tanimationData: data,\n\t\t\t\t\t\trendererSettings: { dpr: 1 }\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst texture = new THREE.CanvasTexture( animation.container );\n\t\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tanimation.addEventListener( 'enterFrame', function () {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tcontainer.style.display = 'none'; // must be done after loadAnimation() otherwise canvas has 0 dimensions\n\n\t\t\t\t\tsetupControls( animation );\n\n\t\t\t\t\t// texture = new THREE.TextureLoader().load( 'textures/uv_grid_directx.jpg' );\n\t\t\t\t\t// texture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tconst geometry = new RoundedBoxGeometry( 1, 1, 1, 7, 0.2 );\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( { roughness: 0.1, map: texture } );\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction setupControls( animation ) {\n\n\t\t\t\t// Lottie animation API\n\t\t\t\t// https://airbnb.io/lottie/#/web\n\n\t\t\t\t// There are a few undocumented properties:\n\t\t\t\t// console.log( animation );\n\n\t\t\t\tconst scrubber = document.getElementById( 'scrubber' );\n\t\t\t\tscrubber.max = animation.totalFrames;\n\n\t\t\t\tscrubber.addEventListener( 'pointerdown', function () {\n\n\t\t\t\t\tanimation.pause();\n\n\t\t\t\t} );\n\n\t\t\t\tscrubber.addEventListener( 'pointerup', function () {\n\n\t\t\t\t\tanimation.play();\n\n\t\t\t\t} );\n\n\t\t\t\tscrubber.addEventListener( 'input', function () {\n\n\t\t\t\t\tanimation.goToAndStop( parseFloat( scrubber.value ), true );\n\n\t\t\t\t} );\n\n\t\t\t\tanimation.addEventListener( 'enterFrame', function () {\n\n\t\t\t\t\tscrubber.value = animation.currentFrame;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tmesh.rotation.y -= 0.001;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - lottie"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - compressed textures"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - compressed textures:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { PVRLoader } from 'three/addons/loaders/PVRLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tconst meshes = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 200, 200, 200 );\n\n\t\t\t\t//\n\n\t\t\t\tconst onCube1Loaded = function ( texture ) {\n\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tmaterial6.needsUpdate = true;\n\n\t\t\t\t};\n\n\t\t\t\tconst onCube2Loaded = function ( texture ) {\n\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t// texture.minFilter = LinearMipmapNearestFilter;\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tmaterial8.needsUpdate = true;\n\n\t\t\t\t};\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new PVRLoader();\n\n\t\t\t\tconst disturb_4bpp_rgb = loader.load( 'textures/compressed/disturb_4bpp_rgb.pvr' );\n\t\t\t\tconst disturb_4bpp_rgb_v3 = loader.load( 'textures/compressed/disturb_4bpp_rgb_v3.pvr' );\n\t\t\t\tconst disturb_4bpp_rgb_mips = loader.load( 'textures/compressed/disturb_4bpp_rgb_mips.pvr' );\n\t\t\t\tconst disturb_2bpp_rgb = loader.load( 'textures/compressed/disturb_2bpp_rgb.pvr' );\n\t\t\t\tconst flare_4bpp_rgba = loader.load( 'textures/compressed/flare_4bpp_rgba.pvr' );\n\t\t\t\tconst flare_2bpp_rgba = loader.load( 'textures/compressed/flare_2bpp_rgba.pvr' );\n\t\t\t\tconst park3_cube_nomip_4bpp_rgb = loader.load( 'textures/compressed/park3_cube_nomip_4bpp_rgb.pvr', onCube1Loaded );\n\t\t\t\tconst park3_cube_mip_2bpp_rgb_v3 = loader.load( 'textures/compressed/park3_cube_mip_2bpp_rgb_v3.pvr', onCube2Loaded );\n\n\t\t\t\tdisturb_2bpp_rgb.minFilter =\n\t\t\t\tdisturb_2bpp_rgb.magFilter =\n\t\t\t\tflare_4bpp_rgba.minFilter =\n\t\t\t\tflare_4bpp_rgba.magFilter =\n\t\t\t\tdisturb_4bpp_rgb.minFilter =\n\t\t\t\tdisturb_4bpp_rgb.magFilter =\n\t\t\t\tdisturb_4bpp_rgb_v3.minFilter =\n\t\t\t\tdisturb_4bpp_rgb_v3.magFilter =\n\t\t\t\tflare_2bpp_rgba.minFilter =\n\t\t\t\tflare_2bpp_rgba.magFilter = THREE.LinearFilter;\n\n\t\t\t\tdisturb_2bpp_rgb.colorSpace =\n\t\t\t\tflare_4bpp_rgba.colorSpace =\n\t\t\t\tdisturb_4bpp_rgb.colorSpace =\n\t\t\t\tdisturb_4bpp_rgb_v3.colorSpace =\n\t\t\t\tflare_2bpp_rgba.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { map: disturb_4bpp_rgb } );\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: disturb_4bpp_rgb_mips } );\n\t\t\t\tconst material3 = new THREE.MeshBasicMaterial( { map: disturb_2bpp_rgb } );\n\t\t\t\tconst material4 = new THREE.MeshBasicMaterial( { map: flare_4bpp_rgba, side: THREE.DoubleSide, depthTest: false, transparent: true } );\n\t\t\t\tconst material5 = new THREE.MeshBasicMaterial( { map: flare_2bpp_rgba, side: THREE.DoubleSide, depthTest: false, transparent: true } );\n\t\t\t\tconst material6 = new THREE.MeshBasicMaterial( { envMap: park3_cube_nomip_4bpp_rgb } );\n\t\t\t\tconst material8 = new THREE.MeshBasicMaterial( { envMap: park3_cube_mip_2bpp_rgb_v3 } );\n\n\t\t\t\tconst material7 = new THREE.MeshBasicMaterial( { map: disturb_4bpp_rgb_v3 } );\n\n\t\t\t\t//\n\n\t\t\t\tlet mesh = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh.position.x = - 500;\n\t\t\t\tmesh.position.y = 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh.position.x = - 166;\n\t\t\t\tmesh.position.y = 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material3 );\n\t\t\t\tmesh.position.x = 166;\n\t\t\t\tmesh.position.y = 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material7 );\n\t\t\t\tmesh.position.x = 500;\n\t\t\t\tmesh.position.y = 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material4 );\n\t\t\t\tmesh.position.x = - 500;\n\t\t\t\tmesh.position.y = - 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material5 );\n\t\t\t\tmesh.position.x = - 166;\n\t\t\t\tmesh.position.y = - 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tconst torus = new THREE.TorusGeometry( 100, 50, 32, 24 );\n\n\t\t\t\tmesh = new THREE.Mesh( torus, material6 );\n\t\t\t\tmesh.position.x = 166;\n\t\t\t\tmesh.position.y = - 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( torus, material8 );\n\t\t\t\tmesh.position.x = 500;\n\t\t\t\tmesh.position.y = - 200;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\t\tmesh.rotation.x = time;\n\t\t\t\t\tmesh.rotation.y = time;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl - PVR compressed textures"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - RGBM texture loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - RGBM texture loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\n\t\t\tconst params = {\n\t\t\t\texposure: 2.0\n\t\t\t};\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 1 );\n\n\t\t\t\tnew RGBMLoader().setMaxRange( 16 ).load( 'textures/memorial.png', function ( texture ) {\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\tconst quad = new THREE.PlaneGeometry( 1, 1.5 );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( quad, material );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'exposure', 0, 4, 0.01 ).onChange( render );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl RGBM texture loader example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - TGA texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - TGA texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TGALoader } from 'three/addons/loaders/TGALoader.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 1, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new TGALoader();\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\t\t// add box 1 - grey8 texture\n\n\t\t\t\tconst texture1 = loader.load( 'textures/crate_grey8.tga' );\n\t\t\t\ttexture1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst material1 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture1 } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.position.x = - 1;\n\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\t// add box 2 - tga texture\n\n\t\t\t\tconst texture2 = loader.load( 'textures/crate_color8.tga' );\n\t\t\t\ttexture2.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst material2 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture2 } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.position.x = 1;\n\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 1.5 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - TGA texture example by Daosheng Mu"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - materials - TIFF texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - TIFF texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TIFFLoader } from 'three/addons/loaders/TIFFLoader.js';\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( 0, 0, 4 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst loader = new TIFFLoader();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry();\n\n\t\t\t\t// uncompressed\n\n\t\t\t\tloader.load( 'textures/tiff/crate_uncompressed.tif', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( - 1.5, 0, 0 );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t// LZW\n\n\t\t\t\tloader.load( 'textures/tiff/crate_lzw.tif', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( 0, 0, 0 );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t// JPEG\n\n\t\t\t\tloader.load( 'textures/tiff/crate_jpeg.tif', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( 1.5, 0, 0 );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - TIFF texture loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loader - ttf"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loader - ttf:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TTFLoader } from 'three/addons/loaders/TTFLoader.js';\n\t\t\timport { Font } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, cameraTarget, scene, renderer;\n\t\t\tlet group, textMesh1, textMesh2, textGeo, material;\n\t\t\tlet firstLetter = true;\n\n\t\t\tlet text = 'three.js';\n\t\t\tconst depth = 20,\n\t\t\t\tsize = 70,\n\t\t\t\thover = 30,\n\t\t\t\tcurveSegments = 4,\n\t\t\t\tbevelThickness = 2,\n\t\t\t\tbevelSize = 1.5;\n\n\t\t\tlet font = null;\n\t\t\tconst mirror = true;\n\n\t\t\tlet targetRotation = 0;\n\t\t\tlet targetRotationOnPointerDown = 0;\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerXOnPointerDown = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );\n\t\t\t\tcamera.position.set( 0, 400, 700 );\n\n\t\t\t\tcameraTarget = new THREE.Vector3( 0, 150, 0 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x000000 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 250, 1400 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst dirLight1 = new THREE.DirectionalLight( 0xffffff, 0.4 );\n\t\t\t\tdirLight1.position.set( 0, 0, 1 ).normalize();\n\t\t\t\tscene.add( dirLight1 );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0xffffff, 2 );\n\t\t\t\tdirLight2.position.set( 0, hover, 10 ).normalize();\n\t\t\t\tdirLight2.color.setHSL( Math.random(), 1, 0.5, THREE.SRGBColorSpace );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tgroup.position.y = 100;\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst loader = new TTFLoader();\n\n\t\t\t\tloader.load( 'fonts/ttf/kenpixel.ttf', function ( json ) {\n\n\t\t\t\t\tfont = new Font( json );\n\t\t\t\t\tcreateText();\n\n\t\t\t\t} );\n\n\t\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10000, 10000 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )\n\t\t\t\t);\n\t\t\t\tplane.position.y = 100;\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\tdocument.addEventListener( 'keypress', onDocumentKeyPress );\n\t\t\t\tdocument.addEventListener( 'keydown', onDocumentKeyDown );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentKeyDown( event ) {\n\n\t\t\t\tif ( firstLetter ) {\n\n\t\t\t\t\tfirstLetter = false;\n\t\t\t\t\ttext = '';\n\n\t\t\t\t}\n\n\t\t\t\tconst keyCode = event.keyCode;\n\n\t\t\t\t// backspace\n\n\t\t\t\tif ( keyCode === 8 ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\ttext = text.substring( 0, text.length - 1 );\n\t\t\t\t\trefreshText();\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onDocumentKeyPress( event ) {\n\n\t\t\t\tconst keyCode = event.which;\n\n\t\t\t\t// backspace\n\n\t\t\t\tif ( keyCode === 8 ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst ch = String.fromCharCode( keyCode );\n\t\t\t\t\ttext += ch;\n\n\t\t\t\t\trefreshText();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createText() {\n\n\t\t\t\ttextGeo = new TextGeometry( text, {\n\n\t\t\t\t\tfont: font,\n\n\t\t\t\t\tsize: size,\n\t\t\t\t\tdepth: depth,\n\t\t\t\t\tcurveSegments: curveSegments,\n\n\t\t\t\t\tbevelThickness: bevelThickness,\n\t\t\t\t\tbevelSize: bevelSize,\n\t\t\t\t\tbevelEnabled: true\n\n\t\t\t\t} );\n\n\t\t\t\ttextGeo.computeBoundingBox();\n\t\t\t\ttextGeo.computeVertexNormals();\n\n\t\t\t\tconst centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );\n\n\t\t\t\ttextMesh1 = new THREE.Mesh( textGeo, material );\n\n\t\t\t\ttextMesh1.position.x = centerOffset;\n\t\t\t\ttextMesh1.position.y = hover;\n\t\t\t\ttextMesh1.position.z = 0;\n\n\t\t\t\ttextMesh1.rotation.x = 0;\n\t\t\t\ttextMesh1.rotation.y = Math.PI * 2;\n\n\t\t\t\tgroup.add( textMesh1 );\n\n\t\t\t\tif ( mirror ) {\n\n\t\t\t\t\ttextMesh2 = new THREE.Mesh( textGeo, material );\n\n\t\t\t\t\ttextMesh2.position.x = centerOffset;\n\t\t\t\t\ttextMesh2.position.y = - hover;\n\t\t\t\t\ttextMesh2.position.z = depth;\n\n\t\t\t\t\ttextMesh2.rotation.x = Math.PI;\n\t\t\t\t\ttextMesh2.rotation.y = Math.PI * 2;\n\n\t\t\t\t\tgroup.add( textMesh2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction refreshText() {\n\n\t\t\t\tgroup.remove( textMesh1 );\n\t\t\t\tif ( mirror ) group.remove( textMesh2 );\n\n\t\t\t\tif ( ! text ) return;\n\n\t\t\t\tcreateText();\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerXOnPointerDown = event.clientX - windowHalfX;\n\t\t\t\ttargetRotationOnPointerDown = targetRotation;\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointerX = event.clientX - windowHalfX;\n\n\t\t\t\ttargetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tdocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tgroup.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( cameraTarget );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - TTFLoader using opentype by gero3 type to enter new text, drag to spin the text"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - USDZLoader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - USDZLoader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { USDZLoader } from 'three/addons/loaders/USDZLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0.75, - 1.5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst usdzLoader = new USDZLoader()\n\t\t\t\t\t.setPath( 'models/usdz/' );\n\n\t\t\t\tconst [ texture, model ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'venice_sunset_1k.hdr' ),\n\t\t\t\t\tusdzLoader.loadAsync( 'saeukkang.usdz' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tmodel.position.y = 0.25;\n\t\t\t\tmodel.position.z = - 0.25;\n\t\t\t\tscene.add( model );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 2.0;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 8;\n\t\t\t\t// controls.target.y = 15;\n\t\t\t\t// controls.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - USDZLoader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - vox"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - vox:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';\n\n\t\t\tlet camera, controls, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( 0.175, 0.075, 0.175 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// light\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xcccccc, 0x444444, 3 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\t\tdirLight.position.set( 1.5, 3, 2.5 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tdirLight2.position.set( - 1.5, - 3, - 2.5 );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tconst loader = new VOXLoader();\n\t\t\t\tloader.load( 'models/vox/monu10.vox', function ( chunks ) {\n\n\t\t\t\t\tfor ( let i = 0; i < chunks.length; i ++ ) {\n\n\t\t\t\t\t\tconst chunk = chunks[ i ];\n\n\t\t\t\t\t\t// displayPalette( chunk.palette );\n\n\t\t\t\t\t\tconst mesh = new VOXMesh( chunk );\n\t\t\t\t\t\tmesh.scale.setScalar( 0.0015 );\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = .1;\n\t\t\t\tcontrols.maxDistance = 0.5;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfunction displayPalette( palette ) {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 8;\n\t\t\t\tcanvas.height = 32;\n\t\t\t\tcanvas.style.position = 'absolute';\n\t\t\t\tcanvas.style.top = '0';\n\t\t\t\tcanvas.style.width = '100px';\n\t\t\t\tcanvas.style.imageRendering = 'pixelated';\n\t\t\t\tdocument.body.appendChild( canvas );\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\n\t\t\t\tfor ( let c = 0; c < 256; c ++ ) {\n\n\t\t\t\t\tconst x = c % 8;\n\t\t\t\t\tconst y = Math.floor( c / 8 );\n\n\t\t\t\t\tconst hex = palette[ c + 1 ];\n\t\t\t\t\tconst r = hex >> 0 & 0xff;\n\t\t\t\t\tconst g = hex >> 8 & 0xff;\n\t\t\t\t\tconst b = hex >> 16 & 0xff;\n\t\t\t\t\tcontext.fillStyle = `rgba(${r},${g},${b},1)`;\n\t\t\t\t\tcontext.fillRect( x, 31 - y, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t*/\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - vox loader ( Magica Voxel )"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - VRML loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - VRML loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VRMLLoader } from 'three/addons/loaders/VRMLLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats, controls, loader;\n\n\t\t\tconst params = {\n\t\t\t\tasset: 'house'\n\t\t\t};\n\n\t\t\tconst assets = [\n\t\t\t\t'creaseAngle',\n\t\t\t\t'crystal',\n\t\t\t\t'house',\n\t\t\t\t'elevationGrid1',\n\t\t\t\t'elevationGrid2',\n\t\t\t\t'extrusion1',\n\t\t\t\t'extrusion2',\n\t\t\t\t'extrusion3',\n\t\t\t\t'lines',\n\t\t\t\t'linesTransparent',\n\t\t\t\t'meshWithLines',\n\t\t\t\t'meshWithTexture',\n\t\t\t\t'pixelTexture',\n\t\t\t\t'points',\n\t\t\t];\n\n\t\t\tlet vrmlScene;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1e10 );\n\t\t\t\tcamera.position.set( - 10, 5, 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// light\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 1.2 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 2.0 );\n\t\t\t\tdirLight.position.set( 200, 200, 200 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tloader = new VRMLLoader();\n\t\t\t\tloadAsset( params.asset );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 200;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'asset', assets ).onChange( function ( value ) {\n\n\t\t\t\t\tif ( vrmlScene ) {\n\n\t\t\t\t\t\tvrmlScene.traverse( function ( object ) {\n\n\t\t\t\t\t\t\tif ( object.material ) object.material.dispose();\n\t\t\t\t\t\t\tif ( object.material && object.material.map ) object.material.map.dispose();\n\t\t\t\t\t\t\tif ( object.geometry ) object.geometry.dispose();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tscene.remove( vrmlScene );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tloadAsset( value );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction loadAsset( asset ) {\n\n\t\t\t\tloader.load( 'models/vrml/' + asset + '.wrl', function ( object ) {\n\n\t\t\t\t\tvrmlScene = object;\n\t\t\t\t\tscene.add( object );\n\t\t\t\t\tcontrols.reset();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update(); // to support damping\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - VRML loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - vtk loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - vtk loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { VTKLoader } from 'three/addons/loaders/VTKLoader.js';\n\n\t\t\tlet stats;\n\n\t\t\tlet camera, controls, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 0.2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// light\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x000000, 3 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tdirLight.position.set( 2, 2, 2 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst loader = new VTKLoader();\n\t\t\t\tloader.load( 'models/vtk/bunny.vtk', function ( geometry ) {\n\n\t\t\t\t\tgeometry.center();\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xffffff } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( - 0.075, 0.005, 0 );\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.2 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\tconst loader1 = new VTKLoader();\n\t\t\t\tloader1.load( 'models/vtk/cube_ascii.vtp', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0x00ff00 } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.set( - 0.025, 0, 0 );\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.01 );\n\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\tconst loader2 = new VTKLoader();\n\t\t\t\tloader2.load( 'models/vtk/cube_binary.vtp', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0x0000ff } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.set( 0.025, 0, 0 );\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.01 );\n\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\tconst loader3 = new VTKLoader();\n\t\t\t\tloader3.load( 'models/vtk/cube_no_compression.vtp', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xff0000 } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.set( 0.075, 0, 0 );\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.01 );\n\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = .1;\n\t\t\t\tcontrols.maxDistance = 0.5;\n\t\t\t\tcontrols.rotateSpeed = 5.0;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - vtk formats loader test Legacy vtk model from The GeorgiaTech Lagre Geometric Model Archive"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_loaders example that demonstrates webgl - loaders - XYZ"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - loaders - XYZ:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { XYZLoader } from 'three/addons/loaders/XYZLoader.js';\n\n\t\t\tlet camera, scene, renderer, clock;\n\n\t\t\tlet points;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 10, 7, 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( camera );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst loader = new XYZLoader();\n\t\t\t\tloader.load( 'models/xyz/helix_201.xyz', function ( geometry ) {\n\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tconst vertexColors = ( geometry.hasAttribute( 'color' ) === true );\n\n\t\t\t\t\tconst material = new THREE.PointsMaterial( { size: 0.1, vertexColors: vertexColors } );\n\n\t\t\t\t\tpoints = new THREE.Points( geometry, material );\n\t\t\t\t\tscene.add( points );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( points ) {\n\n\t\t\t\t\tpoints.rotation.x += delta * 0.2;\n\t\t\t\t\tpoints.rotation.y += delta * 0.5;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - XYZ loader asset from people.math.sc.edu via GNU LGPL"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - level of detail"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - level of detail:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { FlyControls } from 'three/addons/controls/FlyControls.js';\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 15000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1, 15000 );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xff2200, 3, 0, 0 );\n\t\t\t\tpointLight.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 0, 0, 1 ).normalize();\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst geometry = [\n\n\t\t\t\t\t[ new THREE.IcosahedronGeometry( 100, 16 ), 50 ],\n\t\t\t\t\t[ new THREE.IcosahedronGeometry( 100, 8 ), 300 ],\n\t\t\t\t\t[ new THREE.IcosahedronGeometry( 100, 4 ), 1000 ],\n\t\t\t\t\t[ new THREE.IcosahedronGeometry( 100, 2 ), 2000 ],\n\t\t\t\t\t[ new THREE.IcosahedronGeometry( 100, 1 ), 8000 ]\n\n\t\t\t\t];\n\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: true } );\n\n\t\t\t\tfor ( let j = 0; j < 1000; j ++ ) {\n\n\t\t\t\t\tconst lod = new THREE.LOD();\n\n\t\t\t\t\tfor ( let i = 0; i < geometry.length; i ++ ) {\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry[ i ][ 0 ], material );\n\t\t\t\t\t\tmesh.scale.set( 1.5, 1.5, 1.5 );\n\t\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\t\tlod.addLevel( mesh, geometry[ i ][ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlod.position.x = 10000 * ( 0.5 - Math.random() );\n\t\t\t\t\tlod.position.y = 7500 * ( 0.5 - Math.random() );\n\t\t\t\t\tlod.position.z = 10000 * ( 0.5 - Math.random() );\n\t\t\t\t\tlod.updateMatrix();\n\t\t\t\t\tlod.matrixAutoUpdate = false;\n\t\t\t\t\tscene.add( lod );\n\n\t\t\t\t}\n\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new FlyControls( camera, renderer.domElement );\n\t\t\t\tcontrols.movementSpeed = 1000;\n\t\t\t\tcontrols.rollSpeed = Math.PI / 10;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update( clock.getDelta() );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - level of detail"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - marching cubes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - marching cubes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';\n\t\timport { ToonShader1, ToonShader2, ToonShaderHatching, ToonShaderDotted } from 'three/addons/shaders/ToonShader.js';\n\n\t\tlet container, stats;\n\n\t\tlet camera, scene, renderer;\n\n\t\tlet materials, current_material;\n\n\t\tlet light, pointLight, ambientLight;\n\n\t\tlet effect, resolution;\n\n\t\tlet effectController;\n\n\t\tlet time = 0;\n\n\t\tconst clock = new THREE.Clock();\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t// CAMERA\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\tcamera.position.set( - 500, 500, 1500 );\n\n\t\t\t// SCENE\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x050505 );\n\n\t\t\t// LIGHTS\n\n\t\t\tlight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tlight.position.set( 0.5, 0.5, 1 );\n\t\t\tscene.add( light );\n\n\t\t\tpointLight = new THREE.PointLight( 0xff7c00, 3, 0, 0 );\n\t\t\tpointLight.position.set( 0, 0, 100 );\n\t\t\tscene.add( pointLight );\n\n\t\t\tambientLight = new THREE.AmbientLight( 0x323232, 3 );\n\t\t\tscene.add( ambientLight );\n\n\t\t\t// MATERIALS\n\n\t\t\tmaterials = generateMaterials();\n\t\t\tcurrent_material = 'shiny';\n\n\t\t\t// MARCHING CUBES\n\n\t\t\tresolution = 28;\n\n\t\t\teffect = new MarchingCubes( resolution, materials[ current_material ], true, true, 100000 );\n\t\t\teffect.position.set( 0, 0, 0 );\n\t\t\teffect.scale.set( 700, 700, 700 );\n\n\t\t\teffect.enableUvs = false;\n\t\t\teffect.enableColors = false;\n\n\t\t\tscene.add( effect );\n\n\t\t\t// RENDERER\n\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t// CONTROLS\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.minDistance = 500;\n\t\t\tcontrols.maxDistance = 5000;\n\n\t\t\t// STATS\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t// GUI\n\n\t\t\tsetupGui();\n\n\t\t\t// EVENTS\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction generateMaterials() {\n\n\t\t\t// environment map\n\n\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\tconst format = '.jpg';\n\t\t\tconst urls = [\n\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t];\n\n\t\t\tconst cubeTextureLoader = new THREE.CubeTextureLoader();\n\n\t\t\tconst reflectionCube = cubeTextureLoader.load( urls );\n\t\t\tconst refractionCube = cubeTextureLoader.load( urls );\n\t\t\trefractionCube.mapping = THREE.CubeRefractionMapping;\n\n\t\t\t// toons\n\n\t\t\tconst toonMaterial1 = createShaderMaterial( ToonShader1, light, ambientLight );\n\t\t\tconst toonMaterial2 = createShaderMaterial( ToonShader2, light, ambientLight );\n\t\t\tconst hatchingMaterial = createShaderMaterial( ToonShaderHatching, light, ambientLight );\n\t\t\tconst dottedMaterial = createShaderMaterial( ToonShaderDotted, light, ambientLight );\n\n\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tconst materials = {\n\t\t\t\t'shiny': new THREE.MeshStandardMaterial( { color: 0x9c0000, envMap: reflectionCube, roughness: 0.1, metalness: 1.0 } ),\n\t\t\t\t'chrome': new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: reflectionCube } ),\n\t\t\t\t'liquid': new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: refractionCube, refractionRatio: 0.85 } ),\n\t\t\t\t'matte': new THREE.MeshPhongMaterial( { specular: 0x494949, shininess: 1 } ),\n\t\t\t\t'flat': new THREE.MeshLambertMaterial( { /*TODO flatShading: true */ } ),\n\t\t\t\t'textured': new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shininess: 1, map: texture } ),\n\t\t\t\t'colors': new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0xffffff, shininess: 2, vertexColors: true } ),\n\t\t\t\t'multiColors': new THREE.MeshPhongMaterial( { shininess: 2, vertexColors: true } ),\n\t\t\t\t'plastic': new THREE.MeshPhongMaterial( { specular: 0xc1c1c1, shininess: 250 } ),\n\t\t\t\t'toon1': toonMaterial1,\n\t\t\t\t'toon2': toonMaterial2,\n\t\t\t\t'hatching': hatchingMaterial,\n\t\t\t\t'dotted': dottedMaterial\n\t\t\t};\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction createShaderMaterial( shader, light, ambientLight ) {\n\n\t\t\tconst u = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tconst vs = shader.vertexShader;\n\t\t\tconst fs = shader.fragmentShader;\n\n\t\t\tconst material = new THREE.ShaderMaterial( { uniforms: u, vertexShader: vs, fragmentShader: fs } );\n\n\t\t\tmaterial.uniforms[ 'uDirLightPos' ].value = light.position;\n\t\t\tmaterial.uniforms[ 'uDirLightColor' ].value = light.color;\n\n\t\t\tmaterial.uniforms[ 'uAmbientLightColor' ].value = ambientLight.color;\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setupGui() {\n\n\t\t\tconst createHandler = function ( id ) {\n\n\t\t\t\treturn function () {\n\n\t\t\t\t\tcurrent_material = id;\n\n\t\t\t\t\teffect.material = materials[ id ];\n\t\t\t\t\teffect.enableUvs = ( current_material === 'textured' ) ? true : false;\n\t\t\t\t\teffect.enableColors = ( current_material === 'colors' || current_material === 'multiColors' ) ? true : false;\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\teffectController = {\n\n\t\t\t\tmaterial: 'shiny',\n\n\t\t\t\tspeed: 1.0,\n\t\t\t\tnumBlobs: 10,\n\t\t\t\tresolution: 28,\n\t\t\t\tisolation: 80,\n\n\t\t\t\tfloor: true,\n\t\t\t\twallx: false,\n\t\t\t\twallz: false,\n\n\t\t\t\tdummy: function () {}\n\n\t\t\t};\n\n\t\t\tlet h;\n\n\t\t\tconst gui = new GUI();\n\n\t\t\t// material (type)\n\n\t\t\th = gui.addFolder( 'Materials' );\n\n\t\t\tfor ( const m in materials ) {\n\n\t\t\t\teffectController[ m ] = createHandler( m );\n\t\t\t\th.add( effectController, m ).name( m );\n\n\t\t\t}\n\n\t\t\t// simulation\n\n\t\t\th = gui.addFolder( 'Simulation' );\n\n\t\t\th.add( effectController, 'speed', 0.1, 8.0, 0.05 );\n\t\t\th.add( effectController, 'numBlobs', 1, 50, 1 );\n\t\t\th.add( effectController, 'resolution', 14, 100, 1 );\n\t\t\th.add( effectController, 'isolation', 10, 300, 1 );\n\n\t\t\th.add( effectController, 'floor' );\n\t\t\th.add( effectController, 'wallx' );\n\t\t\th.add( effectController, 'wallz' );\n\n\t\t}\n\n\t\t// this controls content of marching cubes voxel field\n\n\t\tfunction updateCubes( object, time, numblobs, floor, wallx, wallz ) {\n\n\t\t\tobject.reset();\n\n\t\t\t// fill the field with some metaballs\n\n\t\t\tconst rainbow = [\n\t\t\t\tnew THREE.Color( 0xff0000 ),\n\t\t\t\tnew THREE.Color( 0xffbb00 ),\n\t\t\t\tnew THREE.Color( 0xffff00 ),\n\t\t\t\tnew THREE.Color( 0x00ff00 ),\n\t\t\t\tnew THREE.Color( 0x0000ff ),\n\t\t\t\tnew THREE.Color( 0x9400bd ),\n\t\t\t\tnew THREE.Color( 0xc800eb )\n\t\t\t];\n\t\t\tconst subtract = 12;\n\t\t\tconst strength = 1.2 / ( ( Math.sqrt( numblobs ) - 1 ) / 4 + 1 );\n\n\t\t\tfor ( let i = 0; i < numblobs; i ++ ) {\n\n\t\t\t\tconst ballx = Math.sin( i + 1.26 * time * ( 1.03 + 0.5 * Math.cos( 0.21 * i ) ) ) * 0.27 + 0.5;\n\t\t\t\tconst bally = Math.abs( Math.cos( i + 1.12 * time * Math.cos( 1.22 + 0.1424 * i ) ) ) * 0.77; // dip into the floor\n\t\t\t\tconst ballz = Math.cos( i + 1.32 * time * 0.1 * Math.sin( ( 0.92 + 0.53 * i ) ) ) * 0.27 + 0.5;\n\n\t\t\t\tif ( current_material === 'multiColors' ) {\n\n\t\t\t\t\tobject.addBall( ballx, bally, ballz, strength, subtract, rainbow[ i % 7 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.addBall( ballx, bally, ballz, strength, subtract );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( floor ) object.addPlaneY( 2, 12 );\n\t\t\tif ( wallz ) object.addPlaneZ( 2, 12 );\n\t\t\tif ( wallx ) object.addPlaneX( 2, 12 );\n\n\t\t\tobject.update();\n\n\t\t}\n\n\t\t//\n\n\t\tfunction animate() {\n\n\t\t\trender();\n\t\t\tstats.update();\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\tconst delta = clock.getDelta();\n\n\t\t\ttime += delta * effectController.speed * 0.5;\n\n\t\t\t// marching cubes\n\n\t\t\tif ( effectController.resolution !== resolution ) {\n\n\t\t\t\tresolution = effectController.resolution;\n\t\t\t\teffect.init( Math.floor( resolution ) );\n\n\t\t\t}\n\n\t\t\tif ( effectController.isolation !== effect.isolation ) {\n\n\t\t\t\teffect.isolation = effectController.isolation;\n\n\t\t\t}\n\n\t\t\tupdateCubes( effect, time, effectController.numBlobs, effectController.floor, effectController.wallx, effectController.wallz );\n\n\t\t\t// render\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js - marching cubes based on greggman's blob , original code by Henrik Rydg\u00e5rd"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - alpha hash"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - alpha hash:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, controls, stats, mesh, material;\n\n\t\t\tlet composer, renderPass, taaRenderPass, outputPass;\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tconst amount = parseInt( window.location.search.slice( 1 ) ) || 3;\n\t\t\tconst count = Math.pow( amount, 3 );\n\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tconst params = {\n\t\t\t\talpha: 0.5,\n\t\t\t\talphaHash: true,\n\t\t\t\ttaa: true,\n\t\t\t\tsampleLevel: 2,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( amount, amount, amount );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 0.5, 3 );\n\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\talphaHash: params.alphaHash,\n\t\t\t\t\topacity: params.alpha\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, count );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst offset = ( amount - 1 ) / 2;\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tfor ( let x = 0; x < amount; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < amount; y ++ ) {\n\n\t\t\t\t\t\tfor ( let z = 0; z < amount; z ++ ) {\n\n\t\t\t\t\t\t\tmatrix.setPosition( offset - x, offset - y, offset - z );\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, matrix );\n\t\t\t\t\t\t\tmesh.setColorAt( i, color.setHex( Math.random() * 0xffffff ) );\n\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\t\t\t\tenvironment.dispose();\n\n\t\t\t\t//\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\trenderPass = new RenderPass( scene, camera );\n\t\t\t\trenderPass.enabled = false;\n\n\t\t\t\ttaaRenderPass = new TAARenderPass( scene, camera );\n\n\t\t\t\toutputPass = new OutputPass();\n\n\t\t\t\tcomposer.addPass( renderPass );\n\t\t\t\tcomposer.addPass( taaRenderPass );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\tcontrols.addEventListener( 'change', () => ( needsUpdate = true ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'alpha', 0, 1 ).onChange( onMaterialUpdate );\n\t\t\t\tgui.add( params, 'alphaHash' ).onChange( onMaterialUpdate );\n\n\t\t\t\tconst taaFolder = gui.addFolder( 'Temporal Anti-Aliasing' );\n\n\t\t\t\ttaaFolder.add( params, 'taa' ).name( 'enabled' ).onChange( () => {\n\n\t\t\t\t\trenderPass.enabled = ! params.taa;\n\t\t\t\t\ttaaRenderPass.enabled = params.taa;\n\n\t\t\t\t\tsampleLevelCtrl.enable( params.taa );\n\n\t\t\t\t\tneedsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst sampleLevelCtrl = taaFolder.add( params, 'sampleLevel', 0, 6, 1 ).onChange( () => ( needsUpdate = true ) );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction onMaterialUpdate() {\n\n\t\t\t\tmaterial.opacity = params.alpha;\n\t\t\t\tmaterial.alphaHash = params.alphaHash;\n\t\t\t\tmaterial.transparent = ! params.alphaHash;\n\t\t\t\tmaterial.depthWrite = params.alphaHash;\n\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\ttaaRenderPass.accumulate = false;\n\t\t\t\t\ttaaRenderPass.sampleLevel = 0;\n\n\t\t\t\t\tneedsUpdate = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttaaRenderPass.accumulate = true;\n\t\t\t\t\ttaaRenderPass.sampleLevel = params.sampleLevel;\n\n\t\t\t\t}\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - blending"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - blending:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mapBg;\n\n\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 600;\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// BACKGROUND\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\tcanvas.width = canvas.height = 128;\n\t\t\t\tctx.fillStyle = '#ddd';\n\t\t\t\tctx.fillRect( 0, 0, 128, 128 );\n\t\t\t\tctx.fillStyle = '#555';\n\t\t\t\tctx.fillRect( 0, 0, 64, 64 );\n\t\t\t\tctx.fillStyle = '#999';\n\t\t\t\tctx.fillRect( 32, 32, 32, 32 );\n\t\t\t\tctx.fillStyle = '#555';\n\t\t\t\tctx.fillRect( 64, 64, 64, 64 );\n\t\t\t\tctx.fillStyle = '#777';\n\t\t\t\tctx.fillRect( 96, 96, 32, 32 );\n\n\t\t\t\tmapBg = new THREE.CanvasTexture( canvas );\n\t\t\t\tmapBg.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tmapBg.wrapS = mapBg.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmapBg.repeat.set( 64, 32 );\n\n\t\t\t\tscene.background = mapBg;\n\n\t\t\t\t// OBJECTS\n\n\t\t\t\tconst blendings = [\n\t\t\t\t\t{ name: 'No', constant: THREE.NoBlending },\n\t\t\t\t\t{ name: 'Normal', constant: THREE.NormalBlending },\n\t\t\t\t\t{ name: 'Additive', constant: THREE.AdditiveBlending },\n\t\t\t\t\t{ name: 'Subtractive', constant: THREE.SubtractiveBlending },\n\t\t\t\t\t{ name: 'Multiply', constant: THREE.MultiplyBlending }\n\t\t\t\t];\n\n\t\t\t\tconst assignSRGB = ( texture ) => {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t};\n\n\t\t\t\tconst map0 = textureLoader.load( 'textures/uv_grid_opengl.jpg', assignSRGB );\n\t\t\t\tconst map1 = textureLoader.load( 'textures/sprite0.jpg', assignSRGB );\n\t\t\t\tconst map2 = textureLoader.load( 'textures/sprite0.png', assignSRGB );\n\t\t\t\tconst map3 = textureLoader.load( 'textures/lensflare/lensflare0.png', assignSRGB );\n\t\t\t\tconst map4 = textureLoader.load( 'textures/lensflare/lensflare0_alpha.png', assignSRGB );\n\n\t\t\t\tconst geo1 = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst geo2 = new THREE.PlaneGeometry( 100, 25 );\n\n\t\t\t\taddImageRow( map0, 300 );\n\t\t\t\taddImageRow( map1, 150 );\n\t\t\t\taddImageRow( map2, 0 );\n\t\t\t\taddImageRow( map3, - 150 );\n\t\t\t\taddImageRow( map4, - 300 );\n\n\t\t\t\tfunction addImageRow( map, y ) {\n\n\t\t\t\t\tfor ( let i = 0; i < blendings.length; i ++ ) {\n\n\t\t\t\t\t\tconst blending = blendings[ i ];\n\n\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: map } );\n\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\tmaterial.blending = blending.constant;\n\n\t\t\t\t\t\tmaterial.premultipliedAlpha = true;\n\n\t\t\t\t\t\tconst x = ( i - blendings.length / 2 ) * 110;\n\t\t\t\t\t\tconst z = 0;\n\n\t\t\t\t\t\tlet mesh = new THREE.Mesh( geo1, material );\n\t\t\t\t\t\tmesh.position.set( x, y, z );\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geo2, generateLabelMaterial( blending.name ) );\n\t\t\t\t\t\tmesh.position.set( x, y - 75, z );\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst SCREEN_WIDTH = window.innerWidth;\n\t\t\t\tconst SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\n\t\t\tfunction generateLabelMaterial( text ) {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\tcanvas.width = 128;\n\t\t\t\tcanvas.height = 32;\n\n\t\t\t\tctx.fillStyle = 'rgba( 0, 0, 0, 0.95 )';\n\t\t\t\tctx.fillRect( 0, 0, 128, 32 );\n\n\t\t\t\tctx.fillStyle = 'white';\n\t\t\t\tctx.font = 'bold 12pt arial';\n\t\t\t\tctx.fillText( text, 10, 22 );\n\n\t\t\t\tconst map = new THREE.CanvasTexture( canvas );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: map, transparent: true } );\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.00025;\n\t\t\t\tconst ox = ( time * - 0.01 * mapBg.repeat.x ) % 1;\n\t\t\t\tconst oy = ( time * - 0.01 * mapBg.repeat.y ) % 1;\n\n\t\t\t\tmapBg.offset.set( ox, oy );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - custom blending"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - custom blending:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mapBg;\n\t\t\tconst materials = [];\n\n\t\t\tconst params = {\n\t\t\t\tblendEquation: THREE.AddEquation\n\t\t\t};\n\n\t\t\tconst equations = { Add: THREE.AddEquation, Subtract: THREE.SubtractEquation, ReverseSubtract: THREE.ReverseSubtractEquation, Min: THREE.MinEquation, Max: THREE.MaxEquation };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 700;\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// BACKGROUND\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\tcanvas.width = canvas.height = 128;\n\t\t\t\tctx.fillStyle = '#ddd';\n\t\t\t\tctx.fillRect( 0, 0, 128, 128 );\n\t\t\t\tctx.fillStyle = '#555';\n\t\t\t\tctx.fillRect( 0, 0, 64, 64 );\n\t\t\t\tctx.fillStyle = '#999';\n\t\t\t\tctx.fillRect( 32, 32, 32, 32 );\n\t\t\t\tctx.fillStyle = '#555';\n\t\t\t\tctx.fillRect( 64, 64, 64, 64 );\n\t\t\t\tctx.fillStyle = '#777';\n\t\t\t\tctx.fillRect( 96, 96, 32, 32 );\n\n\t\t\t\tmapBg = new THREE.CanvasTexture( canvas );\n\t\t\t\tmapBg.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tmapBg.wrapS = mapBg.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmapBg.repeat.set( 64, 32 );\n\n\t\t\t\tscene.background = mapBg;\n\n\t\t\t\t// FOREGROUND OBJECTS\n\n\t\t\t\tconst src = [\n\t\t\t\t\t{ name: 'Zero', constant: THREE.ZeroFactor },\n\t\t\t\t\t{ name: 'One', constant: THREE.OneFactor },\n\t\t\t\t\t{ name: 'SrcColor', constant: THREE.SrcColorFactor },\n\t\t\t\t\t{ name: 'OneMinusSrcColor', constant: THREE.OneMinusSrcColorFactor },\n\t\t\t\t\t{ name: 'SrcAlpha', constant: THREE.SrcAlphaFactor },\n\t\t\t\t\t{ name: 'OneMinusSrcAlpha', constant: THREE.OneMinusSrcAlphaFactor },\n\t\t\t\t\t{ name: 'DstAlpha', constant: THREE.DstAlphaFactor },\n\t\t\t\t\t{ name: 'OneMinusDstAlpha', constant: THREE.OneMinusDstAlphaFactor },\n\t\t\t\t\t{ name: 'DstColor', constant: THREE.DstColorFactor },\n\t\t\t\t\t{ name: 'OneMinusDstColor', constant: THREE.OneMinusDstColorFactor },\n\t\t\t\t\t{ name: 'SrcAlphaSaturate', constant: THREE.SrcAlphaSaturateFactor }\n\t\t\t\t];\n\n\t\t\t\tconst dst = [\n\t\t\t\t\t{ name: 'Zero', constant: THREE.ZeroFactor },\n\t\t\t\t\t{ name: 'One', constant: THREE.OneFactor },\n\t\t\t\t\t{ name: 'SrcColor', constant: THREE.SrcColorFactor },\n\t\t\t\t\t{ name: 'OneMinusSrcColor', constant: THREE.OneMinusSrcColorFactor },\n\t\t\t\t\t{ name: 'SrcAlpha', constant: THREE.SrcAlphaFactor },\n\t\t\t\t\t{ name: 'OneMinusSrcAlpha', constant: THREE.OneMinusSrcAlphaFactor },\n\t\t\t\t\t{ name: 'DstAlpha', constant: THREE.DstAlphaFactor },\n\t\t\t\t\t{ name: 'OneMinusDstAlpha', constant: THREE.OneMinusDstAlphaFactor },\n\t\t\t\t\t{ name: 'DstColor', constant: THREE.DstColorFactor },\n\t\t\t\t\t{ name: 'OneMinusDstColor', constant: THREE.OneMinusDstColorFactor }\n\t\t\t\t];\n\n\t\t\t\tconst geo1 = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst geo2 = new THREE.PlaneGeometry( 100, 25 );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/lensflare/lensflare0_alpha.png' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tfor ( let i = 0; i < dst.length; i ++ ) {\n\n\t\t\t\t\tconst blendDst = dst[ i ];\n\n\t\t\t\t\tfor ( let j = 0; j < src.length; j ++ ) {\n\n\t\t\t\t\t\tconst blendSrc = src[ j ];\n\n\t\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\t\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\t\tmaterial.blending = THREE.CustomBlending;\n\t\t\t\t\t\tmaterial.blendSrc = blendSrc.constant;\n\t\t\t\t\t\tmaterial.blendDst = blendDst.constant;\n\t\t\t\t\t\tmaterial.blendEquation = THREE.AddEquation;\n\n\t\t\t\t\t\tconst x = ( j - src.length / 2 ) * 110;\n\t\t\t\t\t\tconst z = 0;\n\t\t\t\t\t\tconst y = ( i - dst.length / 2 ) * 110 + 50;\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geo1, material );\n\t\t\t\t\t\tmesh.position.set( x, - y, z );\n\t\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < src.length; j ++ ) {\n\n\t\t\t\t\tconst blendSrc = src[ j ];\n\n\t\t\t\t\tconst x = ( j - src.length / 2 ) * 110;\n\t\t\t\t\tconst z = 0;\n\t\t\t\t\tconst y = ( 0 - dst.length / 2 ) * 110 + 50;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geo2, generateLabelMaterial( blendSrc.name, 'rgba( 0, 150, 0, 1 )' ) );\n\t\t\t\t\tmesh.position.set( x, - ( y - 70 ), z );\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < dst.length; i ++ ) {\n\n\t\t\t\t\tconst blendDst = dst[ i ];\n\n\t\t\t\t\tconst x = ( 0 - src.length / 2 ) * 110 - 125;\n\t\t\t\t\tconst z = 0;\n\t\t\t\t\tconst y = ( i - dst.length / 2 ) * 110 + 165;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geo2, generateLabelMaterial( blendDst.name, 'rgba( 150, 0, 0, 1 )' ) );\n\t\t\t\t\tmesh.position.set( x, - ( y - 120 ), z );\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\t//\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\n\t\t\t\tgui.add( params, 'blendEquation', equations ).onChange( updateBlendEquation );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction generateLabelMaterial( text, bg ) {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\tcanvas.width = 128;\n\t\t\t\tcanvas.height = 32;\n\n\t\t\t\tctx.fillStyle = bg;\n\t\t\t\tctx.fillRect( 0, 0, 128, 32 );\n\n\t\t\t\tctx.fillStyle = 'white';\n\t\t\t\tctx.font = 'bold 11pt arial';\n\t\t\t\tctx.fillText( text, 8, 22 );\n\n\t\t\t\tconst map = new THREE.CanvasTexture( canvas );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: map, transparent: true } );\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction updateBlendEquation( value ) {\n\n\t\t\t\tfor ( const material of materials ) {\n\n\t\t\t\t\tmaterial.blendEquation = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.00025;\n\t\t\t\tconst ox = ( time * - 0.01 * mapBg.repeat.x ) % 1;\n\t\t\t\tconst oy = ( time * - 0.01 * mapBg.repeat.y ) % 1;\n\n\t\t\t\tmapBg.offset.set( ox, oy );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - bump map [Lee Perry-Smith]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - bump map [Lee Perry-Smith]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, loader;\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tlet mesh;\n\n\t\t\tlet spotLight;\n\n\t\t\tconst params = {\n\t\t\t\tenableBumpMap: true\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 12;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x060708 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x8d7c7c, 0x494966, 3 ) );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xffffde, 200 );\n\t\t\t\tspotLight.position.set( 3.5, 0, 7 );\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tspotLight.castShadow = true;\n\n\t\t\t\tspotLight.shadow.mapSize.width = 2048;\n\t\t\t\tspotLight.shadow.mapSize.height = 2048;\n\n\t\t\t\tspotLight.shadow.camera.near = 2;\n\t\t\t\tspotLight.shadow.camera.far = 15;\n\n\t\t\t\tspotLight.shadow.camera.fov = 40;\n\n\t\t\t\tspotLight.shadow.bias = - 0.005;\n\n\t\t\t\t//\n\n\t\t\t\tconst mapHeight = new THREE.TextureLoader().load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Disp_NoSmoothUV-4096.jpg' );\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x9c6e49,\n\t\t\t\t\tspecular: 0x666666,\n\t\t\t\t\tshininess: 25,\n\t\t\t\t\tbumpMap: mapHeight,\n\t\t\t\t\tbumpScale: 10\n\t\t\t\t} );\n\n\t\t\t\tloader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tcreateScene( gltf.scene.children[ 0 ].geometry, 1, material );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'enableBumpMap' ).name( 'enable bump map' ).onChange( ( value ) => {\n\n\t\t\t\t\tmesh.material.bumpMap = ( value === true ) ? mapHeight : null;\n\t\t\t\t\tmesh.material.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( material, 'bumpScale', 0, 40 ).name( 'bump scale' );\n\t\t\t\tgui.open();\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 8;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t}\n\n\t\t\tfunction createScene( geometry, scale, material ) {\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\tmesh.position.y = - 0.5;\n\t\t\t\tmesh.scale.set( scale, scale, scale );\n\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - bump mapping without tangents Lee Perry-Smith head"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - car"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - car:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet stats;\n\n\t\t\tlet grid;\n\t\t\tlet controls;\n\n\t\t\tconst wheels = [];\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.85;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 4.25, 1.4, - 4.5 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.maxDistance = 9;\n\t\t\t\tcontrols.maxPolarAngle = THREE.MathUtils.degToRad( 90 );\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x333333 );\n\t\t\t\tscene.environment = new RGBELoader().load( 'textures/equirectangular/venice_sunset_1k.hdr' );\n\t\t\t\tscene.environment.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\tscene.fog = new THREE.Fog( 0x333333, 10, 15 );\n\n\t\t\t\tgrid = new THREE.GridHelper( 20, 40, 0xffffff, 0xffffff );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.depthWrite = false;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// materials\n\n\t\t\t\tconst bodyMaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\tcolor: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03\n\t\t\t\t} );\n\n\t\t\t\tconst detailsMaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff, metalness: 1.0, roughness: 0.5\n\t\t\t\t} );\n\n\t\t\t\tconst glassMaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\tcolor: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0\n\t\t\t\t} );\n\n\t\t\t\tconst bodyColorInput = document.getElementById( 'body-color' );\n\t\t\t\tbodyColorInput.addEventListener( 'input', function () {\n\n\t\t\t\t\tbodyMaterial.color.set( this.value );\n\n\t\t\t\t} );\n\n\t\t\t\tconst detailsColorInput = document.getElementById( 'details-color' );\n\t\t\t\tdetailsColorInput.addEventListener( 'input', function () {\n\n\t\t\t\t\tdetailsMaterial.color.set( this.value );\n\n\t\t\t\t} );\n\n\t\t\t\tconst glassColorInput = document.getElementById( 'glass-color' );\n\t\t\t\tglassColorInput.addEventListener( 'input', function () {\n\n\t\t\t\t\tglassMaterial.color.set( this.value );\n\n\t\t\t\t} );\n\n\t\t\t\t// Car\n\n\t\t\t\tconst shadow = new THREE.TextureLoader().load( 'models/gltf/ferrari_ao.png' );\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.setDRACOLoader( dracoLoader );\n\n\t\t\t\tloader.load( 'models/gltf/ferrari.glb', function ( gltf ) {\n\n\t\t\t\t\tconst carModel = gltf.scene.children[ 0 ];\n\n\t\t\t\t\tcarModel.getObjectByName( 'body' ).material = bodyMaterial;\n\n\t\t\t\t\tcarModel.getObjectByName( 'rim_fl' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'rim_fr' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'rim_rr' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'rim_rl' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'trim' ).material = detailsMaterial;\n\n\t\t\t\t\tcarModel.getObjectByName( 'glass' ).material = glassMaterial;\n\n\t\t\t\t\twheels.push(\n\t\t\t\t\t\tcarModel.getObjectByName( 'wheel_fl' ),\n\t\t\t\t\t\tcarModel.getObjectByName( 'wheel_fr' ),\n\t\t\t\t\t\tcarModel.getObjectByName( 'wheel_rl' ),\n\t\t\t\t\t\tcarModel.getObjectByName( 'wheel_rr' )\n\t\t\t\t\t);\n\n\t\t\t\t\t// shadow\n\t\t\t\t\tconst mesh = new THREE.Mesh(\n\t\t\t\t\t\tnew THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),\n\t\t\t\t\t\tnew THREE.MeshBasicMaterial( {\n\t\t\t\t\t\t\tmap: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true, premultipliedAlpha: true\n\t\t\t\t\t\t} )\n\t\t\t\t\t);\n\t\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\t\tmesh.renderOrder = 2;\n\t\t\t\t\tcarModel.add( mesh );\n\n\t\t\t\t\tscene.add( carModel );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst time = - performance.now() / 1000;\n\n\t\t\t\tfor ( let i = 0; i < wheels.length; i ++ ) {\n\n\t\t\t\t\twheels[ i ].rotation.x = time * Math.PI * 2;\n\n\t\t\t\t}\n\n\t\t\t\tgrid.position.z = - ( time ) % 1;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js car materials Ferrari 458 Italia model by vicent091036 Body Details Glass"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - channels"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - channels:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VelocityShader } from 'three/addons/shaders/VelocityShader.js';\n\n\n\t\t\tlet stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst params = {\n\t\t\t\tmaterial: 'normal',\n\t\t\t\tcamera: 'perspective',\n\t\t\t\tside: 'double'\n\t\t\t};\n\n\t\t\tconst sides = {\n\t\t\t\t'front': THREE.FrontSide,\n\t\t\t\t'back': THREE.BackSide,\n\t\t\t\t'double': THREE.DoubleSide\n\t\t\t};\n\n\t\t\tlet cameraOrtho, cameraPerspective;\n\t\t\tlet controlsOrtho, controlsPerspective;\n\n\t\t\tlet mesh, materialStandard, materialDepthBasic, materialDepthRGBA, materialDepthRGB, materialDepthRG, materialNormal, materialVelocity;\n\n\t\t\tconst SCALE = 2.436143; // from original model\n\t\t\tconst BIAS = - 0.428408; // from original model\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcameraPerspective = new THREE.PerspectiveCamera( 45, aspect, 500, 3000 );\n\t\t\t\tcameraPerspective.position.z = 1500;\n\t\t\t\tscene.add( cameraPerspective );\n\n\t\t\t\tconst height = 500;\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( - height * aspect, height * aspect, height, - height, 1000, 2500 );\n\t\t\t\tcameraOrtho.position.z = 1500;\n\t\t\t\tscene.add( cameraOrtho );\n\n\t\t\t\tcamera = cameraPerspective;\n\n\t\t\t\tcontrolsPerspective = new OrbitControls( cameraPerspective, renderer.domElement );\n\t\t\t\tcontrolsPerspective.minDistance = 1000;\n\t\t\t\tcontrolsPerspective.maxDistance = 2400;\n\t\t\t\tcontrolsPerspective.enableDamping = true;\n\n\t\t\t\tcontrolsOrtho = new OrbitControls( cameraOrtho, renderer.domElement );\n\t\t\t\tcontrolsOrtho.minZoom = 0.5;\n\t\t\t\tcontrolsOrtho.maxZoom = 1.5;\n\t\t\t\tcontrolsOrtho.enableDamping = true;\n\n\t\t\t\t// lights\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 0.3 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xff0000, 1.5, 0, 0 );\n\t\t\t\tpointLight.position.z = 2500;\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tconst pointLight2 = new THREE.PointLight( 0xff6666, 3, 0, 0 );\n\t\t\t\tcamera.add( pointLight2 );\n\n\t\t\t\tconst pointLight3 = new THREE.PointLight( 0x0000ff, 1.5, 0, 0 );\n\t\t\t\tpointLight3.position.x = - 1000;\n\t\t\t\tpointLight3.position.z = 1000;\n\t\t\t\tscene.add( pointLight3 );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst normalMap = textureLoader.load( 'models/obj/ninja/normal.png' );\n\t\t\t\tconst aoMap = textureLoader.load( 'models/obj/ninja/ao.jpg' );\n\t\t\t\tconst displacementMap = textureLoader.load( 'models/obj/ninja/displacement.jpg' );\n\n\t\t\t\t// material\n\n\t\t\t\tmaterialStandard = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\n\t\t\t\t\tmetalness: 0.5,\n\t\t\t\t\troughness: 0.6,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: SCALE,\n\t\t\t\t\tdisplacementBias: BIAS,\n\n\t\t\t\t\taoMap: aoMap,\n\n\t\t\t\t\tnormalMap: normalMap,\n\t\t\t\t\tnormalScale: new THREE.Vector2( 1, - 1 ),\n\n\t\t\t\t\t//flatShading: true,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tmaterialDepthBasic = new THREE.MeshDepthMaterial( {\n\t\t\t\t\tdepthPacking: THREE.BasicDepthPacking,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: SCALE,\n\t\t\t\t\tdisplacementBias: BIAS,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tmaterialDepthRGBA = new THREE.MeshDepthMaterial( {\n\t\t\t\t\tdepthPacking: THREE.RGBADepthPacking,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: SCALE,\n\t\t\t\t\tdisplacementBias: BIAS,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tmaterialDepthRGB = new THREE.MeshDepthMaterial( {\n\t\t\t\t\tdepthPacking: THREE.RGBDepthPacking,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: SCALE,\n\t\t\t\t\tdisplacementBias: BIAS,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tmaterialDepthRG = new THREE.MeshDepthMaterial( {\n\t\t\t\t\tdepthPacking: THREE.RGDepthPacking,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: SCALE,\n\t\t\t\t\tdisplacementBias: BIAS,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tmaterialNormal = new THREE.MeshNormalMaterial( {\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: SCALE,\n\t\t\t\t\tdisplacementBias: BIAS,\n\n\t\t\t\t\tnormalMap: normalMap,\n\t\t\t\t\tnormalScale: new THREE.Vector2( 1, - 1 ),\n\n\t\t\t\t\t//flatShading: true,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tmaterialVelocity = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( VelocityShader.uniforms ),\n\t\t\t\t\tvertexShader: VelocityShader.vertexShader,\n\t\t\t\t\tfragmentShader: VelocityShader.fragmentShader,\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\t\t\t\tmaterialVelocity.displacementMap = displacementMap; // required for defines\n\t\t\t\tmaterialVelocity.uniforms.displacementMap.value = displacementMap;\n\t\t\t\tmaterialVelocity.uniforms.displacementScale.value = SCALE;\n\t\t\t\tmaterialVelocity.uniforms.displacementBias.value = BIAS;\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/ninja/ninjaHead_Low.obj', function ( group ) {\n\n\t\t\t\t\tconst geometry = group.children[ 0 ].geometry;\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, materialNormal );\n\t\t\t\t\tmesh.scale.multiplyScalar( 25 );\n\t\t\t\t\tmesh.userData.matrixWorldPrevious = new THREE.Matrix4(); // for velocity\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'material', [ 'standard', 'normal', 'velocity', 'depthBasic', 'depthRGBA', 'depthRGB', 'depthRG' ] );\n\t\t\t\tgui.add( params, 'camera', [ 'perspective', 'ortho' ] );\n\t\t\t\tgui.add( params, 'side', [ 'front', 'back', 'double' ] );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.aspect = aspect;\n\n\t\t\t\tcamera.left = - height * aspect;\n\t\t\t\tcamera.right = height * aspect;\n\t\t\t\tcamera.top = height;\n\t\t\t\tcamera.bottom = - height;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tlet material = mesh.material;\n\n\t\t\t\t\tswitch ( params.material ) {\n\n\t\t\t\t\t\tcase 'standard': material = materialStandard; break;\n\t\t\t\t\t\tcase 'depthBasic': material = materialDepthBasic; break;\n\t\t\t\t\t\tcase 'depthRGBA': material = materialDepthRGBA; break;\n\t\t\t\t\t\tcase 'depthRGB': material = materialDepthRGB; break;\n\t\t\t\t\t\tcase 'depthRG': material = materialDepthRG; break;\n\t\t\t\t\t\tcase 'normal': material = materialNormal; break;\n\t\t\t\t\t\tcase 'velocity': material = materialVelocity; break;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( sides[ params.side ] !== material.side ) {\n\n\t\t\t\t\t\tswitch ( params.side ) {\n\n\t\t\t\t\t\t\tcase 'front': material.side = THREE.FrontSide; break;\n\t\t\t\t\t\t\tcase 'back': material.side = THREE.BackSide; break;\n\t\t\t\t\t\t\tcase 'double': material.side = THREE.DoubleSide; break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.material = material;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( params.camera ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\t\tcamera = cameraPerspective;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ortho':\n\t\t\t\t\t\tcamera = cameraOrtho;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcontrolsPerspective.update();\n\t\t\t\tcontrolsOrtho.update(); // must update both controls for damping to complete\n\n\t\t\t\t// remember camera projection changes\n\n\t\t\t\tmaterialVelocity.uniforms.previousProjectionViewMatrix.value.copy( materialVelocity.uniforms.currentProjectionViewMatrix.value );\n\t\t\t\tmaterialVelocity.uniforms.currentProjectionViewMatrix.value.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\n\t\t\t\tif ( mesh && mesh.userData.matrixWorldPrevious ) {\n\n\t\t\t\t\tmaterialVelocity.uniforms.modelMatrixPrev.value.copy( mesh.userData.matrixWorldPrevious );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\tobject.userData.matrixWorldPrevious.copy( object.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - Normal, Velocity, and Depth Materials ninja head from AMD GPU MeshMapper"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - cube reflection / refraction [Walt]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - cube reflection / refraction [Walt]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet pointLight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 13;\n\n\t\t\t\t//cubemap\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst reflectionCube = new THREE.CubeTextureLoader().load( urls );\n\t\t\t\tconst refractionCube = new THREE.CubeTextureLoader().load( urls );\n\t\t\t\trefractionCube.mapping = THREE.CubeRefractionMapping;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = reflectionCube;\n\n\t\t\t\t//lights\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0xffffff, 3 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tpointLight = new THREE.PointLight( 0xffffff, 200 );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\t//materials\n\t\t\t\tconst cubeMaterial3 = new THREE.MeshLambertMaterial( { color: 0xffaa00, envMap: reflectionCube, combine: THREE.MixOperation, reflectivity: 0.3 } );\n\t\t\t\tconst cubeMaterial2 = new THREE.MeshLambertMaterial( { color: 0xfff700, envMap: refractionCube, refractionRatio: 0.95 } );\n\t\t\t\tconst cubeMaterial1 = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: reflectionCube } );\n\n\t\t\t\t//models\n\t\t\t\tconst objLoader = new OBJLoader();\n\n\t\t\t\tobjLoader.setPath( 'models/obj/walt/' );\n\t\t\t\tobjLoader.load( 'WaltHead.obj', function ( object ) {\n\n\t\t\t\t\tconst head = object.children[ 0 ];\n\t\t\t\t\thead.scale.setScalar( 0.1 );\n\t\t\t\t\thead.position.y = - 3;\n\t\t\t\t\thead.material = cubeMaterial1;\n\n\t\t\t\t\tconst head2 = head.clone();\n\t\t\t\t\thead2.position.x = - 6;\n\t\t\t\t\thead2.material = cubeMaterial2;\n\n\t\t\t\t\tconst head3 = head.clone();\n\t\t\t\t\thead3.position.x = 6;\n\t\t\t\t\thead3.material = cubeMaterial3;\n\n\t\t\t\t\tscene.add( head, head2, head3 );\n\n\t\t\t\t} );\n\n\t\t\t\t//renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.minPolarAngle = Math.PI / 4;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.5;\n\n\t\t\t\t//stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - cube mapping demo. Texture by Humus , Walt Disney head by David OReilly"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - dynamic cube reflection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - dynamic cube reflection:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet cube, sphere, torus, material;\n\n\t\t\tlet cubeCamera, cubeRenderTarget;\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResized );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 75;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.rotation.y = 0.5; // avoid flying objects occluding the sun\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'quarry_01_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tcubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );\n\t\t\t\tcubeRenderTarget.texture.type = THREE.HalfFloatType;\n\n\t\t\t\tcubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );\n\n\t\t\t\t//\n\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tenvMap: cubeRenderTarget.texture,\n\t\t\t\t\troughness: 0.05,\n\t\t\t\t\tmetalness: 1\n\t\t\t\t} );\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( material, 'roughness', 0, 1 );\n\t\t\t\tgui.add( material, 'metalness', 0, 1 );\n\t\t\t\tgui.add( renderer, 'toneMappingExposure', 0, 2 ).name( 'exposure' );\n\n\t\t\t\tsphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 15, 8 ), material );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\tconst material2 = new THREE.MeshStandardMaterial( {\n\t\t\t\t\troughness: 0.1,\n\t\t\t\t\tmetalness: 0\n\t\t\t\t} );\n\n\t\t\t\tcube = new THREE.Mesh( new THREE.BoxGeometry( 15, 15, 15 ), material2 );\n\t\t\t\tscene.add( cube );\n\n\t\t\t\ttorus = new THREE.Mesh( new THREE.TorusKnotGeometry( 8, 3, 128, 16 ), material2 );\n\t\t\t\tscene.add( torus );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResized() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate( msTime ) {\n\n\t\t\t\tconst time = msTime / 1000;\n\n\t\t\t\tcube.position.x = Math.cos( time ) * 30;\n\t\t\t\tcube.position.y = Math.sin( time ) * 30;\n\t\t\t\tcube.position.z = Math.sin( time ) * 30;\n\n\t\t\t\tcube.rotation.x += 0.02;\n\t\t\t\tcube.rotation.y += 0.03;\n\n\t\t\t\ttorus.position.x = Math.cos( time + 10 ) * 30;\n\t\t\t\ttorus.position.y = Math.sin( time + 10 ) * 30;\n\t\t\t\ttorus.position.z = Math.sin( time + 10 ) * 30;\n\n\t\t\t\ttorus.rotation.x += 0.02;\n\t\t\t\ttorus.rotation.y += 0.03;\n\n\t\t\t\tcubeCamera.update( renderer, scene );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - materials - dynamic cube reflection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - cube refraction [Lucy]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - cube refraction [Lucy]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100000 );\n\t\t\t\tcamera.position.z = - 4000;\n\n\t\t\t\t//\n\n\t\t\t\tconst r = 'textures/cube/Park3Med/';\n\n\t\t\t\tconst urls = [\n\t\t\t\t\tr + 'px.jpg', r + 'nx.jpg',\n\t\t\t\t\tr + 'py.jpg', r + 'ny.jpg',\n\t\t\t\t\tr + 'pz.jpg', r + 'nz.jpg'\n\t\t\t\t];\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\t\t\t\ttextureCube.mapping = THREE.CubeRefractionMapping;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0xffffff, 3.5 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\t// material samples\n\n\t\t\t\tconst cubeMaterial3 = new THREE.MeshPhongMaterial( { color: 0xccddff, envMap: textureCube, refractionRatio: 0.98, reflectivity: 0.9 } );\n\t\t\t\tconst cubeMaterial2 = new THREE.MeshPhongMaterial( { color: 0xccfffd, envMap: textureCube, refractionRatio: 0.985 } );\n\t\t\t\tconst cubeMaterial1 = new THREE.MeshPhongMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.98 } );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tconst loader = new PLYLoader();\n\t\t\t\tloader.load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {\n\n\t\t\t\t\tcreateScene( geometry, cubeMaterial1, cubeMaterial2, cubeMaterial3 );\n\n\t\t\t\t} );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction createScene( geometry, m1, m2, m3 ) {\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\tconst s = 1.5;\n\n\t\t\t\tlet mesh = new THREE.Mesh( geometry, m1 );\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = s;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, m2 );\n\t\t\t\tmesh.position.x = - 1500;\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = s;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, m3 );\n\t\t\t\tmesh.position.x = 1500;\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = s;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX ) * 4;\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) * 4;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example Three.js cube map refraction demo Lucy model from Stanford 3d scanning repository Texture by Humus"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - cubemap mipmaps"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - cubemap mipmaps:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\t//load customized cube texture\n\t\t\tasync function loadCubeTextureWithMipmaps() {\n\n\t\t\t\tconst path = 'textures/cube/angus/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst mipmaps = [];\n\t\t\t\tconst maxLevel = 8;\n\n\t\t\t\tasync function loadCubeTexture( urls ) {\n\n\t\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\t\tnew THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {\n\n\t\t\t\t\t\t\tresolve( cubeTexture );\n\n\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// load mipmaps\n\t\t\t\tconst pendings = [];\n\n\t\t\t\tfor ( let level = 0; level <= maxLevel; ++ level ) {\n\n\t\t\t\t\tconst urls = [];\n\n\t\t\t\t\tfor ( let face = 0; face < 6; ++ face ) {\n\n\t\t\t\t\t\turls.push( path + 'cube_m0' + level + '_c0' + face + format );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mipmapLevel = level;\n\n\t\t\t\t\tpendings.push( loadCubeTexture( urls ).then( function ( cubeTexture ) {\n\n\t\t\t\t\t\tmipmaps[ mipmapLevel ] = cubeTexture;\n\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t\tawait Promise.all( pendings );\n\n\t\t\t\tconst customizedCubeTexture = mipmaps.shift();\n\t\t\t\tcustomizedCubeTexture.mipmaps = mipmaps;\n\t\t\t\tcustomizedCubeTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tcustomizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\t\tcustomizedCubeTexture.magFilter = THREE.LinearFilter;\n\t\t\t\tcustomizedCubeTexture.generateMipmaps = false;\n\t\t\t\tcustomizedCubeTexture.needsUpdate = true;\n\n\t\t\t\treturn customizedCubeTexture;\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tloadCubeTextureWithMipmaps().then( function ( cubeTexture ) {\n\n\t\t\t\t\t//model\n\t\t\t\t\tconst sphere = new THREE.SphereGeometry( 100, 128, 128 );\n\n\t\t\t\t\t//manual mipmaps\n\t\t\t\t\tlet material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: cubeTexture } );\n\t\t\t\t\tmaterial.name = 'manual mipmaps';\n\n\t\t\t\t\tlet mesh = new THREE.Mesh( sphere, material );\n\t\t\t\t\tmesh.position.set( 100, 0, 0 );\n\t\t\t\t\tscene.add( mesh );\n\n\n\t\t\t\t\t//webgl mipmaps\n\t\t\t\t\tmaterial = material.clone();\n\t\t\t\t\tmaterial.name = 'auto mipmaps';\n\n\t\t\t\t\tconst autoCubeTexture = cubeTexture.clone();\n\t\t\t\t\tautoCubeTexture.mipmaps = [];\n\t\t\t\t\tautoCubeTexture.generateMipmaps = true;\n\t\t\t\t\tautoCubeTexture.needsUpdate = true;\n\n\t\t\t\t\tmaterial.envMap = autoCubeTexture;\n\n\t\t\t\t\tmesh = new THREE.Mesh( sphere, material );\n\t\t\t\t\tmesh.position.set( - 100, 0, 0 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t//renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minPolarAngle = Math.PI / 4;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.5;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - cubemap customized mipmaps demo. Left: webgl generated mipmaps Right: manual mipmaps"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - cubemap mipmaps"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - cubemap mipmaps:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst CubemapFilterShader = {\n\n\t\t\t\tname: 'CubemapFilterShader',\n\n\t\t\t\tuniforms: {\n\t\t\t\t\tcubeTexture: { value: null },\n\t\t\t\t\tmipIndex: { value: 0 },\n\t\t\t\t},\n\n\t\t\t\tvertexShader: /* glsl */ `\n\n\t\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t\t#include <common>\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvWorldDirection = transformDirection(position, modelMatrix);\n\t\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\t\t\t\t\t}\n\n\t\t\t\t\t`,\n\n\t\t\t\tfragmentShader: /* glsl */ `\n\n\t\t\t\t\tuniform samplerCube cubeTexture;\n\t\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t\tuniform float mipIndex;\n\n\t\t\t\t\t#include <common>\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec3 cubeCoordinates = normalize(vWorldDirection);\n\n\t\t\t\t\t\t// Colorize mip levels\n\t\t\t\t\t\tvec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n\t\t\t\t\t\tif (mipIndex == 0.0) color.rgb = vec3(1.0, 1.0, 1.0);\n\t\t\t\t\t\telse if (mipIndex == 1.0) color.rgb = vec3(0.0, 0.0, 1.0);\n\t\t\t\t\t\telse if (mipIndex == 2.0) color.rgb = vec3(0.0, 1.0, 1.0);\n\t\t\t\t\t\telse if (mipIndex == 3.0) color.rgb = vec3(0.0, 1.0, 0.0);\n\t\t\t\t\t\telse if (mipIndex == 4.0) color.rgb = vec3(1.0, 1.0, 0.0);\n\n\t\t\t\t\t\tgl_FragColor = textureCube(cubeTexture, cubeCoordinates, 0.0) * color;\n\t\t\t\t\t}\n\n\t\t\t\t\t`,\n\t\t\t};\n\n\n\t\t\tinit();\n\n\t\t\tasync function loadCubeTexture( urls ) {\n\n\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\tnew THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {\n\n\t\t\t\t\t\tresolve( cubeTexture );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction allocateCubemapRenderTarget( cubeMapSize ) {\n\n\t\t\t\tconst params = {\n\t\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\t\tminFilter: THREE.LinearMipMapLinearFilter,\n\t\t\t\t\tgenerateMipmaps: false,\n\t\t\t\t\ttype: THREE.HalfFloatType,\n\t\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\t\tcolorSpace: THREE.LinearSRGBColorSpace,\n\t\t\t\t\tdepthBuffer: false,\n\t\t\t\t};\n\n\t\t\t\tconst rt = new THREE.WebGLCubeRenderTarget( cubeMapSize, params );\n\n\t\t\t\tconst mipLevels = Math.log( cubeMapSize ) * Math.LOG2E + 1.0;\n\t\t\t\tfor ( let i = 0; i < mipLevels; i ++ ) rt.texture.mipmaps.push( {} );\n\n\t\t\t\trt.texture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\treturn rt;\n\n\t\t\t}\n\n\t\t\tfunction renderToCubeTexture( cubeMapRenderTarget, sourceCubeTexture ) {\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 5, 5, 5 );\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\tname: CubemapFilterShader.name,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( CubemapFilterShader.uniforms ),\n\t\t\t\t\tvertexShader: CubemapFilterShader.vertexShader,\n\t\t\t\t\tfragmentShader: CubemapFilterShader.fragmentShader,\n\t\t\t\t\tside: THREE.BackSide,\n\t\t\t\t\tblending: THREE.NoBlending,\n\t\t\t\t} );\n\n\t\t\t\tmaterial.uniforms.cubeTexture.value = sourceCubeTexture;\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tconst cubeCamera = new THREE.CubeCamera( 1, 10, cubeMapRenderTarget );\n\t\t\t\tconst mipmapCount = Math.floor( Math.log2( Math.max( cubeMapRenderTarget.width, cubeMapRenderTarget.height ) ) );\n\n\t\t\t\tfor ( let mipmap = 0; mipmap < mipmapCount; mipmap ++ ) {\n\n\t\t\t\t\tmaterial.uniforms.mipIndex.value = mipmap;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\tcubeMapRenderTarget.viewport.set( 0, 0, cubeMapRenderTarget.width >> mipmap, cubeMapRenderTarget.height >> mipmap );\n\n\t\t\t\t\tcubeCamera.activeMipmapLevel = mipmap;\n\t\t\t\t\tcubeCamera.update( renderer, mesh );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.geometry.dispose();\n\t\t\t\tmesh.material.dispose();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// Create renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\t// Create controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minPolarAngle = Math.PI / 4;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.5;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// Load a cube texture\n\t\t\t\tconst r = 'textures/cube/Park3Med/';\n\t\t\t\tconst urls = [\n\t\t\t\t\tr + 'px.jpg', r + 'nx.jpg',\n\t\t\t\t\tr + 'py.jpg', r + 'ny.jpg',\n\t\t\t\t\tr + 'pz.jpg', r + 'nz.jpg'\n\t\t\t\t];\n\n\t\t\t\tloadCubeTexture( urls ).then( ( cubeTexture ) => {\n\n\t\t\t\t\t// Allocate a cube map render target\n\t\t\t\t\tconst cubeMapRenderTarget = allocateCubemapRenderTarget( 512 );\n\n\t\t\t\t\t// Render to all the mip levels of cubeMapRenderTarget\n\t\t\t\t\trenderToCubeTexture( cubeMapRenderTarget, cubeTexture );\n\n\t\t\t\t\t// Create geometry\n\t\t\t\t\tconst sphere = new THREE.SphereGeometry( 100, 128, 128 );\n\t\t\t\t\tlet material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: cubeTexture } );\n\n\t\t\t\t\tlet mesh = new THREE.Mesh( sphere, material );\n\t\t\t\t\tmesh.position.set( - 100, 0, 0 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmaterial = material.clone();\n\t\t\t\t\tmaterial.envMap = cubeMapRenderTarget.texture;\n\n\t\t\t\t\tmesh = new THREE.Mesh( sphere, material );\n\t\t\t\t\tmesh.position.set( 100, 0, 0 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - rendering to cubemap mip levels demo. Left: original cubemap Right: generated cubemap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - displacement map"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - displacement map:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tconst settings = {\n\t\t\t\tmetalness: 1.0,\n\t\t\t\troughness: 0.4,\n\t\t\t\tambientIntensity: 0.2,\n\t\t\t\taoMapIntensity: 1.0,\n\t\t\t\tenvMapIntensity: 1.0,\n\t\t\t\tdisplacementScale: 2.436143, // from original model\n\t\t\t\tnormalScale: 1.0\n\t\t\t};\n\n\t\t\tlet mesh, material;\n\n\t\t\tlet pointLight, ambientLight;\n\n\t\t\tconst height = 500; // of camera frustum\n\n\t\t\tlet r = 0.0;\n\n\t\t\tinit();\n\t\t\tinitGui();\n\n\t\t\t// Init gui\n\t\t\tfunction initGui() {\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\t//let gui = gui.addFolder( \"Material\" );\n\t\t\t\tgui.add( settings, 'metalness' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.metalness = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'roughness' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.roughness = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'aoMapIntensity' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.aoMapIntensity = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'ambientIntensity' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tambientLight.intensity = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'envMapIntensity' ).min( 0 ).max( 3 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.envMapIntensity = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'displacementScale' ).min( 0 ).max( 3.0 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.displacementScale = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'normalScale' ).min( - 1 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.normalScale.set( 1, - 1 ).multiplyScalar( value );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( - height * aspect, height * aspect, height, - height, 1, 10000 );\n\t\t\t\tcamera.position.z = 1500;\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t// lights\n\n\t\t\t\tambientLight = new THREE.AmbientLight( 0xffffff, settings.ambientIntensity );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tpointLight = new THREE.PointLight( 0xff0000, 1.5, 0, 0 );\n\t\t\t\tpointLight.position.z = 2500;\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tconst pointLight2 = new THREE.PointLight( 0xff6666, 3, 0, 0 );\n\t\t\t\tcamera.add( pointLight2 );\n\n\t\t\t\tconst pointLight3 = new THREE.PointLight( 0x0000ff, 1.5, 0, 0 );\n\t\t\t\tpointLight3.position.x = - 1000;\n\t\t\t\tpointLight3.position.z = 1000;\n\t\t\t\tscene.add( pointLight3 );\n\n\t\t\t\t// env map\n\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst reflectionCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst normalMap = textureLoader.load( 'models/obj/ninja/normal.png' );\n\t\t\t\tconst aoMap = textureLoader.load( 'models/obj/ninja/ao.jpg' );\n\t\t\t\tconst displacementMap = textureLoader.load( 'models/obj/ninja/displacement.jpg' );\n\n\t\t\t\t// material\n\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\n\t\t\t\t\tcolor: 0xc1c1c1,\n\t\t\t\t\troughness: settings.roughness,\n\t\t\t\t\tmetalness: settings.metalness,\n\n\t\t\t\t\tnormalMap: normalMap,\n\t\t\t\t\tnormalScale: new THREE.Vector2( 1, - 1 ), // why does the normal map require negation in this case?\n\n\t\t\t\t\taoMap: aoMap,\n\t\t\t\t\taoMapIntensity: 1,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: settings.displacementScale,\n\t\t\t\t\tdisplacementBias: - 0.428408, // from original model\n\n\t\t\t\t\tenvMap: reflectionCube,\n\t\t\t\t\tenvMapIntensity: settings.envMapIntensity,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/ninja/ninjaHead_Low.obj', function ( group ) {\n\n\t\t\t\t\tconst geometry = group.children[ 0 ].geometry;\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.scale.multiplyScalar( 25 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.left = - height * aspect;\n\t\t\t\tcamera.right = height * aspect;\n\t\t\t\tcamera.top = height;\n\t\t\t\tcamera.bottom = - height;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tpointLight.position.x = 2500 * Math.cos( r );\n\t\t\t\tpointLight.position.z = 2500 * Math.sin( r );\n\n\t\t\t\tr += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - (normal + ao + displacement + environment) map demo. ninja head from AMD GPU MeshMapper"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - environment maps"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - environment maps:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet controls, camera, scene, renderer;\n\t\t\tlet textureEquirec, textureCube;\n\t\t\tlet sphereMesh, sphereMaterial, params;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// CAMERAS\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 2.5 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Textures\n\n\t\t\t\tconst loader = new THREE.CubeTextureLoader();\n\t\t\t\tloader.setPath( 'textures/cube/Bridge2/' );\n\n\t\t\t\ttextureCube = loader.load( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\ttextureEquirec = textureLoader.load( 'textures/2294472375_24a3b8ef46_o.jpg' );\n\t\t\t\ttextureEquirec.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\ttextureEquirec.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 15 );\n\t\t\t\tsphereMaterial = new THREE.MeshBasicMaterial( { envMap: textureCube } );\n\t\t\t\tsphereMesh = new THREE.Mesh( geometry, sphereMaterial );\n\t\t\t\tscene.add( sphereMesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1.5;\n\t\t\t\tcontrols.maxDistance = 6;\n\n\t\t\t\t//\n\n\t\t\t\tparams = {\n\t\t\t\t\tCube: function () {\n\n\t\t\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t\t\tsphereMaterial.envMap = textureCube;\n\t\t\t\t\t\tsphereMaterial.needsUpdate = true;\n\n\t\t\t\t\t},\n\t\t\t\t\tEquirectangular: function () {\n\n\t\t\t\t\t\tscene.background = textureEquirec;\n\n\t\t\t\t\t\tsphereMaterial.envMap = textureEquirec;\n\t\t\t\t\t\tsphereMaterial.needsUpdate = true;\n\n\t\t\t\t\t},\n\t\t\t\t\tRefraction: false,\n\t\t\t\t\tbackgroundRotationX: false,\n\t\t\t\t\tbackgroundRotationY: false,\n\t\t\t\t\tbackgroundRotationZ: false,\n\t\t\t\t\tsyncMaterial: false\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\t\t\t\tgui.add( params, 'Cube' );\n\t\t\t\tgui.add( params, 'Equirectangular' );\n\t\t\t\tgui.add( params, 'Refraction' ).onChange( function ( value ) {\n\n\t\t\t\t\tif ( value ) {\n\n\t\t\t\t\t\ttextureEquirec.mapping = THREE.EquirectangularRefractionMapping;\n\t\t\t\t\t\ttextureCube.mapping = THREE.CubeRefractionMapping;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureEquirec.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\ttextureCube.mapping = THREE.CubeReflectionMapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsphereMaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'backgroundRotationX' );\n\t\t\t\tgui.add( params, 'backgroundRotationY' );\n\t\t\t\tgui.add( params, 'backgroundRotationZ' );\n\t\t\t\tgui.add( params, 'syncMaterial' );\n\t\t\t\tgui.open();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( params.backgroundRotationX ) {\n\n\t\t\t\t\tscene.backgroundRotation.x += 0.001;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.backgroundRotationY ) {\n\n\t\t\t\t\tscene.backgroundRotation.y += 0.001;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.backgroundRotationZ ) {\n\n\t\t\t\t\tscene.backgroundRotation.z += 0.001;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.syncMaterial ) {\n\n\t\t\t\t\tsphereMesh.material.envMapRotation.copy( scene.backgroundRotation );\n\n\t\t\t\t}\n\n\t\t\t\tcamera.lookAt( scene.position );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl environment mapping example Equirectangular Map by J\u00f3n Ragnarsson ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates threejs webgl - materials - equirectangular exr image based lighting"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for threejs webgl - materials - equirectangular exr image based lighting:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n\n\t\t\tconst params = {\n\t\t\t\tenvMap: 'EXR',\n\t\t\t\troughness: 0.0,\n\t\t\t\tmetalness: 0.0,\n\t\t\t\texposure: 1.0,\n\t\t\t\tdebug: false,\n\t\t\t};\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet torusMesh, planeMesh;\n\t\t\tlet pngCubeRenderTarget, exrCubeRenderTarget;\n\t\t\tlet pngBackground, exrBackground;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 120 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\t//\n\n\t\t\t\tlet geometry = new THREE.TorusKnotGeometry( 18, 8, 150, 20 );\n\t\t\t\tlet material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tmetalness: params.metalness,\n\t\t\t\t\troughness: params.roughness,\n\t\t\t\t\tenvMapIntensity: 1.0\n\t\t\t\t} );\n\n\t\t\t\ttorusMesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( torusMesh );\n\n\t\t\t\tgeometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\n\t\t\t\tplaneMesh = new THREE.Mesh( geometry, material );\n\t\t\t\tplaneMesh.position.y = - 50;\n\t\t\t\tplaneMesh.rotation.x = - Math.PI * 0.5;\n\t\t\t\tscene.add( planeMesh );\n\n\t\t\t\tTHREE.DefaultLoadingManager.onLoad = function ( ) {\n\n\t\t\t\t\tpmremGenerator.dispose();\n\n\t\t\t\t};\n\n\t\t\t\tnew EXRLoader().load( 'textures/piz_compressed.exr', function ( texture ) {\n\n\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\texrCubeRenderTarget = pmremGenerator.fromEquirectangular( texture );\n\t\t\t\t\texrBackground = texture;\n\n\t\t\t\t} );\n\n\t\t\t\tnew THREE.TextureLoader().load( 'textures/equirectangular.png', function ( texture ) {\n\n\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tpngCubeRenderTarget = pmremGenerator.fromEquirectangular( texture );\n\t\t\t\t\tpngBackground = texture;\n\n\t\t\t\t} );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tpmremGenerator.compileEquirectangularShader();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 50;\n\t\t\t\tcontrols.maxDistance = 300;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'envMap', [ 'EXR', 'PNG' ] );\n\t\t\t\tgui.add( params, 'roughness', 0, 1, 0.01 );\n\t\t\t\tgui.add( params, 'metalness', 0, 1, 0.01 );\n\t\t\t\tgui.add( params, 'exposure', 0, 2, 0.01 );\n\t\t\t\tgui.add( params, 'debug' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttorusMesh.material.roughness = params.roughness;\n\t\t\t\ttorusMesh.material.metalness = params.metalness;\n\n\t\t\t\tlet newEnvMap = torusMesh.material.envMap;\n\t\t\t\tlet background = scene.background;\n\n\t\t\t\tswitch ( params.envMap ) {\n\n\t\t\t\t\tcase 'EXR':\n\t\t\t\t\t\tnewEnvMap = exrCubeRenderTarget ? exrCubeRenderTarget.texture : null;\n\t\t\t\t\t\tbackground = exrBackground;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'PNG':\n\t\t\t\t\t\tnewEnvMap = pngCubeRenderTarget ? pngCubeRenderTarget.texture : null;\n\t\t\t\t\t\tbackground = pngBackground;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( newEnvMap !== torusMesh.material.envMap ) {\n\n\t\t\t\t\ttorusMesh.material.envMap = newEnvMap;\n\t\t\t\t\ttorusMesh.material.needsUpdate = true;\n\n\t\t\t\t\tplaneMesh.material.map = newEnvMap;\n\t\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\ttorusMesh.rotation.y += 0.005;\n\t\t\t\tplaneMesh.visible = params.debug;\n\n\t\t\t\tscene.background = background;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example threejs - Example of an IBL (Image based lighting) pipeline based around equirectangular EXR lightprobe data. Created by Richard Monette"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates threejs webgl - materials - ground projected environment mapping"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for threejs webgl - materials - ground projected environment mapping:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GroundedSkybox } from 'three/addons/objects/GroundedSkybox.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tconst params = {\n\t\t\t\theight: 15,\n\t\t\t\tradius: 100,\n\t\t\t\tenabled: true,\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer, skybox;\n\n\t\t\tinit().then( render );\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t40,\n\t\t\t\t\twindow.innerWidth / window.innerHeight,\n\t\t\t\t\t1,\n\t\t\t\t\t1000\n\t\t\t\t);\n\t\t\t\tcamera.position.set( - 20, 7, 20 );\n\t\t\t\tcamera.lookAt( 0, 4, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst hdrLoader = new RGBELoader();\n\t\t\t\tconst envMap = await hdrLoader.loadAsync( 'textures/equirectangular/blouberg_sunrise_2_1k.hdr' );\n\t\t\t\tenvMap.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tskybox = new GroundedSkybox( envMap, params.height, params.radius );\n\t\t\t\tskybox.position.y = params.height - 0.01;\n\t\t\t\tscene.add( skybox );\n\n\t\t\t\tscene.environment = envMap;\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.setDRACOLoader( dracoLoader );\n\n\t\t\t\tconst shadow = new THREE.TextureLoader().load( 'models/gltf/ferrari_ao.png' );\n\n\t\t\t\tloader.load( 'models/gltf/ferrari.glb', function ( gltf ) {\n\n\t\t\t\t\tconst bodyMaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\tcolor: 0x000000, metalness: 1.0, roughness: 0.8,\n\t\t\t\t\t\tclearcoat: 1.0, clearcoatRoughness: 0.2\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst detailsMaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0xffffff, metalness: 1.0, roughness: 0.5\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst glassMaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\tcolor: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst carModel = gltf.scene.children[ 0 ];\n\t\t\t\t\tcarModel.scale.multiplyScalar( 4 );\n\t\t\t\t\tcarModel.rotation.y = Math.PI;\n\n\t\t\t\t\tcarModel.getObjectByName( 'body' ).material = bodyMaterial;\n\n\t\t\t\t\tcarModel.getObjectByName( 'rim_fl' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'rim_fr' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'rim_rr' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'rim_rl' ).material = detailsMaterial;\n\t\t\t\t\tcarModel.getObjectByName( 'trim' ).material = detailsMaterial;\n\n\t\t\t\t\tcarModel.getObjectByName( 'glass' ).material = glassMaterial;\n\n\t\t\t\t\t// shadow\n\t\t\t\t\tconst mesh = new THREE.Mesh(\n\t\t\t\t\t\tnew THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),\n\t\t\t\t\t\tnew THREE.MeshBasicMaterial( {\n\t\t\t\t\t\t\tmap: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true, premultipliedAlpha: true\n\t\t\t\t\t\t} )\n\t\t\t\t\t);\n\t\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\t\tcarModel.add( mesh );\n\n\t\t\t\t\tscene.add( carModel );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.maxPolarAngle = THREE.MathUtils.degToRad( 90 );\n\t\t\t\tcontrols.maxDistance = 80;\n\t\t\t\tcontrols.minDistance = 20;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'enabled' ).name( 'Grounded' ).onChange( function ( value ) {\n\n\t\t\t\t\tif ( value ) {\n\n\t\t\t\t\t\tscene.add( skybox );\n\t\t\t\t\t\tscene.background = null;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tscene.remove( skybox );\n\t\t\t\t\t\tscene.background = scene.environment;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example threejs - Ground projected environment mapping. Ferrari 458 Italia model by vicent091036 Blouberg Sunrise 2 by Greg Zaal"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates threejs webgl - materials - hdr environment mapping"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for threejs webgl - materials - hdr environment mapping:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\t\t\timport { DebugEnvironment } from 'three/addons/environments/DebugEnvironment.js';\n\n\t\t\tconst params = {\n\t\t\t\tenvMap: 'HDR',\n\t\t\t\troughness: 0.0,\n\t\t\t\tmetalness: 0.0,\n\t\t\t\texposure: 1.0,\n\t\t\t\tdebug: false\n\t\t\t};\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet torusMesh, planeMesh;\n\t\t\tlet generatedCubeRenderTarget, ldrCubeRenderTarget, hdrCubeRenderTarget, rgbmCubeRenderTarget;\n\t\t\tlet ldrCubeMap, hdrCubeMap, rgbmCubeMap;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 120 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x000000 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\t//\n\n\t\t\t\tlet geometry = new THREE.TorusKnotGeometry( 18, 8, 150, 20 );\n\t\t\t\t// let geometry = new THREE.SphereGeometry( 26, 64, 32 );\n\t\t\t\tlet material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tmetalness: params.metalness,\n\t\t\t\t\troughness: params.roughness\n\t\t\t\t} );\n\n\t\t\t\ttorusMesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( torusMesh );\n\n\n\t\t\t\tgeometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\n\t\t\t\tplaneMesh = new THREE.Mesh( geometry, material );\n\t\t\t\tplaneMesh.position.y = - 50;\n\t\t\t\tplaneMesh.rotation.x = - Math.PI * 0.5;\n\t\t\t\tscene.add( planeMesh );\n\n\t\t\t\tTHREE.DefaultLoadingManager.onLoad = function ( ) {\n\n\t\t\t\t\tpmremGenerator.dispose();\n\n\t\t\t\t};\n\n\t\t\t\tconst hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];\n\t\t\t\thdrCubeMap = new HDRCubeTextureLoader()\n\t\t\t\t\t.setPath( './textures/cube/pisaHDR/' )\n\t\t\t\t\t.load( hdrUrls, function () {\n\n\t\t\t\t\t\thdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );\n\n\t\t\t\t\t\thdrCubeMap.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\thdrCubeMap.needsUpdate = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst ldrUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\t\t\t\tldrCubeMap = new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( './textures/cube/pisa/' )\n\t\t\t\t\t.load( ldrUrls, function () {\n\n\t\t\t\t\t\tldrCubeRenderTarget = pmremGenerator.fromCubemap( ldrCubeMap );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\tconst rgbmUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\t\t\t\trgbmCubeMap = new RGBMLoader().setMaxRange( 16 )\n\t\t\t\t\t.setPath( './textures/cube/pisaRGBM16/' )\n\t\t\t\t\t.loadCubemap( rgbmUrls, function () {\n\n\t\t\t\t\t\trgbmCubeRenderTarget = pmremGenerator.fromCubemap( rgbmCubeMap );\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tpmremGenerator.compileCubemapShader();\n\n\t\t\t\tconst envScene = new DebugEnvironment();\n\t\t\t\tgeneratedCubeRenderTarget = pmremGenerator.fromScene( envScene );\n\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//renderer.toneMapping = ReinhardToneMapping;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 50;\n\t\t\t\tcontrols.maxDistance = 300;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'envMap', [ 'Generated', 'LDR', 'HDR', 'RGBM16' ] );\n\t\t\t\tgui.add( params, 'roughness', 0, 1, 0.01 );\n\t\t\t\tgui.add( params, 'metalness', 0, 1, 0.01 );\n\t\t\t\tgui.add( params, 'exposure', 0, 2, 0.01 );\n\t\t\t\tgui.add( params, 'debug' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttorusMesh.material.roughness = params.roughness;\n\t\t\t\ttorusMesh.material.metalness = params.metalness;\n\n\t\t\t\tlet renderTarget, cubeMap;\n\n\t\t\t\tswitch ( params.envMap ) {\n\n\t\t\t\t\tcase 'Generated':\n\t\t\t\t\t\trenderTarget = generatedCubeRenderTarget;\n\t\t\t\t\t\tcubeMap = generatedCubeRenderTarget.texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LDR':\n\t\t\t\t\t\trenderTarget = ldrCubeRenderTarget;\n\t\t\t\t\t\tcubeMap = ldrCubeMap;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'HDR':\n\t\t\t\t\t\trenderTarget = hdrCubeRenderTarget;\n\t\t\t\t\t\tcubeMap = hdrCubeMap;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'RGBM16':\n\t\t\t\t\t\trenderTarget = rgbmCubeRenderTarget;\n\t\t\t\t\t\tcubeMap = rgbmCubeMap;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tconst newEnvMap = renderTarget ? renderTarget.texture : null;\n\n\t\t\t\tif ( newEnvMap && newEnvMap !== torusMesh.material.envMap ) {\n\n\t\t\t\t\ttorusMesh.material.envMap = newEnvMap;\n\t\t\t\t\ttorusMesh.material.needsUpdate = true;\n\n\t\t\t\t\tplaneMesh.material.map = newEnvMap;\n\t\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\ttorusMesh.rotation.y += 0.005;\n\t\t\t\tplaneMesh.visible = params.debug;\n\n\t\t\t\tscene.background = cubeMap;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example threejs - High dynamic range (RGBE) Image-based Lighting (IBL) using run-time generated pre-filtered roughness mipmaps (PMREM) Created by Prashant Sharma and Ben Houston ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - matcap"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - matcap:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n\n\t\t\tlet mesh, renderer, scene, camera;\n\n\t\t\tconst API = {\n\t\t\t\tcolor: 0xffffff, // sRGB\n\t\t\t\texposure: 1.0\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// tone mapping\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t \trenderer.toneMappingExposure = API.exposure;\n\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 13 );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// manager\n\t\t\t\tconst manager = new THREE.LoadingManager( render );\n\n\t\t\t\t// matcap\n\t\t\t\tconst loaderEXR = new EXRLoader( manager );\n\t\t\t\tconst matcap = loaderEXR.load( 'textures/matcaps/040full.exr' );\n\n\t\t\t\t// normalmap\n\t\t\t\tconst loader = new THREE.TextureLoader( manager );\n\n\t\t\t\tconst normalmap = loader.load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' );\n\n\t\t\t\t// model\n\t\t\t\tnew GLTFLoader( manager ).load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.position.y = - 0.25;\n\n\t\t\t\t\tmesh.material = new THREE.MeshMatcapMaterial( {\n\n\t\t\t\t\t\tcolor: new THREE.Color().setHex( API.color ),\n\t\t\t\t\t\tmatcap: matcap,\n\t\t\t\t\t\tnormalMap: normalmap\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// gui\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( API, 'color' )\n\t\t\t\t\t.listen()\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmesh.material.color.set( API.color );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( API, 'exposure', 0, 2 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = API.exposure;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.domElement.style.webkitUserSelect = 'none';\n\n\t\t\t\t// drag 'n drop\n\t\t\t\tinitDragAndDrop();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\t\t\t// drag and drop anywhere in document\n\t\t\t//\n\n\t\t\tfunction updateMatcap( texture ) {\n\n\t\t\t\tif ( mesh.material.matcap ) {\n\n\t\t\t\t\tmesh.material.matcap.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tmesh.material.matcap = texture;\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tmesh.material.needsUpdate = true; // because the color space can change\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction handleJPG( event ) { // PNG, WebP, AVIF, too\n\n\t\t\t\tfunction imgCallback( event ) {\n\n\t\t\t\t\tconst texture = new THREE.Texture( event.target );\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tupdateMatcap( texture );\n\n\t\t\t\t}\n\n\t\t\t\tconst img = new Image();\n\n\t\t\t\timg.onload = imgCallback;\n\n\t\t\t\timg.src = event.target.result;\n\n\t\t\t}\n\n\t\t\tfunction handleEXR( event ) {\n\n\t\t\t\tconst contents = event.target.result;\n\n\t\t\t\tconst loader = new EXRLoader();\n\n\t\t\t\tloader.setDataType( THREE.HalfFloatType );\n\n\t\t\t\tconst texData = loader.parse( contents );\n\n\t\t\t\tconst texture = new THREE.DataTexture();\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\ttexture.format = texData.format;\n\t\t\t\ttexture.type = texData.type;\n\t\t\t\ttexture.colorSpace = THREE.LinearSRGBColorSpace;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttexture.flipY = false;\n\n\t\t\t\tupdateMatcap( texture );\n\n\t\t\t}\n\n\t\t\tfunction loadFile( file ) {\n\n\t\t\t\tconst filename = file.name;\n\t\t\t\tconst extension = filename.split( '.' ).pop().toLowerCase();\n\n\t\t\t\tif ( extension === 'exr' ) {\n\n\t\t\t\t\tconst reader = new FileReader();\n\n\t\t\t\t\treader.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\t\thandleEXR( event );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treader.readAsArrayBuffer( file );\n\n\t\t\t\t} else { // 'jpg', 'png'\n\n\t\t\t\t\tconst reader = new FileReader();\n\n\t\t\t\t\treader.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\t\thandleJPG( event );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treader.readAsDataURL( file );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initDragAndDrop() {\n\n\t\t\t\tdocument.addEventListener( 'dragover', function ( event ) {\n\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.dataTransfer.dropEffect = 'copy';\n\n\t\t\t\t} );\n\n\t\t\t\tdocument.addEventListener( 'drop', function ( event ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\tloadFile( event.dataTransfer.files[ 0 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - webgl materials matcap Drag-and-drop JPG, PNG, WebP, AVIF, or EXR MatCap image files"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - normal map [Lee Perry-Smith]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - normal map [Lee Perry-Smith]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { BleachBypassShader } from 'three/addons/shaders/BleachBypassShader.js';\n\t\t\timport { ColorCorrectionShader } from 'three/addons/shaders/ColorCorrectionShader.js';\n\t\t\timport { FXAAPass } from 'three/addons/postprocessing/FXAAPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet container, loader;\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tlet mesh;\n\n\t\t\tlet directionalLight, pointLight, ambientLight;\n\n\t\t\tlet composer;\n\n\t\t\tconst params = {\n\t\t\t\tenableNormalMap: true,\n\t\t\t\tnormalScale: 1\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 12;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x494949 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tambientLight = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tpointLight = new THREE.PointLight( 0xffffff, 30 );\n\t\t\t\tpointLight.position.set( 0, 0, 6 );\n\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tdirectionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 1, - 0.5, - 1 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst diffuseMap = textureLoader.load( 'models/gltf/LeePerrySmith/Map-COL.jpg' );\n\t\t\t\tdiffuseMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst specularMap = textureLoader.load( 'models/gltf/LeePerrySmith/Map-SPEC.jpg' );\n\t\t\t\tspecularMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst normalMap = textureLoader.load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' );\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xefefef,\n\t\t\t\t\tspecular: 0x222222,\n\t\t\t\t\tshininess: 35,\n\t\t\t\t\tmap: diffuseMap,\n\t\t\t\t\tspecularMap: specularMap,\n\t\t\t\t\tnormalMap: normalMap,\n\t\t\t\t\tnormalScale: new THREE.Vector2( params.normalScale, params.normalScale )\n\t\t\t\t} );\n\n\t\t\t\tloader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tconst geometry = gltf.scene.children[ 0 ].geometry;\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.y = - 0.5;\n\n\t\t\t\t\tscene.add( mesh );\n\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// COMPOSER\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tconst renderModel = new RenderPass( scene, camera );\n\n\t\t\t\tconst effectBleach = new ShaderPass( BleachBypassShader );\n\t\t\t\tconst effectColor = new ShaderPass( ColorCorrectionShader );\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tconst effectFXAA = new FXAAPass();\n\n\t\t\t\teffectBleach.uniforms[ 'opacity' ].value = 0.2;\n\n\t\t\t\teffectColor.uniforms[ 'powRGB' ].value.set( 1.4, 1.45, 1.45 );\n\t\t\t\teffectColor.uniforms[ 'mulRGB' ].value.set( 1.1, 1.1, 1.1 );\n\n\t\t\t\tconst renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType, depthTexture: new THREE.DepthTexture() } );\n\n\t\t\t\tcomposer = new EffectComposer( renderer, renderTarget );\n\n\t\t\t\tcomposer.addPass( renderModel );\n\t\t\t\tcomposer.addPass( effectBleach );\n\t\t\t\tcomposer.addPass( effectColor );\n\t\t\t\tcomposer.addPass( outputPass );\n\t\t\t\tcomposer.addPass( effectFXAA );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'enableNormalMap' ).name( 'enable normal map' ).onChange( ( value ) => {\n\n\t\t\t\t\tmaterial.normalMap = ( value === true ) ? normalMap : null;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'normalScale', 0, 2 ).name( 'normal scale' ).onChange( ( value )=> material.normalScale.setScalar( value ) );\n\t\t\t\tgui.open();\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 8;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example three.js - webgl normalmap demo. Lee Perry-Smith head."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - normal map [object space]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - normal map [object space]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 10, 0, 23 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// ambient\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 0.6 ) );\n\n\t\t\t\t// light\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 4.5, 0, 0 );\n\t\t\t\tcamera.add( light );\n\n\t\t\t\t// model\n\t\t\t\tnew GLTFLoader().load( 'models/gltf/Nefertiti/Nefertiti.glb', function ( gltf ) {\n\n\t\t\t\t\tgltf.scene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t// glTF currently supports only tangent-space normal maps.\n\t\t\t\t\t\t\t// this model has been modified to demonstrate the use of an object-space normal map.\n\n\t\t\t\t\t\t\tchild.material.normalMapType = THREE.ObjectSpaceNormalMap;\n\n\t\t\t\t\t\t\t// attribute normals are not required with an object-space normal map. remove them.\n\n\t\t\t\t\t\t\tchild.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tchild.material.side = THREE.DoubleSide;\n\n\t\t\t\t\t\t\tchild.scale.multiplyScalar( 0.5 );\n\n\t\t\t\t\t\t\t// recenter\n\n\t\t\t\t\t\t\tnew THREE.Box3().setFromObject( child ).getCenter( child.position ).multiplyScalar( - 1 );\n\n\t\t\t\t\t\t\tscene.add( child );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl object-space normalmap demo Nefertiti Bust by CultLab3D"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - clearcoat"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - clearcoat:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';\n\n\t\t\timport { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet particleLight;\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.25, 50 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tnew HDRCubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/pisaHDR/' )\n\t\t\t\t\t.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],\n\t\t\t\t\t\tfunction ( texture ) {\n\n\t\t\t\t\t\t\tconst geometry = new THREE.SphereGeometry( .8, 64, 32 );\n\n\t\t\t\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\t\t\t\tconst diffuse = textureLoader.load( 'textures/carbon/Carbon.png' );\n\t\t\t\t\t\t\tdiffuse.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\t\tdiffuse.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tdiffuse.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tdiffuse.repeat.x = 10;\n\t\t\t\t\t\t\tdiffuse.repeat.y = 10;\n\n\t\t\t\t\t\t\tconst normalMap = textureLoader.load( 'textures/carbon/Carbon_Normal.png' );\n\t\t\t\t\t\t\tnormalMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap.repeat.x = 10;\n\t\t\t\t\t\t\tnormalMap.repeat.y = 10;\n\n\t\t\t\t\t\t\tconst normalMap2 = textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\n\n\t\t\t\t\t\t\tconst normalMap3 = new THREE.CanvasTexture( new FlakesTexture() );\n\t\t\t\t\t\t\tnormalMap3.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap3.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap3.repeat.x = 10;\n\t\t\t\t\t\t\tnormalMap3.repeat.y = 6;\n\t\t\t\t\t\t\tnormalMap3.anisotropy = 16;\n\n\t\t\t\t\t\t\tconst normalMap4 = textureLoader.load( 'textures/golfball.jpg' );\n\n\t\t\t\t\t\t\tconst clearcoatNormalMap = textureLoader.load( 'textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png' );\n\n\t\t\t\t\t\t\t// car paint\n\n\t\t\t\t\t\t\tlet material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tclearcoatRoughness: 0.1,\n\t\t\t\t\t\t\t\tmetalness: 0.9,\n\t\t\t\t\t\t\t\troughness: 0.5,\n\t\t\t\t\t\t\t\tcolor: 0x0000ff,\n\t\t\t\t\t\t\t\tnormalMap: normalMap3,\n\t\t\t\t\t\t\t\tnormalScale: new THREE.Vector2( 0.15, 0.15 )\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tlet mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = - 1;\n\t\t\t\t\t\t\tmesh.position.y = 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// fibers\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\troughness: 0.5,\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tclearcoatRoughness: 0.1,\n\t\t\t\t\t\t\t\tmap: diffuse,\n\t\t\t\t\t\t\t\tnormalMap: normalMap\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = 1;\n\t\t\t\t\t\t\tmesh.position.y = 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// golf\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tmetalness: 0.0,\n\t\t\t\t\t\t\t\troughness: 0.1,\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tnormalMap: normalMap4,\n\t\t\t\t\t\t\t\tclearcoatNormalMap: clearcoatNormalMap,\n\n\t\t\t\t\t\t\t\t// y scale is negated to compensate for normal map handedness.\n\t\t\t\t\t\t\t\tclearcoatNormalScale: new THREE.Vector2( 2.0, - 2.0 )\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = - 1;\n\t\t\t\t\t\t\tmesh.position.y = - 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// clearcoat + normalmap\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tmetalness: 1.0,\n\t\t\t\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\t\t\t\tnormalMap: normalMap2,\n\t\t\t\t\t\t\t\tnormalScale: new THREE.Vector2( 0.15, 0.15 ),\n\t\t\t\t\t\t\t\tclearcoatNormalMap: clearcoatNormalMap,\n\n\t\t\t\t\t\t\t\t// y scale is negated to compensate for normal map handedness.\n\t\t\t\t\t\t\t\tclearcoatNormalScale: new THREE.Vector2( 2.0, - 2.0 )\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = 1;\n\t\t\t\t\t\t\tmesh.position.y = - 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t);\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tparticleLight = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( .05, 8, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff } )\n\t\t\t\t);\n\t\t\t\tscene.add( particleLight );\n\n\t\t\t\tparticleLight.add( new THREE.PointLight( 0xffffff, 30 ) );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.25;\n\n\t\t\t\t//\n\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 30;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\t\t\t\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.00025;\n\n\t\t\t\tparticleLight.position.x = Math.sin( timer * 7 ) * 3;\n\t\t\t\tparticleLight.position.y = Math.cos( timer * 5 ) * 4;\n\t\t\t\tparticleLight.position.z = Math.cos( timer * 3 ) * 3;\n\n\t\t\t\tfor ( let i = 0; i < group.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = group.children[ i ];\n\t\t\t\t\tchild.rotation.y += 0.005;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - materials - clearcoat"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates threejs webgl - materials - transmission"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for threejs webgl - materials - transmission:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tconst params = {\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\ttransmission: 1,\n\t\t\t\topacity: 1,\n\t\t\t\tmetalness: 0,\n\t\t\t\troughness: 0,\n\t\t\t\tior: 1.5,\n\t\t\t\tthickness: 0.01,\n\t\t\t\tspecularIntensity: 1,\n\t\t\t\tspecularColor: 0xffffff,\n\t\t\t\tenvMapIntensity: 1,\n\t\t\t\tlightIntensity: 1,\n\t\t\t\texposure: 1,\n\t\t\t\ttransmissionResolutionScale: 1\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mesh;\n\n\t\t\tconst hdrEquirect = new RGBELoader()\n\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t.load( 'royal_esplanade_1k.hdr', function () {\n\n\t\t\t\t\thdrEquirect.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\tinit();\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 0, 0, 120 );\n\n\t\t\t\t//\n\n\t\t\t\tscene.background = hdrEquirect;\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 20, 64, 32 );\n\n\t\t\t\tconst texture = new THREE.CanvasTexture( generateTexture() );\n\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.repeat.set( 1, 3.5 );\n\n\t\t\t\tconst material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\tcolor: params.color,\n\t\t\t\t\tmetalness: params.metalness,\n\t\t\t\t\troughness: params.roughness,\n\t\t\t\t\tior: params.ior,\n\t\t\t\t\talphaMap: texture,\n\t\t\t\t\tenvMap: hdrEquirect,\n\t\t\t\t\tenvMapIntensity: params.envMapIntensity,\n\t\t\t\t\ttransmission: params.transmission, // use material.transmission for glass materials\n\t\t\t\t\tspecularIntensity: params.specularIntensity,\n\t\t\t\t\tspecularColor: params.specularColor,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 150;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( params, 'color' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.color.set( params.color );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'transmission', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.transmission = params.transmission;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'opacity', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.opacity = params.opacity;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'metalness', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.metalness = params.metalness;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'roughness', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.roughness = params.roughness;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'ior', 1, 2, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.ior = params.ior;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'thickness', 0, 5, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.thickness = params.thickness;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'specularIntensity', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.specularIntensity = params.specularIntensity;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'specularColor' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.specularColor.set( params.specularColor );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'envMapIntensity', 0, 1, 0.01 )\n\t\t\t\t\t.name( 'envMap intensity' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.envMapIntensity = params.envMapIntensity;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'exposure', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'transmissionResolutionScale', 0.01, 1, 0.01 )\n\t\t\t\t\t.name( 'transmission resolution' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\trenderer.transmissionResolutionScale = params.transmissionResolutionScale;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction generateTexture() {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 2;\n\t\t\t\tcanvas.height = 2;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 1, 2, 1 );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example threejs - Transmission"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates threejs webgl - materials - transmission - alpha"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for threejs webgl - materials - transmission - alpha:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tconst params = {\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\ttransmission: 1,\n\t\t\t\topacity: 1,\n\t\t\t\tmetalness: 0,\n\t\t\t\troughness: 0,\n\t\t\t\tior: 1.5,\n\t\t\t\tthickness: 0.01,\n\t\t\t\tattenuationColor: 0xffffff,\n\t\t\t\tattenuationDistance: 1,\n\t\t\t\tspecularIntensity: 1,\n\t\t\t\tspecularColor: 0xffffff,\n\t\t\t\tenvMapIntensity: 1,\n\t\t\t\tlightIntensity: 1,\n\t\t\t\texposure: 1\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mesh, material;\n\n\t\t\tconst hdrEquirect = new RGBELoader()\n\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t.load( 'royal_esplanade_1k.hdr', function () {\n\n\t\t\t\t\thdrEquirect.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t\t.setPath( 'models/gltf/' )\n\t\t\t\t\t\t.load( 'DragonAttenuation.glb', function ( gltf ) {\n\n\t\t\t\t\t\t\tgltf.scene.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\tif ( child.isMesh && child.material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\t\t\t\t\tmesh = child;\n\t\t\t\t\t\t\t\t\tmaterial = mesh.material;\n\n\t\t\t\t\t\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\t\t\t\t\t\tparams.color = color.copy( mesh.material.color ).getHex();\n\t\t\t\t\t\t\t\t\tparams.roughness = mesh.material.roughness;\n\t\t\t\t\t\t\t\t\tparams.metalness = mesh.material.metalness;\n\n\t\t\t\t\t\t\t\t\tparams.ior = mesh.material.ior;\n\t\t\t\t\t\t\t\t\tparams.specularIntensity = mesh.material.specularIntensity;\n\n\t\t\t\t\t\t\t\t\tparams.transmission = mesh.material.transmission;\n\t\t\t\t\t\t\t\t\tparams.thickness = mesh.material.thickness;\n\t\t\t\t\t\t\t\t\tparams.attenuationColor = color.copy( mesh.material.attenuationColor ).getHex();\n\t\t\t\t\t\t\t\t\tparams.attenuationDistance = mesh.material.attenuationDistance;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tinit();\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\tscene.environment = hdrEquirect;\n\t\t\t\t\t\t\t//scene.background = hdrEquirect;\n\n\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\t// accommodate CSS table\n\t\t\t\trenderer.domElement.style.position = 'absolute';\n\t\t\t\trenderer.domElement.style.top = 0;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( - 5, 0.5, 0 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 20;\n\t\t\t\tcontrols.target.y = 0.5;\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( params, 'color' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.color.set( params.color );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'transmission', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.transmission = params.transmission;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'opacity', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.opacity = params.opacity;\n\t\t\t\t\t\tconst transparent = params.opacity < 1;\n\n\t\t\t\t\t\tif ( transparent !== material.transparent ) {\n\n\t\t\t\t\t\t\tmaterial.transparent = transparent;\n\t\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'metalness', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.metalness = params.metalness;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'roughness', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.roughness = params.roughness;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'ior', 1, 2, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.ior = params.ior;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'thickness', 0, 5, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.thickness = params.thickness;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'attenuationColor' )\n\t\t\t\t\t.name( 'attenuation color' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.attenuationColor.set( params.attenuationColor );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'attenuationDistance', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.attenuationDistance = params.attenuationDistance;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'specularIntensity', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.specularIntensity = params.specularIntensity;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'specularColor' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.specularColor.set( params.specularColor );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'envMapIntensity', 0, 1, 0.01 )\n\t\t\t\t\t.name( 'envMap intensity' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.envMapIntensity = params.envMapIntensity;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'exposure', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example threejs - transmission - alpha"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - Fast subsurface scattering in Blinn-Phong shading demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - Fast subsurface scattering in Blinn-Phong shading demo:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { SubsurfaceScatteringShader } from 'three/addons/shaders/SubsurfaceScatteringShader.js';\n\t\timport { FBXLoader } from 'three/addons/loaders/FBXLoader.js';\n\n\t\tlet container, stats;\n\t\tlet camera, scene, renderer;\n\t\tlet model;\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcontainer = document.createElement( 'div' );\n\t\t\tdocument.body.appendChild( container );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\tcamera.position.set( 0.0, 300, 400 * 4 );\n\n\t\t\tscene = new THREE.Scene();\n\n\t\t\t// Lights\n\n\t\t\tscene.add( new THREE.AmbientLight( 0xc1c1c1 ) );\n\n\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 0.03 );\n\t\t\tdirectionalLight.position.set( 0.0, 0.5, 0.5 ).normalize();\n\t\t\tscene.add( directionalLight );\n\n\t\t\tconst pointLight1 = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xc1c1c1 } ) );\n\t\t\tpointLight1.add( new THREE.PointLight( 0xc1c1c1, 4.0, 300, 0 ) );\n\t\t\tscene.add( pointLight1 );\n\t\t\tpointLight1.position.x = 0;\n\t\t\tpointLight1.position.y = - 50;\n\t\t\tpointLight1.position.z = 350;\n\n\t\t\tconst pointLight2 = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xc1c100 } ) );\n\t\t\tpointLight2.add( new THREE.PointLight( 0xc1c100, 0.75, 500, 0 ) );\n\t\t\tscene.add( pointLight2 );\n\t\t\tpointLight2.position.x = - 100;\n\t\t\tpointLight2.position.y = 20;\n\t\t\tpointLight2.position.z = - 260;\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\tconst controls = new OrbitControls( camera, container );\n\t\t\tcontrols.minDistance = 500;\n\t\t\tcontrols.maxDistance = 3000;\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tinitMaterial();\n\n\t\t}\n\n\t\tfunction initMaterial() {\n\n\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\tconst imgTexture = loader.load( 'models/fbx/white.jpg' );\n\t\t\timgTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tconst thicknessTexture = loader.load( 'models/fbx/bunny_thickness.jpg' );\n\t\t\timgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\tconst shader = SubsurfaceScatteringShader;\n\t\t\tconst uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tuniforms[ 'map' ].value = imgTexture;\n\n\t\t\tuniforms[ 'diffuse' ].value = new THREE.Vector3( 1.0, 0.2, 0.2 );\n\t\t\tuniforms[ 'shininess' ].value = 500;\n\n\t\t\tuniforms[ 'thicknessMap' ].value = thicknessTexture;\n\t\t\tuniforms[ 'thicknessColor' ].value = new THREE.Vector3( 0.5, 0.3, 0.0 );\n\t\t\tuniforms[ 'thicknessDistortion' ].value = 0.1;\n\t\t\tuniforms[ 'thicknessAmbient' ].value = 0.4;\n\t\t\tuniforms[ 'thicknessAttenuation' ].value = 0.8;\n\t\t\tuniforms[ 'thicknessPower' ].value = 2.0;\n\t\t\tuniforms[ 'thicknessScale' ].value = 16.0;\n\n\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tlights: true\n\t\t\t} );\n\n\t\t\t// LOADER\n\n\t\t\tconst loaderFBX = new FBXLoader();\n\t\t\tloaderFBX.load( 'models/fbx/stanford-bunny.fbx', function ( object ) {\n\n\t\t\t\tmodel = object.children[ 0 ];\n\t\t\t\tmodel.position.set( 0, 0, 10 );\n\t\t\t\tmodel.scale.setScalar( 1 );\n\t\t\t\tmodel.material = material;\n\t\t\t\tscene.add( model );\n\n\t\t\t} );\n\n\t\t\tinitGUI( uniforms );\n\n\t\t}\n\n\t\tfunction initGUI( uniforms ) {\n\n\t\t\tconst gui = new GUI( { title: 'Thickness Control' } );\n\n\t\t\tconst ThicknessControls = function () {\n\n\t\t\t\tthis.distortion = uniforms[ 'thicknessDistortion' ].value;\n\t\t\t\tthis.ambient = uniforms[ 'thicknessAmbient' ].value;\n\t\t\t\tthis.attenuation = uniforms[ 'thicknessAttenuation' ].value;\n\t\t\t\tthis.power = uniforms[ 'thicknessPower' ].value;\n\t\t\t\tthis.scale = uniforms[ 'thicknessScale' ].value;\n\n\t\t\t};\n\n\t\t\tconst thicknessControls = new ThicknessControls();\n\n\t\t\tgui.add( thicknessControls, 'distortion' ).min( 0.01 ).max( 1 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\tuniforms[ 'thicknessDistortion' ].value = thicknessControls.distortion;\n\t\t\t\tconsole.log( 'distortion' );\n\n\t\t\t} );\n\n\t\t\tgui.add( thicknessControls, 'ambient' ).min( 0.01 ).max( 5.0 ).step( 0.05 ).onChange( function () {\n\n\t\t\t\tuniforms[ 'thicknessAmbient' ].value = thicknessControls.ambient;\n\n\t\t\t} );\n\n\t\t\tgui.add( thicknessControls, 'attenuation' ).min( 0.01 ).max( 5.0 ).step( 0.05 ).onChange( function () {\n\n\t\t\t\tuniforms[ 'thicknessAttenuation' ].value = thicknessControls.attenuation;\n\n\t\t\t} );\n\n\t\t\tgui.add( thicknessControls, 'power' ).min( 0.01 ).max( 16.0 ).step( 0.1 ).onChange( function () {\n\n\t\t\t\tuniforms[ 'thicknessPower' ].value = thicknessControls.power;\n\n\t\t\t} );\n\n\t\t\tgui.add( thicknessControls, 'scale' ).min( 0.01 ).max( 50.0 ).step( 0.1 ).onChange( function () {\n\n\t\t\t\tuniforms[ 'thicknessScale' ].value = thicknessControls.scale;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction animate() {\n\n\t\t\trender();\n\n\t\t\tstats.update();\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\tif ( model ) model.rotation.y = performance.now() / 5000;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js Fast subsurface scattering in Blinn-Phong shading demo [Thanks for the art support from Shaochun Lin ]"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - anisotropic texture filtering"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - anisotropic texture filtering:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tconst SCREEN_WIDTH = window.innerWidth;\n\t\t\tconst SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene1, scene2, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tconst windowHalfX = window.innerWidth / 2;\n\t\t\tconst windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 25000 );\n\t\t\t\tcamera.position.z = 1500;\n\n\t\t\t\tscene1 = new THREE.Scene();\n\t\t\t\tscene1.background = new THREE.Color( 0xf2f7ff );\n\t\t\t\tscene1.fog = new THREE.Fog( 0xf2f7ff, 1, 25000 );\n\n\t\t\t\tscene2 = new THREE.Scene();\n\t\t\t\tscene2.background = new THREE.Color( 0xf2f7ff );\n\t\t\t\tscene2.fog = new THREE.Fog( 0xf2f7ff, 1, 25000 );\n\n\t\t\t\tscene1.add( new THREE.AmbientLight( 0xeef0ff, 3 ) );\n\t\t\t\tscene2.add( new THREE.AmbientLight( 0xeef0ff, 3 ) );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xffffff, 6 );\n\t\t\t\tlight1.position.set( 1, 1, 1 );\n\t\t\t\tscene1.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffffff, 6 );\n\t\t\t\tlight2.position.set( 1, 1, 1 );\n\t\t\t\tscene2.add( light2 );\n\n\t\t\t\t// GROUND\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst maxAnisotropy = renderer.capabilities.getMaxAnisotropy();\n\n\t\t\t\tconst texture1 = textureLoader.load( 'textures/crate.gif' );\n\t\t\t\tconst material1 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture1 } );\n\n\t\t\t\ttexture1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture1.anisotropy = maxAnisotropy;\n\t\t\t\ttexture1.wrapS = texture1.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture1.repeat.set( 512, 512 );\n\n\t\t\t\tconst texture2 = textureLoader.load( 'textures/crate.gif' );\n\t\t\t\tconst material2 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture2 } );\n\n\t\t\t\ttexture2.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture2.anisotropy = 1;\n\t\t\t\ttexture2.wrapS = texture2.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture2.repeat.set( 512, 512 );\n\n\t\t\t\tif ( maxAnisotropy > 0 ) {\n\n\t\t\t\t\tdocument.getElementById( 'val_left' ).innerHTML = texture1.anisotropy;\n\t\t\t\t\tdocument.getElementById( 'val_right' ).innerHTML = texture2.anisotropy;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdocument.getElementById( 'val_left' ).innerHTML = 'not supported';\n\t\t\t\t\tdocument.getElementById( 'val_right' ).innerHTML = 'not supported';\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh1.scale.set( 1000, 1000, 1000 );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh2.scale.set( 1000, 1000, 1000 );\n\n\t\t\t\tscene1.add( mesh1 );\n\t\t\t\tscene2.add( mesh2 );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// STATS1\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t}\n\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y = THREE.MathUtils.clamp( camera.position.y + ( - ( mouseY - 200 ) - camera.position.y ) * .05, 50, 1000 );\n\n\t\t\t\tcamera.lookAt( scene1.position );\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene1, camera );\n\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene2, camera );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\n\t\t\t}\n```\n\nThis example three.js - anisotropic texture filtering example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - canvas texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - canvas texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer, mesh, material;\n\t\t\tconst drawStartPos = new THREE.Vector2();\n\n\t\t\tinit();\n\t\t\tsetupCanvasDrawing();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\n\t\t\t\tmesh = new THREE.Mesh( new THREE.BoxGeometry( 200, 200, 200 ), material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t// Sets up the drawing canvas and adds it as the material map\n\n\t\t\tfunction setupCanvasDrawing() {\n\n\t\t\t\t// get canvas and context\n\n\t\t\t\tconst drawingCanvas = document.getElementById( 'drawing-canvas' );\n\t\t\t\tconst drawingContext = drawingCanvas.getContext( '2d' );\n\n\t\t\t\t// draw white background\n\n\t\t\t\tdrawingContext.fillStyle = '#FFFFFF';\n\t\t\t\tdrawingContext.fillRect( 0, 0, 128, 128 );\n\n\t\t\t\t// set canvas as material.map (this could be done to any map, bump, displacement etc.)\n\n\t\t\t\tmaterial.map = new THREE.CanvasTexture( drawingCanvas );\n\n\t\t\t\t// set the variable to keep track of when to draw\n\n\t\t\t\tlet paint = false;\n\n\t\t\t\t// add canvas event listeners\n\t\t\t\tdrawingCanvas.addEventListener( 'pointerdown', function ( e ) {\n\n\t\t\t\t\tpaint = true;\n\t\t\t\t\tdrawStartPos.set( e.offsetX, e.offsetY );\n\n\t\t\t\t} );\n\n\t\t\t\tdrawingCanvas.addEventListener( 'pointermove', function ( e ) {\n\n\t\t\t\t\tif ( paint ) draw( drawingContext, e.offsetX, e.offsetY );\n\n\t\t\t\t} );\n\n\t\t\t\tdrawingCanvas.addEventListener( 'pointerup', function () {\n\n\t\t\t\t\tpaint = false;\n\n\t\t\t\t} );\n\n\t\t\t\tdrawingCanvas.addEventListener( 'pointerleave', function () {\n\n\t\t\t\t\tpaint = false;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction draw( drawContext, x, y ) {\n\n\t\t\t\tdrawContext.moveTo( drawStartPos.x, drawStartPos.y );\n\t\t\t\tdrawContext.strokeStyle = '#000000';\n\t\t\t\tdrawContext.lineTo( x, y );\n\t\t\t\tdrawContext.stroke();\n\t\t\t\t// reset drawing start position to current position.\n\t\t\t\tdrawStartPos.set( x, y );\n\t\t\t\t// need to flag the map as needing updating.\n\t\t\t\tmaterial.map.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.x += 0.01;\n\t\t\t\tmesh.rotation.y += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl - canvas as a texture click and draw in the white box"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - texture filtering"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - texture filtering:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tconst SCREEN_WIDTH = window.innerWidth;\n\t\t\tconst SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, scene2, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tconst windowHalfX = window.innerWidth / 2;\n\t\t\tconst windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 5000 );\n\t\t\t\tcamera.position.z = 1500;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x000000 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1500, 4000 );\n\n\t\t\t\tscene2 = new THREE.Scene();\n\t\t\t\tscene2.background = new THREE.Color( 0x000000 );\n\t\t\t\tscene2.fog = new THREE.Fog( 0x000000, 1500, 4000 );\n\n\t\t\t\t// GROUND\n\n\t\t\t\tconst imageCanvas = document.createElement( 'canvas' );\n\t\t\t\tconst context = imageCanvas.getContext( '2d' );\n\n\t\t\t\timageCanvas.width = imageCanvas.height = 128;\n\n\t\t\t\tcontext.fillStyle = '#444';\n\t\t\t\tcontext.fillRect( 0, 0, 128, 128 );\n\n\t\t\t\tcontext.fillStyle = '#fff';\n\t\t\t\tcontext.fillRect( 0, 0, 64, 64 );\n\t\t\t\tcontext.fillRect( 64, 64, 64, 64 );\n\n\t\t\t\tconst textureCanvas = new THREE.CanvasTexture( imageCanvas );\n\t\t\t\ttextureCanvas.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttextureCanvas.repeat.set( 1000, 1000 );\n\t\t\t\ttextureCanvas.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttextureCanvas.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst textureCanvas2 = textureCanvas.clone();\n\t\t\t\ttextureCanvas2.magFilter = THREE.NearestFilter;\n\t\t\t\ttextureCanvas2.minFilter = THREE.NearestFilter;\n\t\t\t\ttextureCanvas2.generateMipmaps = false;\n\n\t\t\t\tconst materialCanvas = new THREE.MeshBasicMaterial( { map: textureCanvas } );\n\t\t\t\tconst materialCanvas2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: textureCanvas2 } );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\n\t\t\t\tconst meshCanvas = new THREE.Mesh( geometry, materialCanvas );\n\t\t\t\tmeshCanvas.rotation.x = - Math.PI / 2;\n\t\t\t\tmeshCanvas.scale.set( 1000, 1000, 1000 );\n\n\t\t\t\tconst meshCanvas2 = new THREE.Mesh( geometry, materialCanvas2 );\n\t\t\t\tmeshCanvas2.rotation.x = - Math.PI / 2;\n\t\t\t\tmeshCanvas2.scale.set( 1000, 1000, 1000 );\n\n\n\t\t\t\t// PAINTING\n\n\t\t\t\tconst callbackPainting = function () {\n\n\t\t\t\t\tconst image = texturePainting.image;\n\n\t\t\t\t\ttexturePainting2.image = image;\n\t\t\t\t\ttexturePainting2.needsUpdate = true;\n\n\t\t\t\t\tscene.add( meshCanvas );\n\t\t\t\t\tscene2.add( meshCanvas2 );\n\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, materialPainting );\n\t\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, materialPainting2 );\n\n\t\t\t\t\taddPainting( scene, mesh );\n\t\t\t\t\taddPainting( scene2, mesh2 );\n\n\t\t\t\t\tfunction addPainting( zscene, zmesh ) {\n\n\t\t\t\t\t\tzmesh.scale.x = image.width / 100;\n\t\t\t\t\t\tzmesh.scale.y = image.height / 100;\n\n\t\t\t\t\t\tzscene.add( zmesh );\n\n\t\t\t\t\t\tconst meshFrame = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );\n\t\t\t\t\t\tmeshFrame.position.z = - 10.0;\n\t\t\t\t\t\tmeshFrame.scale.x = 1.1 * image.width / 100;\n\t\t\t\t\t\tmeshFrame.scale.y = 1.1 * image.height / 100;\n\t\t\t\t\t\tzscene.add( meshFrame );\n\n\t\t\t\t\t\tconst meshShadow = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.75, transparent: true } ) );\n\t\t\t\t\t\tmeshShadow.position.y = - 1.1 * image.height / 2;\n\t\t\t\t\t\tmeshShadow.position.z = - 1.1 * image.height / 2;\n\t\t\t\t\t\tmeshShadow.rotation.x = - Math.PI / 2;\n\t\t\t\t\t\tmeshShadow.scale.x = 1.1 * image.width / 100;\n\t\t\t\t\t\tmeshShadow.scale.y = 1.1 * image.height / 100;\n\t\t\t\t\t\tzscene.add( meshShadow );\n\n\t\t\t\t\t\tconst floorHeight = - 1.117 * image.height / 2;\n\t\t\t\t\t\tmeshCanvas.position.y = meshCanvas2.position.y = floorHeight;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t};\n\n\t\t\t\tconst texturePainting = new THREE.TextureLoader().load( 'textures/758px-Canestra_di_frutta_(Caravaggio).jpg', callbackPainting );\n\t\t\t\tconst texturePainting2 = new THREE.Texture();\n\n\t\t\t\tconst materialPainting = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texturePainting } );\n\t\t\t\tconst materialPainting2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: texturePainting2 } );\n\n\t\t\t\ttexturePainting.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexturePainting2.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexturePainting2.minFilter = texturePainting2.magFilter = THREE.NearestFilter;\n\t\t\t\ttexturePainting.minFilter = texturePainting.magFilter = THREE.LinearFilter;\n\t\t\t\ttexturePainting.mapping = THREE.UVMapping;\n\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t}\n\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - ( mouseY - 200 ) - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene2, camera );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n```\n\nThis example three.js - texture filtering example painting by Caravaggio"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - manual mipmaping"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - manual mipmaping:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tconst SCREEN_WIDTH = window.innerWidth;\n\t\t\tconst SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene1, scene2, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tconst windowHalfX = window.innerWidth / 2;\n\t\t\tconst windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 5000 );\n\t\t\t\tcamera.position.z = 1500;\n\n\t\t\t\tscene1 = new THREE.Scene();\n\t\t\t\tscene1.background = new THREE.Color( 0x000000 );\n\t\t\t\tscene1.fog = new THREE.Fog( 0x000000, 1500, 4000 );\n\n\t\t\t\tscene2 = new THREE.Scene();\n\t\t\t\tscene2.background = new THREE.Color( 0x000000 );\n\t\t\t\tscene2.fog = new THREE.Fog( 0x000000, 1500, 4000 );\n\n\t\t\t\t// GROUND\n\n\t\t\t\tfunction mipmap( size, color ) {\n\n\t\t\t\t\tconst imageCanvas = document.createElement( 'canvas' );\n\t\t\t\t\tconst context = imageCanvas.getContext( '2d' );\n\n\t\t\t\t\timageCanvas.width = imageCanvas.height = size;\n\n\t\t\t\t\tcontext.fillStyle = '#444';\n\t\t\t\t\tcontext.fillRect( 0, 0, size, size );\n\n\t\t\t\t\tcontext.fillStyle = color;\n\t\t\t\t\tcontext.fillRect( 0, 0, size / 2, size / 2 );\n\t\t\t\t\tcontext.fillRect( size / 2, size / 2, size / 2, size / 2 );\n\t\t\t\t\treturn imageCanvas;\n\n\t\t\t\t}\n\n\t\t\t\tconst canvas = mipmap( 128, '#f00' );\n\t\t\t\tconst textureCanvas1 = new THREE.CanvasTexture( canvas );\n\t\t\t\ttextureCanvas1.mipmaps[ 0 ] = canvas;\n\t\t\t\ttextureCanvas1.mipmaps[ 1 ] = mipmap( 64, '#0f0' );\n\t\t\t\ttextureCanvas1.mipmaps[ 2 ] = mipmap( 32, '#00f' );\n\t\t\t\ttextureCanvas1.mipmaps[ 3 ] = mipmap( 16, '#400' );\n\t\t\t\ttextureCanvas1.mipmaps[ 4 ] = mipmap( 8, '#040' );\n\t\t\t\ttextureCanvas1.mipmaps[ 5 ] = mipmap( 4, '#004' );\n\t\t\t\ttextureCanvas1.mipmaps[ 6 ] = mipmap( 2, '#044' );\n\t\t\t\ttextureCanvas1.mipmaps[ 7 ] = mipmap( 1, '#404' );\n\t\t\t\ttextureCanvas1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttextureCanvas1.repeat.set( 1000, 1000 );\n\t\t\t\ttextureCanvas1.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttextureCanvas1.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst textureCanvas2 = textureCanvas1.clone();\n\t\t\t\ttextureCanvas2.magFilter = THREE.NearestFilter;\n\t\t\t\ttextureCanvas2.minFilter = THREE.NearestMipmapNearestFilter;\n\n\t\t\t\tconst materialCanvas1 = new THREE.MeshBasicMaterial( { map: textureCanvas1 } );\n\t\t\t\tconst materialCanvas2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: textureCanvas2 } );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\n\t\t\t\tconst meshCanvas1 = new THREE.Mesh( geometry, materialCanvas1 );\n\t\t\t\tmeshCanvas1.rotation.x = - Math.PI / 2;\n\t\t\t\tmeshCanvas1.scale.set( 1000, 1000, 1000 );\n\n\t\t\t\tconst meshCanvas2 = new THREE.Mesh( geometry, materialCanvas2 );\n\t\t\t\tmeshCanvas2.rotation.x = - Math.PI / 2;\n\t\t\t\tmeshCanvas2.scale.set( 1000, 1000, 1000 );\n\n\n\t\t\t\t// PAINTING\n\n\t\t\t\tconst callbackPainting = function () {\n\n\t\t\t\t\tconst image = texturePainting1.image;\n\n\t\t\t\t\ttexturePainting2.image = image;\n\t\t\t\t\ttexturePainting2.needsUpdate = true;\n\n\t\t\t\t\tscene1.add( meshCanvas1 );\n\t\t\t\t\tscene2.add( meshCanvas2 );\n\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, materialPainting1 );\n\t\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, materialPainting2 );\n\n\t\t\t\t\taddPainting( scene1, mesh1 );\n\t\t\t\t\taddPainting( scene2, mesh2 );\n\n\t\t\t\t\tfunction addPainting( zscene, zmesh ) {\n\n\t\t\t\t\t\tzmesh.scale.x = image.width / 100;\n\t\t\t\t\t\tzmesh.scale.y = image.height / 100;\n\n\t\t\t\t\t\tzscene.add( zmesh );\n\n\t\t\t\t\t\tconst meshFrame = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );\n\t\t\t\t\t\tmeshFrame.position.z = - 10.0;\n\t\t\t\t\t\tmeshFrame.scale.x = 1.1 * image.width / 100;\n\t\t\t\t\t\tmeshFrame.scale.y = 1.1 * image.height / 100;\n\t\t\t\t\t\tzscene.add( meshFrame );\n\n\t\t\t\t\t\tconst meshShadow = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.75, transparent: true } ) );\n\t\t\t\t\t\tmeshShadow.position.y = - 1.1 * image.height / 2;\n\t\t\t\t\t\tmeshShadow.position.z = - 1.1 * image.height / 2;\n\t\t\t\t\t\tmeshShadow.rotation.x = - Math.PI / 2;\n\t\t\t\t\t\tmeshShadow.scale.x = 1.1 * image.width / 100;\n\t\t\t\t\t\tmeshShadow.scale.y = 1.1 * image.height / 100;\n\t\t\t\t\t\tzscene.add( meshShadow );\n\n\t\t\t\t\t\tconst floorHeight = - 1.117 * image.height / 2;\n\t\t\t\t\t\tmeshCanvas1.position.y = meshCanvas2.position.y = floorHeight;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t};\n\n\t\t\t\tconst texturePainting1 = new THREE.TextureLoader().load( 'textures/758px-Canestra_di_frutta_(Caravaggio).jpg', callbackPainting );\n\t\t\t\tconst texturePainting2 = new THREE.Texture();\n\t\t\t\tconst materialPainting1 = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texturePainting1 } );\n\t\t\t\tconst materialPainting2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: texturePainting2 } );\n\n\t\t\t\ttexturePainting1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexturePainting2.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexturePainting2.minFilter = texturePainting2.magFilter = THREE.NearestFilter;\n\t\t\t\ttexturePainting1.minFilter = texturePainting1.magFilter = THREE.LinearFilter;\n\t\t\t\ttexturePainting1.mapping = THREE.UVMapping;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t}\n\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - ( mouseY - 200 ) - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene1.position );\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene1, camera );\n\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene2, camera );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n```\n\nThis example three.js - texture manual mipmapping example painting by Caravaggio"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - texture - partial update"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - texture - partial update:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer, clock, dataTexture, diffuseMap;\n\n\t\t\tlet last = 0;\n\t\t\tconst position = new THREE.Vector2();\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tdiffuseMap = await loader.loadAsync( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tdiffuseMap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tdiffuseMap.minFilter = THREE.LinearFilter;\n\t\t\t\tdiffuseMap.generateMipmaps = false;\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: diffuseMap } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst width = 32;\n\t\t\t\tconst height = 32;\n\n\t\t\t\tconst data = new Uint8Array( width * height * 4 );\n\t\t\t\tdataTexture = new THREE.DataTexture( data, width, height );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst elapsedTime = clock.getElapsedTime();\n\n\t\t\t\tif ( elapsedTime - last > 0.1 ) {\n\n\t\t\t\t\tlast = elapsedTime;\n\n\t\t\t\t\tposition.x = ( 32 * THREE.MathUtils.randInt( 1, 16 ) ) - 32;\n\t\t\t\t\tposition.y = ( 32 * THREE.MathUtils.randInt( 1, 16 ) ) - 32;\n\n\t\t\t\t\t// generate new color data\n\n\t\t\t\t\tupdateDataTexture( dataTexture );\n\n\t\t\t\t\t// perform copy from src to dest texture to a random position\n\n\t\t\t\t\trenderer.copyTextureToTexture( dataTexture, diffuseMap, null, position );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction updateDataTexture( texture ) {\n\n\t\t\t\tconst size = texture.image.width * texture.image.height;\n\t\t\t\tconst data = texture.image.data;\n\n\t\t\t\t// generate a random color and update texture data\n\n\t\t\t\tcolor.setHex( Math.random() * 0xffffff );\n\n\t\t\t\tconst r = Math.floor( color.r * 255 );\n\t\t\t\tconst g = Math.floor( color.g * 255 );\n\t\t\t\tconst b = Math.floor( color.b * 255 );\n\n\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\tconst stride = i * 4;\n\n\t\t\t\t\tdata[ stride ] = r;\n\t\t\t\t\tdata[ stride + 1 ] = g;\n\t\t\t\t\tdata[ stride + 2 ] = b;\n\t\t\t\t\tdata[ stride + 3 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - partial texture update replace parts of an existing texture with all data of another texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - texture - rotation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - texture - rotation:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet mesh, renderer, scene, camera;\n\n\t\t\tlet gui;\n\n\t\t\tconst API = {\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\trepeatX: 0.25,\n\t\t\t\trepeatY: 0.25,\n\t\t\t\trotation: Math.PI / 4, // positive is counterclockwise\n\t\t\t\tcenterX: 0.5,\n\t\t\t\tcenterY: 0.5\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 10, 15, 25 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 20;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 10, 10, 10 );\n\n\t\t\t\tnew THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg', function ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\t//texture.matrixAutoUpdate = false; // default is true; set to false to update texture.matrix manually\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tupdateUvTransform();\n\n\t\t\t\t\tinitGui();\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction updateUvTransform() {\n\n\t\t\t\tconst texture = mesh.material.map;\n\n\t\t\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\t\t\ttexture.offset.set( API.offsetX, API.offsetY );\n\t\t\t\t\ttexture.repeat.set( API.repeatX, API.repeatY );\n\t\t\t\t\ttexture.center.set( API.centerX, API.centerY );\n\t\t\t\t\ttexture.rotation = API.rotation; // rotation is around center\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// setting the matrix uv transform directly\n\t\t\t\t\ttexture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( API, 'offsetX', 0.0, 1.0 ).name( 'offset.x' ).onChange( updateUvTransform );\n\t\t\t\tgui.add( API, 'offsetY', 0.0, 1.0 ).name( 'offset.y' ).onChange( updateUvTransform );\n\t\t\t\tgui.add( API, 'repeatX', 0.25, 2.0 ).name( 'repeat.x' ).onChange( updateUvTransform );\n\t\t\t\tgui.add( API, 'repeatY', 0.25, 2.0 ).name( 'repeat.y' ).onChange( updateUvTransform );\n\t\t\t\tgui.add( API, 'rotation', - 2.0, 2.0 ).name( 'rotation' ).onChange( updateUvTransform );\n\t\t\t\tgui.add( API, 'centerX', 0.0, 1.0 ).name( 'center.x' ).onChange( updateUvTransform );\n\t\t\t\tgui.add( API, 'centerY', 0.0, 1.0 ).name( 'center.y' ).onChange( updateUvTransform );\n\n\t\t\t}\n```\n\nThis example three.js webgl - texture rotation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer, effect;\n\t\t\tlet particleLight;\n\n\t\t\tconst loader = new FontLoader();\n\t\t\tloader.load( 'fonts/gentilis_regular.typeface.json', function ( font ) {\n\n\t\t\t\tinit( font );\n\n\t\t\t} );\n\n\t\t\tfunction init( font ) {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2500 );\n\t\t\t\tcamera.position.set( 0.0, 400, 400 * 3.5 );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x444488 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// Materials\n\n\t\t\t\tconst cubeWidth = 400;\n\t\t\t\tconst numberOfSpheresPerSide = 5;\n\t\t\t\tconst sphereRadius = ( cubeWidth / numberOfSpheresPerSide ) * 0.8 * 0.5;\n\t\t\t\tconst stepSize = 1.0 / numberOfSpheresPerSide;\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( sphereRadius, 32, 16 );\n\n\t\t\t\tfor ( let alpha = 0, alphaIndex = 0; alpha <= 1.0; alpha += stepSize, alphaIndex ++ ) {\n\n\t\t\t\t\tconst colors = new Uint8Array( alphaIndex + 2 );\n\n\t\t\t\t\tfor ( let c = 0; c <= colors.length; c ++ ) {\n\n\t\t\t\t\t\tcolors[ c ] = ( c / colors.length ) * 256;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst gradientMap = new THREE.DataTexture( colors, colors.length, 1, THREE.RedFormat );\n\t\t\t\t\tgradientMap.needsUpdate = true;\n\n\t\t\t\t\tfor ( let beta = 0; beta <= 1.0; beta += stepSize ) {\n\n\t\t\t\t\t\tfor ( let gamma = 0; gamma <= 1.0; gamma += stepSize ) {\n\n\t\t\t\t\t\t\t// basic monochromatic energy preservation\n\t\t\t\t\t\t\tconst diffuseColor = new THREE.Color().setHSL( alpha, 0.5, gamma * 0.5 + 0.1 ).multiplyScalar( 1 - beta * 0.2 );\n\n\t\t\t\t\t\t\tconst material = new THREE.MeshToonMaterial( {\n\t\t\t\t\t\t\t\tcolor: diffuseColor,\n\t\t\t\t\t\t\t\tgradientMap: gradientMap\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t\tmesh.position.x = alpha * 400 - 200;\n\t\t\t\t\t\t\tmesh.position.y = beta * 400 - 200;\n\t\t\t\t\t\t\tmesh.position.z = gamma * 400 - 200;\n\n\t\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction addLabel( name, location ) {\n\n\t\t\t\t\tconst textGeo = new TextGeometry( name, {\n\n\t\t\t\t\t\tfont: font,\n\n\t\t\t\t\t\tsize: 20,\n\t\t\t\t\t\tdepth: 1,\n\t\t\t\t\t\tcurveSegments: 1\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst textMaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\tconst textMesh = new THREE.Mesh( textGeo, textMaterial );\n\t\t\t\t\ttextMesh.position.copy( location );\n\t\t\t\t\tscene.add( textMesh );\n\n\t\t\t\t}\n\n\t\t\t\taddLabel( '-gradientMap', new THREE.Vector3( - 350, 0, 0 ) );\n\t\t\t\taddLabel( '+gradientMap', new THREE.Vector3( 350, 0, 0 ) );\n\n\t\t\t\taddLabel( '-diffuse', new THREE.Vector3( 0, 0, - 300 ) );\n\t\t\t\taddLabel( '+diffuse', new THREE.Vector3( 0, 0, 300 ) );\n\n\t\t\t\tparticleLight = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 4, 8, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff } )\n\t\t\t\t);\n\t\t\t\tscene.add( particleLight );\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xc1c1c1, 3 ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 2, 800, 0 );\n\t\t\t\tparticleLight.add( pointLight );\n\n\t\t\t\t//\n\n\t\t\t\teffect = new OutlineEffect( renderer );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 200;\n\t\t\t\tcontrols.maxDistance = 2000;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.00025;\n\n\t\t\t\tparticleLight.position.x = Math.sin( timer * 7 ) * 300;\n\t\t\t\tparticleLight.position.y = Math.cos( timer * 5 ) * 400;\n\t\t\t\tparticleLight.position.z = Math.cos( timer * 3 ) * 300;\n\n\t\t\t\teffect.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Toon Material with OutlineEffect"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - video"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - video:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { BloomPass } from 'three/addons/postprocessing/BloomPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet video, texture, material, mesh;\n\n\t\t\tlet composer;\n\n\t\t\tlet mouseX = 0;\n\t\t\tlet mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet cube_count;\n\n\t\t\tconst meshes = [],\n\t\t\t\tmaterials = [],\n\n\t\t\t\txgrid = 20,\n\t\t\t\tygrid = 10;\n\n\t\t\tconst startButton = document.getElementById( 'startButton' );\n\t\t\tstartButton.addEventListener( 'click', function () {\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\t\toverlay.remove();\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0.5, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tvideo = document.getElementById( 'video' );\n\t\t\t\tvideo.play();\n\t\t\t\tvideo.addEventListener( 'play', function () {\n\n\t\t\t\t\tthis.currentTime = 3;\n\n\t\t\t\t} );\n\n\t\t\t\ttexture = new THREE.VideoTexture( video );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t//\n\n\t\t\t\tlet i, j, ox, oy, geometry;\n\n\t\t\t\tconst ux = 1 / xgrid;\n\t\t\t\tconst uy = 1 / ygrid;\n\n\t\t\t\tconst xsize = 480 / xgrid;\n\t\t\t\tconst ysize = 204 / ygrid;\n\n\t\t\t\tconst parameters = { color: 0xffffff, map: texture };\n\n\t\t\t\tcube_count = 0;\n\n\t\t\t\tfor ( i = 0; i < xgrid; i ++ ) {\n\n\t\t\t\t\tfor ( j = 0; j < ygrid; j ++ ) {\n\n\t\t\t\t\t\tox = i;\n\t\t\t\t\t\toy = j;\n\n\t\t\t\t\t\tgeometry = new THREE.BoxGeometry( xsize, ysize, xsize );\n\n\t\t\t\t\t\tchange_uvs( geometry, ux, uy, ox, oy );\n\n\t\t\t\t\t\tmaterials[ cube_count ] = new THREE.MeshLambertMaterial( parameters );\n\n\t\t\t\t\t\tmaterial = materials[ cube_count ];\n\n\t\t\t\t\t\tmaterial.hue = i / xgrid;\n\t\t\t\t\t\tmaterial.saturation = 1 - j / ygrid;\n\n\t\t\t\t\t\tmaterial.color.setHSL( material.hue, material.saturation, 0.5 );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tmesh.position.x = ( i - xgrid / 2 ) * xsize;\n\t\t\t\t\t\tmesh.position.y = ( j - ygrid / 2 ) * ysize;\n\t\t\t\t\t\tmesh.position.z = 0;\n\n\t\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 1;\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmesh.dx = 0.001 * ( 0.5 - Math.random() );\n\t\t\t\t\t\tmesh.dy = 0.001 * ( 0.5 - Math.random() );\n\n\t\t\t\t\t\tmeshes[ cube_count ] = mesh;\n\n\t\t\t\t\t\tcube_count += 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tconst bloomPass = new BloomPass( 1.3 );\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tcomposer.addPass( renderPass );\n\t\t\t\tcomposer.addPass( bloomPass );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction change_uvs( geometry, unitx, unity, offsetx, offsety ) {\n\n\t\t\t\tconst uvs = geometry.attributes.uv.array;\n\n\t\t\t\tfor ( let i = 0; i < uvs.length; i += 2 ) {\n\n\t\t\t\t\tuvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;\n\t\t\t\t\tuvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) * 0.3;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet h, counter = 1;\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.00005;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0; i < cube_count; i ++ ) {\n\n\t\t\t\t\tmaterial = materials[ i ];\n\n\t\t\t\t\th = ( 360 * ( material.hue + time ) % 360 ) / 360;\n\t\t\t\t\tmaterial.color.setHSL( h, material.saturation, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( counter % 1000 > 200 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < cube_count; i ++ ) {\n\n\t\t\t\t\t\tmesh = meshes[ i ];\n\n\t\t\t\t\t\tmesh.rotation.x += 10 * mesh.dx;\n\t\t\t\t\t\tmesh.rotation.y += 10 * mesh.dy;\n\n\t\t\t\t\t\tmesh.position.x -= 150 * mesh.dx;\n\t\t\t\t\t\tmesh.position.y += 150 * mesh.dy;\n\t\t\t\t\t\tmesh.position.z += 300 * mesh.dx;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( counter % 1000 === 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < cube_count; i ++ ) {\n\n\t\t\t\t\t\tmesh = meshes[ i ];\n\n\t\t\t\t\t\tmesh.dx *= - 1;\n\t\t\t\t\t\tmesh.dy *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcounter ++;\n\n\t\t\t\trenderer.clear();\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example three.js - webgl video demo playing sintel trailer"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - video - webcam"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - video - webcam:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, video;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 0.01;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tvideo = document.getElementById( 'video' );\n\n\t\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 16, 9 );\n\t\t\t\tgeometry.scale( 0.5, 0.5, 0.5 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst count = 128;\n\t\t\t\tconst radius = 32;\n\n\t\t\t\tfor ( let i = 1, l = count; i <= l; i ++ ) {\n\n\t\t\t\t\tconst phi = Math.acos( - 1 + ( 2 * i ) / l );\n\t\t\t\t\tconst theta = Math.sqrt( l * Math.PI ) * phi;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.setFromSphericalCoords( radius, phi, theta );\n\t\t\t\t\tmesh.lookAt( camera.position );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tif ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {\n\n\t\t\t\t\tconst constraints = { video: { width: 1280, height: 720, facingMode: 'user' } };\n\n\t\t\t\t\tnavigator.mediaDevices.getUserMedia( constraints ).then( function ( stream ) {\n\n\t\t\t\t\t\t// apply the stream to the video element used in the texture\n\n\t\t\t\t\t\tvideo.srcObject = stream;\n\t\t\t\t\t\tvideo.play();\n\n\t\t\t\t\t} ).catch( function ( error ) {\n\n\t\t\t\t\t\tconsole.error( 'Unable to access the camera/webcam.', error );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'MediaDevices interface not available.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - video webcam input"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - wireframe"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - wireframe:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst API = {\n\t\t\t\tthickness: 1\n\t\t\t};\n\n\t\t\tlet renderer, scene, camera, mesh2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 500 );\n\t\t\t\tcamera.position.z = 200;\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\tnew THREE.BufferGeometryLoader().load( 'models/json/WaltHeadLo_buffergeometry.json', function ( geometry ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'normal' );\n\t\t\t\t\tgeometry.deleteAttribute( 'uv' );\n\n\t\t\t\t\tsetupAttributes( geometry );\n\n\t\t\t\t\t// left\n\n\t\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( {\n\n\t\t\t\t\t\tcolor: 0xe0e0ff,\n\t\t\t\t\t\twireframe: true\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\t\tmesh1.position.set( - 40, 0, 0 );\n\n\t\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\t\t// right\n\n\t\t\t\t\tconst material2 = new THREE.ShaderMaterial( {\n\n\t\t\t\t\t\tuniforms: { 'thickness': { value: API.thickness } },\n\t\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent,\n\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t\talphaToCoverage: true // only works when WebGLRenderer's \"antialias\" is set to \"true\"\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tmesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\t\tmesh2.position.set( 40, 0, 0 );\n\n\t\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t\t//\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( API, 'thickness', 0, 4 ).onChange( function () {\n\n\t\t\t\t\tmesh2.material.uniforms.thickness.value = API.thickness;\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction setupAttributes( geometry ) {\n\n\t\t\t\tconst vectors = [\n\t\t\t\t\tnew THREE.Vector3( 1, 0, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 0, 1, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 0, 0, 1 )\n\t\t\t\t];\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst centers = new Float32Array( position.count * 3 );\n\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tvectors[ i % 3 ].toArray( centers, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'center', new THREE.BufferAttribute( centers, 3 ) );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - materials - wireframe"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - math - OBB"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - math - OBB:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OBB } from 'three/addons/math/OBB.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, clock, controls, stats, raycaster, hitbox;\n\n\t\t\tconst objects = [], mouse = new THREE.Vector2();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 75 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x222222, 4 );\n\t\t\t\themiLight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst size = new THREE.Vector3( 10, 5, 6 );\n\t\t\t\tconst geometry = new THREE.BoxGeometry( size.x, size.y, size.z );\n\n\t\t\t\t// setup OBB on geometry level (doing this manually for now)\n\n\t\t\t\tgeometry.userData.obb = new OBB();\n\t\t\t\tgeometry.userData.obb.halfSize.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x00ff00 } ) );\n\t\t\t\t\tobject.matrixAutoUpdate = false;\n\n\t\t\t\t\tobject.position.x = Math.random() * 80 - 40;\n\t\t\t\t\tobject.position.y = Math.random() * 80 - 40;\n\t\t\t\t\tobject.position.z = Math.random() * 80 - 40;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t\t// bounding volume on object level (this will reflect the current world transform)\n\n\t\t\t\t\tobject.userData.obb = new OBB();\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\thitbox = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true } ) );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tdocument.addEventListener( 'click', onClick );\n\n\t\t\t}\n\n\t\t\tfunction onClick( event ) {\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\tconst intersectionPoint = new THREE.Vector3();\n\t\t\t\tconst intersections = [];\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\t\t\t\t\tconst obb = object.userData.obb;\n\n\t\t\t\t\tconst ray = raycaster.ray;\n\n\t\t\t\t\tif ( obb.intersectRay( ray, intersectionPoint ) !== null ) {\n\n\t\t\t\t\t\tconst distance = ray.origin.distanceTo( intersectionPoint );\n\t\t\t\t\t\tintersections.push( { distance: distance, object: object } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\t\t// determine closest intersection and highlight the respective 3D object\n\n\t\t\t\t\tintersections.sort( sortIntersections );\n\n\t\t\t\t\tintersections[ 0 ].object.add( hitbox );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst parent = hitbox.parent;\n\n\t\t\t\t\tif ( parent ) parent.remove( hitbox );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction sortIntersections( a, b ) {\n\n\t\t\t\treturn a.distance - b.distance;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// transform cubes\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tobject.rotation.x += delta * Math.PI * 0.20;\n\t\t\t\t\tobject.rotation.y += delta * Math.PI * 0.1;\n\n\t\t\t\t\tobject.updateMatrix();\n\t\t\t\t\tobject.updateMatrixWorld();\n\n\t\t\t\t\t// update OBB\n\n\t\t\t\t\tobject.userData.obb.copy( object.geometry.userData.obb );\n\t\t\t\t\tobject.userData.obb.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\t// reset\n\n\t\t\t\t\tobject.material.color.setHex( 0x00ff00 );\n\n\t\t\t\t}\n\n\t\t\t\t// collision detection\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\t\t\t\t\tconst obb = object.userData.obb;\n\n\t\t\t\t\tfor ( let j = i + 1, jl = objects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst objectToTest = objects[ j ];\n\t\t\t\t\t\tconst obbToTest = objectToTest.userData.obb;\n\n\t\t\t\t\t\t// now perform intersection test\n\n\t\t\t\t\t\tif ( obb.intersectsOBB( obbToTest ) === true ) {\n\n\t\t\t\t\t\t\tobject.material.color.setHex( 0xff0000 );\n\t\t\t\t\t\t\tobjectToTest.material.color.setHex( 0xff0000 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - OBB (Oriented Bounding Box)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - math - orientation transform"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - math - orientation transform:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, mesh, target;\n\n\t\t\tconst spherical = new THREE.Spherical();\n\t\t\tconst rotationMatrix = new THREE.Matrix4();\n\t\t\tconst targetQuaternion = new THREE.Quaternion();\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst speed = Math.PI / 2;\n\n\t\t\tconst params = {\n\t\t\t\tuseLookAt: false,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.z = 5;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.ConeGeometry( 0.1, 0.5, 8 );\n\t\t\t\tgeometry.rotateX( Math.PI * 0.5 );\n\t\t\t\tconst material = new THREE.MeshNormalMaterial();\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst targetGeometry = new THREE.SphereGeometry( 0.05 );\n\t\t\t\tconst targetMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\n\t\t\t\ttarget = new THREE.Mesh( targetGeometry, targetMaterial );\n\t\t\t\tscene.add( target );\n\n\t\t\t\t//\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );\n\t\t\t\tconst sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.3 } );\n\t\t\t\tconst sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'useLookAt' );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\tgenerateTarget();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mesh.quaternion.equals( targetQuaternion ) === false ) {\n\n\t\t\t\t\tif ( params.useLookAt === true ) {\n\n\t\t\t\t\t\t// using lookAt() will make the mesh instantly look at the target\n\n\t\t\t\t\t\tmesh.lookAt( target.position );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// using rotateTowards() will gradually rotate the mesh towards the target\n\t\t\t\t\t\t// the \"speed\" variable represents the rotation speed in radians per seconds\n\n\t\t\t\t\t\tconst step = speed * delta;\n\t\t\t\t\t\tmesh.quaternion.rotateTowards( targetQuaternion, step );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction generateTarget() {\n\n\t\t\t\t// generate a random point on a sphere\n\n\t\t\t\tspherical.theta = Math.random() * Math.PI * 2;\n\t\t\t\tspherical.phi = Math.acos( ( 2 * Math.random() ) - 1 );\n\t\t\t\tspherical.radius = 2;\n\n\t\t\t\ttarget.position.setFromSpherical( spherical );\n\n\t\t\t\t// compute target rotation\n\n\t\t\t\trotationMatrix.lookAt( target.position, mesh.position, mesh.up );\n\t\t\t\ttargetQuaternion.setFromRotationMatrix( rotationMatrix );\n\n\t\t\t\tsetTimeout( generateTarget, 2000 );\n\n\t\t\t}\n```\n\nThis example three.js - gradually transform an orientation to a target orientation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - mesh - batch"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - mesh - batch:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { radixSort } from 'three/addons/utils/SortUtils.js';\n\n\t\tlet stats, gui, guiStatsEl;\n\t\tlet camera, controls, scene, renderer;\n\t\tlet geometries, mesh, material;\n\t\tconst ids = [];\n\t\tconst matrix = new THREE.Matrix4();\n\n\t\t//\n\n\t\tconst position = new THREE.Vector3();\n\t\tconst rotation = new THREE.Euler();\n\t\tconst quaternion = new THREE.Quaternion();\n\t\tconst scale = new THREE.Vector3();\n\n\t\t//\n\n\t\tconst MAX_GEOMETRY_COUNT = 20000;\n\n\t\tconst Method = {\n\t\t\tBATCHED: 'BATCHED',\n\t\t\tNAIVE: 'NAIVE'\n\t\t};\n\n\t\tconst api = {\n\t\t\tmethod: Method.BATCHED,\n\t\t\tcount: 256,\n\t\t\tdynamic: 16,\n\n\t\t\tsortObjects: true,\n\t\t\tperObjectFrustumCulled: true,\n\t\t\topacity: 1,\n\t\t\tuseCustomSort: true,\n\t\t};\n\n\t\tinit();\n\t\tinitGeometries();\n\t\tinitMesh();\n\n\t\t//\n\n\t\tfunction randomizeMatrix( matrix ) {\n\n\t\t\tposition.x = Math.random() * 40 - 20;\n\t\t\tposition.y = Math.random() * 40 - 20;\n\t\t\tposition.z = Math.random() * 40 - 20;\n\n\t\t\trotation.x = Math.random() * 2 * Math.PI;\n\t\t\trotation.y = Math.random() * 2 * Math.PI;\n\t\t\trotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\tquaternion.setFromEuler( rotation );\n\n\t\t\tscale.x = scale.y = scale.z = 0.5 + ( Math.random() * 0.5 );\n\n\t\t\treturn matrix.compose( position, quaternion, scale );\n\n\t\t}\n\n\t\tfunction randomizeRotationSpeed( rotation ) {\n\n\t\t\trotation.x = Math.random() * 0.01;\n\t\t\trotation.y = Math.random() * 0.01;\n\t\t\trotation.z = Math.random() * 0.01;\n\t\t\treturn rotation;\n\n\t\t}\n\n\t\tfunction initGeometries() {\n\n\t\t\tgeometries = [\n\t\t\t\tnew THREE.ConeGeometry( 1.0, 2.0 ),\n\t\t\t\tnew THREE.BoxGeometry( 2.0, 2.0, 2.0 ),\n\t\t\t\tnew THREE.SphereGeometry( 1.0, 16, 8 ),\n\t\t\t];\n\n\t\t}\n\n\t\tfunction createMaterial() {\n\n\t\t\tif ( ! material ) {\n\n\t\t\t\tmaterial = new THREE.MeshNormalMaterial();\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction cleanup() {\n\n\t\t\tif ( mesh ) {\n\n\t\t\t\tmesh.parent.remove( mesh );\n\n\t\t\t\tif ( mesh.dispose ) {\n\n\t\t\t\t\tmesh.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMesh() {\n\n\t\t\tcleanup();\n\n\t\t\tif ( api.method === Method.BATCHED ) {\n\n\t\t\t\tinitBatchedMesh();\n\n\t\t\t} else {\n\n\t\t\t\tinitRegularMesh();\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initRegularMesh() {\n\n\t\t\tmesh = new THREE.Group();\n\t\t\tconst material = createMaterial();\n\n\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\tconst child = new THREE.Mesh( geometries[ i % geometries.length ], material );\n\t\t\t\trandomizeMatrix( child.matrix );\n\t\t\t\tchild.matrix.decompose( child.position, child.quaternion, child.scale );\n\t\t\t\tchild.userData.rotationSpeed = randomizeRotationSpeed( new THREE.Euler() );\n\t\t\t\tmesh.add( child );\n\n\t\t\t}\n\n\t\t\tscene.add( mesh );\n\n\t\t}\n\n\t\tfunction initBatchedMesh() {\n\n\t\t\tconst geometryCount = api.count;\n\t\t\tconst vertexCount = geometries.length * 512;\n\t\t\tconst indexCount = geometries.length * 1024;\n\n\t\t\tconst euler = new THREE.Euler();\n\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\tmesh = new THREE.BatchedMesh( geometryCount, vertexCount, indexCount, createMaterial() );\n\t\t\tmesh.userData.rotationSpeeds = [];\n\n\t\t\t// disable full-object frustum culling since all of the objects can be dynamic.\n\t\t\tmesh.frustumCulled = false;\n\n\t\t\tids.length = 0;\n\n\t\t\tconst geometryIds = [\n\t\t\t\tmesh.addGeometry( geometries[ 0 ] ),\n\t\t\t\tmesh.addGeometry( geometries[ 1 ] ),\n\t\t\t\tmesh.addGeometry( geometries[ 2 ] ),\n\t\t\t];\n\n\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\tconst id = mesh.addInstance( geometryIds[ i % geometryIds.length ] );\n\t\t\t\tmesh.setMatrixAt( id, randomizeMatrix( matrix ) );\n\n\t\t\t\tconst rotationMatrix = new THREE.Matrix4();\n\t\t\t\trotationMatrix.makeRotationFromEuler( randomizeRotationSpeed( euler ) );\n\t\t\t\tmesh.userData.rotationSpeeds.push( rotationMatrix );\n\n\t\t\t\tids.push( id );\n\n\t\t\t}\n\n\t\t\tscene.add( mesh );\n\n\t\t}\n\n\t\tfunction init() {\n\n\t\t\tconst width = window.innerWidth;\n\t\t\tconst height = window.innerHeight;\n\n\t\t\t// camera\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 70, width / height, 1, 100 );\n\t\t\tcamera.position.z = 30;\n\n\t\t\t// renderer\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( width, height );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t// scene\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t// controls\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.autoRotate = true;\n\t\t\tcontrols.autoRotateSpeed = 1.0;\n\n\t\t\t// stats\n\n\t\t\tstats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t// gui\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( api, 'count', 1, MAX_GEOMETRY_COUNT ).step( 1 ).onChange( initMesh );\n\t\t\tgui.add( api, 'dynamic', 0, MAX_GEOMETRY_COUNT ).step( 1 );\n\t\t\tgui.add( api, 'method', Method ).onChange( initMesh );\n\t\t\tgui.add( api, 'opacity', 0, 1 ).onChange( v => {\n\n\t\t\t\tif ( v < 1 ) {\n\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\tmaterial.depthWrite = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.transparent = false;\n\t\t\t\t\tmaterial.depthWrite = true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.opacity = v;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\t\t\tgui.add( api, 'sortObjects' );\n\t\t\tgui.add( api, 'perObjectFrustumCulled' );\n\t\t\tgui.add( api, 'useCustomSort' );\n\n\t\t\tguiStatsEl = document.createElement( 'li' );\n\t\t\tguiStatsEl.classList.add( 'gui-stats' );\n\n\t\t\t// listeners\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction sortFunction( list ) {\n\n\t\t\t// initialize options\n\t\t\tthis._options = this._options || {\n\t\t\t\tget: el => el.z,\n\t\t\t\taux: new Array( this.maxInstanceCount )\n\t\t\t};\n\n\t\t\tconst options = this._options;\n\t\t\toptions.reversed = this.material.transparent;\n\n\t\t\tlet minZ = Infinity;\n\t\t\tlet maxZ = - Infinity;\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst z = list[ i ].z;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t}\n\n\t\t\t// convert depth to unsigned 32 bit range\n\t\t\tconst depthDelta = maxZ - minZ;\n\t\t\tconst factor = ( 2 ** 32 - 1 ) / depthDelta; // UINT32_MAX / z range\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tlist[ i ].z -= minZ;\n\t\t\t\tlist[ i ].z *= factor;\n\n\t\t\t}\n\n\t\t\t// perform a fast-sort using the hybrid radix sort function\n\t\t\tradixSort( list, options );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tconst width = window.innerWidth;\n\t\t\tconst height = window.innerHeight;\n\n\t\t\tcamera.aspect = width / height;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( width, height );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tanimateMeshes();\n\n\t\t\tcontrols.update();\n\t\t\tstats.update();\n\n\t\t\trender();\n\n\t\t}\n\n\t\tfunction animateMeshes() {\n\n\t\t\tconst loopNum = Math.min( api.count, api.dynamic );\n\n\t\t\tif ( api.method === Method.BATCHED ) {\n\n\t\t\t\tfor ( let i = 0; i < loopNum; i ++ ) {\n\n\t\t\t\t\tconst rotationMatrix = mesh.userData.rotationSpeeds[ i ];\n\t\t\t\t\tconst id = ids[ i ];\n\n\t\t\t\t\tmesh.getMatrixAt( id, matrix );\n\t\t\t\t\tmatrix.multiply( rotationMatrix );\n\t\t\t\t\tmesh.setMatrixAt( id, matrix );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0; i < loopNum; i ++ ) {\n\n\t\t\t\t\tconst child = mesh.children[ i ];\n\t\t\t\t\tconst rotationSpeed = child.userData.rotationSpeed;\n\n\t\t\t\t\tchild.rotation.set(\n\t\t\t\t\t\tchild.rotation.x + rotationSpeed.x,\n\t\t\t\t\t\tchild.rotation.y + rotationSpeed.y,\n\t\t\t\t\t\tchild.rotation.z + rotationSpeed.z\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\tif ( mesh.isBatchedMesh ) {\n\n\t\t\t\tmesh.sortObjects = api.sortObjects;\n\t\t\t\tmesh.perObjectFrustumCulled = api.perObjectFrustumCulled;\n\t\t\t\tmesh.setCustomSort( api.useCustomSort ? sortFunction : null );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js webgl - mesh - batch"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - mirror"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - mirror:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Reflector } from 'three/addons/objects/Reflector.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet cameraControls;\n\n\t\t\tlet sphereGroup, smallSphere;\n\n\t\t\tlet groundMirror, verticalMirror;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );\n\t\t\t\tcamera.position.set( 0, 75, 160 );\n\n\t\t\t\tcameraControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcameraControls.target.set( 0, 40, 0 );\n\t\t\t\tcameraControls.maxDistance = 400;\n\t\t\t\tcameraControls.minDistance = 10;\n\t\t\t\tcameraControls.update();\n\n\t\t\t\t//\n\n\t\t\t\tconst planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );\n\n\t\t\t\t// reflectors/mirrors\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\tgeometry = new THREE.CircleGeometry( 40, 64 );\n\t\t\t\tgroundMirror = new Reflector( geometry, {\n\t\t\t\t\tclipBias: 0.003,\n\t\t\t\t\ttextureWidth: window.innerWidth * window.devicePixelRatio,\n\t\t\t\t\ttextureHeight: window.innerHeight * window.devicePixelRatio,\n\t\t\t\t\tcolor: 0xb5b5b5\n\t\t\t\t} );\n\t\t\t\tgroundMirror.position.y = 0.5;\n\t\t\t\tgroundMirror.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( groundMirror );\n\n\t\t\t\tgeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tverticalMirror = new Reflector( geometry, {\n\t\t\t\t\tclipBias: 0.003,\n\t\t\t\t\ttextureWidth: window.innerWidth * window.devicePixelRatio,\n\t\t\t\t\ttextureHeight: window.innerHeight * window.devicePixelRatio,\n\t\t\t\t\tcolor: 0xc1cbcb\n\t\t\t\t} );\n\t\t\t\tverticalMirror.position.y = 50;\n\t\t\t\tverticalMirror.position.z = - 50;\n\t\t\t\tscene.add( verticalMirror );\n\n\n\t\t\t\tsphereGroup = new THREE.Object3D();\n\t\t\t\tscene.add( sphereGroup );\n\n\t\t\t\tgeometry = new THREE.CylinderGeometry( 0.1, 15 * Math.cos( Math.PI / 180 * 30 ), 0.1, 24, 1 );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x8d8d8d } );\n\t\t\t\tconst sphereCap = new THREE.Mesh( geometry, material );\n\t\t\t\tsphereCap.position.y = - 15 * Math.sin( Math.PI / 180 * 30 ) - 0.05;\n\t\t\t\tsphereCap.rotateX( - Math.PI );\n\n\t\t\t\tgeometry = new THREE.SphereGeometry( 15, 24, 24, Math.PI / 2, Math.PI * 2, 0, Math.PI / 180 * 120 );\n\t\t\t\tconst halfSphere = new THREE.Mesh( geometry, material );\n\t\t\t\thalfSphere.add( sphereCap );\n\t\t\t\thalfSphere.rotateX( - Math.PI / 180 * 135 );\n\t\t\t\thalfSphere.rotateZ( - Math.PI / 180 * 20 );\n\t\t\t\thalfSphere.position.y = 7.5 + 15 * Math.sin( Math.PI / 180 * 30 );\n\n\t\t\t\tsphereGroup.add( halfSphere );\n\n\t\t\t\tgeometry = new THREE.IcosahedronGeometry( 5, 0 );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x7b7b7b, flatShading: true } );\n\t\t\t\tsmallSphere = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( smallSphere );\n\n\t\t\t\t// walls\n\t\t\t\tconst planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneTop.position.y = 100;\n\t\t\t\tplaneTop.rotateX( Math.PI / 2 );\n\t\t\t\tscene.add( planeTop );\n\n\t\t\t\tconst planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneBottom.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( planeBottom );\n\n\t\t\t\tconst planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );\n\t\t\t\tplaneFront.position.z = 50;\n\t\t\t\tplaneFront.position.y = 50;\n\t\t\t\tplaneFront.rotateY( Math.PI );\n\t\t\t\tscene.add( planeFront );\n\n\t\t\t\tconst planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );\n\t\t\t\tplaneRight.position.x = 50;\n\t\t\t\tplaneRight.position.y = 50;\n\t\t\t\tplaneRight.rotateY( - Math.PI / 2 );\n\t\t\t\tscene.add( planeRight );\n\n\t\t\t\tconst planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );\n\t\t\t\tplaneLeft.position.x = - 50;\n\t\t\t\tplaneLeft.position.y = 50;\n\t\t\t\tplaneLeft.rotateY( Math.PI / 2 );\n\t\t\t\tscene.add( planeLeft );\n\n\t\t\t\t// lights\n\t\t\t\tconst mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );\n\t\t\t\tmainLight.position.y = 60;\n\t\t\t\tscene.add( mainLight );\n\n\t\t\t\tconst greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );\n\t\t\t\tgreenLight.position.set( 550, 50, 0 );\n\t\t\t\tscene.add( greenLight );\n\n\t\t\t\tconst redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );\n\t\t\t\tredLight.position.set( - 550, 50, 0 );\n\t\t\t\tscene.add( redLight );\n\n\t\t\t\tconst blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );\n\t\t\t\tblueLight.position.set( 0, 50, 550 );\n\t\t\t\tscene.add( blueLight );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tgroundMirror.getRenderTarget().setSize(\n\t\t\t\t\twindow.innerWidth * window.devicePixelRatio,\n\t\t\t\t\twindow.innerHeight * window.devicePixelRatio\n\t\t\t\t);\n\t\t\t\tverticalMirror.getRenderTarget().setSize(\n\t\t\t\t\twindow.innerWidth * window.devicePixelRatio,\n\t\t\t\t\twindow.innerHeight * window.devicePixelRatio\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = Date.now() * 0.01;\n\n\t\t\t\tsphereGroup.rotation.y -= 0.002;\n\n\t\t\t\tsmallSphere.position.set(\n\t\t\t\t\tMath.cos( timer * 0.1 ) * 30,\n\t\t\t\t\tMath.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,\n\t\t\t\t\tMath.sin( timer * 0.1 ) * 30\n\t\t\t\t);\n\t\t\t\tsmallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;\n\t\t\t\tsmallSphere.rotation.z = timer * 0.8;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - mirror"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - curve modifier"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - curve modifier:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { Flow } from 'three/addons/modifiers/CurveModifier.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tconst ACTION_SELECT = 1, ACTION_NONE = 0;\n\t\t\tconst curveHandles = [];\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tlet stats;\n\t\t\tlet scene,\n\t\t\t\tcamera,\n\t\t\t\trenderer,\n\t\t\t\trayCaster,\n\t\t\t\tcontrol,\n\t\t\t\tflow,\n\t\t\t\taction = ACTION_NONE;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t40,\n\t\t\t\t\twindow.innerWidth / window.innerHeight,\n\t\t\t\t\t1,\n\t\t\t\t\t1000\n\t\t\t\t);\n\t\t\t\tcamera.position.set( 2, 2, 4 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst initialPoints = [\n\t\t\t\t\t{ x: 1, y: 0, z: - 1 },\n\t\t\t\t\t{ x: 1, y: 0, z: 1 },\n\t\t\t\t\t{ x: - 1, y: 0, z: 1 },\n\t\t\t\t\t{ x: - 1, y: 0, z: - 1 },\n\t\t\t\t];\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );\n\t\t\t\tconst boxMaterial = new THREE.MeshBasicMaterial();\n\n\t\t\t\tfor ( const handlePos of initialPoints ) {\n\n\t\t\t\t\tconst handle = new THREE.Mesh( boxGeometry, boxMaterial );\n\t\t\t\t\thandle.position.copy( handlePos );\n\t\t\t\t\tcurveHandles.push( handle );\n\t\t\t\t\tscene.add( handle );\n\n\t\t\t\t}\n\n\t\t\t\tconst curve = new THREE.CatmullRomCurve3(\n\t\t\t\t\tcurveHandles.map( ( handle ) => handle.position )\n\t\t\t\t);\n\t\t\t\tcurve.curveType = 'centripetal';\n\t\t\t\tcurve.closed = true;\n\n\t\t\t\tconst points = curve.getPoints( 50 );\n\t\t\t\tconst line = new THREE.LineLoop(\n\t\t\t\t\tnew THREE.BufferGeometry().setFromPoints( points ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0x00ff00 } )\n\t\t\t\t);\n\n\t\t\t\tscene.add( line );\n\n\t\t\t\t//\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffaa33, 3 );\n\t\t\t\tlight.position.set( - 10, 10, 10 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.AmbientLight( 0x003973, 3 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst geometry = new TextGeometry( 'Hello three.js!', {\n\t\t\t\t\t\tfont: font,\n\t\t\t\t\t\tsize: 0.2,\n\t\t\t\t\t\tdepth: 0.05,\n\t\t\t\t\t\tcurveSegments: 12,\n\t\t\t\t\t\tbevelEnabled: true,\n\t\t\t\t\t\tbevelThickness: 0.02,\n\t\t\t\t\t\tbevelSize: 0.01,\n\t\t\t\t\t\tbevelOffset: 0,\n\t\t\t\t\t\tbevelSegments: 5,\n\t\t\t\t\t} );\n\n\t\t\t\t\tgeometry.rotateX( Math.PI );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0x99ffff\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst objectToCurve = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tflow = new Flow( objectToCurve );\n\t\t\t\t\tflow.updateCurve( 0, curve );\n\t\t\t\t\tscene.add( flow.object3D );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.domElement.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\trayCaster = new THREE.Raycaster();\n\t\t\t\tcontrol = new TransformControls( camera, renderer.domElement );\n\t\t\t\tcontrol.addEventListener( 'dragging-changed', function ( event ) {\n\n\t\t\t\t\tif ( ! event.value ) {\n\n\t\t\t\t\t\tconst points = curve.getPoints( 50 );\n\t\t\t\t\t\tline.geometry.setFromPoints( points );\n\t\t\t\t\t\tflow.updateCurve( 0, curve );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\taction = ACTION_SELECT;\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( action === ACTION_SELECT ) {\n\n\t\t\t\t\trayCaster.setFromCamera( mouse, camera );\n\t\t\t\t\taction = ACTION_NONE;\n\t\t\t\t\tconst intersects = rayCaster.intersectObjects( curveHandles, false );\n\t\t\t\t\tif ( intersects.length ) {\n\n\t\t\t\t\t\tconst target = intersects[ 0 ].object;\n\t\t\t\t\t\tcontrol.attach( target );\n\t\t\t\t\t\tscene.add( control.getHelper() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( flow ) {\n\n\t\t\t\t\tflow.moveAlongCurve( 0.001 );\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - curve modifier"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - curve modifier - instanced"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - curve modifier - instanced:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { InstancedFlow } from 'three/addons/modifiers/CurveModifier.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tconst ACTION_SELECT = 1, ACTION_NONE = 0;\n\t\t\tconst curveHandles = [];\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tlet stats;\n\t\t\tlet scene,\n\t\t\t\tcamera,\n\t\t\t\trenderer,\n\t\t\t\trayCaster,\n\t\t\t\tcontrol,\n\t\t\t\tflow,\n\t\t\t\taction = ACTION_NONE;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t40,\n\t\t\t\t\twindow.innerWidth / window.innerHeight,\n\t\t\t\t\t1,\n\t\t\t\t\t1000\n\t\t\t\t);\n\t\t\t\tcamera.position.set( 2, 2, 4 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );\n\t\t\t\tconst boxMaterial = new THREE.MeshBasicMaterial();\n\n\t\t\t\tconst curves = [[\n\t\t\t\t\t{ x: 1, y: - 0.5, z: - 1 },\n\t\t\t\t\t{ x: 1, y: - 0.5, z: 1 },\n\t\t\t\t\t{ x: - 1, y: - 0.5, z: 1 },\n\t\t\t\t\t{ x: - 1, y: - 0.5, z: - 1 },\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t{ x: - 1, y: 0.5, z: - 1 },\n\t\t\t\t\t{ x: - 1, y: 0.5, z: 1 },\n\t\t\t\t\t{ x: 1, y: 0.5, z: 1 },\n\t\t\t\t\t{ x: 1, y: 0.5, z: - 1 },\n\t\t\t\t]].map( function ( curvePoints ) {\n\n\t\t\t\t\tconst curveVertices = curvePoints.map( function ( handlePos ) {\n\n\t\t\t\t\t\tconst handle = new THREE.Mesh( boxGeometry, boxMaterial );\n\t\t\t\t\t\thandle.position.copy( handlePos );\n\t\t\t\t\t\tcurveHandles.push( handle );\n\t\t\t\t\t\tscene.add( handle );\n\t\t\t\t\t\treturn handle.position;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst curve = new THREE.CatmullRomCurve3( curveVertices );\n\t\t\t\t\tcurve.curveType = 'centripetal';\n\t\t\t\t\tcurve.closed = true;\n\n\t\t\t\t\tconst points = curve.getPoints( 50 );\n\t\t\t\t\tconst line = new THREE.LineLoop(\n\t\t\t\t\t\tnew THREE.BufferGeometry().setFromPoints( points ),\n\t\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0x00ff00 } )\n\t\t\t\t\t);\n\n\t\t\t\t\tscene.add( line );\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcurve,\n\t\t\t\t\t\tline\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\n\t\t\t\t//\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffaa33, 3 );\n\t\t\t\tlight.position.set( - 10, 10, 10 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.AmbientLight( 0x003973, 3 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst geometry = new TextGeometry( 'Hello three.js!', {\n\t\t\t\t\t\tfont: font,\n\t\t\t\t\t\tsize: 0.2,\n\t\t\t\t\t\tdepth: 0.05,\n\t\t\t\t\t\tcurveSegments: 12,\n\t\t\t\t\t\tbevelEnabled: true,\n\t\t\t\t\t\tbevelThickness: 0.02,\n\t\t\t\t\t\tbevelSize: 0.01,\n\t\t\t\t\t\tbevelOffset: 0,\n\t\t\t\t\t\tbevelSegments: 5,\n\t\t\t\t\t} );\n\n\t\t\t\t\tgeometry.rotateX( Math.PI );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0x99ffff\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst numberOfInstances = 8;\n\t\t\t\t\tflow = new InstancedFlow( numberOfInstances, curves.length, geometry, material );\n\n\t\t\t\t\tcurves.forEach( function ( { curve }, i ) {\n\n\t\t\t\t\t\tflow.updateCurve( i, curve );\n\t\t\t\t\t\tscene.add( flow.object3D );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tfor ( let i = 0; i < numberOfInstances; i ++ ) {\n\n\t\t\t\t\t\tconst curveIndex = i % curves.length;\n\t\t\t\t\t\tflow.setCurve( i, curveIndex );\n\t\t\t\t\t\tflow.moveIndividualAlongCurve( i, i * 1 / numberOfInstances );\n\t\t\t\t\t\tflow.object3D.setColorAt( i, new THREE.Color( 0xffffff * Math.random() ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.domElement.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\trayCaster = new THREE.Raycaster();\n\t\t\t\tcontrol = new TransformControls( camera, renderer.domElement );\n\t\t\t\tcontrol.addEventListener( 'dragging-changed', function ( event ) {\n\n\t\t\t\t\tif ( ! event.value ) {\n\n\t\t\t\t\t\tcurves.forEach( function ( { curve, line }, i ) {\n\n\t\t\t\t\t\t\tconst points = curve.getPoints( 50 );\n\t\t\t\t\t\t\tline.geometry.setFromPoints( points );\n\t\t\t\t\t\t\tflow.updateCurve( i, curve );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\taction = ACTION_SELECT;\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( action === ACTION_SELECT ) {\n\n\t\t\t\t\trayCaster.setFromCamera( mouse, camera );\n\t\t\t\t\taction = ACTION_NONE;\n\t\t\t\t\tconst intersects = rayCaster.intersectObjects( curveHandles, false );\n\t\t\t\t\tif ( intersects.length ) {\n\n\t\t\t\t\t\tconst target = intersects[ 0 ].object;\n\t\t\t\t\t\tcontrol.attach( target );\n\t\t\t\t\t\tscene.add( control.getHelper() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( flow ) {\n\n\t\t\t\t\tflow.moveAlongCurve( 0.001 );\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - curve modifier - instanced"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - modifier - Edge Split modifier"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - modifier - Edge Split modifier:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { EdgeSplitModifier } from 'three/addons/modifiers/EdgeSplitModifier.js';\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet modifier, mesh, baseGeometry;\n\t\t\tlet map;\n\n\t\t\tconst params = {\n\t\t\t\tsmoothShading: true,\n\t\t\t\tedgeSplit: true,\n\t\t\t\tcutOffAngle: 20,\n\t\t\t\tshowMap: false,\n\t\t\t\ttryKeepNormals: true,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst info = document.createElement( 'div' );\n\t\t\t\tinfo.style.position = 'absolute';\n\t\t\t\tinfo.style.top = '10px';\n\t\t\t\tinfo.style.width = '100%';\n\t\t\t\tinfo.style.textAlign = 'center';\n\t\t\t\tinfo.innerHTML = '<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - Edge Split modifier';\n\t\t\t\tdocument.body.appendChild( info );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.dampingFactor = 0.25;\n\t\t\t\tcontrols.rotateSpeed = 0.35;\n\t\t\t\tcontrols.minZoom = 1;\n\t\t\t\tcamera.position.set( 0, 0, 4 );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xffffff, 0x444444, 3 ) );\n\n\t\t\t\tnew OBJLoader().load(\n\t\t\t\t\t'./models/obj/cerberus/Cerberus.obj',\n\t\t\t\t\tfunction ( group ) {\n\n\t\t\t\t\t\tconst cerberus = group.children[ 0 ];\n\t\t\t\t\t\tconst modelGeometry = cerberus.geometry;\n\n\t\t\t\t\t\tmodifier = new EdgeSplitModifier();\n\t\t\t\t\t\tbaseGeometry = BufferGeometryUtils.mergeVertices( modelGeometry );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( getGeometry(), new THREE.MeshStandardMaterial() );\n\t\t\t\t\t\tmesh.material.flatShading = ! params.smoothShading;\n\t\t\t\t\t\tmesh.rotateY( - Math.PI / 2 );\n\t\t\t\t\t\tmesh.scale.set( 3.5, 3.5, 3.5 );\n\t\t\t\t\t\tmesh.translateZ( 1.5 );\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tif ( map !== undefined && params.showMap ) {\n\n\t\t\t\t\t\t\tmesh.material.map = map;\n\t\t\t\t\t\t\tmesh.material.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tnew THREE.TextureLoader().load( './models/obj/cerberus/Cerberus_A.jpg', function ( texture ) {\n\n\t\t\t\t\tmap = texture;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tif ( mesh !== undefined && params.showMap ) {\n\n\t\t\t\t\t\tmesh.material.map = map;\n\t\t\t\t\t\tmesh.material.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\n\t\t\t\tconst gui = new GUI( { title: 'Edge split modifier parameters' } );\n\n\t\t\t\tgui.add( params, 'showMap' ).onFinishChange( updateMesh );\n\t\t\t\tgui.add( params, 'smoothShading' ).onFinishChange( updateMesh );\n\t\t\t\tgui.add( params, 'edgeSplit' ).onFinishChange( updateMesh );\n\t\t\t\tgui.add( params, 'cutOffAngle' ).min( 0 ).max( 180 ).onFinishChange( updateMesh );\n\t\t\t\tgui.add( params, 'tryKeepNormals' ).onFinishChange( updateMesh );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\n\t\t\tfunction getGeometry() {\n\n\t\t\t\tlet geometry;\n\n\t\t\t\tif ( params.edgeSplit ) {\n\n\t\t\t\t\tgeometry = modifier.modify(\n\t\t\t\t\t\tbaseGeometry,\n\t\t\t\t\t\tparams.cutOffAngle * Math.PI / 180,\n\t\t\t\t\t\tparams.tryKeepNormals\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgeometry = baseGeometry;\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\n\t\t\tfunction updateMesh() {\n\n\t\t\t\tif ( mesh !== undefined ) {\n\n\t\t\t\t\tmesh.geometry = getGeometry();\n\n\t\t\t\t\tlet needsUpdate = mesh.material.flatShading === params.smoothShading;\n\t\t\t\t\tmesh.material.flatShading = params.smoothShading === false;\n\n\t\t\t\t\tif ( map !== undefined ) {\n\n\t\t\t\t\t\tneedsUpdate = needsUpdate || mesh.material.map !== ( params.showMap ? map : null );\n\t\t\t\t\t\tmesh.material.map = params.showMap ? map : null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.material.needsUpdate = needsUpdate;\n\n\t\t\t\t\trender();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - modifier - simplify modifier"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - modifier - simplify modifier:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst info = document.createElement( 'div' );\n\t\t\t\tinfo.style.position = 'absolute';\n\t\t\t\tinfo.style.top = '10px';\n\t\t\t\tinfo.style.width = '100%';\n\t\t\t\tinfo.style.textAlign = 'center';\n\t\t\t\tinfo.innerHTML = '<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - Vertex Reduction using SimplifyModifier';\n\t\t\t\tdocument.body.appendChild( info );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 15;\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 0.6 ) );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 400 );\n\t\t\t\tcamera.add( light );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tnew GLTFLoader().load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.position.x = - 3;\n\t\t\t\t\tmesh.rotation.y = Math.PI / 2;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tconst modifier = new SimplifyModifier();\n\n\t\t\t\t\tconst simplified = mesh.clone();\n\t\t\t\t\tsimplified.material = simplified.material.clone();\n\t\t\t\t\tsimplified.material.flatShading = true;\n\t\t\t\t\tconst count = Math.floor( simplified.geometry.attributes.position.count * 0.875 ); // number of vertices to remove\n\t\t\t\t\tsimplified.geometry = modifier.modify( simplified.geometry, count );\n\n\t\t\t\t\tsimplified.position.x = 3;\n\t\t\t\t\tsimplified.rotation.y = - Math.PI / 2;\n\t\t\t\t\tscene.add( simplified );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - modifier - subdivision"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - modifier - subdivision:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { LoopSubdivision } from 'three-subdivide';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet texture;\n\t\t\tlet meshNormal, meshSmooth;\n\t\t\tlet wireNormal, wireSmooth;\n\t\t\tlet wireMaterial;\n\n\t\t\tconst params = {\n\t\t\t\tgeometry: 'Box',\n\t\t\t\titerations: 3,\n\t\t\t\tsplit: true,\n\t\t\t\tuvSmooth: false,\n\t\t\t\tpreserveEdges: false,\n\t\t\t\tflatOnly: false,\n\t\t\t\tmaxTriangles: 25000,\n\t\t\t\tflatShading: false,\n\t\t\t\ttextured: true,\n\t\t\t\twireframe: false\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight );\n\t\t\t\tcamera.position.set( 0, 0.7, 2.1 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.rotateSpeed = 0.5;\n\t\t\t\tcontrols.minZoom = 1;\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xffffff, 0x737373, 3 ) );\n\n\t\t\t\tconst frontLight = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tconst backLight = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tfrontLight.position.set( 0, 1, 1 );\n\t\t\t\tbackLight.position.set( 0, 1, - 1 );\n\t\t\t\tscene.add( frontLight, backLight );\n\n\t\t\t\ttexture = new THREE.TextureLoader().load( './textures/uv_grid_opengl.jpg', () => {\n\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tmeshNormal = new THREE.Mesh( new THREE.BufferGeometry(), new THREE.MeshBasicMaterial() );\n\t\t\t\tmeshSmooth = new THREE.Mesh( new THREE.BufferGeometry(), new THREE.MeshBasicMaterial() );\n\t\t\t\tmeshNormal.position.set( - 0.7, 0, 0 );\n\t\t\t\tmeshSmooth.position.set( 0.7, 0, 0 );\n\t\t\t\tscene.add( meshNormal, meshSmooth );\n\n\t\t\t\twireMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, depthTest: true, wireframe: true } );\n\t\t\t\twireNormal = new THREE.Mesh( new THREE.BufferGeometry(), wireMaterial );\n\t\t\t\twireSmooth = new THREE.Mesh( new THREE.BufferGeometry(), wireMaterial );\n\t\t\t\twireNormal.visible = false;\n\t\t\t\twireSmooth.visible = false;\n\t\t\t\twireNormal.position.copy( meshNormal.position );\n\t\t\t\twireSmooth.position.copy( meshSmooth.position );\n\t\t\t\tscene.add( wireNormal, wireSmooth );\n\n\t\t\t\tupdateMeshes();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst geomTypes = [ 'Box', 'Capsule', 'Circle', 'Cone', 'Cylinder', 'Dodecahedron', 'Icosahedron', 'Lathe', 'Octahedron', 'Plane', 'Ring', 'Sphere', 'Tetrahedron', 'Torus', 'TorusKnot' ];\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst folder1 = gui.addFolder( 'Subdivide Params' );\n\t\t\t\tconst geomController = folder1.add( params, 'geometry', geomTypes ).onFinishChange( () => {\n\n\t\t\t\t\tconst geom = params.geometry.toLowerCase();\n\n\t\t\t\t\tparams.split = geom === 'box' || geom === 'ring' || geom === 'plane';\n\t\t\t\t\tparams.uvSmooth = geom === 'circle' || geom === 'plane' || geom === 'ring';\n\n\t\t\t\t\trefreshDisplay();\n\n\t\t\t\t} );\n\n\t\t\t\tfolder1.add( params, 'iterations' ).min( 0 ).max( 5 ).step( 1 ).onFinishChange( updateMeshes );\n\t\t\t\tconst splitController = folder1.add( params, 'split' ).onFinishChange( updateMeshes );\n\t\t\t\tconst uvSmoothController = folder1.add( params, 'uvSmooth' ).onFinishChange( updateMeshes );\n\t\t\t\tconst preserveController = folder1.add( params, 'preserveEdges' ).onFinishChange( updateMeshes );\n\t\t\t\tfolder1.add( params, 'flatOnly' ).onFinishChange( updateMeshes );\n\t\t\t\tfolder1.add( params, 'maxTriangles' ).onFinishChange( updateMeshes );\n\n\t\t\t\tconst folder2 = gui.addFolder( 'Material' );\n\t\t\t\tfolder2.add( params, 'flatShading' ).onFinishChange( updateMaterial );\n\t\t\t\tfolder2.add( params, 'textured' ).onFinishChange( updateMaterial );\n\t\t\t\tfolder2.add( params, 'wireframe' ).onFinishChange( updateWireframe );\n\n\t\t\t\tfunction refreshDisplay() {\n\n\t\t\t\t\tgeomController.updateDisplay();\n\t\t\t\t\tsplitController.updateDisplay();\n\t\t\t\t\tuvSmoothController.updateDisplay();\n\t\t\t\t\tpreserveController.updateDisplay();\n\n\t\t\t\t\tupdateMeshes();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getGeometry() {\n\n\t\t\t\tswitch ( params.geometry.toLowerCase() ) {\n\n\t\t\t\t\tcase 'box':\n\t\t\t\t\t\treturn new THREE.BoxGeometry();\n\n\t\t\t\t\tcase 'capsule':\n\t\t\t\t\t\treturn new THREE.CapsuleGeometry( 0.5, 0.5, 3, 5 );\n\n\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\treturn new THREE.CircleGeometry( 0.6, 10 );\n\n\t\t\t\t\tcase 'cone':\n\t\t\t\t\t\treturn new THREE.ConeGeometry( 0.6, 1.5, 5, 3 );\n\n\t\t\t\t\tcase 'cylinder':\n\t\t\t\t\t\treturn new THREE.CylinderGeometry( 0.5, 0.5, 1, 5, 4 );\n\n\t\t\t\t\tcase 'dodecahedron':\n\t\t\t\t\t\treturn new THREE.DodecahedronGeometry( 0.6 );\n\n\t\t\t\t\tcase 'icosahedron':\n\t\t\t\t\t\treturn new THREE.IcosahedronGeometry( 0.6 );\n\n\t\t\t\t\tcase 'lathe':\n\n\t\t\t\t\t\t// Sine Wave\n\n\t\t\t\t\t\tconst points = [];\n\n\t\t\t\t\t\tfor ( let i = 0; i < 65; i += 5 ) {\n\n\t\t\t\t\t\t\tconst x = ( Math.sin( i * 0.2 ) * Math.sin( i * 0.1 ) * 15 + 50 ) * 1.2;\n\t\t\t\t\t\t\tconst y = ( i - 5 ) * 3;\n\t\t\t\t\t\t\tpoints.push( new THREE.Vector2( x * 0.0075, y * 0.005 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst latheGeometry = new THREE.LatheGeometry( points, 4 );\n\t\t\t\t\t\tlatheGeometry.center();\n\n\t\t\t\t\t\treturn latheGeometry;\n\n\t\t\t\t\tcase 'octahedron':\n\t\t\t\t\t\treturn new THREE.OctahedronGeometry( 0.7 );\n\n\t\t\t\t\tcase 'plane':\n\t\t\t\t\t\treturn new THREE.PlaneGeometry();\n\n\t\t\t\t\tcase 'ring':\n\t\t\t\t\t\treturn new THREE.RingGeometry( 0.3, 0.6, 10 );\n\n\t\t\t\t\tcase 'sphere':\n\t\t\t\t\t\treturn new THREE.SphereGeometry( 0.6, 8, 4 );\n\n\t\t\t\t\tcase 'tetrahedron':\n\t\t\t\t\t\treturn new THREE.TetrahedronGeometry( 0.8 );\n\n\t\t\t\t\tcase 'torus':\n\t\t\t\t\t\treturn new THREE.TorusGeometry( 0.48, 0.24, 4, 6 );\n\n\t\t\t\t\tcase 'torusknot':\n\t\t\t\t\t\treturn new THREE.TorusKnotGeometry( 0.38, 0.18, 20, 4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updateMeshes() {\n\n\t\t\t\tconst normalGeometry = getGeometry();\n\n\t\t\t\tconst smoothGeometry = LoopSubdivision.modify( normalGeometry, params.iterations, params );\n\n\t\t\t\tmeshNormal.geometry.dispose();\n\t\t\t\tmeshSmooth.geometry.dispose();\n\t\t\t\tmeshNormal.geometry = normalGeometry;\n\t\t\t\tmeshSmooth.geometry = smoothGeometry;\n\n\t\t\t\twireNormal.geometry.dispose();\n\t\t\t\twireSmooth.geometry.dispose();\n\t\t\t\twireNormal.geometry = normalGeometry.clone();\n\t\t\t\twireSmooth.geometry = smoothGeometry.clone();\n\n\t\t\t\tupdateMaterial();\n\n\t\t\t}\n\n\t\t\tfunction disposeMaterial( material ) {\n\n\t\t\t\tconst materials = Array.isArray( material ) ? material : [ material ];\n\n\t\t\t\tfor ( let i = 0; i < materials.length; i ++ ) {\n\n\t\t\t\t\tif ( materials[ i ].dispose ) materials[ i ].dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updateMaterial() {\n\n\t\t\t\tdisposeMaterial( meshNormal.material );\n\t\t\t\tdisposeMaterial( meshSmooth.material );\n\n\t\t\t\tconst materialParams = {\n\t\t\t\t\tcolor: ( params.textured ) ? 0xffffff : 0x808080,\n\t\t\t\t\tflatShading: params.flatShading,\n\t\t\t\t\tmap: ( params.textured ) ? texture : null,\n\t\t\t\t\tpolygonOffset: true,\n\t\t\t\t\tpolygonOffsetFactor: 1, // positive value pushes polygon further away\n\t\t\t\t\tpolygonOffsetUnits: 1\n\t\t\t\t};\n\n\t\t\t\tswitch ( params.geometry.toLowerCase() ) {\n\n\t\t\t\t\tcase 'circle':\n\t\t\t\t\tcase 'lathe':\n\t\t\t\t\tcase 'plane':\n\t\t\t\t\tcase 'ring':\n\n\t\t\t\t\t\tmaterialParams.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'box':\n\t\t\t\t\tcase 'capsule':\n\t\t\t\t\tcase 'cone':\n\t\t\t\t\tcase 'cylinder':\n\t\t\t\t\tcase 'dodecahedron':\n\t\t\t\t\tcase 'icosahedron':\n\t\t\t\t\tcase 'octahedron':\n\t\t\t\t\tcase 'sphere':\n\t\t\t\t\tcase 'tetrahedron':\n\t\t\t\t\tcase 'torus':\n\t\t\t\t\tcase 'torusknot':\n\n\t\t\t\t\t\tmaterialParams.side = THREE.FrontSide;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmeshNormal.material = meshSmooth.material = new THREE.MeshStandardMaterial( materialParams );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction updateWireframe() {\n\n\t\t\t\twireNormal.visible = wireSmooth.visible = params.wireframe;\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - modifier - subdivision See external three-subdivide for more information on subdivision surfaces."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - modifier - tessellation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - modifier - tessellation:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { TessellateModifier } from 'three/addons/modifiers/TessellateModifier.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet controls;\n\n\t\t\tlet mesh, uniforms;\n\n\t\t\tconst WIDTH = window.innerWidth;\n\t\t\tconst HEIGHT = window.innerHeight;\n\n\t\t\tconst loader = new FontLoader();\n\t\t\tloader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {\n\n\t\t\t\tinit( font );\n\n\t\t\t} );\n\n\t\t\tfunction init( font ) {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 10000 );\n\t\t\t\tcamera.position.set( - 100, 100, 200 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\n\t\t\t\t//\n\n\t\t\t\tlet geometry = new TextGeometry( 'THREE.JS', {\n\n\t\t\t\t\tfont: font,\n\n\t\t\t\t\tsize: 40,\n\t\t\t\t\tdepth: 5,\n\t\t\t\t\tcurveSegments: 3,\n\n\t\t\t\t\tbevelThickness: 2,\n\t\t\t\t\tbevelSize: 1,\n\t\t\t\t\tbevelEnabled: true\n\n\t\t\t\t} );\n\n\t\t\t\tgeometry.center();\n\n\t\t\t\tconst tessellateModifier = new TessellateModifier( 8, 6 );\n\n\t\t\t\tgeometry = tessellateModifier.modify( geometry );\n\n\t\t\t\t//\n\n\t\t\t\tconst numFaces = geometry.attributes.position.count / 3;\n\n\t\t\t\tconst colors = new Float32Array( numFaces * 3 * 3 );\n\t\t\t\tconst displacement = new Float32Array( numFaces * 3 * 3 );\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let f = 0; f < numFaces; f ++ ) {\n\n\t\t\t\t\tconst index = 9 * f;\n\n\t\t\t\t\tconst h = 0.2 * Math.random();\n\t\t\t\t\tconst s = 0.5 + 0.5 * Math.random();\n\t\t\t\t\tconst l = 0.5 + 0.5 * Math.random();\n\n\t\t\t\t\tcolor.setHSL( h, s, l );\n\n\t\t\t\t\tconst d = 10 * ( 0.5 - Math.random() );\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tcolors[ index + ( 3 * i ) ] = color.r;\n\t\t\t\t\t\tcolors[ index + ( 3 * i ) + 1 ] = color.g;\n\t\t\t\t\t\tcolors[ index + ( 3 * i ) + 2 ] = color.b;\n\n\t\t\t\t\t\tdisplacement[ index + ( 3 * i ) ] = d;\n\t\t\t\t\t\tdisplacement[ index + ( 3 * i ) + 1 ] = d;\n\t\t\t\t\t\tdisplacement[ index + ( 3 * i ) + 2 ] = d;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'displacement', new THREE.BufferAttribute( displacement, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tuniforms = {\n\n\t\t\t\t\tamplitude: { value: 0.0 }\n\n\t\t\t\t};\n\n\t\t\t\tconst shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, shaderMaterial );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( WIDTH, HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tuniforms.amplitude.value = 1.0 + Math.sin( time * 0.5 );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - modifier tessellation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - morph targets"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, camera, scene, renderer, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x8FBCD4 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.z = 10;\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x8FBCD4, 1.5 ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 200 );\n\t\t\t\tcamera.add( pointLight );\n\n\t\t\t\tconst geometry = createGeometry();\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\tflatShading: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tinitGUI();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( function () {\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t} );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createGeometry() {\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 2, 2, 2, 32, 32, 32 );\n\n\t\t\t\t// create an empty array to  hold targets for the attribute we want to morph\n\t\t\t\t// morphing positions and normals is supported\n\t\t\t\tgeometry.morphAttributes.position = [];\n\n\t\t\t\t// the original positions of the cube's vertices\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\n\t\t\t\t// for the first morph target we'll move the cube's vertices onto the surface of a sphere\n\t\t\t\tconst spherePositions = [];\n\n\t\t\t\t// for the second morph target, we'll twist the cubes vertices\n\t\t\t\tconst twistPositions = [];\n\t\t\t\tconst direction = new THREE.Vector3( 1, 0, 0 );\n\t\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tconst x = positionAttribute.getX( i );\n\t\t\t\t\tconst y = positionAttribute.getY( i );\n\t\t\t\t\tconst z = positionAttribute.getZ( i );\n\n\t\t\t\t\tspherePositions.push(\n\n\t\t\t\t\t\tx * Math.sqrt( 1 - ( y * y / 2 ) - ( z * z / 2 ) + ( y * y * z * z / 3 ) ),\n\t\t\t\t\t\ty * Math.sqrt( 1 - ( z * z / 2 ) - ( x * x / 2 ) + ( z * z * x * x / 3 ) ),\n\t\t\t\t\t\tz * Math.sqrt( 1 - ( x * x / 2 ) - ( y * y / 2 ) + ( x * x * y * y / 3 ) )\n\n\t\t\t\t\t);\n\n\t\t\t\t\t// stretch along the x-axis so we can see the twist better\n\t\t\t\t\tvertex.set( x * 2, y, z );\n\n\t\t\t\t\tvertex.applyAxisAngle( direction, Math.PI * x / 2 ).toArray( twistPositions, twistPositions.length );\n\n\t\t\t\t}\n\n\t\t\t\t// add the spherical positions as the first morph target\n\t\t\t\tgeometry.morphAttributes.position[ 0 ] = new THREE.Float32BufferAttribute( spherePositions, 3 );\n\n\t\t\t\t// add the twisted positions as the second morph target\n\t\t\t\tgeometry.morphAttributes.position[ 1 ] = new THREE.Float32BufferAttribute( twistPositions, 3 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\t// Set up dat.GUI to control targets\n\t\t\t\tconst params = {\n\t\t\t\t\tSpherify: 0,\n\t\t\t\t\tTwist: 0,\n\t\t\t\t};\n\t\t\t\tconst gui = new GUI( { title: 'Morph Targets' } );\n\n\t\t\t\tgui.add( params, 'Spherify', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 0 ] = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'Twist', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 1 ] = value;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n```\n\nThis example three.js - morph targets by Discover three.js"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl morphtargets in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, camera, scene, renderer, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x8FBCD4 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.z = 10;\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x8FBCD4, 1.5 ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 200 );\n\t\t\t\tcamera.add( pointLight );\n\n\t\t\t\tconst geometry = createGeometry();\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\tflatShading: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tinitGUI();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( function () {\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t} );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createGeometry() {\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 2, 2, 2, 32, 32, 32 );\n\n\t\t\t\t// create an empty array to  hold targets for the attribute we want to morph\n\t\t\t\t// morphing positions and normals is supported\n\t\t\t\tgeometry.morphAttributes.position = [];\n\n\t\t\t\t// the original positions of the cube's vertices\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\n\t\t\t\t// for the first morph target we'll move the cube's vertices onto the surface of a sphere\n\t\t\t\tconst spherePositions = [];\n\n\t\t\t\t// for the second morph target, we'll twist the cubes vertices\n\t\t\t\tconst twistPositions = [];\n\t\t\t\tconst direction = new THREE.Vector3( 1, 0, 0 );\n\t\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tconst x = positionAttribute.getX( i );\n\t\t\t\t\tconst y = positionAttribute.getY( i );\n\t\t\t\t\tconst z = positionAttribute.getZ( i );\n\n\t\t\t\t\tspherePositions.push(\n\n\t\t\t\t\t\tx * Math.sqrt( 1 - ( y * y / 2 ) - ( z * z / 2 ) + ( y * y * z * z / 3 ) ),\n\t\t\t\t\t\ty * Math.sqrt( 1 - ( z * z / 2 ) - ( x * x / 2 ) + ( z * z * x * x / 3 ) ),\n\t\t\t\t\t\tz * Math.sqrt( 1 - ( x * x / 2 ) - ( y * y / 2 ) + ( x * x * y * y / 3 ) )\n\n\t\t\t\t\t);\n\n\t\t\t\t\t// stretch along the x-axis so we can see the twist better\n\t\t\t\t\tvertex.set( x * 2, y, z );\n\n\t\t\t\t\tvertex.applyAxisAngle( direction, Math.PI * x / 2 ).toArray( twistPositions, twistPositions.length );\n\n\t\t\t\t}\n\n\t\t\t\t// add the spherical positions as the first morph target\n\t\t\t\tgeometry.morphAttributes.position[ 0 ] = new THREE.Float32BufferAttribute( spherePositions, 3 );\n\n\t\t\t\t// add the twisted positions as the second morph target\n\t\t\t\tgeometry.morphAttributes.position[ 1 ] = new THREE.Float32BufferAttribute( twistPositions, 3 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\t// Set up dat.GUI to control targets\n\t\t\t\tconst params = {\n\t\t\t\t\tSpherify: 0,\n\t\t\t\t\tTwist: 0,\n\t\t\t\t};\n\t\t\t\tconst gui = new GUI( { title: 'Morph Targets' } );\n\n\t\t\t\tgui.add( params, 'Spherify', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 0 ] = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'Twist', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 1 ] = value;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n```\n\nThis example three.js - morph targets by Discover three.js"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - morph targets - face"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - face:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats, mixer, clock, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.8, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst ktx2Loader = new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupport( renderer );\n\n\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t.setKTX2Loader( ktx2Loader )\n\t\t\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t\t\t.load( 'models/gltf/facecap.glb', ( gltf ) => {\n\n\t\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\n\t\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\t\t\t// GUI\n\n\t\t\t\t\t\tconst head = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\t\tconst influences = head.morphTargetInfluences;\n\n\t\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\t\tgui.close();\n\n\t\t\t\t\t\tfor ( const [ key, value ] of Object.entries( head.morphTargetDictionary ) ) {\n\n\t\t\t\t\t\t\tgui.add( influences, value, 0, 1, 0.01 )\n\t\t\t\t\t\t\t\t.name( key.replace( 'blendShape1.', '' ) )\n\t\t\t\t\t\t\t\t.listen();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 2.5;\n\t\t\t\tcontrols.maxDistance = 5;\n\t\t\t\tcontrols.minAzimuthAngle = - Math.PI / 2;\n\t\t\t\tcontrols.maxAzimuthAngle = Math.PI / 2;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.8;\n\t\t\t\tcontrols.target.set( 0, 0.15, - 0.2 );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - morph targets - face model by Face Cap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl morphtargets face in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - face:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats, mixer, clock, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.8, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst ktx2Loader = new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupport( renderer );\n\n\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t.setKTX2Loader( ktx2Loader )\n\t\t\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t\t\t.load( 'models/gltf/facecap.glb', ( gltf ) => {\n\n\t\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\n\t\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\t\t\t// GUI\n\n\t\t\t\t\t\tconst head = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\t\tconst influences = head.morphTargetInfluences;\n\n\t\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\t\tgui.close();\n\n\t\t\t\t\t\tfor ( const [ key, value ] of Object.entries( head.morphTargetDictionary ) ) {\n\n\t\t\t\t\t\t\tgui.add( influences, value, 0, 1, 0.01 )\n\t\t\t\t\t\t\t\t.name( key.replace( 'blendShape1.', '' ) )\n\t\t\t\t\t\t\t\t.listen();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 2.5;\n\t\t\t\tcontrols.maxDistance = 5;\n\t\t\t\tcontrols.minAzimuthAngle = - Math.PI / 2;\n\t\t\t\tcontrols.maxAzimuthAngle = Math.PI / 2;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.8;\n\t\t\t\tcontrols.target.set( 0, 0.15, - 0.2 );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - morph targets - face model by Face Cap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - morph targets - horse"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - horse:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh, mixer;\n\n\t\t\tconst radius = 600;\n\t\t\tlet theta = 0;\n\t\t\tlet prevTime = Date.now();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.y = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\t//\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xefefff, 5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffefef, 5 );\n\t\t\t\tlight2.position.set( - 1, - 1, - 1 ).normalize();\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Horse.glb', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.scale.set( 1.5, 1.5, 1.5 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\n\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttheta += 0.1;\n\n\t\t\t\tcamera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );\n\n\t\t\t\tcamera.lookAt( 0, 150, 0 );\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tconst time = Date.now();\n\n\t\t\t\t\tmixer.update( ( time - prevTime ) * 0.001 );\n\n\t\t\t\t\tprevTime = time;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - morph targets - horse model by mirada from rome"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl morphtargets horse in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - horse:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh, mixer;\n\n\t\t\tconst radius = 600;\n\t\t\tlet theta = 0;\n\t\t\tlet prevTime = Date.now();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.y = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\t//\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xefefff, 5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffefef, 5 );\n\t\t\t\tlight2.position.set( - 1, - 1, - 1 ).normalize();\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Horse.glb', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.scale.set( 1.5, 1.5, 1.5 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\n\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\ttheta += 0.1;\n\n\t\t\t\tcamera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );\n\t\t\t\tcamera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );\n\n\t\t\t\tcamera.lookAt( 0, 150, 0 );\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tconst time = Date.now();\n\n\t\t\t\t\tmixer.update( ( time - prevTime ) * 0.001 );\n\n\t\t\t\t\tprevTime = time;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - morph targets - horse model by mirada from rome"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - morph targets - sphere"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - sphere:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\n\t\t\tlet camera, scene, renderer, timer;\n\n\t\t\tlet mesh;\n\n\t\t\tlet sign = 1;\n\t\t\tconst speed = 0.5;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.2, 100 );\n\t\t\t\tcamera.position.set( 0, 5, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tconst light1 = new THREE.PointLight( 0xff2200, 50000 );\n\t\t\t\tlight1.position.set( 100, 100, 100 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.PointLight( 0x22ff00, 10000 );\n\t\t\t\tlight2.position.set( - 100, - 100, - 100 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x111111 ) );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/AnimatedMorphSphere/glTF/AnimatedMorphSphere.gltf', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.getObjectByName( 'AnimatedMorphSphere' );\n\t\t\t\t\tmesh.rotation.z = Math.PI / 2;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst pointsMaterial = new THREE.PointsMaterial( {\n\t\t\t\t\t\tsize: 10,\n\t\t\t\t\t\tsizeAttenuation: false,\n\t\t\t\t\t\tmap: new THREE.TextureLoader().load( 'textures/sprites/disc.png' ),\n\t\t\t\t\t\talphaTest: 0.5\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst points = new THREE.Points( mesh.geometry, pointsMaterial );\n\t\t\t\t\tpoints.morphTargetInfluences = mesh.morphTargetInfluences;\n\t\t\t\t\tpoints.morphTargetDictionary = mesh.morphTargetDictionary;\n\t\t\t\t\tmesh.add( points );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 20;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = timer.getDelta();\n\n\t\t\t\tif ( mesh !== undefined ) {\n\n\t\t\t\t\tconst step = delta * speed;\n\n\t\t\t\t\tmesh.rotation.y += step;\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 1 ] = mesh.morphTargetInfluences[ 1 ] + step * sign;\n\n\t\t\t\t\tif ( mesh.morphTargetInfluences[ 1 ] <= 0 || mesh.morphTargetInfluences[ 1 ] >= 1 ) {\n\n\t\t\t\t\t\tsign *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - WebGL morph target example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl morphtargets sphere in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - sphere:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\n\t\t\tlet camera, scene, renderer, timer;\n\n\t\t\tlet mesh;\n\n\t\t\tlet sign = 1;\n\t\t\tconst speed = 0.5;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.2, 100 );\n\t\t\t\tcamera.position.set( 0, 5, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tconst light1 = new THREE.PointLight( 0xff2200, 50000 );\n\t\t\t\tlight1.position.set( 100, 100, 100 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.PointLight( 0x22ff00, 10000 );\n\t\t\t\tlight2.position.set( - 100, - 100, - 100 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x111111 ) );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/AnimatedMorphSphere/glTF/AnimatedMorphSphere.gltf', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.getObjectByName( 'AnimatedMorphSphere' );\n\t\t\t\t\tmesh.rotation.z = Math.PI / 2;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst pointsMaterial = new THREE.PointsMaterial( {\n\t\t\t\t\t\tsize: 10,\n\t\t\t\t\t\tsizeAttenuation: false,\n\t\t\t\t\t\tmap: new THREE.TextureLoader().load( 'textures/sprites/disc.png' ),\n\t\t\t\t\t\talphaTest: 0.5\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst points = new THREE.Points( mesh.geometry, pointsMaterial );\n\t\t\t\t\tpoints.morphTargetInfluences = mesh.morphTargetInfluences;\n\t\t\t\t\tpoints.morphTargetDictionary = mesh.morphTargetDictionary;\n\t\t\t\t\tmesh.add( points );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 20;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = timer.getDelta();\n\n\t\t\t\tif ( mesh !== undefined ) {\n\n\t\t\t\t\tconst step = delta * speed;\n\n\t\t\t\t\tmesh.rotation.y += step;\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 1 ] = mesh.morphTargetInfluences[ 1 ] + step * sign;\n\n\t\t\t\t\tif ( mesh.morphTargetInfluences[ 1 ] <= 0 || mesh.morphTargetInfluences[ 1 ] >= 1 ) {\n\n\t\t\t\t\t\tsign *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - WebGL morph target example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_animation example that demonstrates webgl - morph targets - webcam"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - webcam:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\t// Mediapipe\n\n\t\t\timport vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';\n\n\t\t\tconst { FaceLandmarker, FilesetResolver } = vision;\n\n\t\t\tconst blendshapesMap = {\n\t\t\t\t// '_neutral': '',\n\t\t\t\t'browDownLeft': 'browDown_L',\n\t\t\t\t'browDownRight': 'browDown_R',\n\t\t\t\t'browInnerUp': 'browInnerUp',\n\t\t\t\t'browOuterUpLeft': 'browOuterUp_L',\n\t\t\t\t'browOuterUpRight': 'browOuterUp_R',\n\t\t\t\t'cheekPuff': 'cheekPuff',\n\t\t\t\t'cheekSquintLeft': 'cheekSquint_L',\n\t\t\t\t'cheekSquintRight': 'cheekSquint_R',\n\t\t\t\t'eyeBlinkLeft': 'eyeBlink_L',\n\t\t\t\t'eyeBlinkRight': 'eyeBlink_R',\n\t\t\t\t'eyeLookDownLeft': 'eyeLookDown_L',\n\t\t\t\t'eyeLookDownRight': 'eyeLookDown_R',\n\t\t\t\t'eyeLookInLeft': 'eyeLookIn_L',\n\t\t\t\t'eyeLookInRight': 'eyeLookIn_R',\n\t\t\t\t'eyeLookOutLeft': 'eyeLookOut_L',\n\t\t\t\t'eyeLookOutRight': 'eyeLookOut_R',\n\t\t\t\t'eyeLookUpLeft': 'eyeLookUp_L',\n\t\t\t\t'eyeLookUpRight': 'eyeLookUp_R',\n\t\t\t\t'eyeSquintLeft': 'eyeSquint_L',\n\t\t\t\t'eyeSquintRight': 'eyeSquint_R',\n\t\t\t\t'eyeWideLeft': 'eyeWide_L',\n\t\t\t\t'eyeWideRight': 'eyeWide_R',\n\t\t\t\t'jawForward': 'jawForward',\n\t\t\t\t'jawLeft': 'jawLeft',\n\t\t\t\t'jawOpen': 'jawOpen',\n\t\t\t\t'jawRight': 'jawRight',\n\t\t\t\t'mouthClose': 'mouthClose',\n\t\t\t\t'mouthDimpleLeft': 'mouthDimple_L',\n\t\t\t\t'mouthDimpleRight': 'mouthDimple_R',\n\t\t\t\t'mouthFrownLeft': 'mouthFrown_L',\n\t\t\t\t'mouthFrownRight': 'mouthFrown_R',\n\t\t\t\t'mouthFunnel': 'mouthFunnel',\n\t\t\t\t'mouthLeft': 'mouthLeft',\n\t\t\t\t'mouthLowerDownLeft': 'mouthLowerDown_L',\n\t\t\t\t'mouthLowerDownRight': 'mouthLowerDown_R',\n\t\t\t\t'mouthPressLeft': 'mouthPress_L',\n\t\t\t\t'mouthPressRight': 'mouthPress_R',\n\t\t\t\t'mouthPucker': 'mouthPucker',\n\t\t\t\t'mouthRight': 'mouthRight',\n\t\t\t\t'mouthRollLower': 'mouthRollLower',\n\t\t\t\t'mouthRollUpper': 'mouthRollUpper',\n\t\t\t\t'mouthShrugLower': 'mouthShrugLower',\n\t\t\t\t'mouthShrugUpper': 'mouthShrugUpper',\n\t\t\t\t'mouthSmileLeft': 'mouthSmile_L',\n\t\t\t\t'mouthSmileRight': 'mouthSmile_R',\n\t\t\t\t'mouthStretchLeft': 'mouthStretch_L',\n\t\t\t\t'mouthStretchRight': 'mouthStretch_R',\n\t\t\t\t'mouthUpperUpLeft': 'mouthUpperUp_L',\n\t\t\t\t'mouthUpperUpRight': 'mouthUpperUp_R',\n\t\t\t\t'noseSneerLeft': 'noseSneer_L',\n\t\t\t\t'noseSneerRight': 'noseSneer_R',\n\t\t\t\t// '': 'tongueOut'\n\t\t\t};\n\n\t\t\t//\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\tcamera.position.z = 5;\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.scale.x = - 1;\n\n\t\t\tconst environment = new RoomEnvironment();\n\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\tscene.background = new THREE.Color( 0x666666 );\n\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\n\t\t\t// Face\n\n\t\t\tlet face, eyeL, eyeR;\n\t\t\tconst eyeRotationLimit = THREE.MathUtils.degToRad( 30 );\n\n\t\t\tconst ktx2Loader = new KTX2Loader()\n\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t.detectSupport( renderer );\n\n\t\t\tnew GLTFLoader()\n\t\t\t\t.setKTX2Loader( ktx2Loader )\n\t\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t\t.load( 'models/gltf/facecap.glb', ( gltf ) => {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tconst head = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\thead.material = new THREE.MeshNormalMaterial();\n\n\t\t\t\t\tface = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\teyeL = mesh.getObjectByName( 'eyeLeft' );\n  \t\t\t\t\teyeR = mesh.getObjectByName( 'eyeRight' );\n\n\t\t\t\t\t// GUI\n\n\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\tgui.close();\n\n\t\t\t\t\tconst influences = head.morphTargetInfluences;\n\n\t\t\t\t\tfor ( const [ key, value ] of Object.entries( head.morphTargetDictionary ) ) {\n\n\t\t\t\t\t\tgui.add( influences, value, 0, 1, 0.01 )\n\t\t\t\t\t\t\t.name( key.replace( 'blendShape1.', '' ) )\n\t\t\t\t\t\t\t.listen( influences );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t// Video Texture\n\n\t\t\tconst video = document.createElement( 'video' );\n\n\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tconst geometry = new THREE.PlaneGeometry( 1, 1 );\n\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture, depthWrite: false } );\n\t\t\tconst videomesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( videomesh );\n\n\t\t\t// MediaPipe\n\n\t\t\tconst filesetResolver = await FilesetResolver.forVisionTasks(\n\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'\n\t\t\t);\n\n\t\t\tconst faceLandmarker = await FaceLandmarker.createFromOptions( filesetResolver, {\n\t\t\t\tbaseOptions: {\n\t\t\t\t\tmodelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n\t\t\t\t\tdelegate: 'GPU'\n\t\t\t\t},\n\t\t\t\toutputFaceBlendshapes: true,\n\t\t\t\toutputFacialTransformationMatrixes: true,\n\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\tnumFaces: 1\n\t\t\t} );\n\n\t\t\tif ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {\n\n\t\t\t\tnavigator.mediaDevices.getUserMedia( { video: { facingMode: 'user' } } )\n\t\t\t\t\t.then( function ( stream ) {\n\n\t\t\t\t\t\tvideo.srcObject = stream;\n\t\t\t\t\t\tvideo.play();\n\n\t\t\t\t\t} )\n\t\t\t\t\t.catch( function ( error ) {\n\n\t\t\t\t\t\tconsole.error( 'Unable to access the camera/webcam.', error );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst transform = new THREE.Object3D();\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( video.readyState >= HTMLMediaElement.HAVE_METADATA ) {\n\n\t\t\t\t\tconst results = faceLandmarker.detectForVideo( video, Date.now() );\n\n\t\t\t\t\tif ( results.facialTransformationMatrixes.length > 0 ) {\n\n\t\t\t\t\t\tconst facialTransformationMatrixes = results.facialTransformationMatrixes[ 0 ].data;\n\n\t\t\t\t\t\ttransform.matrix.fromArray( facialTransformationMatrixes );\n\t\t\t\t\t\ttransform.matrix.decompose( transform.position, transform.quaternion, transform.scale );\n\n\t\t\t\t\t\tconst object = scene.getObjectByName( 'grp_transform' );\n\n\t\t\t\t\t\tobject.position.x = transform.position.x;\n\t\t\t\t\t\tobject.position.y = transform.position.z + 40;\n\t\t\t\t\t\tobject.position.z = - transform.position.y;\n\n\t\t\t\t\t\tobject.rotation.x = transform.rotation.x;\n\t\t\t\t\t\tobject.rotation.y = transform.rotation.z;\n\t\t\t\t\t\tobject.rotation.z = - transform.rotation.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( results.faceBlendshapes.length > 0 ) {\n\t\t\t\n\t\t\t\t\t\tconst faceBlendshapes = results.faceBlendshapes[ 0 ].categories;\n\t\t\t\n\t\t\t\t\t\t// Morph values does not exist on the eye meshes, so we map the eyes blendshape score into rotation values\n\t\t\t\t\t\tconst eyeScore = {\n\t\t\t\t\t\t\tleftHorizontal: 0,\n\t\t\t\t\t\t\trightHorizontal: 0,\n\t\t\t\t\t\t\tleftVertical: 0,\n\t\t\t\t\t\t\trightVertical: 0,\n      \t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( const blendshape of faceBlendshapes ) {\n\n\t\t\t\t\t\t\tconst categoryName = blendshape.categoryName;\n\t\t\t\t\t\t\tconst score = blendshape.score;\n\n\t\t\t\t\t\t\tconst index = face.morphTargetDictionary[ blendshapesMap[ categoryName ] ];\n\n\t\t\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\t\t\tface.morphTargetInfluences[ index ] = score;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// There are two blendshape for movement on each axis (up/down , in/out)\n\t\t\t\t\t\t\t// Add one and subtract the other to get the final score in -1 to 1 range\n\t\t\t\t\t\t\tswitch ( categoryName ) {\n\n\t\t\t\t\t\t\t\tcase 'eyeLookInLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftHorizontal += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookOutLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftHorizontal -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookInRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightHorizontal -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookOutRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightHorizontal += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookUpLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftVertical -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookDownLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftVertical += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookUpRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightVertical -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookDownRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightVertical += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\teyeL.rotation.z = eyeScore.leftHorizontal * eyeRotationLimit;\n\t\t\t\t\t\teyeR.rotation.z = eyeScore.rightHorizontal * eyeRotationLimit;\n\t\t\t\t\t\teyeL.rotation.x = eyeScore.leftVertical * eyeRotationLimit;\n\t\t\t\t\t\teyeR.rotation.x = eyeScore.rightVertical * eyeRotationLimit;\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvideomesh.scale.x = video.videoWidth / 100;\n\t\t\t\tvideomesh.scale.y = video.videoHeight / 100;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t}\n\n\t\t\twindow.addEventListener( 'resize', function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t} );\n```\n\nThis example three.js webgl - morph targets - webcam model by Face Cap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "How do I implement webgl morphtargets webcam in Three.js?"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - morph targets - webcam:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\t// Mediapipe\n\n\t\t\timport vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';\n\n\t\t\tconst { FaceLandmarker, FilesetResolver } = vision;\n\n\t\t\tconst blendshapesMap = {\n\t\t\t\t// '_neutral': '',\n\t\t\t\t'browDownLeft': 'browDown_L',\n\t\t\t\t'browDownRight': 'browDown_R',\n\t\t\t\t'browInnerUp': 'browInnerUp',\n\t\t\t\t'browOuterUpLeft': 'browOuterUp_L',\n\t\t\t\t'browOuterUpRight': 'browOuterUp_R',\n\t\t\t\t'cheekPuff': 'cheekPuff',\n\t\t\t\t'cheekSquintLeft': 'cheekSquint_L',\n\t\t\t\t'cheekSquintRight': 'cheekSquint_R',\n\t\t\t\t'eyeBlinkLeft': 'eyeBlink_L',\n\t\t\t\t'eyeBlinkRight': 'eyeBlink_R',\n\t\t\t\t'eyeLookDownLeft': 'eyeLookDown_L',\n\t\t\t\t'eyeLookDownRight': 'eyeLookDown_R',\n\t\t\t\t'eyeLookInLeft': 'eyeLookIn_L',\n\t\t\t\t'eyeLookInRight': 'eyeLookIn_R',\n\t\t\t\t'eyeLookOutLeft': 'eyeLookOut_L',\n\t\t\t\t'eyeLookOutRight': 'eyeLookOut_R',\n\t\t\t\t'eyeLookUpLeft': 'eyeLookUp_L',\n\t\t\t\t'eyeLookUpRight': 'eyeLookUp_R',\n\t\t\t\t'eyeSquintLeft': 'eyeSquint_L',\n\t\t\t\t'eyeSquintRight': 'eyeSquint_R',\n\t\t\t\t'eyeWideLeft': 'eyeWide_L',\n\t\t\t\t'eyeWideRight': 'eyeWide_R',\n\t\t\t\t'jawForward': 'jawForward',\n\t\t\t\t'jawLeft': 'jawLeft',\n\t\t\t\t'jawOpen': 'jawOpen',\n\t\t\t\t'jawRight': 'jawRight',\n\t\t\t\t'mouthClose': 'mouthClose',\n\t\t\t\t'mouthDimpleLeft': 'mouthDimple_L',\n\t\t\t\t'mouthDimpleRight': 'mouthDimple_R',\n\t\t\t\t'mouthFrownLeft': 'mouthFrown_L',\n\t\t\t\t'mouthFrownRight': 'mouthFrown_R',\n\t\t\t\t'mouthFunnel': 'mouthFunnel',\n\t\t\t\t'mouthLeft': 'mouthLeft',\n\t\t\t\t'mouthLowerDownLeft': 'mouthLowerDown_L',\n\t\t\t\t'mouthLowerDownRight': 'mouthLowerDown_R',\n\t\t\t\t'mouthPressLeft': 'mouthPress_L',\n\t\t\t\t'mouthPressRight': 'mouthPress_R',\n\t\t\t\t'mouthPucker': 'mouthPucker',\n\t\t\t\t'mouthRight': 'mouthRight',\n\t\t\t\t'mouthRollLower': 'mouthRollLower',\n\t\t\t\t'mouthRollUpper': 'mouthRollUpper',\n\t\t\t\t'mouthShrugLower': 'mouthShrugLower',\n\t\t\t\t'mouthShrugUpper': 'mouthShrugUpper',\n\t\t\t\t'mouthSmileLeft': 'mouthSmile_L',\n\t\t\t\t'mouthSmileRight': 'mouthSmile_R',\n\t\t\t\t'mouthStretchLeft': 'mouthStretch_L',\n\t\t\t\t'mouthStretchRight': 'mouthStretch_R',\n\t\t\t\t'mouthUpperUpLeft': 'mouthUpperUp_L',\n\t\t\t\t'mouthUpperUpRight': 'mouthUpperUp_R',\n\t\t\t\t'noseSneerLeft': 'noseSneer_L',\n\t\t\t\t'noseSneerRight': 'noseSneer_R',\n\t\t\t\t// '': 'tongueOut'\n\t\t\t};\n\n\t\t\t//\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\tcamera.position.z = 5;\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.scale.x = - 1;\n\n\t\t\tconst environment = new RoomEnvironment();\n\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\tscene.background = new THREE.Color( 0x666666 );\n\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\n\t\t\t// Face\n\n\t\t\tlet face, eyeL, eyeR;\n\t\t\tconst eyeRotationLimit = THREE.MathUtils.degToRad( 30 );\n\n\t\t\tconst ktx2Loader = new KTX2Loader()\n\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t.detectSupport( renderer );\n\n\t\t\tnew GLTFLoader()\n\t\t\t\t.setKTX2Loader( ktx2Loader )\n\t\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t\t.load( 'models/gltf/facecap.glb', ( gltf ) => {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tconst head = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\thead.material = new THREE.MeshNormalMaterial();\n\n\t\t\t\t\tface = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\teyeL = mesh.getObjectByName( 'eyeLeft' );\n  \t\t\t\t\teyeR = mesh.getObjectByName( 'eyeRight' );\n\n\t\t\t\t\t// GUI\n\n\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\tgui.close();\n\n\t\t\t\t\tconst influences = head.morphTargetInfluences;\n\n\t\t\t\t\tfor ( const [ key, value ] of Object.entries( head.morphTargetDictionary ) ) {\n\n\t\t\t\t\t\tgui.add( influences, value, 0, 1, 0.01 )\n\t\t\t\t\t\t\t.name( key.replace( 'blendShape1.', '' ) )\n\t\t\t\t\t\t\t.listen( influences );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t} );\n\n\t\t\t// Video Texture\n\n\t\t\tconst video = document.createElement( 'video' );\n\n\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\tconst geometry = new THREE.PlaneGeometry( 1, 1 );\n\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture, depthWrite: false } );\n\t\t\tconst videomesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( videomesh );\n\n\t\t\t// MediaPipe\n\n\t\t\tconst filesetResolver = await FilesetResolver.forVisionTasks(\n\t\t\t\t'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'\n\t\t\t);\n\n\t\t\tconst faceLandmarker = await FaceLandmarker.createFromOptions( filesetResolver, {\n\t\t\t\tbaseOptions: {\n\t\t\t\t\tmodelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n\t\t\t\t\tdelegate: 'GPU'\n\t\t\t\t},\n\t\t\t\toutputFaceBlendshapes: true,\n\t\t\t\toutputFacialTransformationMatrixes: true,\n\t\t\t\trunningMode: 'VIDEO',\n\t\t\t\tnumFaces: 1\n\t\t\t} );\n\n\t\t\tif ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {\n\n\t\t\t\tnavigator.mediaDevices.getUserMedia( { video: { facingMode: 'user' } } )\n\t\t\t\t\t.then( function ( stream ) {\n\n\t\t\t\t\t\tvideo.srcObject = stream;\n\t\t\t\t\t\tvideo.play();\n\n\t\t\t\t\t} )\n\t\t\t\t\t.catch( function ( error ) {\n\n\t\t\t\t\t\tconsole.error( 'Unable to access the camera/webcam.', error );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst transform = new THREE.Object3D();\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( video.readyState >= HTMLMediaElement.HAVE_METADATA ) {\n\n\t\t\t\t\tconst results = faceLandmarker.detectForVideo( video, Date.now() );\n\n\t\t\t\t\tif ( results.facialTransformationMatrixes.length > 0 ) {\n\n\t\t\t\t\t\tconst facialTransformationMatrixes = results.facialTransformationMatrixes[ 0 ].data;\n\n\t\t\t\t\t\ttransform.matrix.fromArray( facialTransformationMatrixes );\n\t\t\t\t\t\ttransform.matrix.decompose( transform.position, transform.quaternion, transform.scale );\n\n\t\t\t\t\t\tconst object = scene.getObjectByName( 'grp_transform' );\n\n\t\t\t\t\t\tobject.position.x = transform.position.x;\n\t\t\t\t\t\tobject.position.y = transform.position.z + 40;\n\t\t\t\t\t\tobject.position.z = - transform.position.y;\n\n\t\t\t\t\t\tobject.rotation.x = transform.rotation.x;\n\t\t\t\t\t\tobject.rotation.y = transform.rotation.z;\n\t\t\t\t\t\tobject.rotation.z = - transform.rotation.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( results.faceBlendshapes.length > 0 ) {\n\t\t\t\n\t\t\t\t\t\tconst faceBlendshapes = results.faceBlendshapes[ 0 ].categories;\n\t\t\t\n\t\t\t\t\t\t// Morph values does not exist on the eye meshes, so we map the eyes blendshape score into rotation values\n\t\t\t\t\t\tconst eyeScore = {\n\t\t\t\t\t\t\tleftHorizontal: 0,\n\t\t\t\t\t\t\trightHorizontal: 0,\n\t\t\t\t\t\t\tleftVertical: 0,\n\t\t\t\t\t\t\trightVertical: 0,\n      \t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( const blendshape of faceBlendshapes ) {\n\n\t\t\t\t\t\t\tconst categoryName = blendshape.categoryName;\n\t\t\t\t\t\t\tconst score = blendshape.score;\n\n\t\t\t\t\t\t\tconst index = face.morphTargetDictionary[ blendshapesMap[ categoryName ] ];\n\n\t\t\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\t\t\tface.morphTargetInfluences[ index ] = score;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// There are two blendshape for movement on each axis (up/down , in/out)\n\t\t\t\t\t\t\t// Add one and subtract the other to get the final score in -1 to 1 range\n\t\t\t\t\t\t\tswitch ( categoryName ) {\n\n\t\t\t\t\t\t\t\tcase 'eyeLookInLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftHorizontal += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookOutLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftHorizontal -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookInRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightHorizontal -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookOutRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightHorizontal += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookUpLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftVertical -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookDownLeft':\n\t\t\t\t\t\t\t\t\teyeScore.leftVertical += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookUpRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightVertical -= score;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'eyeLookDownRight':\n\t\t\t\t\t\t\t\t\teyeScore.rightVertical += score;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\teyeL.rotation.z = eyeScore.leftHorizontal * eyeRotationLimit;\n\t\t\t\t\t\teyeR.rotation.z = eyeScore.rightHorizontal * eyeRotationLimit;\n\t\t\t\t\t\teyeL.rotation.x = eyeScore.leftVertical * eyeRotationLimit;\n\t\t\t\t\t\teyeR.rotation.x = eyeScore.rightVertical * eyeRotationLimit;\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvideomesh.scale.x = video.videoWidth / 100;\n\t\t\t\tvideomesh.scale.y = video.videoHeight / 100;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t}\n\n\t\t\twindow.addEventListener( 'resize', function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t} );\n```\n\nThis example three.js webgl - morph targets - webcam model by Face Cap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - multiple elements"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - multiple elements:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet canvas, renderer;\n\n\t\t\tconst scenes = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcanvas = document.getElementById( 'c' );\n\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew THREE.SphereGeometry( 0.5, 12, 8 ),\n\t\t\t\t\tnew THREE.DodecahedronGeometry( 0.5 ),\n\t\t\t\t\tnew THREE.CylinderGeometry( 0.5, 0.5, 1, 12 )\n\t\t\t\t];\n\n\t\t\t\tconst content = document.getElementById( 'content' );\n\n\t\t\t\tfor ( let i = 0; i < 40; i ++ ) {\n\n\t\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\t\t// make a list item\n\t\t\t\t\tconst element = document.createElement( 'div' );\n\t\t\t\t\telement.className = 'list-item';\n\n\t\t\t\t\tconst sceneElement = document.createElement( 'div' );\n\t\t\t\t\telement.appendChild( sceneElement );\n\n\t\t\t\t\tconst descriptionElement = document.createElement( 'div' );\n\t\t\t\t\tdescriptionElement.innerText = 'Scene ' + ( i + 1 );\n\t\t\t\t\telement.appendChild( descriptionElement );\n\n\t\t\t\t\t// the element that represents the area we want to render the scene\n\t\t\t\t\tscene.userData.element = sceneElement;\n\t\t\t\t\tcontent.appendChild( element );\n\n\t\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, 1, 1, 10 );\n\t\t\t\t\tcamera.position.z = 2;\n\t\t\t\t\tscene.userData.camera = camera;\n\n\t\t\t\t\tconst controls = new OrbitControls( scene.userData.camera, scene.userData.element );\n\t\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\t\tcontrols.maxDistance = 5;\n\t\t\t\t\tcontrols.enablePan = false;\n\t\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\t\tscene.userData.controls = controls;\n\n\t\t\t\t\t// add one random mesh to each scene\n\t\t\t\t\tconst geometry = geometries[ geometries.length * Math.random() | 0 ];\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\n\t\t\t\t\t\tcolor: new THREE.Color().setHSL( Math.random(), 1, 0.75, THREE.SRGBColorSpace ),\n\t\t\t\t\t\troughness: 0.5,\n\t\t\t\t\t\tmetalness: 0,\n\t\t\t\t\t\tflatShading: true\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( new THREE.Mesh( geometry, material ) );\n\n\t\t\t\t\tscene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444, 3 ) );\n\n\t\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\t\tscene.add( light );\n\n\t\t\t\t\tscenes.push( scene );\n\n\t\t\t\t}\n\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );\n\t\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}\n\n\t\t\tfunction updateSize() {\n\n\t\t\t\tconst width = canvas.clientWidth;\n\t\t\t\tconst height = canvas.clientHeight;\n\n\t\t\t\tif ( canvas.width !== width || canvas.height !== height ) {\n\n\t\t\t\t\trenderer.setSize( width, height, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tupdateSize();\n\n\t\t\t\tcanvas.style.transform = `translateY(${window.scrollY}px)`;\n\n\t\t\t\trenderer.setClearColor( 0xffffff );\n\t\t\t\trenderer.setScissorTest( false );\n\t\t\t\trenderer.clear();\n\n\t\t\t\trenderer.setClearColor( 0xe0e0e0 );\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\tscenes.forEach( function ( scene ) {\n\n\t\t\t\t\t// so something moves\n\t\t\t\t\tscene.children[ 0 ].rotation.y = Date.now() * 0.001;\n\n\t\t\t\t\t// get the element that is a place holder for where we want to\n\t\t\t\t\t// draw the scene\n\t\t\t\t\tconst element = scene.userData.element;\n\n\t\t\t\t\t// get its position relative to the page's viewport\n\t\t\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\t\t\t// check if it's offscreen. If so skip it\n\t\t\t\t\tif ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||\n\t\t\t\t\t\t rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {\n\n\t\t\t\t\t\treturn; // it's off screen\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// set the viewport\n\t\t\t\t\tconst width = rect.right - rect.left;\n\t\t\t\t\tconst height = rect.bottom - rect.top;\n\t\t\t\t\tconst left = rect.left;\n\t\t\t\t\tconst bottom = renderer.domElement.clientHeight - rect.bottom;\n\n\t\t\t\t\trenderer.setViewport( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissor( left, bottom, width, height );\n\n\t\t\t\t\tconst camera = scene.userData.camera;\n\n\t\t\t\t\t//camera.aspect = width / height; // not changing in this example\n\t\t\t\t\t//camera.updateProjectionMatrix();\n\n\t\t\t\t\t//scene.userData.controls.update();\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - multiple elements - webgl"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - multiple elements with text"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - multiple elements with text:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tconst scenes = [];\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet views, t, canvas, renderer;\n\n\t\t\twindow.onload = init;\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst balls = 20;\n\t\t\t\tconst size = .25;\n\n\t\t\t\tconst colors = [\n\t\t\t\t\t'rgb(0,127,255)', 'rgb(255,0,0)', 'rgb(0,255,0)', 'rgb(0,255,255)',\n\t\t\t\t\t'rgb(255,0,255)', 'rgb(255,0,127)', 'rgb(255,255,0)', 'rgb(0,255,127)'\n\t\t\t\t];\n\n\t\t\t\tcanvas = document.getElementById( 'c' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tviews = document.querySelectorAll( '.view' );\n\n\t\t\t\tfor ( let n = 0; n < views.length; n ++ ) {\n\n\t\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\t\tconst geometry0 = new THREE.BufferGeometry();\n\t\t\t\t\tconst geometry1 = new THREE.BufferGeometry();\n\n\t\t\t\t\tconst vertices = [];\n\n\t\t\t\t\tif ( views[ n ].lattice ) {\n\n\t\t\t\t\t\tconst range = balls / 2;\n\t\t\t\t\t\tfor ( let i = - range; i <= range; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( let j = - range; j <= range; j ++ ) {\n\n\t\t\t\t\t\t\t\tfor ( let k = - range; k <= range; k ++ ) {\n\n\t\t\t\t\t\t\t\t\tvertices.push( i, j, k );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let m = 0; m < Math.pow( balls, 3 ); m ++ ) {\n\n\t\t\t\t\t\t\tconst i = balls * Math.random() - balls / 2;\n\t\t\t\t\t\t\tconst j = balls * Math.random() - balls / 2;\n\t\t\t\t\t\t\tconst k = balls * Math.random() - balls / 2;\n\n\t\t\t\t\t\t\tvertices.push( i, j, k );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry0.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\t\tgeometry1.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices.slice(), 3 ) );\n\n\t\t\t\t\tconst index = Math.floor( colors.length * Math.random() );\n\n\t\t\t\t\tconst canvas2 = document.createElement( 'canvas' );\n\t\t\t\t\tcanvas2.width = 128;\n\t\t\t\t\tcanvas2.height = 128;\n\t\t\t\t\tconst context = canvas2.getContext( '2d' );\n\t\t\t\t\tcontext.arc( 64, 64, 64, 0, 2 * Math.PI );\n\t\t\t\t\tcontext.fillStyle = colors[ index ];\n\t\t\t\t\tcontext.fill();\n\t\t\t\t\tconst texture = new THREE.CanvasTexture( canvas2 );\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tconst material = new THREE.PointsMaterial( { size: size, map: texture, transparent: true, alphaTest: 0.1 } );\n\n\t\t\t\t\tscene.add( new THREE.Points( geometry0, material ) );\n\n\t\t\t\t\tscene.userData.view = views[ n ];\n\t\t\t\t\tscene.userData.geometry1 = geometry1;\n\n\t\t\t\t\tconst camera = new THREE.PerspectiveCamera( 75, 1, 0.1, 100 );\n\t\t\t\t\tcamera.position.set( 0, 0, 1.2 * balls );\n\t\t\t\t\tscene.userData.camera = camera;\n\n\t\t\t\t\tconst controls = new OrbitControls( camera, views[ n ] );\n\t\t\t\t\tscene.userData.controls = controls;\n\n\t\t\t\t\tscenes.push( scene );\n\n\t\t\t\t}\n\n\t\t\t\tt = 0;\n\t\t\t\tanimate();\n\n\t\t\t}\n\n\t\t\tfunction updateSize() {\n\n\t\t\t\tconst width = canvas.clientWidth;\n\t\t\t\tconst height = canvas.clientHeight;\n\n\t\t\t\tif ( canvas.width !== width || canvas.height != height ) {\n\n\t\t\t\t\trenderer.setSize( width, height, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tupdateSize();\n\n\t\t\t\trenderer.setClearColor( 0xffffff );\n\t\t\t\trenderer.setScissorTest( false );\n\t\t\t\trenderer.clear();\n\n\t\t\t\trenderer.setClearColor( 0x000000 );\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\tscenes.forEach( function ( scene ) {\n\n\t\t\t\t\tconst rect = scene.userData.view.getBoundingClientRect();\n\n\t\t\t\t\t// check if it's offscreen. If so skip it\n\n\t\t\t\t\tif ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||\n\t\t\t\t\t\t rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {\n\n\t\t\t\t\t\treturn; // it's off screen\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// set the viewport\n\n\t\t\t\t\tconst width = rect.right - rect.left;\n\t\t\t\t\tconst height = rect.bottom - rect.top;\n\t\t\t\t\tconst left = rect.left;\n\t\t\t\t\tconst bottom = renderer.domElement.clientHeight - rect.bottom;\n\n\t\t\t\t\trenderer.setViewport( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissor( left, bottom, width, height );\n\n\t\t\t\t\trenderer.render( scene, scene.userData.camera );\n\n\t\t\t\t\tconst points = scene.children[ 0 ];\n\t\t\t\t\tconst position = points.geometry.attributes.position;\n\n\t\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\t\tconst offset = new THREE.Vector3();\n\n\t\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tpoint.fromBufferAttribute( scene.userData.geometry1.attributes.position, i );\n\n\t\t\t\t\t\tscene.userData.view.displacement( point.x, point.y, point.z, t / 5, offset );\n\n\t\t\t\t\t\tposition.setXYZ( i, point.x + offset.x, point.y + offset.y, point.z + offset.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tt += clock.getDelta() * 60;\n\n\t\t\t}\n```\n\nThis example three.js - multiple elements with text - webgl"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - scene - multiple - compare"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - scene - multiple - compare:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, camera, renderer, controls;\n\t\t\tlet sceneL, sceneR;\n\n\t\t\tlet sliderPos = window.innerWidth / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.querySelector( '.container' );\n\n\t\t\t\tsceneL = new THREE.Scene();\n\t\t\t\tsceneL.background = new THREE.Color( 0xBCD48F );\n\n\t\t\t\tsceneR = new THREE.Scene();\n\t\t\t\tsceneR.background = new THREE.Color( 0x8FBCD4 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 6;\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xffffff, 0x444444, 3 );\n\t\t\t\tlight.position.set( - 2, 2, 2 );\n\t\t\t\tsceneL.add( light.clone() );\n\t\t\t\tsceneR.add( light.clone() );\n\n\t\t\t\tinitMeshes();\n\t\t\t\tinitSlider();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setScissorTest( true );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initMeshes() {\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 3 );\n\n\t\t\t\tconst meshL = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\t\t\tsceneL.add( meshL );\n\n\t\t\t\tconst meshR = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial( { wireframe: true } ) );\n\t\t\t\tsceneR.add( meshR );\n\n\t\t\t}\n\n\t\t\tfunction initSlider() {\n\n\t\t\t\tconst slider = document.querySelector( '.slider' );\n\n\t\t\t\tfunction onPointerDown() {\n\n\t\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\t\tcontrols.enabled = false;\n\n\t\t\t\t\twindow.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\twindow.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t}\n\n\t\t\t\tfunction onPointerUp() {\n\n\t\t\t\t\tcontrols.enabled = true;\n\n\t\t\t\t\twindow.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\twindow.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t}\n\n\t\t\t\tfunction onPointerMove( e ) {\n\n\t\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\t\tsliderPos = Math.max( 0, Math.min( window.innerWidth, e.pageX ) );\n\n\t\t\t\t\tslider.style.left = sliderPos - ( slider.offsetWidth / 2 ) + 'px';\n\n\t\t\t\t}\n\n\t\t\t\tslider.style.touchAction = 'none'; // disable touch scroll\n\t\t\t\tslider.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.setScissor( 0, 0, sliderPos, window.innerHeight );\n\t\t\t\trenderer.render( sceneL, camera );\n\n\t\t\t\trenderer.setScissor( sliderPos, 0, window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.render( sceneR, camera );\n\n\t\t\t}\n```\n\nThis example three.js - multiple scenes comparison"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - multiple views"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - multiple views:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet stats;\n\n\t\t\tlet scene, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowWidth, windowHeight;\n\n\t\t\tconst views = [\n\t\t\t\t{\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\twidth: 0.5,\n\t\t\t\t\theight: 1.0,\n\t\t\t\t\tbackground: new THREE.Color().setRGB( 0.5, 0.5, 0.7, THREE.SRGBColorSpace ),\n\t\t\t\t\teye: [ 0, 300, 1800 ],\n\t\t\t\t\tup: [ 0, 1, 0 ],\n\t\t\t\t\tfov: 30,\n\t\t\t\t\tupdateCamera: function ( camera, scene, mouseX ) {\n\n\t\t\t\t\t  camera.position.x += mouseX * 0.05;\n\t\t\t\t\t  camera.position.x = Math.max( Math.min( camera.position.x, 2000 ), - 2000 );\n\t\t\t\t\t  camera.lookAt( scene.position );\n\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tleft: 0.5,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\twidth: 0.5,\n\t\t\t\t\theight: 0.5,\n\t\t\t\t\tbackground: new THREE.Color().setRGB( 0.7, 0.5, 0.5, THREE.SRGBColorSpace ),\n\t\t\t\t\teye: [ 0, 1800, 0 ],\n\t\t\t\t\tup: [ 0, 0, 1 ],\n\t\t\t\t\tfov: 45,\n\t\t\t\t\tupdateCamera: function ( camera, scene, mouseX ) {\n\n\t\t\t\t\t  camera.position.x -= mouseX * 0.05;\n\t\t\t\t\t  camera.position.x = Math.max( Math.min( camera.position.x, 2000 ), - 2000 );\n\t\t\t\t\t  camera.lookAt( camera.position.clone().setY( 0 ) );\n\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tleft: 0.5,\n\t\t\t\t\tbottom: 0.5,\n\t\t\t\t\twidth: 0.5,\n\t\t\t\t\theight: 0.5,\n\t\t\t\t\tbackground: new THREE.Color().setRGB( 0.5, 0.7, 0.7, THREE.SRGBColorSpace ),\n\t\t\t\t\teye: [ 1400, 800, 1400 ],\n\t\t\t\t\tup: [ 0, 1, 0 ],\n\t\t\t\t\tfov: 60,\n\t\t\t\t\tupdateCamera: function ( camera, scene, mouseX ) {\n\n\t\t\t\t\t  camera.position.y -= mouseX * 0.05;\n\t\t\t\t\t  camera.position.y = Math.max( Math.min( camera.position.y, 1600 ), - 1600 );\n\t\t\t\t\t  camera.lookAt( scene.position );\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tfor ( let ii = 0; ii < views.length; ++ ii ) {\n\n\t\t\t\t\tconst view = views[ ii ];\n\t\t\t\t\tconst camera = new THREE.PerspectiveCamera( view.fov, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\t\tcamera.position.fromArray( view.eye );\n\t\t\t\t\tcamera.up.fromArray( view.up );\n\t\t\t\t\tview.camera = camera;\n\n\t\t\t\t}\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 0, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// shadow\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 128;\n\t\t\t\tcanvas.height = 128;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tconst gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );\n\t\t\t\tgradient.addColorStop( 0.1, 'rgba(0,0,0,0.15)' );\n\t\t\t\tgradient.addColorStop( 1, 'rgba(0,0,0,0)' );\n\n\t\t\t\tcontext.fillStyle = gradient;\n\t\t\t\tcontext.fillRect( 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconst shadowTexture = new THREE.CanvasTexture( canvas );\n\n\t\t\t\tconst shadowMaterial = new THREE.MeshBasicMaterial( { map: shadowTexture, transparent: true } );\n\t\t\t\tconst shadowGeo = new THREE.PlaneGeometry( 300, 300, 1, 1 );\n\n\t\t\t\tlet shadowMesh;\n\n\t\t\t\tshadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );\n\t\t\t\tshadowMesh.position.y = - 250;\n\t\t\t\tshadowMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\tshadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );\n\t\t\t\tshadowMesh.position.x = - 400;\n\t\t\t\tshadowMesh.position.y = - 250;\n\t\t\t\tshadowMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\tshadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );\n\t\t\t\tshadowMesh.position.x = 400;\n\t\t\t\tshadowMesh.position.y = - 250;\n\t\t\t\tshadowMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\tconst radius = 200;\n\n\t\t\t\tconst geometry1 = new THREE.IcosahedronGeometry( radius, 1 );\n\n\t\t\t\tconst count = geometry1.attributes.position.count;\n\t\t\t\tgeometry1.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array( count * 3 ), 3 ) );\n\n\t\t\t\tconst geometry2 = geometry1.clone();\n\t\t\t\tconst geometry3 = geometry1.clone();\n\n\t\t\t\tconst color = new THREE.Color();\n\t\t\t\tconst positions1 = geometry1.attributes.position;\n\t\t\t\tconst positions2 = geometry2.attributes.position;\n\t\t\t\tconst positions3 = geometry3.attributes.position;\n\t\t\t\tconst colors1 = geometry1.attributes.color;\n\t\t\t\tconst colors2 = geometry2.attributes.color;\n\t\t\t\tconst colors3 = geometry3.attributes.color;\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tcolor.setHSL( ( positions1.getY( i ) / radius + 1 ) / 2, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors1.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setHSL( 0, ( positions2.getY( i ) / radius + 1 ) / 2, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors2.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t\tcolor.setRGB( 1, 0.8 - ( positions3.getY( i ) / radius + 1 ) / 2, 0, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors3.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tflatShading: true,\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tshininess: 0\n\t\t\t\t} );\n\n\t\t\t\tconst wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );\n\n\t\t\t\tlet mesh = new THREE.Mesh( geometry1, material );\n\t\t\t\tlet wireframe = new THREE.Mesh( geometry1, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\t\t\t\tmesh.position.x = - 400;\n\t\t\t\tmesh.rotation.x = - 1.87;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry2, material );\n\t\t\t\twireframe = new THREE.Mesh( geometry2, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\t\t\t\tmesh.position.x = 400;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t mesh = new THREE.Mesh( geometry3, material );\n\t\t\t\twireframe = new THREE.Mesh( geometry3, wireframeMaterial );\n\t\t\t\tmesh.add( wireframe );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowWidth / 2 );\n\t\t\t\tmouseY = ( event.clientY - windowHeight / 2 );\n\n\t\t\t}\n\n\t\t\tfunction updateSize() {\n\n\t\t\t\tif ( windowWidth != window.innerWidth || windowHeight != window.innerHeight ) {\n\n\t\t\t\t\twindowWidth = window.innerWidth;\n\t\t\t\t\twindowHeight = window.innerHeight;\n\n\t\t\t\t\trenderer.setSize( windowWidth, windowHeight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tupdateSize();\n\n\t\t\t\tfor ( let ii = 0; ii < views.length; ++ ii ) {\n\n\t\t\t\t\tconst view = views[ ii ];\n\t\t\t\t\tconst camera = view.camera;\n\n\t\t\t\t\tview.updateCamera( camera, scene, mouseX );\n\n\t\t\t\t\tconst left = Math.floor( windowWidth * view.left );\n\t\t\t\t\tconst bottom = Math.floor( windowHeight * view.bottom );\n\t\t\t\t\tconst width = Math.floor( windowWidth * view.width );\n\t\t\t\t\tconst height = Math.floor( windowHeight * view.height );\n\n\t\t\t\t\trenderer.setViewport( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissor( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissorTest( true );\n\t\t\t\t\trenderer.setClearColor( view.background );\n\n\t\t\t\t\tcamera.aspect = width / height;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - multiple views - webgl"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - panorama"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - panorama:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, controls;\n\t\t\tlet renderer;\n\t\t\tlet scene;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 0.01;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.rotateSpeed = - 0.25;\n\n\t\t\t\tconst textures = getTexturesFromAtlasFile( 'textures/cube/sun_temple_stripe.jpg', 6 );\n\n\t\t\t\tconst materials = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tmaterials.push( new THREE.MeshBasicMaterial( { map: textures[ i ] } ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst skyBox = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), materials );\n\t\t\t\tskyBox.geometry.scale( 1, 1, - 1 );\n\t\t\t\tscene.add( skyBox );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction getTexturesFromAtlasFile( atlasImgUrl, tilesNum ) {\n\n\t\t\t\tconst textures = [];\n\n\t\t\t\tfor ( let i = 0; i < tilesNum; i ++ ) {\n\n\t\t\t\t\ttextures[ i ] = new THREE.Texture();\n\n\t\t\t\t}\n\n\t\t\t\tnew THREE.ImageLoader()\n\t\t\t\t\t.load( atlasImgUrl, ( image ) => {\n\n\t\t\t\t\t\tlet canvas, context;\n\t\t\t\t\t\tconst tileWidth = image.height;\n\n\t\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\t\tcanvas = document.createElement( 'canvas' );\n\t\t\t\t\t\t\tcontext = canvas.getContext( '2d' );\n\t\t\t\t\t\t\tcanvas.height = tileWidth;\n\t\t\t\t\t\t\tcanvas.width = tileWidth;\n\t\t\t\t\t\t\tcontext.drawImage( image, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth );\n\t\t\t\t\t\t\ttextures[ i ].colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\t\ttextures[ i ].image = canvas;\n\t\t\t\t\t\t\ttextures[ i ].needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\treturn textures;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update(); // required when damping is enabled\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - cube panorama demo"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - equirectangular panorama"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - equirectangular panorama:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet isUserInteracting = false,\n\t\t\t\tonPointerDownMouseX = 0, onPointerDownMouseY = 0,\n\t\t\t\tlon = 0, onPointerDownLon = 0,\n\t\t\t\tlat = 0, onPointerDownLat = 0,\n\t\t\t\tphi = 0, theta = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 500, 60, 40 );\n\t\t\t\t// invert the geometry on the x-axis so that all of the faces point inward\n\t\t\t\tgeometry.scale( - 1, 1, 1 );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\tdocument.addEventListener( 'wheel', onDocumentMouseWheel );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tisUserInteracting = true;\n\n\t\t\t\tonPointerDownMouseX = event.clientX;\n\t\t\t\tonPointerDownMouseY = event.clientY;\n\n\t\t\t\tonPointerDownLon = lon;\n\t\t\t\tonPointerDownLat = lat;\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tlon = ( onPointerDownMouseX - event.clientX ) * 0.1 + onPointerDownLon;\n\t\t\t\tlat = ( event.clientY - onPointerDownMouseY ) * 0.1 + onPointerDownLat;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tisUserInteracting = false;\n\n\t\t\t\tdocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseWheel( event ) {\n\n\t\t\t\tconst fov = camera.fov + event.deltaY * 0.05;\n\n\t\t\t\tcamera.fov = THREE.MathUtils.clamp( fov, 10, 75 );\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( isUserInteracting === false ) {\n\n\t\t\t\t\tlon += 0.1;\n\n\t\t\t\t}\n\n\t\t\t\tlat = Math.max( - 85, Math.min( 85, lat ) );\n\t\t\t\tphi = THREE.MathUtils.degToRad( 90 - lat );\n\t\t\t\ttheta = THREE.MathUtils.degToRad( lon );\n\n\t\t\t\tconst x = 500 * Math.sin( phi ) * Math.cos( theta );\n\t\t\t\tconst y = 500 * Math.cos( phi );\n\t\t\t\tconst z = 500 * Math.sin( phi ) * Math.sin( theta );\n\n\t\t\t\tcamera.lookAt( x, y, z );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - equirectangular panorama demo. photo by J\u00f3n Ragnarsson"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - particles - billboards"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - particles - billboards:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats, material;\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 2, 2000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.FogExp2( 0x000000, 0.001 );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tconst sprite = new THREE.TextureLoader().load( 'textures/sprites/disc.png' );\n\t\t\t\tsprite.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tfor ( let i = 0; i < 10000; i ++ ) {\n\n\t\t\t\t\tconst x = 2000 * Math.random() - 1000;\n\t\t\t\t\tconst y = 2000 * Math.random() - 1000;\n\t\t\t\t\tconst z = 2000 * Math.random() - 1000;\n\n\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tmaterial = new THREE.PointsMaterial( { size: 35, sizeAttenuation: true, map: sprite, alphaTest: 0.5, transparent: true } );\n\t\t\t\tmaterial.color.setHSL( 1.0, 0.3, 0.7, THREE.SRGBColorSpace );\n\n\t\t\t\tconst particles = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( material, 'sizeAttenuation' ).onChange( function () {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.style.touchAction = 'none';\n\t\t\t\tdocument.body.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.00005;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst h = ( 360 * ( 1.0 + time ) % 360 ) / 360;\n\t\t\t\tmaterial.color.setHSL( h, 0.5, 0.5 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl particle billboards example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - particles - dynamic - postprocessing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - particles - dynamic - postprocessing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { BloomPass } from 'three/addons/postprocessing/BloomPass.js';\n\t\t\timport { FilmPass } from 'three/addons/postprocessing/FilmPass.js';\n\t\t\timport { FocusShader } from 'three/addons/shaders/FocusShader.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, mesh;\n\n\t\t\tlet parent;\n\n\t\t\tconst meshes = [], clonemeshes = [];\n\n\t\t\tlet composer, effectFocus;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.querySelector( '#container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 50000 );\n\t\t\t\tcamera.position.set( 0, 700, 7000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x000104 );\n\t\t\t\tscene.fog = new THREE.FogExp2( 0x000104, 0.0000675 );\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst loader = new OBJLoader();\n\n\t\t\t\tloader.load( 'models/obj/male02/male02.obj', function ( object ) {\n\n\t\t\t\t\tconst positions = combineBuffer( object, 'position' );\n\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, - 500, - 350, 600, 0xff7744 );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, 500, - 350, 0, 0xff5522 );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, - 250, - 350, 1500, 0xff9922 );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, - 250, - 350, - 1500, 0xff99ff );\n\n\t\t\t\t} );\n\n\t\t\t\tloader.load( 'models/obj/female02/female02.obj', function ( object ) {\n\n\t\t\t\t\tconst positions = combineBuffer( object, 'position' );\n\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, - 1000, - 350, 0, 0xffdd44 );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, 0, - 350, 0, 0xffffff );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, 1000, - 350, 400, 0xff4422 );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, 250, - 350, 1500, 0xff9955 );\n\t\t\t\t\tcreateMesh( positions, scene, 4.05, 250, - 350, 2500, 0xff77dd );\n\n\t\t\t\t} );\n\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tparent = new THREE.Object3D();\n\t\t\t\tscene.add( parent );\n\n\t\t\t\tconst grid = new THREE.Points( new THREE.PlaneGeometry( 15000, 15000, 64, 64 ), new THREE.PointsMaterial( { color: 0xff0000, size: 10 } ) );\n\t\t\t\tgrid.position.y = - 400;\n\t\t\t\tgrid.rotation.x = - Math.PI / 2;\n\t\t\t\tparent.add( grid );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tconst renderModel = new RenderPass( scene, camera );\n\t\t\t\tconst effectBloom = new BloomPass( 0.75 );\n\t\t\t\tconst effectFilm = new FilmPass();\n\n\t\t\t\teffectFocus = new ShaderPass( FocusShader );\n\n\t\t\t\teffectFocus.uniforms[ 'screenWidth' ].value = window.innerWidth * window.devicePixelRatio;\n\t\t\t\teffectFocus.uniforms[ 'screenHeight' ].value = window.innerHeight * window.devicePixelRatio;\n\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tcomposer.addPass( renderModel );\n\t\t\t\tcomposer.addPass( effectBloom );\n\t\t\t\tcomposer.addPass( effectFilm );\n\t\t\t\tcomposer.addPass( effectFocus );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t//stats\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\teffectFocus.uniforms[ 'screenWidth' ].value = window.innerWidth * window.devicePixelRatio;\n\t\t\t\teffectFocus.uniforms[ 'screenHeight' ].value = window.innerHeight * window.devicePixelRatio;\n\n\t\t\t}\n\n\t\t\tfunction combineBuffer( model, bufferName ) {\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tmodel.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tconst buffer = child.geometry.attributes[ bufferName ];\n\n\t\t\t\t\t\tcount += buffer.array.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tconst combined = new Float32Array( count );\n\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tmodel.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tconst buffer = child.geometry.attributes[ bufferName ];\n\n\t\t\t\t\t\tcombined.set( buffer.array, offset );\n\t\t\t\t\t\toffset += buffer.array.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn new THREE.BufferAttribute( combined, 3 );\n\n\t\t\t}\n\n\t\t\tfunction createMesh( positions, scene, scale, x, y, z, color ) {\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', positions.clone() );\n\t\t\t\tgeometry.setAttribute( 'initialPosition', positions.clone() );\n\n\t\t\t\tgeometry.attributes.position.setUsage( THREE.DynamicDrawUsage );\n\n\t\t\t\tconst clones = [\n\n\t\t\t\t\t[ 6000, 0, - 4000 ],\n\t\t\t\t\t[ 5000, 0, 0 ],\n\t\t\t\t\t[ 1000, 0, 5000 ],\n\t\t\t\t\t[ 1000, 0, - 5000 ],\n\t\t\t\t\t[ 4000, 0, 2000 ],\n\t\t\t\t\t[ - 4000, 0, 1000 ],\n\t\t\t\t\t[ - 5000, 0, - 5000 ],\n\n\t\t\t\t\t[ 0, 0, 0 ]\n\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < clones.length; i ++ ) {\n\n\t\t\t\t\tconst c = ( i < clones.length - 1 ) ? 0x252525 : color;\n\n\t\t\t\t\tmesh = new THREE.Points( geometry, new THREE.PointsMaterial( { size: 30, color: c } ) );\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = scale;\n\n\t\t\t\t\tmesh.position.x = x + clones[ i ][ 0 ];\n\t\t\t\t\tmesh.position.y = y + clones[ i ][ 1 ];\n\t\t\t\t\tmesh.position.z = z + clones[ i ][ 2 ];\n\n\t\t\t\t\tparent.add( mesh );\n\n\t\t\t\t\tclonemeshes.push( { mesh: mesh, speed: 0.5 + Math.random() } );\n\n\t\t\t\t}\n\n\t\t\t\tmeshes.push( {\n\t\t\t\t\tmesh: mesh, verticesDown: 0, verticesUp: 0, direction: 0, speed: 15, delay: Math.floor( 200 + 200 * Math.random() ),\n\t\t\t\t\tstart: Math.floor( 100 + 200 * Math.random() ),\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tlet delta = 10 * clock.getDelta();\n\n\t\t\t\tdelta = delta < 2 ? delta : 2;\n\n\t\t\t\tparent.rotation.y += - 0.02 * delta;\n\n\t\t\t\tfor ( let j = 0; j < clonemeshes.length; j ++ ) {\n\n\t\t\t\t\tconst cm = clonemeshes[ j ];\n\t\t\t\t\tcm.mesh.rotation.y += - 0.1 * delta * cm.speed;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < meshes.length; j ++ ) {\n\n\t\t\t\t\tconst data = meshes[ j ];\n\t\t\t\t\tconst positions = data.mesh.geometry.attributes.position;\n\t\t\t\t\tconst initialPositions = data.mesh.geometry.attributes.initialPosition;\n\n\t\t\t\t\tconst count = positions.count;\n\n\t\t\t\t\tif ( data.start > 0 ) {\n\n\t\t\t\t\t\tdata.start -= 1;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( data.direction === 0 ) {\n\n\t\t\t\t\t\t\tdata.direction = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tconst px = positions.getX( i );\n\t\t\t\t\t\tconst py = positions.getY( i );\n\t\t\t\t\t\tconst pz = positions.getZ( i );\n\n\t\t\t\t\t\t// falling down\n\t\t\t\t\t\tif ( data.direction < 0 ) {\n\n\t\t\t\t\t\t\tif ( py > 0 ) {\n\n\t\t\t\t\t\t\t\tpositions.setXYZ(\n\t\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t\tpx + 1.5 * ( 0.50 - Math.random() ) * data.speed * delta,\n\t\t\t\t\t\t\t\t\tpy + 3.0 * ( 0.25 - Math.random() ) * data.speed * delta,\n\t\t\t\t\t\t\t\t\tpz + 1.5 * ( 0.50 - Math.random() ) * data.speed * delta\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tdata.verticesDown += 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// rising up\n\t\t\t\t\t\tif ( data.direction > 0 ) {\n\n\t\t\t\t\t\t\tconst ix = initialPositions.getX( i );\n\t\t\t\t\t\t\tconst iy = initialPositions.getY( i );\n\t\t\t\t\t\t\tconst iz = initialPositions.getZ( i );\n\n\t\t\t\t\t\t\tconst dx = Math.abs( px - ix );\n\t\t\t\t\t\t\tconst dy = Math.abs( py - iy );\n\t\t\t\t\t\t\tconst dz = Math.abs( pz - iz );\n\n\t\t\t\t\t\t\tconst d = dx + dy + dx;\n\n\t\t\t\t\t\t\tif ( d > 1 ) {\n\n\t\t\t\t\t\t\t\tpositions.setXYZ(\n\t\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t\tpx - ( px - ix ) / dx * data.speed * delta * ( 0.85 - Math.random() ),\n\t\t\t\t\t\t\t\t\tpy - ( py - iy ) / dy * data.speed * delta * ( 1 + Math.random() ),\n\t\t\t\t\t\t\t\t\tpz - ( pz - iz ) / dz * data.speed * delta * ( 0.85 - Math.random() )\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tdata.verticesUp += 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// all vertices down\n\t\t\t\t\tif ( data.verticesDown >= count ) {\n\n\t\t\t\t\t\tif ( data.delay <= 0 ) {\n\n\t\t\t\t\t\t\tdata.direction = 1;\n\t\t\t\t\t\t\tdata.speed = 5;\n\t\t\t\t\t\t\tdata.verticesDown = 0;\n\t\t\t\t\t\t\tdata.delay = 320;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.delay -= 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// all vertices up\n\t\t\t\t\tif ( data.verticesUp >= count ) {\n\n\t\t\t\t\t\tif ( data.delay <= 0 ) {\n\n\t\t\t\t\t\t\tdata.direction = - 1;\n\t\t\t\t\t\t\tdata.speed = 15;\n\t\t\t\t\t\t\tdata.verticesUp = 0;\n\t\t\t\t\t\t\tdata.delay = 120;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.delay -= 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpositions.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tcomposer.render( 0.01 );\n\n\t\t\t}\n```\n\nThis example three.js - webgl dynamic particles + postprocessing models by Reallusion iClone"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - particles - sprites"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - particles - sprites:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats, parameters;\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tconst materials = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.FogExp2( 0x000000, 0.0008 );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst assignSRGB = ( texture ) => {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t};\n\n\t\t\t\tconst sprite1 = textureLoader.load( 'textures/sprites/snowflake1.png', assignSRGB );\n\t\t\t\tconst sprite2 = textureLoader.load( 'textures/sprites/snowflake2.png', assignSRGB );\n\t\t\t\tconst sprite3 = textureLoader.load( 'textures/sprites/snowflake3.png', assignSRGB );\n\t\t\t\tconst sprite4 = textureLoader.load( 'textures/sprites/snowflake4.png', assignSRGB );\n\t\t\t\tconst sprite5 = textureLoader.load( 'textures/sprites/snowflake5.png', assignSRGB );\n\n\t\t\t\tfor ( let i = 0; i < 10000; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * 2000 - 1000;\n\t\t\t\t\tconst y = Math.random() * 2000 - 1000;\n\t\t\t\t\tconst z = Math.random() * 2000 - 1000;\n\n\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tparameters = [\n\t\t\t\t\t[[ 1.0, 0.2, 0.5 ], sprite2, 20 ],\n\t\t\t\t\t[[ 0.95, 0.1, 0.5 ], sprite3, 15 ],\n\t\t\t\t\t[[ 0.90, 0.05, 0.5 ], sprite1, 10 ],\n\t\t\t\t\t[[ 0.85, 0, 0.5 ], sprite5, 8 ],\n\t\t\t\t\t[[ 0.80, 0, 0.5 ], sprite4, 5 ]\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\t\tconst color = parameters[ i ][ 0 ];\n\t\t\t\t\tconst sprite = parameters[ i ][ 1 ];\n\t\t\t\t\tconst size = parameters[ i ][ 2 ];\n\n\t\t\t\t\tmaterials[ i ] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );\n\t\t\t\t\tmaterials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ], THREE.SRGBColorSpace );\n\n\t\t\t\t\tconst particles = new THREE.Points( geometry, materials[ i ] );\n\n\t\t\t\t\tparticles.rotation.x = Math.random() * 6;\n\t\t\t\t\tparticles.rotation.y = Math.random() * 6;\n\t\t\t\t\tparticles.rotation.z = Math.random() * 6;\n\n\t\t\t\t\tscene.add( particles );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst params = {\n\t\t\t\t\ttexture: true\n\t\t\t\t};\n\n\t\t\t\tgui.add( params, 'texture' ).onChange( function ( value ) {\n\n\t\t\t\t\tfor ( let i = 0; i < materials.length; i ++ ) {\n\n\t\t\t\t\t\tmaterials[ i ].map = ( value === true ) ? parameters[ i ][ 1 ] : null;\n\t\t\t\t\t\tmaterials[ i ].needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t\tdocument.body.style.touchAction = 'none';\n\t\t\t\tdocument.body.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.00005;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\tconst object = scene.children[ i ];\n\n\t\t\t\t\tif ( object instanceof THREE.Points ) {\n\n\t\t\t\t\t\tobject.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < materials.length; i ++ ) {\n\n\t\t\t\t\tconst color = parameters[ i ][ 0 ];\n\n\t\t\t\t\tconst h = ( 360 * ( color[ 0 ] + time ) % 360 ) / 360;\n\t\t\t\t\tmaterials[ i ].color.setHSL( h, color[ 1 ], color[ 2 ], THREE.SRGBColorSpace );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl particle sprites example snowflakes by Ren\u00e9 Descartes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - particles - waves"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - particles - waves:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tconst SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet particles, count = 0;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst numParticles = AMOUNTX * AMOUNTY;\n\n\t\t\t\tconst positions = new Float32Array( numParticles * 3 );\n\t\t\t\tconst scales = new Float32Array( numParticles );\n\n\t\t\t\tlet i = 0, j = 0;\n\n\t\t\t\tfor ( let ix = 0; ix < AMOUNTX; ix ++ ) {\n\n\t\t\t\t\tfor ( let iy = 0; iy < AMOUNTY; iy ++ ) {\n\n\t\t\t\t\t\tpositions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x\n\t\t\t\t\t\tpositions[ i + 1 ] = 0; // y\n\t\t\t\t\t\tpositions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z\n\n\t\t\t\t\t\tscales[ j ] = 1;\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tcolor: { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tparticles = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst positions = particles.geometry.attributes.position.array;\n\t\t\t\tconst scales = particles.geometry.attributes.scale.array;\n\n\t\t\t\tlet i = 0, j = 0;\n\n\t\t\t\tfor ( let ix = 0; ix < AMOUNTX; ix ++ ) {\n\n\t\t\t\t\tfor ( let iy = 0; iy < AMOUNTY; iy ++ ) {\n\n\t\t\t\t\t\tpositions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +\n\t\t\t\t\t\t\t\t\t\t( Math.sin( ( iy + count ) * 0.5 ) * 50 );\n\n\t\t\t\t\t\tscales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 +\n\t\t\t\t\t\t\t\t\t\t( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tparticles.geometry.attributes.position.needsUpdate = true;\n\t\t\t\tparticles.geometry.attributes.scale.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tcount += 0.1;\n\n\t\t\t}\n```\n\nThis example three.js - webgl particles waves example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - portal"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - portal:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport * as CameraUtils from 'three/addons/utils/CameraUtils.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet cameraControls;\n\n\t\t\tlet smallSphereOne, smallSphereTwo;\n\n\t\t\tlet portalCamera, leftPortal, rightPortal, leftPortalTexture, reflectedPosition,\n\t\t\t\trightPortalTexture, bottomLeftCorner, bottomRightCorner, topLeftCorner;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.localClippingEnabled = true;\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.set( 0, 75, 160 );\n\n\t\t\t\tcameraControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcameraControls.target.set( 0, 40, 0 );\n\t\t\t\tcameraControls.maxDistance = 400;\n\t\t\t\tcameraControls.minDistance = 10;\n\t\t\t\tcameraControls.update();\n\n\t\t\t\t//\n\n\t\t\t\tconst planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );\n\n\t\t\t\t// bouncing icosphere\n\t\t\t\tconst portalPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 0.0 );\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 5, 0 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xffffff, emissive: 0x333333, flatShading: true,\n\t\t\t\t\tclippingPlanes: [ portalPlane ], clipShadows: true } );\n\t\t\t\tsmallSphereOne = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( smallSphereOne );\n\t\t\t\tsmallSphereTwo = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( smallSphereTwo );\n\n\t\t\t\t// portals\n\t\t\t\tportalCamera = new THREE.PerspectiveCamera( 45, 1.0, 0.1, 500.0 );\n\t\t\t\tscene.add( portalCamera );\n\t\t\t\t//frustumHelper = new THREE.CameraHelper( portalCamera );\n\t\t\t\t//scene.add( frustumHelper );\n\t\t\t\tbottomLeftCorner = new THREE.Vector3();\n\t\t\t\tbottomRightCorner = new THREE.Vector3();\n\t\t\t\ttopLeftCorner = new THREE.Vector3();\n\t\t\t\treflectedPosition = new THREE.Vector3();\n\n\t\t\t\tleftPortalTexture = new THREE.WebGLRenderTarget( 256, 256 );\n\t\t\t\tleftPortal = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { map: leftPortalTexture.texture } ) );\n\t\t\t\tleftPortal.position.x = - 30;\n\t\t\t\tleftPortal.position.y = 20;\n\t\t\t\tleftPortal.scale.set( 0.35, 0.35, 0.35 );\n\t\t\t\tscene.add( leftPortal );\n\n\t\t\t\trightPortalTexture = new THREE.WebGLRenderTarget( 256, 256 );\n\t\t\t\trightPortal = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { map: rightPortalTexture.texture } ) );\n\t\t\t\trightPortal.position.x = 30;\n\t\t\t\trightPortal.position.y = 20;\n\t\t\t\trightPortal.scale.set( 0.35, 0.35, 0.35 );\n\t\t\t\tscene.add( rightPortal );\n\n\t\t\t\t// walls\n\t\t\t\tconst planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneTop.position.y = 100;\n\t\t\t\tplaneTop.rotateX( Math.PI / 2 );\n\t\t\t\tscene.add( planeTop );\n\n\t\t\t\tconst planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneBottom.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( planeBottom );\n\n\t\t\t\tconst planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );\n\t\t\t\tplaneFront.position.z = 50;\n\t\t\t\tplaneFront.position.y = 50;\n\t\t\t\tplaneFront.rotateY( Math.PI );\n\t\t\t\tscene.add( planeFront );\n\n\t\t\t\tconst planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff7fff } ) );\n\t\t\t\tplaneBack.position.z = - 50;\n\t\t\t\tplaneBack.position.y = 50;\n\t\t\t\t//planeBack.rotateY( Math.PI );\n\t\t\t\tscene.add( planeBack );\n\n\t\t\t\tconst planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );\n\t\t\t\tplaneRight.position.x = 50;\n\t\t\t\tplaneRight.position.y = 50;\n\t\t\t\tplaneRight.rotateY( - Math.PI / 2 );\n\t\t\t\tscene.add( planeRight );\n\n\t\t\t\tconst planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );\n\t\t\t\tplaneLeft.position.x = - 50;\n\t\t\t\tplaneLeft.position.y = 50;\n\t\t\t\tplaneLeft.rotateY( Math.PI / 2 );\n\t\t\t\tscene.add( planeLeft );\n\n\t\t\t\t// lights\n\t\t\t\tconst mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );\n\t\t\t\tmainLight.position.y = 60;\n\t\t\t\tscene.add( mainLight );\n\n\t\t\t\tconst greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );\n\t\t\t\tgreenLight.position.set( 550, 50, 0 );\n\t\t\t\tscene.add( greenLight );\n\n\t\t\t\tconst redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );\n\t\t\t\tredLight.position.set( - 550, 50, 0 );\n\t\t\t\tscene.add( redLight );\n\n\t\t\t\tconst blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );\n\t\t\t\tblueLight.position.set( 0, 50, 550 );\n\t\t\t\tscene.add( blueLight );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction renderPortal( thisPortalMesh, otherPortalMesh, thisPortalTexture ) {\n\n\t\t\t\t// set the portal camera position to be reflected about the portal plane\n\t\t\t\tthisPortalMesh.worldToLocal( reflectedPosition.copy( camera.position ) );\n\t\t\t\treflectedPosition.x *= - 1.0; reflectedPosition.z *= - 1.0;\n\t\t\t\totherPortalMesh.localToWorld( reflectedPosition );\n\t\t\t\tportalCamera.position.copy( reflectedPosition );\n\n\t\t\t\t// grab the corners of the other portal\n\t\t\t\t// - note: the portal is viewed backwards; flip the left/right coordinates\n\t\t\t\totherPortalMesh.localToWorld( bottomLeftCorner.set( 50.05, - 50.05, 0.0 ) );\n\t\t\t\totherPortalMesh.localToWorld( bottomRightCorner.set( - 50.05, - 50.05, 0.0 ) );\n\t\t\t\totherPortalMesh.localToWorld( topLeftCorner.set( 50.05, 50.05, 0.0 ) );\n\t\t\t\t// set the projection matrix to encompass the portal's frame\n\t\t\t\tCameraUtils.frameCorners( portalCamera, bottomLeftCorner, bottomRightCorner, topLeftCorner, false );\n\n\t\t\t\t// render the portal\n\t\t\t\tthisPortalTexture.texture.colorSpace = renderer.outputColorSpace;\n\t\t\t\trenderer.setRenderTarget( thisPortalTexture );\n\t\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\t\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\t\tthisPortalMesh.visible = false; // hide this portal from its own rendering\n\t\t\t\trenderer.render( scene, portalCamera );\n\t\t\t\tthisPortalMesh.visible = true; // re-enable this portal's visibility for general rendering\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// move the bouncing sphere(s)\n\t\t\t\tconst timerOne = Date.now() * 0.01;\n\t\t\t\tconst timerTwo = timerOne + Math.PI * 10.0;\n\n\t\t\t\tsmallSphereOne.position.set(\n\t\t\t\t\tMath.cos( timerOne * 0.1 ) * 30,\n\t\t\t\t\tMath.abs( Math.cos( timerOne * 0.2 ) ) * 20 + 5,\n\t\t\t\t\tMath.sin( timerOne * 0.1 ) * 30\n\t\t\t\t);\n\t\t\t\tsmallSphereOne.rotation.y = ( Math.PI / 2 ) - timerOne * 0.1;\n\t\t\t\tsmallSphereOne.rotation.z = timerOne * 0.8;\n\n\t\t\t\tsmallSphereTwo.position.set(\n\t\t\t\t\tMath.cos( timerTwo * 0.1 ) * 30,\n\t\t\t\t\tMath.abs( Math.cos( timerTwo * 0.2 ) ) * 20 + 5,\n\t\t\t\t\tMath.sin( timerTwo * 0.1 ) * 30\n\t\t\t\t);\n\t\t\t\tsmallSphereTwo.rotation.y = ( Math.PI / 2 ) - timerTwo * 0.1;\n\t\t\t\tsmallSphereTwo.rotation.z = timerTwo * 0.8;\n\n\t\t\t\t// save the original camera properties\n\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\t\t// render the portal effect\n\t\t\t\trenderPortal( leftPortal, rightPortal, leftPortalTexture );\n\t\t\t\trenderPortal( rightPortal, leftPortal, rightPortalTexture );\n\n\t\t\t\t// restore the original rendering properties\n\t\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t\t// render the main scene\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - portal"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - random - uv"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - random - uv:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, dirLight, ground, gui, material, materialIn, uniforms, uniformsIn;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 20 );\n\t\t\t\tcamera.position.set( - 0.8, 0.6, 1.5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.7;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0xFFFFFF, 3 );\n\t\t\t\tdirLight.position.set( - 0.5, 1, 0.8 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tscene.add( dirLight );\n\t\t\t\tconst shadow = dirLight.shadow;\n\t\t\t\tshadow.mapSize.width = shadow.mapSize.height = 1024;\n\t\t\t\tshadow.radius = 16;\n\t\t\t\tshadow.bias = - 0.0005;\n\t\t\t\tconst shadowCam = shadow.camera, s = 2;\n\t\t\t\tshadowCam.near = 0.5;\n\t\t\t\tshadowCam.far = 3;\n\t\t\t\tshadowCam.right = shadowCam.top\t= s;\n\t\t\t\tshadowCam.left = shadowCam.bottom = - s;\n\t\t\t\t// debug shadow\n\t\t\t\t//scene.add( new THREE.CameraHelper(shadowCam) );\n\n\t\t\t\t// add ground plane\n\t\t\t\tconst plane = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tplane.rotateX( - Math.PI * 0.5 );\n\t\t\t\tground = new THREE.Mesh( plane, new THREE.ShadowMaterial( { opacity: 0.5 } ) );\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tground.position.z = - 0.5;\n\t\t\t\tscene.add( ground );\n\n\n\n\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/jade.jpg' );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tmap.wrapS = map.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmap.repeat.set( 20, 20 );\n\t\t\t\tmap.flipY = false;\n\n\t\t\t\tconst disolveMap = new THREE.TextureLoader().load( 'textures/shaderball_ds.jpg' );\n\t\t\t\tdisolveMap.flipY = false;\n\n\t\t\t\tconst noise = new THREE.TextureLoader().load( 'textures/noise.png' );\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'lobe.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\t\t\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\t\t\tscene.backgroundIntensity = 1.0;\n\t\t\t\t\t\tscene.environmentIntensity = 1.5;\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\t\t\tloader.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) );\n\t\t\t\t\t\tloader.load( 'ShaderBall2.glb', function ( gltf ) {\n\n\t\t\t\t\t\t\tconst shaderBall = gltf.scene.children[ 0 ];\n\n\t\t\t\t\t\t\t// shaderBall is a group with 3 children : base, inside and logo\n\t\t\t\t\t\t\t// ao map is include in model\n\n\t\t\t\t\t\t\tlet i = shaderBall.children.length, n = 0;\n\n\t\t\t\t\t\t\twhile ( i -- ) {\n\n\t\t\t\t\t\t\t\tshaderBall.children[ i ].receiveShadow = true;\n\t\t\t\t\t\t\t\tshaderBall.children[ i ].castShadow = true;\n\t\t\t\t\t\t\t\tshaderBall.children[ i ].renderOrder = n ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial = shaderBall.children[ 0 ].material;\n\t\t\t\t\t\t\tmaterial.map = map;\n\t\t\t\t\t\t\tmaterial.alphaMap = disolveMap;\n\t\t\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\t\t\tmaterialIn = shaderBall.children[ 1 ].material;\n\t\t\t\t\t\t\tmaterialIn.alphaMap = disolveMap;\n\t\t\t\t\t\t\tmaterialIn.transparent = true;\n\n\t\t\t\t\t\t\tmaterial.onBeforeCompile = function ( shader ) {\n\n\t\t\t\t\t\t\t\tshader.uniforms[ 'disolve' ] = { value: 0 };\n\t\t\t\t\t\t\t\tshader.uniforms[ 'threshold' ] = { value: 0.2 };\n\n\t\t\t\t\t\t\t\tshader.uniforms[ 'noiseMap' ] = { value: noise };\n\t\t\t\t\t\t\t\tshader.uniforms[ 'enableRandom' ] = { value: 1 };\n\t\t\t\t\t\t\t\tshader.uniforms[ 'useNoiseMap' ] = { value: 1 };\n\t\t\t\t\t\t\t\tshader.uniforms[ 'useSuslikMethod' ] = { value: 0 };\n\t\t\t\t\t\t\t\tshader.uniforms[ 'debugNoise' ] = { value: 0 };\n\n\t\t\t\t\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>' + randomUV );\n\t\t\t\t\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <map_fragment>', map_fragment );\n\n\t\t\t\t\t\t\t\t// for disolve\n\t\t\t\t\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <alphamap_pars_fragment>', alphamap_pars_fragment );\n\t\t\t\t\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <alphamap_fragment>', alphamap_fragment );\n\n\t\t\t\t\t\t\t\tuniforms = shader.uniforms;\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tmaterialIn.onBeforeCompile = function ( shader ) {\n\n\t\t\t\t\t\t\t\tshader.uniforms[ 'disolve' ] = { value: 0 };\n\t\t\t\t\t\t\t\tshader.uniforms[ 'threshold' ] = { value: 0.2 };\n\t\t\t\t\t\t\t\t// for disolve\n\t\t\t\t\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <alphamap_pars_fragment>', alphamap_pars_fragment );\n\t\t\t\t\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <alphamap_fragment>', alphamap_fragment );\n\n\t\t\t\t\t\t\t\tuniformsIn = shader.uniforms;\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tscene.add( shaderBall );\n\n\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t\tcreateGUI();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 0.3;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0.4, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tconst setting = {\n\n\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\treturn uniforms.enableRandom.value ? true : false;\n\n\t\t\t\t\t},\n\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\tuniforms.enableRandom.value = v ? 1 : 0; render();\n\n\t\t\t\t\t},\n\n\t\t\t\t\tget 'UseNoiseMap'() {\n\n\t\t\t\t\t\treturn uniforms.useNoiseMap.value ? true : false;\n\n\t\t\t\t\t},\n\t\t\t\t\tset 'UseNoiseMap'( v ) {\n\n\t\t\t\t\t\tuniforms.useNoiseMap.value = v ? 1 : 0; render();\n\n\t\t\t\t\t},\n\n\t\t\t\t\tget 'SuslikMethod'() {\n\n\t\t\t\t\t\treturn uniforms.useSuslikMethod.value ? true : false;\n\n\t\t\t\t\t},\n\t\t\t\t\tset 'SuslikMethod'( v ) {\n\n\t\t\t\t\t\tuniforms.useSuslikMethod.value = v ? 1 : 0; render();\n\n\t\t\t\t\t},\n\n\t\t\t\t\tget 'DebugNoise'() {\n\n\t\t\t\t\t\treturn uniforms.debugNoise.value ? true : false;\n\n\t\t\t\t\t},\n\t\t\t\t\tset 'DebugNoise'( v ) {\n\n\t\t\t\t\t\tuniforms.debugNoise.value = v ? 1 : 0; render();\n\n\t\t\t\t\t},\n\n\t\t\t\t\t// disolve\n\t\t\t\t\tget 'disolve'() {\n\n\t\t\t\t\t\treturn uniforms.disolve.value;\n\n\t\t\t\t\t},\n\t\t\t\t\tset 'disolve'( v ) {\n\n\t\t\t\t\t\tuniforms.disolve.value = v; uniformsIn.disolve.value = v; ground.material.opacity = ( 1 - v ) * 0.5; render();\n\n\t\t\t\t\t},\n\n\t\t\t\t\tget 'threshold'() {\n\n\t\t\t\t\t\treturn uniforms.threshold.value;\n\n\t\t\t\t\t},\n\t\t\t\t\tset 'threshold'( v ) {\n\n\t\t\t\t\t\tuniforms.threshold.value = v; uniformsIn.threshold.value = v; render();\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tgui.add( material, 'roughness', 0, 1, 0.01 ).onChange( render );\n\t\t\t\tgui.add( material, 'metalness', 0, 1, 0.01 ).onChange( render );\n\t\t\t\tgui.add( setting, 'disolve', 0, 1, 0.01 ).onChange( render );\n\t\t\t\tgui.add( setting, 'threshold', 0, 1, 0.01 ).onChange( render );\n\t\t\t\tgui.add( setting, 'Enabled' );\n\t\t\t\tgui.add( setting, 'UseNoiseMap' );\n\t\t\t\tgui.add( setting, 'SuslikMethod' );\n\t\t\t\tgui.add( setting, 'DebugNoise' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tconst randomUV = /* glsl */ `\n\n\t\t\tuniform sampler2D noiseMap;\n\t\t\tuniform float enableRandom;\n\t\t\tuniform float useNoiseMap;\n\t\t\tuniform float debugNoise;\n\t\t\tuniform float useSuslikMethod;\n\n\t\t\tfloat directNoise(vec2 p){\n\t\t\t    vec2 ip = floor(p);\n\t\t\t    vec2 u = fract(p);\n\t\t\t    u = u*u*(3.0-2.0*u);\n\n\t\t\t    float res = mix(\n\t\t\t        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\t\t        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\t\t\t    return res*res;\n\t\t\t}\n\n\t\t\tfloat sum( vec4 v ) { return v.x+v.y+v.z; }\n\n\t\t\tvec4 textureNoTile( sampler2D mapper, in vec2 uv ){\n\n\t\t\t    // sample variation pattern\n\t\t\t    float k = 0.0;\n\t\t\t    if( useNoiseMap == 1.0 ) k = texture2D( noiseMap, 0.005*uv ).x;\n\t\t\t    else k = directNoise( uv );\n\n\t\t\t    // compute index\n\t\t\t    float index = k*8.0;\n\t\t\t    float f = fract( index );\n\t\t\t    float ia = 0.0;\n\t\t\t    float ib = 0.0;\n\n\t\t\t    if( useSuslikMethod == 1.0 ){\n\t\t\t    \tia = floor(index+0.5);\n\t\t\t    \tib = floor(index);\n\t\t\t    \tf = min(f, 1.0-f)*2.0;\n\t\t\t    } else {\n\t\t\t    \tia = floor( index );\n\t\t\t    \tib = ia + 1.0;\n\t\t\t    }\n\n\t\t\t    // offsets for the different virtual patterns\n\t\t\t    vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash\n\t\t\t    vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash\n\n\t\t\t    // compute derivatives for mip-mapping\n\t\t\t    vec2 dx = dFdx(uv);\n\t\t\t    vec2 dy = dFdy(uv);\n\n\t\t\t    // sample the two closest virtual patterns\n\t\t\t    vec4 cola = textureGrad( mapper, uv + offa, dx, dy );\n\t\t\t    vec4 colb = textureGrad( mapper, uv + offb, dx, dy );\n\t\t\t    if( debugNoise == 1.0 ){\n\t\t\t    \tcola = vec4( 0.1,0.0,0.0,1.0 );\n\t\t\t    \tcolb = vec4( 0.0,0.0,1.0,1.0 );\n\t\t\t    }\n\n\t\t\t    // interpolate between the two virtual patterns\n\t\t\t    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );\n\n\t\t\t}`;\n\n\t\t\tconst map_fragment = /* glsl */ `\n\t\t\t#ifdef USE_MAP\n\n\t\t\t\tif( enableRandom == 1.0 ) diffuseColor *= textureNoTile( map, vMapUv );\n\t\t\t\telse diffuseColor *= texture2D( map, vMapUv );\n\n\t\t\t#endif\n\t\t\t`;\n\n\t\t\tconst alphamap_pars_fragment = /* glsl */ `\n\t\t\t#ifdef USE_ALPHAMAP\n\t\t\t\tuniform sampler2D alphaMap;\n\t\t\t\tuniform float disolve;\n\t\t\t\tuniform float threshold;\n\t\t\t#endif\n\t\t\t`;\n\n\t\t\tconst alphamap_fragment = /* glsl */ `\n\t\t\t#ifdef USE_ALPHAMAP\n\t\t\t    float vv = texture2D( alphaMap, vAlphaMapUv ).g;\n\t\t\t    float r = disolve * (1.0 + threshold * 2.0) - threshold;\n\t\t\t    float mixf = clamp((vv - r)*(1.0/threshold), 0.0, 1.0);\n\t\t\t\tdiffuseColor.a = mixf;\n\t\t\t#endif\n\t\t\t`;\n```\n\nThis example three.js - Random UV and Disolve"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates raycaster - bvh"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js raycaster - bvh:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast, MeshBVHHelper } from 'three-mesh-bvh';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { FBXLoader } from 'three/addons/loaders/FBXLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\t// Add the extension functions\n\t\t\tTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n\t\t\tTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\t\t\tTHREE.Mesh.prototype.raycast = acceleratedRaycast;\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh, helper, bvh;\n\t\t\tlet sphereInstance, lineSegments;\n\n\t\t\t// reusable variables\n\t\t\tconst _raycaster = new THREE.Raycaster();\n\t\t\tconst _position = new THREE.Vector3();\n\t\t\tconst _quaternion = new THREE.Quaternion();\n\t\t\tconst _scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\tconst _matrix = new THREE.Matrix4();\n\t\t\tconst _axis = new THREE.Vector3();\n\t\t\tconst MAX_RAYS = 3000;\n\t\t\tconst RAY_COLOR = 0x444444;\n\n\t\t\tconst params = {\n\n\t\t\t\tcount: 150,\n\t\t\t\tfirstHitOnly: true,\n\t\t\t\tuseBVH: true,\n\n\t\t\t\tdisplayHelper: false,\n\t\t\t\thelperDepth: 10,\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// environment\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xeeeeee );\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0xffffff, 0x999999, 3 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// raycast visualizations\n\t\t\t\tconst lineGeometry = new THREE.BufferGeometry();\n\t\t\t\tlineGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( MAX_RAYS * 2 * 3 ), 3 ) );\n\t\t\t\tlineSegments = new THREE.LineSegments( lineGeometry, new THREE.LineBasicMaterial( {\n\t\t\t\t\tcolor: RAY_COLOR,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 0.25,\n\t\t\t\t\tdepthWrite: false\n\t\t\t\t} ) );\n\n\t\t\t\tsphereInstance = new THREE.InstancedMesh(\n\t\t\t\t\tnew THREE.SphereGeometry(),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: RAY_COLOR } ),\n\t\t\t\t\t2 * MAX_RAYS\n\t\t\t\t);\n\t\t\t\tsphereInstance.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\tsphereInstance.count = 0;\n\n\t\t\t\tscene.add( sphereInstance, lineSegments );\n\n\t\t\t\t// load the bunny\n\t\t\t\tconst loader = new FBXLoader();\n\t\t\t\tloader.load( 'models/fbx/stanford-bunny.fbx', object => {\n\n\t\t\t\t\tmesh = object.children[ 0 ];\n\n\t\t\t\t\tconst geometry = mesh.geometry;\n\t\t\t\t\tgeometry.translate( 0, 0.5 / 0.0075, 0 );\n\t\t\t\t\tgeometry.computeBoundsTree();\n\t\t\t\t\tbvh = geometry.boundsTree;\n\n\t\t\t\t\tif ( ! params.useBVH ) {\n\n\t\t\t\t\t\tgeometry.boundsTree = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\tmesh.scale.setScalar( 0.0075 );\n\n\t\t\t\t\thelper = new MeshBVHHelper( mesh );\n\t\t\t\t\thelper.color.set( 0xE91E63 );\n\t\t\t\t\tscene.add( helper );\n\n\t\t\t\t} );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 75;\n\n\t\t\t\t// set up gui\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tconst rayFolder = gui.addFolder( 'Raycasting' );\n\t\t\t\trayFolder.add( params, 'count', 1, MAX_RAYS, 1 );\n\t\t\t\trayFolder.add( params, 'firstHitOnly' );\n\t\t\t\trayFolder.add( params, 'useBVH' ).onChange( v => {\n\n\t\t\t\t\tmesh.geometry.boundsTree = v ? bvh : null;\n\n\t\t\t\t} );\n\n\t\t\t\tconst helperFolder = gui.addFolder( 'BVH Helper' );\n\t\t\t\thelperFolder.add( params, 'displayHelper' );\n\t\t\t\thelperFolder.add( params, 'helperDepth', 1, 20, 1 ).onChange( v => {\n\n\t\t\t\t\thelper.depth = v;\n\t\t\t\t\thelper.update();\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tinitRays();\n\n\t\t\t}\n\n\t\t\tfunction initRays() {\n\n\t\t\t\tconst position = new THREE.Vector3();\n\t\t\t\tconst quaternion = new THREE.Quaternion();\n\t\t\t\tconst scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tfor ( let i = 0; i < MAX_RAYS * 2; i ++ ) {\n\n\t\t\t\t\tposition.randomDirection().multiplyScalar( 3.75 );\n\t\t\t\t\tmatrix.compose( position, quaternion, scale );\n\t\t\t\t\tsphereInstance.setMatrixAt( i, matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updateRays() {\n\n\t\t\t\tif ( ! mesh ) return;\n\n\t\t\t\t_raycaster.firstHitOnly = params.firstHitOnly;\n\t\t\t\tconst rayCount = params.count;\n\n\t\t\t\tlet lineNum = 0;\n\t\t\t\tfor ( let i = 0; i < rayCount; i ++ ) {\n\n\t\t\t\t\t// get the current ray origin\n\t\t\t\t\tsphereInstance.getMatrixAt( i * 2, _matrix );\n\t\t\t\t\t_matrix.decompose( _position, _quaternion, _scale );\n\n\t\t\t\t\t// rotate it about the origin\n\t\t\t\t\tconst offset = 1e-4 * window.performance.now();\n\t\t\t\t\t_axis.set(\n\t\t\t\t\t\tMath.sin( i * 100 + offset ),\n\t\t\t\t\t\tMath.cos( - i * 10 + offset ),\n\t\t\t\t\t\tMath.sin( i * 1 + offset ),\n\t\t\t\t\t).normalize();\n\t\t\t\t\t_position.applyAxisAngle( _axis, 0.001 );\n\n\t\t\t\t\t// update the position\n\t\t\t\t\t_scale.setScalar( 0.02 );\n\t\t\t\t\t_matrix.compose( _position, _quaternion, _scale );\n\t\t\t\t\tsphereInstance.setMatrixAt( i * 2, _matrix );\n\n\t\t\t\t\t// raycast\n\t\t\t\t\t_raycaster.ray.origin.copy( _position );\n\t\t\t\t\t_raycaster.ray.direction.copy( _position ).multiplyScalar( - 1 ).normalize();\n\n\t\t\t\t\t// update hits points and lines\n\t\t\t\t\tconst hits = _raycaster.intersectObject( mesh );\n\t\t\t\t\tif ( hits.length !== 0 ) {\n\n\t\t\t\t\t\tconst hit = hits[ 0 ];\n\t\t\t\t\t\tconst point = hit.point;\n\t\t\t\t\t\t_scale.setScalar( 0.01 );\n\t\t\t\t\t\t_matrix.compose( point, _quaternion, _scale );\n\t\t\t\t\t\tsphereInstance.setMatrixAt( i * 2 + 1, _matrix );\n\n\t\t\t\t\t\tlineSegments.geometry.attributes.position.setXYZ( lineNum ++, _position.x, _position.y, _position.z );\n\t\t\t\t\t\tlineSegments.geometry.attributes.position.setXYZ( lineNum ++, point.x, point.y, point.z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsphereInstance.setMatrixAt( i * 2 + 1, _matrix );\n\t\t\t\t\t\tlineSegments.geometry.attributes.position.setXYZ( lineNum ++, _position.x, _position.y, _position.z );\n\t\t\t\t\t\tlineSegments.geometry.attributes.position.setXYZ( lineNum ++, 0, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tsphereInstance.count = rayCount * 2;\n\t\t\t\tsphereInstance.instanceMatrix.needsUpdate = true;\n\n\t\t\t\tlineSegments.geometry.setDrawRange( 0, lineNum );\n\t\t\t\tlineSegments.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( helper ) {\n\n\t\t\t\t\thelper.visible = params.displayHelper;\n\n\t\t\t\t}\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tmesh.rotation.y += 0.002;\n\t\t\t\t\tmesh.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tupdateRays();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js raycaster - three-mesh-bvh See main project repository for more information and examples on high performance spatial queries."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates raycaster - sprite"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js raycaster - sprite:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\tlet renderer, scene, camera;\n\t\tlet group;\n\n\t\tlet selectedObject = null;\n\t\tconst raycaster = new THREE.Raycaster();\n\t\tconst pointer = new THREE.Vector2();\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\t// init renderer\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t// init scene\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\tgroup = new THREE.Group();\n\t\t\tscene.add( group );\n\n\t\t\t// init camera\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\tcamera.position.set( 15, 15, 15 );\n\t\t\tcamera.lookAt( scene.position );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.minDistance = 15;\n\t\t\tcontrols.maxDistance = 250;\n\n\t\t\t// add sprites\n\n\t\t\tconst sprite1 = new THREE.Sprite( new THREE.SpriteMaterial( { color: '#69f' } ) );\n\t\t\tsprite1.position.set( 6, 5, 5 );\n\t\t\tsprite1.scale.set( 2, 5, 1 );\n\t\t\tgroup.add( sprite1 );\n\n\t\t\tconst sprite2 = new THREE.Sprite( new THREE.SpriteMaterial( { color: '#69f', sizeAttenuation: false } ) );\n\t\t\tsprite2.material.rotation = Math.PI / 3 * 4;\n\t\t\tsprite2.position.set( 8, - 2, 2 );\n\t\t\tsprite2.center.set( 0.5, 0 );\n\t\t\tsprite2.scale.set( .1, .5, .1 );\n\t\t\tgroup.add( sprite2 );\n\n\t\t\tconst group2 = new THREE.Object3D();\n\t\t\tgroup2.scale.set( 1, 2, 1 );\n\t\t\tgroup2.position.set( - 5, 0, 0 );\n\t\t\tgroup2.rotation.set( Math.PI / 2, 0, 0 );\n\t\t\tgroup.add( group2 );\n\n\t\t\tconst sprite3 = new THREE.Sprite( new THREE.SpriteMaterial( { color: '#69f' } ) );\n\t\t\tsprite3.position.set( 0, 2, 5 );\n\t\t\tsprite3.scale.set( 10, 2, 3 );\n\t\t\tsprite3.center.set( - 0.1, 0 );\n\t\t\tsprite3.material.rotation = Math.PI / 3;\n\t\t\tgroup2.add( sprite3 );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( selectedObject ) {\n\n\t\t\t\tselectedObject.material.color.set( '#69f' );\n\t\t\t\tselectedObject = null;\n\n\t\t\t}\n\n\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\tconst intersects = raycaster.intersectObject( group, true );\n\n\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\tconst res = intersects.filter( function ( res ) {\n\n\t\t\t\t\treturn res && res.object;\n\n\t\t\t\t} )[ 0 ];\n\n\t\t\t\tif ( res && res.object ) {\n\n\t\t\t\t\tselectedObject = res.object;\n\t\t\t\t\tselectedObject.material.color.set( '#f00' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n```\n\nThis example three.js raycaster - sprite"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates raycaster - texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js raycaster - texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst WRAPPING = {\n\t\t\t\t'RepeatWrapping': THREE.RepeatWrapping,\n\t\t\t\t'ClampToEdgeWrapping': THREE.ClampToEdgeWrapping,\n\t\t\t\t'MirroredRepeatWrapping': THREE.MirroredRepeatWrapping\n\t\t\t};\n\n\t\t\tconst params = {\n\t\t\t\twrapS: THREE.RepeatWrapping,\n\t\t\t\twrapT: THREE.RepeatWrapping,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\trepeatX: 1,\n\t\t\t\trepeatY: 1,\n\t\t\t\trotation: 0,\n\t\t\t};\n\n\n\t\t\tfunction CanvasTexture( parentTexture ) {\n\n\t\t\t\tthis._canvas = document.createElement( 'canvas' );\n\t\t\t\tthis._canvas.width = this._canvas.height = 1024;\n\t\t\t\tthis._context2D = this._canvas.getContext( '2d' );\n\n\t\t\t\tif ( parentTexture ) {\n\n\t\t\t\t\tthis._parentTexture.push( parentTexture );\n\t\t\t\t\tparentTexture.image = this._canvas;\n\n\t\t\t\t}\n\n\t\t\t\tconst that = this;\n\t\t\t\tthis._background = document.createElement( 'img' );\n\t\t\t\tthis._background.addEventListener( 'load', function () {\n\n\t\t\t\t\tthat._canvas.width = that._background.naturalWidth;\n\t\t\t\t\tthat._canvas.height = that._background.naturalHeight;\n\n\t\t\t\t\tthat._crossRadius = Math.ceil( Math.min( that._canvas.width, that._canvas.height / 30 ) );\n\t\t\t\t\tthat._crossMax = Math.ceil( 0.70710678 * that._crossRadius );\n\t\t\t\t\tthat._crossMin = Math.ceil( that._crossMax / 10 );\n\t\t\t\t\tthat._crossThickness = Math.ceil( that._crossMax / 10 );\n\n\t\t\t\t\tthat._draw();\n\n\t\t\t\t} );\n\t\t\t\tthis._background.crossOrigin = '';\n\t\t\t\tthis._background.src = 'textures/uv_grid_opengl.jpg';\n\n\t\t\t\tthis._draw();\n\n\t\t\t}\n\n\n\t\t\tCanvasTexture.prototype = {\n\n\t\t\t\tconstructor: CanvasTexture,\n\n\t\t\t\t_canvas: null,\n\t\t\t\t_context2D: null,\n\t\t\t\t_xCross: 0,\n\t\t\t\t_yCross: 0,\n\n\t\t\t\t_crossRadius: 57,\n\t\t\t\t_crossMax: 40,\n\t\t\t\t_crossMin: 4,\n\t\t\t\t_crossThickness: 4,\n\n\t\t\t\t_parentTexture: [],\n\n\t\t\t\taddParent: function ( parentTexture ) {\n\n\t\t\t\t\tif ( this._parentTexture.indexOf( parentTexture ) === - 1 ) {\n\n\t\t\t\t\t\tthis._parentTexture.push( parentTexture );\n\t\t\t\t\t\tparentTexture.image = this._canvas;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetCrossPosition: function ( x, y ) {\n\n\t\t\t\t\tthis._xCross = x * this._canvas.width;\n\t\t\t\t\tthis._yCross = y * this._canvas.height;\n\n\t\t\t\t\tthis._draw();\n\n\t\t\t\t},\n\n\t\t\t\t_draw: function () {\n\n\t\t\t\t\tif ( ! this._context2D ) return;\n\n\t\t\t\t\tthis._context2D.clearRect( 0, 0, this._canvas.width, this._canvas.height );\n\n\t\t\t\t\t// Background.\n\t\t\t\t\tthis._context2D.drawImage( this._background, 0, 0 );\n\n\t\t\t\t\t// Yellow cross.\n\t\t\t\t\tthis._context2D.lineWidth = this._crossThickness * 3;\n\t\t\t\t\tthis._context2D.strokeStyle = '#FFFF00';\n\n\t\t\t\t\tthis._context2D.beginPath();\n\t\t\t\t\tthis._context2D.moveTo( this._xCross - this._crossMax - 2, this._yCross - this._crossMax - 2 );\n\t\t\t\t\tthis._context2D.lineTo( this._xCross - this._crossMin, this._yCross - this._crossMin );\n\n\t\t\t\t\tthis._context2D.moveTo( this._xCross + this._crossMin, this._yCross + this._crossMin );\n\t\t\t\t\tthis._context2D.lineTo( this._xCross + this._crossMax + 2, this._yCross + this._crossMax + 2 );\n\n\t\t\t\t\tthis._context2D.moveTo( this._xCross - this._crossMax - 2, this._yCross + this._crossMax + 2 );\n\t\t\t\t\tthis._context2D.lineTo( this._xCross - this._crossMin, this._yCross + this._crossMin );\n\n\t\t\t\t\tthis._context2D.moveTo( this._xCross + this._crossMin, this._yCross - this._crossMin );\n\t\t\t\t\tthis._context2D.lineTo( this._xCross + this._crossMax + 2, this._yCross - this._crossMax - 2 );\n\n\t\t\t\t\tthis._context2D.stroke();\n\n\t\t\t\t\tfor ( let i = 0; i < this._parentTexture.length; i ++ ) {\n\n\t\t\t\t\t\tthis._parentTexture[ i ].needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst width = window.innerWidth;\n\t\t\tconst height = window.innerHeight;\n\n\t\t\tlet canvas;\n\t\t\tlet planeTexture, cubeTexture, circleTexture;\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst mouse = new THREE.Vector2();\n\t\t\tconst onClickPosition = new THREE.Vector2();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xeeeeee );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );\n\t\t\t\tcamera.position.x = - 30;\n\t\t\t\tcamera.position.y = 40;\n\t\t\t\tcamera.position.z = 50;\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// A cube, in the middle.\n\t\t\t\tcubeTexture = new THREE.Texture( undefined, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping );\n\t\t\t\tcubeTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tcanvas = new CanvasTexture( cubeTexture );\n\t\t\t\tconst cubeMaterial = new THREE.MeshBasicMaterial( { map: cubeTexture } );\n\t\t\t\tconst cubeGeometry = new THREE.BoxGeometry( 20, 20, 20 );\n\t\t\t\tlet uvs = cubeGeometry.attributes.uv.array;\n\t\t\t\t// Set a specific texture mapping.\n\t\t\t\tfor ( let i = 0; i < uvs.length; i ++ ) {\n\n\t\t\t\t\tuvs[ i ] *= 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst cube = new THREE.Mesh( cubeGeometry, cubeMaterial );\n\t\t\t\tcube.position.x = 4;\n\t\t\t\tcube.position.y = - 5;\n\t\t\t\tcube.position.z = 0;\n\t\t\t\tscene.add( cube );\n\n\t\t\t\t// A plane on the left\n\n\t\t\t\tplaneTexture = new THREE.Texture( undefined, THREE.UVMapping, THREE.MirroredRepeatWrapping, THREE.MirroredRepeatWrapping );\n\t\t\t\tplaneTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tcanvas.addParent( planeTexture );\n\t\t\t\tconst planeMaterial = new THREE.MeshBasicMaterial( { map: planeTexture } );\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 25, 25, 1, 1 );\n\t\t\t\tuvs = planeGeometry.attributes.uv.array;\n\n\t\t\t\t// Set a specific texture mapping.\n\n\t\t\t\tfor ( let i = 0; i < uvs.length; i ++ ) {\n\n\t\t\t\t\tuvs[ i ] *= 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst plane = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tplane.position.x = - 16;\n\t\t\t\tplane.position.y = - 5;\n\t\t\t\tplane.position.z = 0;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// A circle on the right.\n\n\t\t\t\tcircleTexture = new THREE.Texture( undefined, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping );\n\t\t\t\tcircleTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tcanvas.addParent( circleTexture );\n\t\t\t\tconst circleMaterial = new THREE.MeshBasicMaterial( { map: circleTexture } );\n\t\t\t\tconst circleGeometry = new THREE.CircleGeometry( 25, 40, 0, Math.PI * 2 );\n\t\t\t\tuvs = circleGeometry.attributes.uv.array;\n\n\t\t\t\t// Set a specific texture mapping.\n\n\t\t\t\tfor ( let i = 0; i < uvs.length; i ++ ) {\n\n\t\t\t\t\tuvs[ i ] = ( uvs[ i ] - 0.25 ) * 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst circle = new THREE.Mesh( circleGeometry, circleMaterial );\n\t\t\t\tcircle.position.x = 24;\n\t\t\t\tcircle.position.y = - 5;\n\t\t\t\tcircle.position.z = 0;\n\t\t\t\tscene.add( circle );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tcontainer.addEventListener( 'mousemove', onMouseMove );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.title( 'Circle Texture Settings' );\n\n\t\t\t\tgui.add( params, 'wrapS', WRAPPING ).onChange( setwrapS );\n\t\t\t\tgui.add( params, 'wrapT', WRAPPING ).onChange( setwrapT );\n\t\t\t\tgui.add( params, 'offsetX', 0, 5 );\n\t\t\t\tgui.add( params, 'offsetY', 0, 5 );\n\t\t\t\tgui.add( params, 'repeatX', 0, 5 );\n\t\t\t\tgui.add( params, 'repeatY', 0, 5 );\n\t\t\t\tgui.add( params, 'rotation', 0, 2 * Math.PI );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onMouseMove( evt ) {\n\n\t\t\t\tevt.preventDefault();\n\n\t\t\t\tconst array = getMousePosition( container, evt.clientX, evt.clientY );\n\t\t\t\tonClickPosition.fromArray( array );\n\n\t\t\t\tconst intersects = getIntersects( onClickPosition, scene.children );\n\n\t\t\t\tif ( intersects.length > 0 && intersects[ 0 ].uv ) {\n\n\t\t\t\t\tconst uv = intersects[ 0 ].uv;\n\t\t\t\t\tintersects[ 0 ].object.material.map.transformUv( uv );\n\t\t\t\t\tcanvas.setCrossPosition( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getMousePosition( dom, x, y ) {\n\n\t\t\t\tconst rect = dom.getBoundingClientRect();\n\t\t\t\treturn [ ( x - rect.left ) / rect.width, ( y - rect.top ) / rect.height ];\n\n\t\t\t}\n\n\t\t\tfunction getIntersects( point, objects ) {\n\n\t\t\t\tmouse.set( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1 );\n\n\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\treturn raycaster.intersectObjects( objects, false );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// update texture parameters\n\n\t\t\t\tcircleTexture.offset.x = params.offsetX;\n\t\t\t\tcircleTexture.offset.y = params.offsetY;\n\t\t\t\tcircleTexture.repeat.x = params.repeatX;\n\t\t\t\tcircleTexture.repeat.y = params.repeatY;\n\t\t\t\tcircleTexture.rotation = params.rotation;\n\n\t\t\t\t//\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction setwrapS( value ) {\n\n\t\t\t\tcircleTexture.wrapS = value;\n\t\t\t\tcircleTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction setwrapT( value ) {\n\n\t\t\t\tcircleTexture.wrapT = value;\n\t\t\t\tcircleTexture.needsUpdate = true;\n\n\t\t\t}\n```\n\nThis example three.js raycaster - texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - read float pixels"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - read float pixels:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet cameraRTT, sceneRTT, sceneScreen, renderer, zmesh1, zmesh2;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tconst windowHalfX = window.innerWidth / 2;\n\t\t\tconst windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet rtTexture, material, quad;\n\n\t\t\tlet delta = 0.01;\n\t\t\tlet valueNode;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcameraRTT = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );\n\t\t\t\tcameraRTT.position.z = 100;\n\n\t\t\t\t//\n\n\t\t\t\tsceneRTT = new THREE.Scene();\n\t\t\t\tsceneScreen = new THREE.Scene();\n\n\t\t\t\tlet light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 0, 1 ).normalize();\n\t\t\t\tsceneRTT.add( light );\n\n\t\t\t\tlight = new THREE.DirectionalLight( 0xffd5d5, 4.5 );\n\t\t\t\tlight.position.set( 0, 0, - 1 ).normalize();\n\t\t\t\tsceneRTT.add( light );\n\n\t\t\t\trtTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat, type: THREE.FloatType } );\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: { 'time': { value: 0.0 } },\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragment_shader_pass_1' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\tconst materialScreen = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: { 'tDiffuse': { value: rtTexture.texture } },\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,\n\n\t\t\t\t\tdepthWrite: false\n\n\t\t\t\t} );\n\n\t\t\t\tconst plane = new THREE.PlaneGeometry( window.innerWidth, window.innerHeight );\n\n\t\t\t\tquad = new THREE.Mesh( plane, material );\n\t\t\t\tquad.position.z = - 100;\n\t\t\t\tsceneRTT.add( quad );\n\n\t\t\t\tconst geometry = new THREE.TorusGeometry( 100, 25, 15, 30 );\n\n\t\t\t\tconst mat1 = new THREE.MeshPhongMaterial( { color: 0x9c9c9c, specular: 0xffaa00, shininess: 5 } );\n\t\t\t\tconst mat2 = new THREE.MeshPhongMaterial( { color: 0x9c0000, specular: 0xff2200, shininess: 5 } );\n\n\t\t\t\tzmesh1 = new THREE.Mesh( geometry, mat1 );\n\t\t\t\tzmesh1.position.set( 0, 0, 100 );\n\t\t\t\tzmesh1.scale.set( 1.5, 1.5, 1.5 );\n\t\t\t\tsceneRTT.add( zmesh1 );\n\n\t\t\t\tzmesh2 = new THREE.Mesh( geometry, mat2 );\n\t\t\t\tzmesh2.position.set( 0, 150, 100 );\n\t\t\t\tzmesh2.scale.set( 0.75, 0.75, 0.75 );\n\t\t\t\tsceneRTT.add( zmesh2 );\n\n\t\t\t\tquad = new THREE.Mesh( plane, materialScreen );\n\t\t\t\tquad.position.z = - 100;\n\t\t\t\tsceneScreen.add( quad );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tvalueNode = document.getElementById( 'values' );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.0015;\n\n\t\t\t\tif ( zmesh1 && zmesh2 ) {\n\n\t\t\t\t\tzmesh1.rotation.y = - time;\n\t\t\t\t\tzmesh2.rotation.y = - time + Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.uniforms[ 'time' ].value > 1 || material.uniforms[ 'time' ].value < 0 ) {\n\n\t\t\t\t\tdelta *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.uniforms[ 'time' ].value += delta;\n\n\t\t\t\trenderer.clear();\n\n\t\t\t\t// Render first scene into texture\n\n\t\t\t\trenderer.setRenderTarget( rtTexture );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( sceneRTT, cameraRTT );\n\n\t\t\t\t// Render full screen quad with generated texture\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.render( sceneScreen, cameraRTT );\n\n\t\t\t\tconst read = new Float32Array( 4 );\n\t\t\t\trenderer.readRenderTargetPixels( rtTexture, windowHalfX + mouseX, windowHalfY - mouseY, 1, 1, read );\n\n\t\t\t\tvalueNode.innerHTML = 'r:' + read[ 0 ] + '<br/>g:' + read[ 1 ] + '<br/>b:' + read[ 2 ];\n\n\t\t\t}\n```\n\nThis example three.js read linear-srgb float pixel data"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - three-gpu-pathtracer"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - three-gpu-pathtracer:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n\t\t\timport { LDrawUtils } from 'three/addons/utils/LDrawUtils.js';\n\t\t\timport { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';\n\t\t\timport { WebGLPathTracer, BlurredEnvMapGenerator, GradientEquirectTexture } from 'three-gpu-pathtracer';\n\n\t\t\tlet progressBarDiv, samplesEl;\n\t\t\tlet camera, scene, renderer, controls, gui;\n\t\t\tlet pathTracer, floor, gradientMap;\n\n\t\t\tconst params = {\n\t\t\t\tenable: true,\n\t\t\t\ttoneMapping: true,\n\t\t\t\tpause: false,\n\t\t\t\ttiles: 3,\n\t\t\t\ttransparentBackground: false,\n\t\t\t\tresolutionScale: 1,\n\t\t\t\tdownload: () => {\n\n\t\t\t\t\tconst link = document.createElement( 'a' );\n\t\t\t\t\tlink.download = 'pathtraced-render.png';\n\t\t\t\t\tlink.href = renderer.domElement.toDataURL().replace( 'image/png', 'image/octet-stream' );\n\t\t\t\t\tlink.click();\n\n\t\t\t\t},\n\t\t\t\troughness: 0.15,\n\t\t\t\tmetalness: 0.9,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 150, 200, 250 );\n\n\t\t\t\t// initialize the renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true, preserveDrawingBuffer: true, premultipliedAlpha: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tgradientMap = new GradientEquirectTexture();\n\t\t\t\tgradientMap.topColor.set( 0xeeeeee );\n\t\t\t\tgradientMap.bottomColor.set( 0xeaeaea );\n\t\t\t\tgradientMap.update();\n\n\t\t\t\t// initialize the pathtracer\n\t\t\t\tpathTracer = new WebGLPathTracer( renderer );\n\t\t\t\tpathTracer.filterGlossyFactor = 1;\n\t\t\t\tpathTracer.minSamples = 3;\n\t\t\t\tpathTracer.renderScale = params.resolutionScale;\n\t\t\t\tpathTracer.tiles.set( params.tiles, params.tiles );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = gradientMap;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', () => {\n\n\t\t\t\t\tpathTracer.updateCamera();\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tprogressBarDiv = document.createElement( 'div' );\n\t\t\t\tprogressBarDiv.innerText = 'Loading...';\n\t\t\t\tprogressBarDiv.style.fontSize = '3em';\n\t\t\t\tprogressBarDiv.style.color = '#888';\n\t\t\t\tprogressBarDiv.style.display = 'block';\n\t\t\t\tprogressBarDiv.style.position = 'absolute';\n\t\t\t\tprogressBarDiv.style.top = '50%';\n\t\t\t\tprogressBarDiv.style.width = '100%';\n\t\t\t\tprogressBarDiv.style.textAlign = 'center';\n\n\t\t\t\t// load materials and then the model\n\t\t\t\tcreateGUI();\n\n\t\t\t\tloadModel();\n\n\t\t\t}\n\n\t\t\tasync function loadModel() {\n\n\t\t\t\tprogressBarDiv.innerText = 'Loading...';\n\n\t\t\t\tlet model = null;\n\t\t\t\tlet environment = null;\n\n\t\t\t\tupdateProgressBar( 0 );\n\t\t\t\tshowProgressBar();\n\n\t\t\t\t// only smooth when not rendering with flat colors to improve processing time\n\t\t\t\tconst ldrawPromise =\n\t\t\t\t\tnew LDrawLoader()\n\t\t\t\t\t\t.setConditionalLineMaterial( LDrawConditionalLineMaterial )\n\t\t\t\t\t\t.setPath( 'models/ldraw/officialLibrary/' )\n\t\t\t\t\t\t.loadAsync( 'models/7140-1-X-wingFighter.mpd_Packed.mpd', onProgress )\n\t\t\t\t\t\t.then( function ( legoGroup ) {\n\n\t\t\t\t\t\t\t// Convert from LDraw coordinates: rotate 180 degrees around OX\n\t\t\t\t\t\t\tlegoGroup = LDrawUtils.mergeObject( legoGroup );\n\t\t\t\t\t\t\tlegoGroup.rotation.x = Math.PI;\n\t\t\t\t\t\t\tlegoGroup.updateMatrixWorld();\n\t\t\t\t\t\t\tmodel = legoGroup;\n\n\t\t\t\t\t\t\tlegoGroup.traverse( c => {\n\n\t\t\t\t\t\t\t\t// hide the line segments\n\t\t\t\t\t\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\t\t\t\t\t\tc.visible = false;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// adjust the materials to use transmission, be a bit shinier\n\t\t\t\t\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\t\t\t\t\tc.material.roughness *= 0.25;\n\n\t\t\t\t\t\t\t\t\tif ( c.material.opacity < 1.0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst oldMaterial = c.material;\n\t\t\t\t\t\t\t\t\t\tconst newMaterial = new THREE.MeshPhysicalMaterial();\n\n\t\t\t\t\t\t\t\t\t\tnewMaterial.opacity = 1.0;\n\t\t\t\t\t\t\t\t\t\tnewMaterial.transmission = 1.0;\n\t\t\t\t\t\t\t\t\t\tnewMaterial.thickness = 1.0;\n\t\t\t\t\t\t\t\t\t\tnewMaterial.ior = 1.4;\n\t\t\t\t\t\t\t\t\t\tnewMaterial.roughness = oldMaterial.roughness;\n\t\t\t\t\t\t\t\t\t\tnewMaterial.metalness = 0.0;\n\n\t\t\t\t\t\t\t\t\t\tconst hsl = {};\n\t\t\t\t\t\t\t\t\t\toldMaterial.color.getHSL( hsl );\n\t\t\t\t\t\t\t\t\t\thsl.l = Math.max( hsl.l, 0.35 );\n\t\t\t\t\t\t\t\t\t\tnewMaterial.color.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\t\t\t\t\t\t\t\tc.material = newMaterial;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.catch( onError );\n\n\t\t\t\tconst envMapPromise =\n\t\t\t\t\tnew RGBELoader()\n\t\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t\t.loadAsync( 'royal_esplanade_1k.hdr' )\n\t\t\t\t\t\t.then( tex => {\n\n\t\t\t\t\t\t\tconst envMapGenerator = new BlurredEnvMapGenerator( renderer );\n\t\t\t\t\t\t\tconst blurredEnvMap = envMapGenerator.generate( tex, 0 );\n\n\t\t\t\t\t\t\tenvironment = blurredEnvMap;\n\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.catch( onError );\n\n\t\t\t\tawait Promise.all( [ envMapPromise, ldrawPromise ] );\n\n\t\t\t\thideProgressBar();\n\t\t\t\tdocument.body.classList.add( 'checkerboard' );\n\n\t\t\t\t// set environment map\n\t\t\t\tscene.environment = environment;\n\n\t\t\t\t// Adjust camera\n\t\t\t\tconst bbox = new THREE.Box3().setFromObject( model );\n\t\t\t\tconst size = bbox.getSize( new THREE.Vector3() );\n\t\t\t\tconst radius = Math.max( size.x, Math.max( size.y, size.z ) ) * 0.4;\n\n\t\t\t\tcontrols.target0.copy( bbox.getCenter( new THREE.Vector3() ) );\n\t\t\t\tcontrols.position0.set( 2.3, 1, 2 ).multiplyScalar( radius ).add( controls.target0 );\n\t\t\t\tcontrols.reset();\n\n\t\t\t\t// add the model\n\t\t\t\tscene.add( model );\n\n\t\t\t\t// add floor\n\t\t\t\tfloor = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry(),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t\troughness: params.roughness,\n\t\t\t\t\t\tmetalness: params.metalness,\n\t\t\t\t\t\tmap: generateRadialFloorTexture( 1024 ),\n\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t} ),\n\t\t\t\t);\n\t\t\t\tfloor.scale.setScalar( 2500 );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.position.y = bbox.min.y;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// reset the progress bar to display bvh generation\n\t\t\t\tprogressBarDiv.innerText = 'Generating BVH...';\n\t\t\t\tupdateProgressBar( 0 );\n\n\t\t\t\tpathTracer.setScene( scene, camera );\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst w = window.innerWidth;\n\t\t\t\tconst h = window.innerHeight;\n\t\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\t\trenderer.setSize( w, h );\n\t\t\t\trenderer.setPixelRatio( dpr );\n\n\t\t\t\tconst aspect = w / h;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tpathTracer.updateCamera();\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tif ( gui ) {\n\n\t\t\t\t\tgui.destroy();\n\n\t\t\t\t}\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tgui.add( params, 'enable' );\n\t\t\t\tgui.add( params, 'pause' );\n\t\t\t\tgui.add( params, 'toneMapping' );\n\t\t\t\tgui.add( params, 'transparentBackground' ).onChange( v => {\n\n\t\t\t\t\tscene.background = v ? null : gradientMap;\n\t\t\t\t\tpathTracer.updateEnvironment();\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'resolutionScale', 0.1, 1.0, 0.1 ).onChange( v => {\n\n\t\t\t\t\tpathTracer.renderScale = v;\n\t\t\t\t\tpathTracer.reset();\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'tiles', 1, 6, 1 ).onChange( v => {\n\n\t\t\t\t\tpathTracer.tiles.set( v, v );\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'roughness', 0, 1 ).name( 'floor roughness' ).onChange( v => {\n\n\t\t\t\t\tfloor.material.roughness = v;\n\t\t\t\t\tpathTracer.updateMaterials();\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'metalness', 0, 1 ).name( 'floor metalness' ).onChange( v => {\n\n\t\t\t\t\tfloor.material.metalness = v;\n\t\t\t\t\tpathTracer.updateMaterials();\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'download' ).name( 'download image' );\n\n\t\t\t\tconst renderFolder = gui.addFolder( 'Render' );\n\n\t\t\t\tsamplesEl = document.createElement( 'div' );\n\t\t\t\tsamplesEl.classList.add( 'gui-render' );\n\t\t\t\tsamplesEl.innerText = 'samples: 0';\n\n\t\t\t\trenderFolder.$children.appendChild( samplesEl );\n\t\t\t\trenderFolder.open();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.toneMapping = params.toneMapping ? THREE.ACESFilmicToneMapping : THREE.NoToneMapping;\n\n\t\t\t\tconst samples = Math.floor( pathTracer.samples );\n\t\t\t\tsamplesEl.innerText = `samples: ${ samples }`;\n\n\t\t\t\tpathTracer.enablePathTracing = params.enable;\n\t\t\t\tpathTracer.pausePathTracing = params.pause;\n\t\t\t\tpathTracer.renderSample();\n\n\t\t\t\tsamplesEl.innerText = `samples: ${ Math.floor( pathTracer.samples ) }`;\n\n\t\t\t}\n\n\t\t\tfunction onProgress( xhr ) {\n\n\t\t\t\tif ( xhr.lengthComputable ) {\n\n\t\t\t\t\tupdateProgressBar( xhr.loaded / xhr.total );\n\n\t\t\t\t\tconsole.log( Math.round( xhr.loaded / xhr.total * 100 ) + '% downloaded' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onError( error ) {\n\n\t\t\t\tconst message = 'Error loading model';\n\t\t\t\tprogressBarDiv.innerText = message;\n\t\t\t\tconsole.log( message );\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t\tfunction showProgressBar() {\n\n\t\t\t\tdocument.body.appendChild( progressBarDiv );\n\n\t\t\t}\n\n\t\t\tfunction hideProgressBar() {\n\n\t\t\t\tdocument.body.removeChild( progressBarDiv );\n\n\t\t\t}\n\n\t\t\tfunction updateProgressBar( fraction ) {\n\n\t\t\t\tprogressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';\n\n\t\t\t}\n\n\t\t\tfunction generateRadialFloorTexture( dim ) {\n\n\t\t\t\tconst data = new Uint8Array( dim * dim * 4 );\n\n\t\t\t\tfor ( let x = 0; x < dim; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < dim; y ++ ) {\n\n\t\t\t\t\t\tconst xNorm = x / ( dim - 1 );\n\t\t\t\t\t\tconst yNorm = y / ( dim - 1 );\n\n\t\t\t\t\t\tconst xCent = 2.0 * ( xNorm - 0.5 );\n\t\t\t\t\t\tconst yCent = 2.0 * ( yNorm - 0.5 );\n\t\t\t\t\t\tlet a = Math.max( Math.min( 1.0 - Math.sqrt( xCent ** 2 + yCent ** 2 ), 1.0 ), 0.0 );\n\t\t\t\t\t\ta = a ** 1.5;\n\t\t\t\t\t\ta = a * 1.5;\n\t\t\t\t\t\ta = Math.min( a, 1.0 );\n\n\t\t\t\t\t\tconst i = y * dim + x;\n\t\t\t\t\t\tdata[ i * 4 + 0 ] = 255;\n\t\t\t\t\t\tdata[ i * 4 + 1 ] = 255;\n\t\t\t\t\t\tdata[ i * 4 + 2 ] = 255;\n\t\t\t\t\t\tdata[ i * 4 + 3 ] = a * 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst tex = new THREE.DataTexture( data, dim, dim );\n\t\t\t\ttex.format = THREE.RGBAFormat;\n\t\t\t\ttex.type = THREE.UnsignedByteType;\n\t\t\t\ttex.minFilter = THREE.LinearFilter;\n\t\t\t\ttex.magFilter = THREE.LinearFilter;\n\t\t\t\ttex.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttex.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttex.needsUpdate = true;\n\t\t\t\treturn tex;\n\n\t\t\t}\n```\n\nThis example three.js pathtracer - three-gpu-pathtracer See main project repository for more information and examples on high fidelity path tracing."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates refraction"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js refraction:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Refractor } from 'three/addons/objects/Refractor.js';\n\t\t\timport { WaterRefractionShader } from 'three/addons/shaders/WaterRefractionShader.js';\n\n\t\t\tlet camera, scene, renderer, clock;\n\n\t\t\tlet refractor, smallSphere;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );\n\t\t\t\tcamera.position.set( 0, 75, 160 );\n\n\t\t\t\t// refractor\n\n\t\t\t\tconst refractorGeometry = new THREE.PlaneGeometry( 90, 90 );\n\n\t\t\t\trefractor = new Refractor( refractorGeometry, {\n\t\t\t\t\tcolor: 0xcbcbcb,\n\t\t\t\t\ttextureWidth: 1024,\n\t\t\t\t\ttextureHeight: 1024,\n\t\t\t\t\tshader: WaterRefractionShader\n\t\t\t\t} );\n\n\t\t\t\trefractor.position.set( 0, 50, 0 );\n\n\t\t\t\tscene.add( refractor );\n\n\t\t\t\t// load dudv map for distortion effect\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst dudvMap = await loader.loadAsync( 'textures/waterdudv.jpg' );\n\n\t\t\t\tdudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\trefractor.material.uniforms.tDudv.value = dudvMap;\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 5, 0 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x333333, flatShading: true } );\n\t\t\t\tsmallSphere = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( smallSphere );\n\n\t\t\t\t// walls\n\t\t\t\tconst planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );\n\n\t\t\t\tconst planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneTop.position.y = 100;\n\t\t\t\tplaneTop.rotateX( Math.PI / 2 );\n\t\t\t\tscene.add( planeTop );\n\n\t\t\t\tconst planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneBottom.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( planeBottom );\n\n\t\t\t\tconst planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );\n\t\t\t\tplaneBack.position.z = - 50;\n\t\t\t\tplaneBack.position.y = 50;\n\t\t\t\tscene.add( planeBack );\n\n\t\t\t\tconst planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );\n\t\t\t\tplaneRight.position.x = 50;\n\t\t\t\tplaneRight.position.y = 50;\n\t\t\t\tplaneRight.rotateY( - Math.PI / 2 );\n\t\t\t\tscene.add( planeRight );\n\n\t\t\t\tconst planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );\n\t\t\t\tplaneLeft.position.x = - 50;\n\t\t\t\tplaneLeft.position.y = 50;\n\t\t\t\tplaneLeft.rotateY( Math.PI / 2 );\n\t\t\t\tscene.add( planeLeft );\n\n\t\t\t\t// lights\n\t\t\t\tconst mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );\n\t\t\t\tmainLight.position.y = 60;\n\t\t\t\tscene.add( mainLight );\n\n\t\t\t\tconst greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );\n\t\t\t\tgreenLight.position.set( 550, 50, 0 );\n\t\t\t\tscene.add( greenLight );\n\n\t\t\t\tconst redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );\n\t\t\t\tredLight.position.set( - 550, 50, 0 );\n\t\t\t\tscene.add( redLight );\n\n\t\t\t\tconst blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );\n\t\t\t\tblueLight.position.set( 0, 50, 550 );\n\t\t\t\tscene.add( blueLight );\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 40, 0 );\n\t\t\t\tcontrols.maxDistance = 400;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\t\trefractor.material.uniforms.time.value = time;\n\n\t\t\t\tsmallSphere.position.set(\n\t\t\t\t\tMath.cos( time ) * 30,\n\t\t\t\t\tMath.abs( Math.cos( time * 2 ) ) * 20 + 5,\n\t\t\t\t\tMath.sin( time ) * 30\n\t\t\t\t);\n\t\t\t\tsmallSphere.rotation.y = ( Math.PI / 2 ) - time;\n\t\t\t\tsmallSphere.rotation.z = time * 8;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - refraction"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - render-to-texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - render-to-texture:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet cameraRTT, camera, sceneRTT, sceneScreen, scene, renderer, zmesh1, zmesh2;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tconst windowHalfX = window.innerWidth / 2;\n\t\t\tconst windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet rtTexture, material, quad;\n\n\t\t\tlet delta = 0.01;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 100;\n\n\t\t\t\tcameraRTT = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );\n\t\t\t\tcameraRTT.position.z = 100;\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tsceneRTT = new THREE.Scene();\n\t\t\t\tsceneScreen = new THREE.Scene();\n\n\t\t\t\tlet light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 0, 1 ).normalize();\n\t\t\t\tsceneRTT.add( light );\n\n\t\t\t\tlight = new THREE.DirectionalLight( 0xffd5d5, 4.5 );\n\t\t\t\tlight.position.set( 0, 0, - 1 ).normalize();\n\t\t\t\tsceneRTT.add( light );\n\n\t\t\t\trtTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: { time: { value: 0.0 } },\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragment_shader_pass_1' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\tconst materialScreen = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: { tDiffuse: { value: rtTexture.texture } },\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,\n\n\t\t\t\t\tdepthWrite: false\n\n\t\t\t\t} );\n\n\t\t\t\tconst plane = new THREE.PlaneGeometry( window.innerWidth, window.innerHeight );\n\n\t\t\t\tquad = new THREE.Mesh( plane, material );\n\t\t\t\tquad.position.z = - 100;\n\t\t\t\tsceneRTT.add( quad );\n\n\t\t\t\tconst torusGeometry = new THREE.TorusGeometry( 100, 25, 15, 30 );\n\n\t\t\t\tconst mat1 = new THREE.MeshPhongMaterial( { color: 0x9c9c9c, specular: 0xffaa00, shininess: 5 } );\n\t\t\t\tconst mat2 = new THREE.MeshPhongMaterial( { color: 0x9c0000, specular: 0xff2200, shininess: 5 } );\n\n\t\t\t\tzmesh1 = new THREE.Mesh( torusGeometry, mat1 );\n\t\t\t\tzmesh1.position.set( 0, 0, 100 );\n\t\t\t\tzmesh1.scale.set( 1.5, 1.5, 1.5 );\n\t\t\t\tsceneRTT.add( zmesh1 );\n\n\t\t\t\tzmesh2 = new THREE.Mesh( torusGeometry, mat2 );\n\t\t\t\tzmesh2.position.set( 0, 150, 100 );\n\t\t\t\tzmesh2.scale.set( 0.75, 0.75, 0.75 );\n\t\t\t\tsceneRTT.add( zmesh2 );\n\n\t\t\t\tquad = new THREE.Mesh( plane, materialScreen );\n\t\t\t\tquad.position.z = - 100;\n\t\t\t\tsceneScreen.add( quad );\n\n\t\t\t\tconst n = 5,\n\t\t\t\t\tgeometry = new THREE.SphereGeometry( 10, 64, 32 ),\n\t\t\t\t\tmaterial2 = new THREE.MeshBasicMaterial( { color: 0xffffff, map: rtTexture.texture } );\n\n\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material2 );\n\n\t\t\t\t\t\tmesh.position.x = ( i - ( n - 1 ) / 2 ) * 20;\n\t\t\t\t\t\tmesh.position.y = ( j - ( n - 1 ) / 2 ) * 20;\n\t\t\t\t\t\tmesh.position.z = 0;\n\n\t\t\t\t\t\tmesh.rotation.y = - Math.PI / 2;\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.0015;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tif ( zmesh1 && zmesh2 ) {\n\n\t\t\t\t\tzmesh1.rotation.y = - time;\n\t\t\t\t\tzmesh2.rotation.y = - time + Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.uniforms[ 'time' ].value > 1 || material.uniforms[ 'time' ].value < 0 ) {\n\n\t\t\t\t\tdelta *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.uniforms[ 'time' ].value += delta;\n\n\n\t\t\t\t// Render first scene into texture\n\n\t\t\t\trenderer.setRenderTarget( rtTexture );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( sceneRTT, cameraRTT );\n\n\t\t\t\t// Render full screen quad with generated texture\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( sceneScreen, cameraRTT );\n\n\t\t\t\t// Render second scene to screen\n\t\t\t\t// (using first scene as regular texture)\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js render-to-texture webgl example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - shader [Monjori]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - shader [Monjori]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet uniforms;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2 );\n\n\t\t\t\tuniforms = {\n\t\t\t\t\ttime: { value: 1.0 }\n\t\t\t\t};\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tuniforms[ 'time' ].value = performance.now() / 1000;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - shader demo. featuring Monjori by Mic"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - shaders [lava]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - shaders [lava]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { BloomPass } from 'three/addons/postprocessing/BloomPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, renderer, composer, clock;\n\n\t\t\tlet uniforms, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 3000 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst cloudTexture = textureLoader.load( 'textures/lava/cloud.png' );\n\t\t\t\tconst lavaTexture = textureLoader.load( 'textures/lava/lavatile.jpg' );\n\n\t\t\t\tlavaTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tcloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\tlavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tuniforms = {\n\n\t\t\t\t\t'fogDensity': { value: 0.45 },\n\t\t\t\t\t'fogColor': { value: new THREE.Vector3( 0, 0, 0 ) },\n\t\t\t\t\t'time': { value: 1.0 },\n\t\t\t\t\t'uvScale': { value: new THREE.Vector2( 3.0, 1.0 ) },\n\t\t\t\t\t'texture1': { value: cloudTexture },\n\t\t\t\t\t'texture2': { value: lavaTexture }\n\n\t\t\t\t};\n\n\t\t\t\tconst size = 0.65;\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( new THREE.TorusGeometry( size, 0.3, 30, 30 ), material );\n\t\t\t\tmesh.rotation.x = 0.3;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst renderModel = new RenderPass( scene, camera );\n\t\t\t\tconst effectBloom = new BloomPass( 1.25 );\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tcomposer.addPass( renderModel );\n\t\t\t\tcomposer.addPass( effectBloom );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = 5 * clock.getDelta();\n\n\t\t\t\tuniforms[ 'time' ].value += 0.2 * delta;\n\n\t\t\t\tmesh.rotation.y += 0.0125 * delta;\n\t\t\t\tmesh.rotation.x += 0.05 * delta;\n\n\t\t\t\trenderer.clear();\n\t\t\t\tcomposer.render( 0.01 );\n\n\t\t\t}\n```\n\nThis example three.js - shader material demo. featuring lava shader by TheGameMaker"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - shaders - ocean"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - shaders - ocean:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Water } from 'three/addons/objects/Water.js';\n\t\t\timport { Sky } from 'three/addons/objects/Sky.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, water, sun, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 1, 20000 );\n\t\t\t\tcamera.position.set( 30, 30, 100 );\n\n\t\t\t\t//\n\n\t\t\t\tsun = new THREE.Vector3();\n\n\t\t\t\t// Water\n\n\t\t\t\tconst waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );\n\n\t\t\t\twater = new Water(\n\t\t\t\t\twaterGeometry,\n\t\t\t\t\t{\n\t\t\t\t\t\ttextureWidth: 512,\n\t\t\t\t\t\ttextureHeight: 512,\n\t\t\t\t\t\twaterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {\n\n\t\t\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t\t} ),\n\t\t\t\t\t\tsunDirection: new THREE.Vector3(),\n\t\t\t\t\t\tsunColor: 0xffffff,\n\t\t\t\t\t\twaterColor: 0x001e0f,\n\t\t\t\t\t\tdistortionScale: 3.7,\n\t\t\t\t\t\tfog: scene.fog !== undefined\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\twater.rotation.x = - Math.PI / 2;\n\n\t\t\t\tscene.add( water );\n\n\t\t\t\t// Skybox\n\n\t\t\t\tconst sky = new Sky();\n\t\t\t\tsky.scale.setScalar( 10000 );\n\t\t\t\tscene.add( sky );\n\n\t\t\t\tconst skyUniforms = sky.material.uniforms;\n\n\t\t\t\tskyUniforms[ 'turbidity' ].value = 10;\n\t\t\t\tskyUniforms[ 'rayleigh' ].value = 2;\n\t\t\t\tskyUniforms[ 'mieCoefficient' ].value = 0.005;\n\t\t\t\tskyUniforms[ 'mieDirectionalG' ].value = 0.8;\n\n\t\t\t\tconst parameters = {\n\t\t\t\t\televation: 2,\n\t\t\t\t\tazimuth: 180\n\t\t\t\t};\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tconst sceneEnv = new THREE.Scene();\n\n\t\t\t\tlet renderTarget;\n\n\t\t\t\tfunction updateSun() {\n\n\t\t\t\t\tconst phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );\n\t\t\t\t\tconst theta = THREE.MathUtils.degToRad( parameters.azimuth );\n\n\t\t\t\t\tsun.setFromSphericalCoords( 1, phi, theta );\n\n\t\t\t\t\tsky.material.uniforms[ 'sunPosition' ].value.copy( sun );\n\t\t\t\t\twater.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();\n\n\t\t\t\t\tif ( renderTarget !== undefined ) renderTarget.dispose();\n\n\t\t\t\t\tsceneEnv.add( sky );\n\t\t\t\t\trenderTarget = pmremGenerator.fromScene( sceneEnv );\n\t\t\t\t\tscene.add( sky );\n\n\t\t\t\t\tscene.environment = renderTarget.texture;\n\n\t\t\t\t}\n\n\t\t\t\tupdateSun();\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 30, 30, 30 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { roughness: 0 } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.495;\n\t\t\t\tcontrols.target.set( 0, 10, 0 );\n\t\t\t\tcontrols.minDistance = 40.0;\n\t\t\t\tcontrols.maxDistance = 200.0;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst folderSky = gui.addFolder( 'Sky' );\n\t\t\t\tfolderSky.add( parameters, 'elevation', 0, 90, 0.1 ).onChange( updateSun );\n\t\t\t\tfolderSky.add( parameters, 'azimuth', - 180, 180, 0.1 ).onChange( updateSun );\n\t\t\t\tfolderSky.open();\n\n\t\t\t\tconst waterUniforms = water.material.uniforms;\n\n\t\t\t\tconst folderWater = gui.addFolder( 'Water' );\n\t\t\t\tfolderWater.add( waterUniforms.distortionScale, 'value', 0, 8, 0.1 ).name( 'distortionScale' );\n\t\t\t\tfolderWater.add( waterUniforms.size, 'value', 0.1, 10, 0.1 ).name( 'size' );\n\t\t\t\tfolderWater.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = performance.now() * 0.001;\n\n\t\t\t\tmesh.position.y = Math.sin( time ) * 20 + 5;\n\t\t\t\tmesh.rotation.x = time * 0.5;\n\t\t\t\tmesh.rotation.z = time * 0.51;\n\n\t\t\t\twater.material.uniforms[ 'time' ].value += 1.0 / 60.0;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl ocean"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - shaders - sky sun shader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - shaders - sky sun shader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Sky } from 'three/addons/objects/Sky.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet sky, sun;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction initSky() {\n\n\t\t\t\t// Add Sky\n\t\t\t\tsky = new Sky();\n\t\t\t\tsky.scale.setScalar( 450000 );\n\t\t\t\tscene.add( sky );\n\n\t\t\t\tsun = new THREE.Vector3();\n\n\t\t\t\t/// GUI\n\n\t\t\t\tconst effectController = {\n\t\t\t\t\tturbidity: 10,\n\t\t\t\t\trayleigh: 3,\n\t\t\t\t\tmieCoefficient: 0.005,\n\t\t\t\t\tmieDirectionalG: 0.7,\n\t\t\t\t\televation: 2,\n\t\t\t\t\tazimuth: 180,\n\t\t\t\t\texposure: renderer.toneMappingExposure\n\t\t\t\t};\n\n\t\t\t\tfunction guiChanged() {\n\n\t\t\t\t\tconst uniforms = sky.material.uniforms;\n\t\t\t\t\tuniforms[ 'turbidity' ].value = effectController.turbidity;\n\t\t\t\t\tuniforms[ 'rayleigh' ].value = effectController.rayleigh;\n\t\t\t\t\tuniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;\n\t\t\t\t\tuniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;\n\n\t\t\t\t\tconst phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );\n\t\t\t\t\tconst theta = THREE.MathUtils.degToRad( effectController.azimuth );\n\n\t\t\t\t\tsun.setFromSphericalCoords( 1, phi, theta );\n\n\t\t\t\t\tuniforms[ 'sunPosition' ].value.copy( sun );\n\n\t\t\t\t\trenderer.toneMappingExposure = effectController.exposure;\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( effectController, 'turbidity', 0.0, 20.0, 0.1 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'rayleigh', 0.0, 4, 0.001 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'mieCoefficient', 0.0, 0.1, 0.001 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'mieDirectionalG', 0.0, 1, 0.001 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'elevation', 0, 90, 0.1 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'azimuth', - 180, 180, 0.1 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'exposure', 0, 1, 0.0001 ).onChange( guiChanged );\n\n\t\t\t\tguiChanged();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 2000000 );\n\t\t\t\tcamera.position.set( 0, 100, 2000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst helper = new THREE.GridHelper( 10000, 2, 0xffffff, 0xffffff );\n\t\t\t\tscene.add( helper );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\t//controls.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\tinitSky();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - sky + sun shader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - contact shadows"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - contact shadows:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';\n\t\t\timport { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';\n\n\t\t\tlet camera, scene, renderer, stats, gui;\n\n\t\t\tconst meshes = [];\n\n\t\t\tconst PLANE_WIDTH = 2.5;\n\t\t\tconst PLANE_HEIGHT = 2.5;\n\t\t\tconst CAMERA_HEIGHT = 0.3;\n\n\t\t\tconst state = {\n\t\t\t\tshadow: {\n\t\t\t\t\tblur: 3.5,\n\t\t\t\t\tdarkness: 1,\n\t\t\t\t\topacity: 1,\n\t\t\t\t},\n\t\t\t\tplane: {\n\t\t\t\t\tcolor: '#ffffff',\n\t\t\t\t\topacity: 1,\n\t\t\t\t},\n\t\t\t\tshowWireframe: false,\n\t\t\t};\n\n\t\t\tlet shadowGroup, renderTarget, renderTargetBlur, shadowCamera, cameraHelper, depthMaterial, horizontalBlurMaterial, verticalBlurMaterial;\n\n\t\t\tlet plane, blurPlane, fillPlane;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0.5, 1, 2 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// add the example meshes\n\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.BoxGeometry( 0.4, 0.4, 0.4 ),\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 0.3 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 0.4, 0.05, 256, 24, 1, 3 )\n\t\t\t\t];\n\n\t\t\t\tconst material = new THREE.MeshNormalMaterial();\n\n\t\t\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst angle = ( i / l ) * Math.PI * 2;\n\n\t\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.y = 0.1;\n\t\t\t\t\tmesh.position.x = Math.cos( angle ) / 2.0;\n\t\t\t\t\tmesh.position.z = Math.sin( angle ) / 2.0;\n\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\n\n\t\t\t\t// the container, if you need to move the plane just move this\n\t\t\t\tshadowGroup = new THREE.Group();\n\t\t\t\tshadowGroup.position.y = - 0.3;\n\t\t\t\tscene.add( shadowGroup );\n\n\t\t\t\t// the render target that will show the shadows in the plane texture\n\t\t\t\trenderTarget = new THREE.WebGLRenderTarget( 512, 512 );\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\t\t// the render target that we will use to blur the first render target\n\t\t\t\trenderTargetBlur = new THREE.WebGLRenderTarget( 512, 512 );\n\t\t\t\trenderTargetBlur.texture.generateMipmaps = false;\n\n\n\t\t\t\t// make a plane and make it face up\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( PLANE_WIDTH, PLANE_HEIGHT ).rotateX( Math.PI / 2 );\n\t\t\t\tconst planeMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tmap: renderTarget.texture,\n\t\t\t\t\topacity: state.shadow.opacity,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t} );\n\t\t\t\tplane = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\t// make sure it's rendered after the fillPlane\n\t\t\t\tplane.renderOrder = 1;\n\t\t\t\tshadowGroup.add( plane );\n\n\t\t\t\t// the y from the texture is flipped!\n\t\t\t\tplane.scale.y = - 1;\n\n\t\t\t\t// the plane onto which to blur the texture\n\t\t\t\tblurPlane = new THREE.Mesh( planeGeometry );\n\t\t\t\tblurPlane.visible = false;\n\t\t\t\tshadowGroup.add( blurPlane );\n\n\t\t\t\t// the plane with the color of the ground\n\t\t\t\tconst fillPlaneMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: state.plane.color,\n\t\t\t\t\topacity: state.plane.opacity,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t} );\n\t\t\t\tfillPlane = new THREE.Mesh( planeGeometry, fillPlaneMaterial );\n\t\t\t\tfillPlane.rotateX( Math.PI );\n\t\t\t\tshadowGroup.add( fillPlane );\n\n\t\t\t\t// the camera to render the depth material from\n\t\t\t\tshadowCamera = new THREE.OrthographicCamera( - PLANE_WIDTH / 2, PLANE_WIDTH / 2, PLANE_HEIGHT / 2, - PLANE_HEIGHT / 2, 0, CAMERA_HEIGHT );\n\t\t\t\tshadowCamera.rotation.x = Math.PI / 2; // get the camera to look up\n\t\t\t\tshadowGroup.add( shadowCamera );\n\n\t\t\t\tcameraHelper = new THREE.CameraHelper( shadowCamera );\n\n\t\t\t\t// like MeshDepthMaterial, but goes from black to transparent\n\t\t\t\tdepthMaterial = new THREE.MeshDepthMaterial();\n\t\t\t\tdepthMaterial.userData.darkness = { value: state.shadow.darkness };\n\t\t\t\tdepthMaterial.onBeforeCompile = function ( shader ) {\n\n\t\t\t\t\tshader.uniforms.darkness = depthMaterial.userData.darkness;\n\t\t\t\t\tshader.fragmentShader = /* glsl */`\n\t\t\t\t\t\tuniform float darkness;\n\t\t\t\t\t\t${shader.fragmentShader.replace(\n\t\t\t\t\t'gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n\t\t\t\t\t'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );'\n\t\t\t\t)}\n\t\t\t\t\t`;\n\n\t\t\t\t};\n\n\t\t\t\tdepthMaterial.depthTest = false;\n\t\t\t\tdepthMaterial.depthWrite = false;\n\n\t\t\t\thorizontalBlurMaterial = new THREE.ShaderMaterial( HorizontalBlurShader );\n\t\t\t\thorizontalBlurMaterial.depthTest = false;\n\n\t\t\t\tverticalBlurMaterial = new THREE.ShaderMaterial( VerticalBlurShader );\n\t\t\t\tverticalBlurMaterial.depthTest = false;\n\n\t\t\t\t//\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tconst shadowFolder = gui.addFolder( 'shadow' );\n\t\t\t\tshadowFolder.open();\n\t\t\t\tconst planeFolder = gui.addFolder( 'plane' );\n\t\t\t\tplaneFolder.open();\n\n\n\t\t\t\tshadowFolder.add( state.shadow, 'blur', 0, 15, 0.1 );\n\t\t\t\tshadowFolder.add( state.shadow, 'darkness', 1, 5, 0.1 ).onChange( function () {\n\n\t\t\t\t\tdepthMaterial.userData.darkness.value = state.shadow.darkness;\n\n\t\t\t\t} );\n\t\t\t\tshadowFolder.add( state.shadow, 'opacity', 0, 1, 0.01 ).onChange( function () {\n\n\t\t\t\t\tplane.material.opacity = state.shadow.opacity;\n\n\t\t\t\t} );\n\t\t\t\tplaneFolder.addColor( state.plane, 'color' ).onChange( function () {\n\n\t\t\t\t\tfillPlane.material.color = new THREE.Color( state.plane.color );\n\n\t\t\t\t} );\n\t\t\t\tplaneFolder.add( state.plane, 'opacity', 0, 1, 0.01 ).onChange( function () {\n\n\t\t\t\t\tfillPlane.material.opacity = state.plane.opacity;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( state, 'showWireframe' ).onChange( function () {\n\n\t\t\t\t\tif ( state.showWireframe ) {\n\n\t\t\t\t\t\tscene.add( cameraHelper );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tscene.remove( cameraHelper );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t// renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget\n\t\t\tfunction blurShadow( amount ) {\n\n\t\t\t\tblurPlane.visible = true;\n\n\t\t\t\t// blur horizontally and draw in the renderTargetBlur\n\t\t\t\tblurPlane.material = horizontalBlurMaterial;\n\t\t\t\tblurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;\n\t\t\t\thorizontalBlurMaterial.uniforms.h.value = amount * 1 / 256;\n\n\t\t\t\trenderer.setRenderTarget( renderTargetBlur );\n\t\t\t\trenderer.render( blurPlane, shadowCamera );\n\n\t\t\t\t// blur vertically and draw in the main renderTarget\n\t\t\t\tblurPlane.material = verticalBlurMaterial;\n\t\t\t\tblurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;\n\t\t\t\tverticalBlurMaterial.uniforms.v.value = amount * 1 / 256;\n\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( blurPlane, shadowCamera );\n\n\t\t\t\tblurPlane.visible = false;\n\n\t\t\t}\n\n\t\t\tfunction animate( ) {\n\n\t\t\t\tmeshes.forEach( mesh => {\n\n\t\t\t\t\tmesh.rotation.x += 0.01;\n\t\t\t\t\tmesh.rotation.y += 0.02;\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\t// remove the background\n\t\t\t\tconst initialBackground = scene.background;\n\t\t\t\tscene.background = null;\n\n\t\t\t\t// force the depthMaterial to everything\n\t\t\t\tcameraHelper.visible = false;\n\t\t\t\tscene.overrideMaterial = depthMaterial;\n\n\t\t\t\t// set renderer clear alpha\n\t\t\t\tconst initialClearAlpha = renderer.getClearAlpha();\n\t\t\t\trenderer.setClearAlpha( 0 );\n\n\t\t\t\t// render to the render target to get the depths\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( scene, shadowCamera );\n\n\t\t\t\t// and reset the override material\n\t\t\t\tscene.overrideMaterial = null;\n\t\t\t\tcameraHelper.visible = true;\n\n\t\t\t\tblurShadow( state.shadow.blur );\n\n\t\t\t\t// a second pass to reduce the artifacts\n\t\t\t\t// (0.4 is the minimum blur amount so that the artifacts are gone)\n\t\t\t\tblurShadow( state.shadow.blur * 0.4 );\n\n\t\t\t\t// reset and render the normal scene\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.setClearAlpha( initialClearAlpha );\n\t\t\t\tscene.background = initialBackground;\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - contact shadows"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - shadow map"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - shadow map:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\t\t\timport { ShadowMapViewer } from 'three/addons/utils/ShadowMapViewer.js';\n\n\t\t\tconst SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tconst FLOOR = - 250;\n\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet container, stats;\n\n\t\t\tconst NEAR = 10, FAR = 3000;\n\n\t\t\tlet mixer;\n\n\t\t\tconst morphs = [];\n\n\t\t\tlet light;\n\t\t\tlet lightShadowMapViewer;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet showHUD = false;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 23, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );\n\t\t\t\tcamera.position.set( 700, 50, 1900 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x59472b );\n\t\t\t\tscene.fog = new THREE.Fog( 0x59472b, 1000, FAR );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tlight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 1500, 1000 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 2000;\n\t\t\t\tlight.shadow.camera.bottom = - 2000;\n\t\t\t\tlight.shadow.camera.left = - 2000;\n\t\t\t\tlight.shadow.camera.right = 2000;\n\t\t\t\tlight.shadow.camera.near = 1200;\n\t\t\t\tlight.shadow.camera.far = 2500;\n\t\t\t\tlight.shadow.bias = 0.0001;\n\n\t\t\t\tlight.shadow.mapSize.width = SHADOW_MAP_WIDTH;\n\t\t\t\tlight.shadow.mapSize.height = SHADOW_MAP_HEIGHT;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tcreateHUD();\n\t\t\t\tcreateScene();\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\t//\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFShadowMap;\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tcontrols = new FirstPersonControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.lookSpeed = 0.0125;\n\t\t\t\tcontrols.movementSpeed = 500;\n\t\t\t\tcontrols.lookVertical = true;\n\n\t\t\t\tcontrols.lookAt( scene.position );\n\n\t\t\t\t// STATS\n\n\t\t\t\tstats = new Stats();\n\t\t\t\t//container.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.addEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\tcase 84:\t/*t*/\n\t\t\t\t\t\tshowHUD = ! showHUD;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createHUD() {\n\n\t\t\t\tlightShadowMapViewer = new ShadowMapViewer( light );\n\t\t\t\tlightShadowMapViewer.position.x = 10;\n\t\t\t\tlightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;\n\t\t\t\tlightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;\n\t\t\t\tlightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;\n\t\t\t\tlightShadowMapViewer.update();\n\n\t\t\t}\n\n\t\t\tfunction createScene( ) {\n\n\t\t\t\t// GROUND\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffdd99 } );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, planeMaterial );\n\n\t\t\t\tground.position.set( 0, FLOOR, 0 );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.set( 100, 100, 100 );\n\n\t\t\t\tground.castShadow = false;\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// TEXT\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst textGeo = new TextGeometry( 'THREE.JS', {\n\n\t\t\t\t\t\tfont: font,\n\n\t\t\t\t\t\tsize: 200,\n\t\t\t\t\t\tdepth: 50,\n\t\t\t\t\t\tcurveSegments: 12,\n\n\t\t\t\t\t\tbevelThickness: 2,\n\t\t\t\t\t\tbevelSize: 5,\n\t\t\t\t\t\tbevelEnabled: true\n\n\t\t\t\t\t} );\n\n\t\t\t\t\ttextGeo.computeBoundingBox();\n\t\t\t\t\tconst centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );\n\n\t\t\t\t\tconst textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( textGeo, textMaterial );\n\t\t\t\t\tmesh.position.x = centerOffset;\n\t\t\t\t\tmesh.position.y = FLOOR + 67;\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// CUBES\n\n\t\t\t\tconst cubes1 = new THREE.Mesh( new THREE.BoxGeometry( 1500, 220, 150 ), planeMaterial );\n\n\t\t\t\tcubes1.position.y = FLOOR - 50;\n\t\t\t\tcubes1.position.z = 20;\n\n\t\t\t\tcubes1.castShadow = true;\n\t\t\t\tcubes1.receiveShadow = true;\n\n\t\t\t\tscene.add( cubes1 );\n\n\t\t\t\tconst cubes2 = new THREE.Mesh( new THREE.BoxGeometry( 1600, 170, 250 ), planeMaterial );\n\n\t\t\t\tcubes2.position.y = FLOOR - 50;\n\t\t\t\tcubes2.position.z = 20;\n\n\t\t\t\tcubes2.castShadow = true;\n\t\t\t\tcubes2.receiveShadow = true;\n\n\t\t\t\tscene.add( cubes2 );\n\n\t\t\t\t// MORPHS\n\n\t\t\t\tmixer = new THREE.AnimationMixer( scene );\n\n\t\t\t\tfunction addMorph( mesh, clip, speed, duration, x, y, z, fudgeColor ) {\n\n\t\t\t\t\tmesh = mesh.clone();\n\t\t\t\t\tmesh.material = mesh.material.clone();\n\n\t\t\t\t\tif ( fudgeColor ) {\n\n\t\t\t\t\t\tmesh.material.color.offsetHSL( 0, Math.random() * 0.5 - 0.25, Math.random() * 0.5 - 0.25 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.speed = speed;\n\n\t\t\t\t\tmixer.clipAction( clip, mesh ).\n\t\t\t\t\t\tsetDuration( duration ).\n\t\t\t\t\t// to shift the playback out of phase:\n\t\t\t\t\t\tstartAt( - duration * Math.random() ).\n\t\t\t\t\t\tplay();\n\n\t\t\t\t\tmesh.position.set( x, y, z );\n\t\t\t\t\tmesh.rotation.y = Math.PI / 2;\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmorphs.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tconst gltfloader = new GLTFLoader();\n\n\t\t\t\tgltfloader.load( 'models/gltf/Horse.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\n\t\t\t\t\tconst clip = gltf.animations[ 0 ];\n\n\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, 300, true );\n\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, 450, true );\n\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, 600, true );\n\n\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, - 300, true );\n\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, - 450, true );\n\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, - 600, true );\n\n\t\t\t\t} );\n\n\t\t\t\tgltfloader.load( 'models/gltf/Flamingo.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tconst clip = gltf.animations[ 0 ];\n\n\t\t\t\t\taddMorph( mesh, clip, 500, 1, 500 - Math.random() * 500, FLOOR + 350, 40 );\n\n\t\t\t\t} );\n\n\t\t\t\tgltfloader.load( 'models/gltf/Stork.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tconst clip = gltf.animations[ 0 ];\n\n\t\t\t\t\taddMorph( mesh, clip, 350, 1, 500 - Math.random() * 500, FLOOR + 350, 340 );\n\n\t\t\t\t} );\n\n\t\t\t\tgltfloader.load( 'models/gltf/Parrot.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tconst clip = gltf.animations[ 0 ];\n\n\t\t\t\t\taddMorph( mesh, clip, 450, 0.5, 500 - Math.random() * 500, FLOOR + 300, 700 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tfor ( let i = 0; i < morphs.length; i ++ ) {\n\n\t\t\t\t\tconst morph = morphs[ i ];\n\n\t\t\t\t\tmorph.position.x += morph.speed * delta;\n\n\t\t\t\t\tif ( morph.position.x > 2000 ) {\n\n\t\t\t\t\t\tmorph.position.x = - 1000 - Math.random() * 500;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.update( delta );\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// Render debug HUD with shadow map\n\n\t\t\t\tif ( showHUD ) {\n\n\t\t\t\t\tlightShadowMapViewer.render( renderer );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - shadowmap - models by mirada from rome move camera with WASD / RF + mouse t: toggle HUD"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - shadow map"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - shadow map:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tconst SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tconst FLOOR = - 250;\n\n\t\t\tconst ANIMATION_GROUPS = 25;\n\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet stats;\n\n\t\t\tconst NEAR = 5, FAR = 3000;\n\n\t\t\tlet morph, mixer;\n\n\t\t\tconst morphs = [], animGroups = [];\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 23, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );\n\t\t\t\tcamera.position.set( 700, 50, 1900 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x59472b );\n\t\t\t\tscene.fog = new THREE.Fog( 0x59472b, 1000, FAR );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 1500, 1000 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 2000;\n\t\t\t\tlight.shadow.camera.bottom = - 2000;\n\t\t\t\tlight.shadow.camera.left = - 2000;\n\t\t\t\tlight.shadow.camera.right = 2000;\n\t\t\t\tlight.shadow.camera.near = 1200;\n\t\t\t\tlight.shadow.camera.far = 2500;\n\t\t\t\tlight.shadow.bias = 0.0001;\n\n\t\t\t\tlight.shadow.mapSize.width = SHADOW_MAP_WIDTH;\n\t\t\t\tlight.shadow.mapSize.height = SHADOW_MAP_HEIGHT;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tcreateScene();\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\t//\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tcontrols = new FirstPersonControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.lookSpeed = 0.0125;\n\t\t\t\tcontrols.movementSpeed = 500;\n\t\t\t\tcontrols.lookVertical = true;\n\n\t\t\t\tcontrols.lookAt( scene.position );\n\n\t\t\t\t// STATS\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction createScene( ) {\n\n\t\t\t\t// GROUND\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffdd99 } );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, planeMaterial );\n\n\t\t\t\tground.position.set( 0, FLOOR, 0 );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.set( 100, 100, 100 );\n\n\t\t\t\tground.castShadow = false;\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// TEXT\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst textGeo = new TextGeometry( 'THREE.JS', {\n\n\t\t\t\t\t\tfont: font,\n\n\t\t\t\t\t\tsize: 200,\n\t\t\t\t\t\tdepth: 50,\n\t\t\t\t\t\tcurveSegments: 12,\n\n\t\t\t\t\t\tbevelThickness: 2,\n\t\t\t\t\t\tbevelSize: 5,\n\t\t\t\t\t\tbevelEnabled: true\n\n\t\t\t\t\t} );\n\n\t\t\t\t\ttextGeo.computeBoundingBox();\n\t\t\t\t\tconst centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );\n\n\t\t\t\t\tconst textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( textGeo, textMaterial );\n\t\t\t\t\tmesh.position.x = centerOffset;\n\t\t\t\t\tmesh.position.y = FLOOR + 67;\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// CUBES\n\n\t\t\t\tconst cubes1 = new THREE.Mesh( new THREE.BoxGeometry( 1500, 220, 150 ), planeMaterial );\n\n\t\t\t\tcubes1.position.y = FLOOR - 50;\n\t\t\t\tcubes1.position.z = 20;\n\n\t\t\t\tcubes1.castShadow = true;\n\t\t\t\tcubes1.receiveShadow = true;\n\n\t\t\t\tscene.add( cubes1 );\n\n\t\t\t\tconst cubes2 = new THREE.Mesh( new THREE.BoxGeometry( 1600, 170, 250 ), planeMaterial );\n\n\t\t\t\tcubes2.position.y = FLOOR - 50;\n\t\t\t\tcubes2.position.z = 20;\n\n\t\t\t\tcubes2.castShadow = true;\n\t\t\t\tcubes2.receiveShadow = true;\n\n\t\t\t\tscene.add( cubes2 );\n\n\t\t\t\tmixer = new THREE.AnimationMixer( scene );\n\n\t\t\t\tfor ( let i = 0; i !== ANIMATION_GROUPS; ++ i ) {\n\n\t\t\t\t\tconst group = new THREE.AnimationObjectGroup();\n\t\t\t\t\tanimGroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\t// MORPHS\n\n\t\t\t\tfunction addMorph( mesh, clip, speed, duration, x, y, z, fudgeColor, massOptimization ) {\n\n\t\t\t\t\tmesh = mesh.clone();\n\t\t\t\t\tmesh.material = mesh.material.clone();\n\n\t\t\t\t\tif ( fudgeColor ) {\n\n\t\t\t\t\t\tmesh.material.color.offsetHSL( 0, Math.random() * 0.5 - 0.25, Math.random() * 0.5 - 0.25 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.speed = speed;\n\n\t\t\t\t\tif ( massOptimization ) {\n\n\t\t\t\t\t\tconst index = Math.floor( Math.random() * ANIMATION_GROUPS ),\n\t\t\t\t\t\t\tanimGroup = animGroups[ index ];\n\n\t\t\t\t\t\tanimGroup.add( mesh );\n\n\t\t\t\t\t\tif ( ! mixer.existingAction( clip, animGroup ) ) {\n\n\t\t\t\t\t\t\tconst randomness = 0.6 * Math.random() - 0.3;\n\t\t\t\t\t\t\tconst phase = ( index + randomness ) / ANIMATION_GROUPS;\n\n\t\t\t\t\t\t\tmixer.clipAction( clip, animGroup ).\n\t\t\t\t\t\t\t\tsetDuration( duration ).\n\t\t\t\t\t\t\t\tstartAt( - duration * phase ).\n\t\t\t\t\t\t\t\tplay();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmixer.clipAction( clip, mesh ).\n\t\t\t\t\t\t\tsetDuration( duration ).\n\t\t\t\t\t\t\tstartAt( - duration * Math.random() ).\n\t\t\t\t\t\t\tplay();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.position.set( x, y, z );\n\t\t\t\t\tmesh.rotation.y = Math.PI / 2;\n\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmorphs.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.load( 'models/gltf/Horse.glb', function ( gltf ) {\n\n\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tconst clip = gltf.animations[ 0 ];\n\n\t\t\t\t\tfor ( let i = - 600; i < 601; i += 2 ) {\n\n\t\t\t\t\t\taddMorph( mesh, clip, 550, 1, 100 - Math.random() * 3000, FLOOR, i, true, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\tfor ( let i = 0; i < morphs.length; i ++ ) {\n\n\t\t\t\t\tmorph = morphs[ i ];\n\n\t\t\t\t\tmorph.position.x += morph.speed * delta;\n\n\t\t\t\t\tif ( morph.position.x > 2000 ) {\n\n\t\t\t\t\t\tmorph.position.x = - 1000 - Math.random() * 500;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.update( delta );\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - shadowmap - models by mirada from rome move camera with WASD / RF + mouse"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - THREE.PointLight ShadowMap"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - THREE.PointLight ShadowMap:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet pointLight, pointLight2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 10, 40 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x111122, 3 ) );\n\n\t\t\t\t// lights\n\n\t\t\t\tfunction createLight( color ) {\n\n\t\t\t\t\tconst intensity = 200;\n\n\t\t\t\t\tconst light = new THREE.PointLight( color, intensity, 20 );\n\t\t\t\t\tlight.castShadow = true;\n\t\t\t\t\tlight.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects\n\n\t\t\t\t\tlet geometry = new THREE.SphereGeometry( 0.3, 12, 6 );\n\t\t\t\t\tlet material = new THREE.MeshBasicMaterial( { color: color } );\n\t\t\t\t\tmaterial.color.multiplyScalar( intensity );\n\t\t\t\t\tlet sphere = new THREE.Mesh( geometry, material );\n\t\t\t\t\tlight.add( sphere );\n\n\t\t\t\t\tconst texture = new THREE.CanvasTexture( generateTexture() );\n\t\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( 1, 4.5 );\n\n\t\t\t\t\tgeometry = new THREE.SphereGeometry( 2, 32, 8 );\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\t\talphaMap: texture,\n\t\t\t\t\t\talphaTest: 0.5\n\t\t\t\t\t} );\n\n\t\t\t\t\tsphere = new THREE.Mesh( geometry, material );\n\t\t\t\t\tsphere.castShadow = true;\n\t\t\t\t\tsphere.receiveShadow = true;\n\t\t\t\t\tlight.add( sphere );\n\n\t\t\t\t\treturn light;\n\n\t\t\t\t}\n\n\t\t\t\tpointLight = createLight( 0x0088ff );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tpointLight2 = createLight( 0xff8888 );\n\t\t\t\tscene.add( pointLight2 );\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 30, 30, 30 );\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xa0adaf,\n\t\t\t\t\tshininess: 10,\n\t\t\t\t\tspecular: 0x111111,\n\t\t\t\t\tside: THREE.BackSide\n\t\t\t\t} );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.position.y = 10;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.BasicShadowMap;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 10, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction generateTexture() {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 2;\n\t\t\t\tcanvas.height = 2;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 1, 2, 1 );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tlet time = performance.now() * 0.001;\n\n\t\t\t\tpointLight.position.x = Math.sin( time * 0.6 ) * 9;\n\t\t\t\tpointLight.position.y = Math.sin( time * 0.7 ) * 9 + 6;\n\t\t\t\tpointLight.position.z = Math.sin( time * 0.8 ) * 9;\n\n\t\t\t\tpointLight.rotation.x = time;\n\t\t\t\tpointLight.rotation.z = time;\n\n\t\t\t\ttime += 10000;\n\n\t\t\t\tpointLight2.position.x = Math.sin( time * 0.6 ) * 9;\n\t\t\t\tpointLight2.position.y = Math.sin( time * 0.7 ) * 9 + 6;\n\t\t\t\tpointLight2.position.z = Math.sin( time * 0.8 ) * 9;\n\n\t\t\t\tpointLight2.rotation.x = time;\n\t\t\t\tpointLight2.rotation.z = time;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - THREE.PointLight ShadowMap by mkkellogg"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - ShadowMapViewer example"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - ShadowMapViewer example:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ShadowMapViewer } from 'three/addons/utils/ShadowMapViewer.js';\n\n\t\t\tlet camera, scene, renderer, clock, stats;\n\t\t\tlet dirLight, spotLight;\n\t\t\tlet torusKnot, cube;\n\t\t\tlet dirLightShadowMapViewer, spotLightShadowMapViewer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitScene();\n\t\t\t\tinitShadowMapViewers();\n\t\t\t\tinitMisc();\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initScene() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 15, 35 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x404040, 3 ) );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xffffff, 500 );\n\t\t\t\tspotLight.name = 'Spot Light';\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.3;\n\t\t\t\tspotLight.position.set( 10, 10, 5 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 8;\n\t\t\t\tspotLight.shadow.camera.far = 30;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tscene.add( new THREE.CameraHelper( spotLight.shadow.camera ) );\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.name = 'Dir. Light';\n\t\t\t\tdirLight.position.set( 0, 10, 0 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 10;\n\t\t\t\tdirLight.shadow.camera.right = 15;\n\t\t\t\tdirLight.shadow.camera.left = - 15;\n\t\t\t\tdirLight.shadow.camera.top\t= 15;\n\t\t\t\tdirLight.shadow.camera.bottom = - 15;\n\t\t\t\tdirLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tscene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t\t// Geometry\n\t\t\t\tlet geometry = new THREE.TorusKnotGeometry( 25, 8, 75, 20 );\n\t\t\t\tlet material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\tshininess: 150,\n\t\t\t\t\tspecular: 0x222222\n\t\t\t\t} );\n\n\t\t\t\ttorusKnot = new THREE.Mesh( geometry, material );\n\t\t\t\ttorusKnot.scale.multiplyScalar( 1 / 18 );\n\t\t\t\ttorusKnot.position.y = 3;\n\t\t\t\ttorusKnot.castShadow = true;\n\t\t\t\ttorusKnot.receiveShadow = true;\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\tgeometry = new THREE.BoxGeometry( 3, 3, 3 );\n\t\t\t\tcube = new THREE.Mesh( geometry, material );\n\t\t\t\tcube.position.set( 8, 3, 8 );\n\t\t\t\tcube.castShadow = true;\n\t\t\t\tcube.receiveShadow = true;\n\t\t\t\tscene.add( cube );\n\n\t\t\t\tgeometry = new THREE.BoxGeometry( 10, 0.15, 10 );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xa0adaf,\n\t\t\t\t\tshininess: 150,\n\t\t\t\t\tspecular: 0x111111\n\t\t\t\t} );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, material );\n\t\t\t\tground.scale.multiplyScalar( 3 );\n\t\t\t\tground.castShadow = false;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t}\n\n\t\t\tfunction initShadowMapViewers() {\n\n\t\t\t\tdirLightShadowMapViewer = new ShadowMapViewer( dirLight );\n\t\t\t\tspotLightShadowMapViewer = new ShadowMapViewer( spotLight );\n\t\t\t\tresizeShadowMapViewers();\n\n\t\t\t}\n\n\t\t\tfunction initMisc() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.BasicShadowMap;\n\n\t\t\t\t// Mouse control\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction resizeShadowMapViewers() {\n\n\t\t\t\tconst size = window.innerWidth * 0.15;\n\n\t\t\t\tdirLightShadowMapViewer.position.x = 10;\n\t\t\t\tdirLightShadowMapViewer.position.y = 10;\n\t\t\t\tdirLightShadowMapViewer.size.width = size;\n\t\t\t\tdirLightShadowMapViewer.size.height = size;\n\t\t\t\tdirLightShadowMapViewer.update(); //Required when setting position or size directly\n\n\t\t\t\tspotLightShadowMapViewer.size.set( size, size );\n\t\t\t\tspotLightShadowMapViewer.position.set( size + 20, 10 );\n\t\t\t\t// spotLightShadowMapViewer.update();\t//NOT required because .set updates automatically\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tresizeShadowMapViewers();\n\t\t\t\tdirLightShadowMapViewer.updateForWindowResize();\n\t\t\t\tspotLightShadowMapViewer.updateForWindowResize();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction renderScene() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction renderShadowMapViewers() {\n\n\t\t\t\tdirLightShadowMapViewer.render( renderer );\n\t\t\t\tspotLightShadowMapViewer.render( renderer );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\trenderScene();\n\t\t\t\trenderShadowMapViewers();\n\n\t\t\t\ttorusKnot.rotation.x += 0.25 * delta;\n\t\t\t\ttorusKnot.rotation.y += 2 * delta;\n\t\t\t\ttorusKnot.rotation.z += 1 * delta;\n\n\t\t\t\tcube.rotation.x += 0.25 * delta;\n\t\t\t\tcube.rotation.y += 2 * delta;\n\t\t\t\tcube.rotation.z += 1 * delta;\n\n\t\t\t}\n```\n\nThis example three.js - ShadowMapViewer example by arya-s"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - VSM Shadows example"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - VSM Shadows example:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, clock, stats;\n\t\t\tlet dirLight, spotLight;\n\t\t\tlet torusKnot, dirGroup;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitScene();\n\t\t\t\tinitMisc();\n\n\t\t\t\t// Init gui\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst config = {\n\t\t\t\t\tspotlightRadius: 4,\n\t\t\t\t\tspotlightSamples: 8,\n\t\t\t\t\tdirlightRadius: 4,\n\t\t\t\t\tdirlightSamples: 8\n\t\t\t\t};\n\n\t\t\t\tconst spotlightFolder = gui.addFolder( 'Spotlight' );\n\t\t\t\tspotlightFolder.add( config, 'spotlightRadius' ).name( 'radius' ).min( 0 ).max( 25 ).onChange( function ( value ) {\n\n\t\t\t\t\tspotLight.shadow.radius = value;\n\n\t\t\t\t} );\n\n\t\t\t\tspotlightFolder.add( config, 'spotlightSamples', 1, 25, 1 ).name( 'samples' ).onChange( function ( value ) {\n\n\t\t\t\t\tspotLight.shadow.blurSamples = value;\n\n\t\t\t\t} );\n\t\t\t\tspotlightFolder.open();\n\n\t\t\t\tconst dirlightFolder = gui.addFolder( 'Directional Light' );\n\t\t\t\tdirlightFolder.add( config, 'dirlightRadius' ).name( 'radius' ).min( 0 ).max( 25 ).onChange( function ( value ) {\n\n\t\t\t\t\tdirLight.shadow.radius = value;\n\n\t\t\t\t} );\n\n\t\t\t\tdirlightFolder.add( config, 'dirlightSamples', 1, 25, 1 ).name( 'samples' ).onChange( function ( value ) {\n\n\t\t\t\t\tdirLight.shadow.blurSamples = value;\n\n\t\t\t\t} );\n\t\t\t\tdirlightFolder.open();\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initScene() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 10, 30 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222244 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x222244, 50, 100 );\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x444444 ) );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xff8888, 400 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.3;\n\t\t\t\tspotLight.position.set( 8, 10, 5 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 8;\n\t\t\t\tspotLight.shadow.camera.far = 200;\n\t\t\t\tspotLight.shadow.mapSize.width = 256;\n\t\t\t\tspotLight.shadow.mapSize.height = 256;\n\t\t\t\tspotLight.shadow.bias = - 0.002;\n\t\t\t\tspotLight.shadow.radius = 4;\n\t\t\t\tscene.add( spotLight );\n\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0x8888ff, 3 );\n\t\t\t\tdirLight.position.set( 3, 12, 17 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 500;\n\t\t\t\tdirLight.shadow.camera.right = 17;\n\t\t\t\tdirLight.shadow.camera.left = - 17;\n\t\t\t\tdirLight.shadow.camera.top\t= 17;\n\t\t\t\tdirLight.shadow.camera.bottom = - 17;\n\t\t\t\tdirLight.shadow.mapSize.width = 512;\n\t\t\t\tdirLight.shadow.mapSize.height = 512;\n\t\t\t\tdirLight.shadow.radius = 4;\n\t\t\t\tdirLight.shadow.bias = - 0.0005;\n\n\t\t\t\tdirGroup = new THREE.Group();\n\t\t\t\tdirGroup.add( dirLight );\n\t\t\t\tscene.add( dirGroup );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 25, 8, 75, 20 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x999999,\n\t\t\t\t\tshininess: 0,\n\t\t\t\t\tspecular: 0x222222\n\t\t\t\t} );\n\n\t\t\t\ttorusKnot = new THREE.Mesh( geometry, material );\n\t\t\t\ttorusKnot.scale.multiplyScalar( 1 / 18 );\n\t\t\t\ttorusKnot.position.y = 3;\n\t\t\t\ttorusKnot.castShadow = true;\n\t\t\t\ttorusKnot.receiveShadow = true;\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 0.75, 0.75, 7, 32 );\n\n\t\t\t\tconst pillar1 = new THREE.Mesh( cylinderGeometry, material );\n\t\t\t\tpillar1.position.set( 8, 3.5, 8 );\n\t\t\t\tpillar1.castShadow = true;\n\t\t\t\tpillar1.receiveShadow = true;\n\n\t\t\t\tconst pillar2 = pillar1.clone();\n\t\t\t\tpillar2.position.set( 8, 3.5, - 8 );\n\t\t\t\tconst pillar3 = pillar1.clone();\n\t\t\t\tpillar3.position.set( - 8, 3.5, 8 );\n\t\t\t\tconst pillar4 = pillar1.clone();\n\t\t\t\tpillar4.position.set( - 8, 3.5, - 8 );\n\n\t\t\t\tscene.add( pillar1 );\n\t\t\t\tscene.add( pillar2 );\n\t\t\t\tscene.add( pillar3 );\n\t\t\t\tscene.add( pillar4 );\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x999999,\n\t\t\t\t\tshininess: 0,\n\t\t\t\t\tspecular: 0x111111\n\t\t\t\t} );\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.multiplyScalar( 3 );\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t}\n\n\t\t\tfunction initMisc() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\n\t\t\t\t// Mouse control\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate( time ) {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\ttorusKnot.rotation.x += 0.25 * delta;\n\t\t\t\ttorusKnot.rotation.y += 0.5 * delta;\n\t\t\t\ttorusKnot.rotation.z += 1 * delta;\n\n\t\t\t\tdirGroup.rotation.y += 0.7 * delta;\n\t\t\t\tdirLight.position.z = 17 + Math.sin( time * 0.001 ) * 5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - VSM Shadows example by Paul Brunt"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - ShadowMesh"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - ShadowMesh:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { ShadowMesh } from 'three/addons/objects/ShadowMesh.js';\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tconst camera = new THREE.PerspectiveCamera( 55, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 3000 );\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst renderer = new THREE.WebGLRenderer( { stencil: true } );\n\n\t\t\tconst sunLight = new THREE.DirectionalLight( 'rgb(255,255,255)', 3 );\n\t\t\tlet useDirectionalLight = true;\n\t\t\tlet arrowHelper1, arrowHelper2, arrowHelper3;\n\t\t\tconst arrowDirection = new THREE.Vector3();\n\t\t\tconst arrowPosition1 = new THREE.Vector3();\n\t\t\tconst arrowPosition2 = new THREE.Vector3();\n\t\t\tconst arrowPosition3 = new THREE.Vector3();\n\t\t\tlet groundMesh;\n\t\t\tlet lightSphere, lightHolder;\n\t\t\tlet pyramid, pyramidShadow;\n\t\t\tlet sphere, sphereShadow;\n\t\t\tlet cube, cubeShadow;\n\t\t\tlet cylinder, cylinderShadow;\n\t\t\tlet torus, torusShadow;\n\t\t\tconst normalVector = new THREE.Vector3( 0, 1, 0 );\n\t\t\tconst planeConstant = 0.01; // this value must be slightly higher than the groundMesh's y position of 0.0\n\t\t\tconst groundPlane = new THREE.Plane( normalVector, planeConstant );\n\t\t\tconst lightPosition4D = new THREE.Vector4();\n\t\t\tlet verticalAngle = 0;\n\t\t\tlet horizontalAngle = 0;\n\t\t\tlet frameTime = 0;\n\t\t\tconst TWO_PI = Math.PI * 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene.background = new THREE.Color( 0x0096ff );\n\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.getElementById( 'container' ).appendChild( renderer.domElement );\n\t\t\t\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tcamera.position.set( 0, 2.5, 10 );\n\t\t\t\tscene.add( camera );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tsunLight.position.set( 5, 7, - 1 );\n\t\t\t\tsunLight.lookAt( scene.position );\n\t\t\t\tscene.add( sunLight );\n\n\t\t\t\tlightPosition4D.x = sunLight.position.x;\n\t\t\t\tlightPosition4D.y = sunLight.position.y;\n\t\t\t\tlightPosition4D.z = sunLight.position.z;\n\t\t\t\t// amount of light-ray divergence. Ranging from:\n\t\t\t\t// 0.001 = sunlight(min divergence) to 1.0 = pointlight(max divergence)\n\t\t\t\tlightPosition4D.w = 0.001; // must be slightly greater than 0, due to 0 causing matrixInverse errors\n\n\t\t\t\t// YELLOW ARROW HELPERS\n\t\t\t\tarrowDirection.subVectors( scene.position, sunLight.position ).normalize();\n\n\t\t\t\tarrowPosition1.copy( sunLight.position );\n\t\t\t\tarrowHelper1 = new THREE.ArrowHelper( arrowDirection, arrowPosition1, 0.9, 0xffff00, 0.25, 0.08 );\n\t\t\t\tscene.add( arrowHelper1 );\n\n\t\t\t\tarrowPosition2.copy( sunLight.position ).add( new THREE.Vector3( 0, 0.2, 0 ) );\n\t\t\t\tarrowHelper2 = new THREE.ArrowHelper( arrowDirection, arrowPosition2, 0.9, 0xffff00, 0.25, 0.08 );\n\t\t\t\tscene.add( arrowHelper2 );\n\n\t\t\t\tarrowPosition3.copy( sunLight.position ).add( new THREE.Vector3( 0, - 0.2, 0 ) );\n\t\t\t\tarrowHelper3 = new THREE.ArrowHelper( arrowDirection, arrowPosition3, 0.9, 0xffff00, 0.25, 0.08 );\n\t\t\t\tscene.add( arrowHelper3 );\n\n\t\t\t\t// LIGHTBULB\n\t\t\t\tconst lightSphereGeometry = new THREE.SphereGeometry( 0.09 );\n\t\t\t\tconst lightSphereMaterial = new THREE.MeshBasicMaterial( { color: 'rgb(255,255,255)' } );\n\t\t\t\tlightSphere = new THREE.Mesh( lightSphereGeometry, lightSphereMaterial );\n\t\t\t\tscene.add( lightSphere );\n\t\t\t\tlightSphere.visible = false;\n\n\t\t\t\tconst lightHolderGeometry = new THREE.CylinderGeometry( 0.05, 0.05, 0.13 );\n\t\t\t\tconst lightHolderMaterial = new THREE.MeshBasicMaterial( { color: 'rgb(75,75,75)' } );\n\t\t\t\tlightHolder = new THREE.Mesh( lightHolderGeometry, lightHolderMaterial );\n\t\t\t\tscene.add( lightHolder );\n\t\t\t\tlightHolder.visible = false;\n\n\t\t\t\t// GROUND\n\t\t\t\tconst groundGeometry = new THREE.BoxGeometry( 30, 0.01, 40 );\n\t\t\t\tconst groundMaterial = new THREE.MeshLambertMaterial( { color: 'rgb(0,130,0)' } );\n\t\t\t\tgroundMesh = new THREE.Mesh( groundGeometry, groundMaterial );\n\t\t\t\tgroundMesh.position.y = 0.0; //this value must be slightly lower than the planeConstant (0.01) parameter above\n\t\t\t\tscene.add( groundMesh );\n\n\t\t\t\t// RED CUBE and CUBE's SHADOW\n\t\t\t\tconst cubeGeometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\tconst cubeMaterial = new THREE.MeshLambertMaterial( { color: 'rgb(255,0,0)', emissive: 0x200000 } );\n\t\t\t\tcube = new THREE.Mesh( cubeGeometry, cubeMaterial );\n\t\t\t\tcube.position.z = - 1;\n\t\t\t\tscene.add( cube );\n\n\t\t\t\tcubeShadow = new ShadowMesh( cube );\n\t\t\t\tscene.add( cubeShadow );\n\n\t\t\t\t// BLUE CYLINDER and CYLINDER's SHADOW\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 0.3, 0.3, 2 );\n\t\t\t\tconst cylinderMaterial = new THREE.MeshPhongMaterial( { color: 'rgb(0,0,255)', emissive: 0x000020 } );\n\t\t\t\tcylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );\n\t\t\t\tcylinder.position.z = - 2.5;\n\t\t\t\tscene.add( cylinder );\n\n\t\t\t\tcylinderShadow = new ShadowMesh( cylinder );\n\t\t\t\tscene.add( cylinderShadow );\n\n\t\t\t\t// MAGENTA TORUS and TORUS' SHADOW\n\t\t\t\tconst torusGeometry = new THREE.TorusGeometry( 1, 0.2, 10, 16, TWO_PI );\n\t\t\t\tconst torusMaterial = new THREE.MeshPhongMaterial( { color: 'rgb(255,0,255)', emissive: 0x200020 } );\n\t\t\t\ttorus = new THREE.Mesh( torusGeometry, torusMaterial );\n\t\t\t\ttorus.position.z = - 6;\n\t\t\t\tscene.add( torus );\n\n\t\t\t\ttorusShadow = new ShadowMesh( torus );\n\t\t\t\tscene.add( torusShadow );\n\n\t\t\t\t// WHITE SPHERE and SPHERE'S SHADOW\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.5, 20, 10 );\n\t\t\t\tconst sphereMaterial = new THREE.MeshPhongMaterial( { color: 'rgb(255,255,255)', emissive: 0x222222 } );\n\t\t\t\tsphere = new THREE.Mesh( sphereGeometry, sphereMaterial );\n\t\t\t\tsphere.position.set( 4, 0.5, 2 );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\tsphereShadow = new ShadowMesh( sphere );\n\t\t\t\tscene.add( sphereShadow );\n\n\t\t\t\t// YELLOW PYRAMID and PYRAMID'S SHADOW\n\t\t\t\tconst pyramidGeometry = new THREE.CylinderGeometry( 0, 0.5, 2, 4 );\n\t\t\t\tconst pyramidMaterial = new THREE.MeshPhongMaterial( { color: 'rgb(255,255,0)', emissive: 0x440000, flatShading: true, shininess: 0 } );\n\t\t\t\tpyramid = new THREE.Mesh( pyramidGeometry, pyramidMaterial );\n\t\t\t\tpyramid.position.set( - 4, 1, 2 );\n\t\t\t\tscene.add( pyramid );\n\n\t\t\t\tpyramidShadow = new ShadowMesh( pyramid );\n\t\t\t\tscene.add( pyramidShadow );\n\n\t\t\t\tdocument.getElementById( 'lightButton' ).addEventListener( 'click', lightButtonHandler );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tframeTime = clock.getDelta();\n\n\t\t\t\tcube.rotation.x += 1.0 * frameTime;\n\t\t\t\tcube.rotation.y += 1.0 * frameTime;\n\n\t\t\t\tcylinder.rotation.y += 1.0 * frameTime;\n\t\t\t\tcylinder.rotation.z -= 1.0 * frameTime;\n\n\t\t\t\ttorus.rotation.x -= 1.0 * frameTime;\n\t\t\t\ttorus.rotation.y -= 1.0 * frameTime;\n\n\t\t\t\tpyramid.rotation.y += 0.5 * frameTime;\n\n\t\t\t\thorizontalAngle += 0.5 * frameTime;\n\t\t\t\tif ( horizontalAngle > TWO_PI )\n\t\t\t\t\thorizontalAngle -= TWO_PI;\n\t\t\t\tcube.position.x = Math.sin( horizontalAngle ) * 4;\n\t\t\t\tcylinder.position.x = Math.sin( horizontalAngle ) * - 4;\n\t\t\t\ttorus.position.x = Math.cos( horizontalAngle ) * 4;\n\n\t\t\t\tverticalAngle += 1.5 * frameTime;\n\t\t\t\tif ( verticalAngle > TWO_PI )\n\t\t\t\t\tverticalAngle -= TWO_PI;\n\t\t\t\tcube.position.y = Math.sin( verticalAngle ) * 2 + 2.9;\n\t\t\t\tcylinder.position.y = Math.sin( verticalAngle ) * 2 + 3.1;\n\t\t\t\ttorus.position.y = Math.cos( verticalAngle ) * 2 + 3.3;\n\n\t\t\t\t// update the ShadowMeshes to follow their shadow-casting objects\n\t\t\t\tcubeShadow.update( groundPlane, lightPosition4D );\n\t\t\t\tcylinderShadow.update( groundPlane, lightPosition4D );\n\t\t\t\ttorusShadow.update( groundPlane, lightPosition4D );\n\t\t\t\tsphereShadow.update( groundPlane, lightPosition4D );\n\t\t\t\tpyramidShadow.update( groundPlane, lightPosition4D );\n\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction lightButtonHandler() {\n\n\t\t\t\tuseDirectionalLight = ! useDirectionalLight;\n\n\t\t\t\tif ( useDirectionalLight ) {\n\n\t\t\t\t\tscene.background.setHex( 0x0096ff );\n\n\t\t\t\t\tgroundMesh.material.color.setHex( 0x008200 );\n\t\t\t\t\tsunLight.position.set( 5, 7, - 1 );\n\t\t\t\t\tsunLight.lookAt( scene.position );\n\n\t\t\t\t\tlightPosition4D.x = sunLight.position.x;\n\t\t\t\t\tlightPosition4D.y = sunLight.position.y;\n\t\t\t\t\tlightPosition4D.z = sunLight.position.z;\n\t\t\t\t\tlightPosition4D.w = 0.001; // more of a directional Light value\n\n\t\t\t\t\tarrowHelper1.visible = true;\n\t\t\t\t\tarrowHelper2.visible = true;\n\t\t\t\t\tarrowHelper3.visible = true;\n\n\t\t\t\t\tlightSphere.visible = false;\n\t\t\t\t\tlightHolder.visible = false;\n\n\t\t\t\t\tdocument.getElementById( 'lightButton' ).value = 'Switch to PointLight';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.background.setHex( 0x000000 );\n\n\t\t\t\t\tgroundMesh.material.color.setHex( 0x969696 );\n\n\t\t\t\t\tsunLight.position.set( 0, 6, - 2 );\n\t\t\t\t\tsunLight.lookAt( scene.position );\n\t\t\t\t\tlightSphere.position.copy( sunLight.position );\n\t\t\t\t\tlightHolder.position.copy( lightSphere.position );\n\t\t\t\t\tlightHolder.position.y += 0.12;\n\n\t\t\t\t\tlightPosition4D.x = sunLight.position.x;\n\t\t\t\t\tlightPosition4D.y = sunLight.position.y;\n\t\t\t\t\tlightPosition4D.z = sunLight.position.z;\n\t\t\t\t\tlightPosition4D.w = 0.9; // more of a point Light value\n\n\t\t\t\t\tarrowHelper1.visible = false;\n\t\t\t\t\tarrowHelper2.visible = false;\n\t\t\t\t\tarrowHelper3.visible = false;\n\n\t\t\t\t\tlightSphere.visible = true;\n\t\t\t\t\tlightHolder.visible = true;\n\n\t\t\t\t\tdocument.getElementById( 'lightButton' ).value = 'Switch to THREE.DirectionalLight';\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - shadow mesh"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - sprites"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - sprites:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet cameraOrtho, sceneOrtho;\n\n\t\t\tlet spriteTL, spriteTR, spriteBL, spriteBR, spriteC;\n\n\t\t\tlet mapC;\n\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, width / height, 1, 2100 );\n\t\t\t\tcamera.position.z = 1500;\n\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 10 );\n\t\t\t\tcameraOrtho.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1500, 2100 );\n\n\t\t\t\tsceneOrtho = new THREE.Scene();\n\n\t\t\t\t// create sprites\n\n\t\t\t\tconst amount = 200;\n\t\t\t\tconst radius = 500;\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\ttextureLoader.load( 'textures/sprite0.png', createHUDSprites );\n\t\t\t\tconst mapB = textureLoader.load( 'textures/sprite1.png' );\n\t\t\t\tmapC = textureLoader.load( 'textures/sprite2.png' );\n\n\t\t\t\tmapB.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tmapC.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tgroup = new THREE.Group();\n\n\t\t\t\tconst materialC = new THREE.SpriteMaterial( { map: mapC, color: 0xffffff, fog: true } );\n\t\t\t\tconst materialB = new THREE.SpriteMaterial( { map: mapB, color: 0xffffff, fog: true } );\n\n\t\t\t\tfor ( let a = 0; a < amount; a ++ ) {\n\n\t\t\t\t\tconst x = Math.random() - 0.5;\n\t\t\t\t\tconst y = Math.random() - 0.5;\n\t\t\t\t\tconst z = Math.random() - 0.5;\n\n\t\t\t\t\tlet material;\n\n\t\t\t\t\tif ( z < 0 ) {\n\n\t\t\t\t\t\tmaterial = materialB.clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial = materialC.clone();\n\t\t\t\t\t\tmaterial.color.setHSL( 0.5 * Math.random(), 0.75, 0.5 );\n\t\t\t\t\t\tmaterial.map.offset.set( - 0.5, - 0.5 );\n\t\t\t\t\t\tmaterial.map.repeat.set( 2, 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst sprite = new THREE.Sprite( material );\n\n\t\t\t\t\tsprite.position.set( x, y, z );\n\t\t\t\t\tsprite.position.normalize();\n\t\t\t\t\tsprite.position.multiplyScalar( radius );\n\n\t\t\t\t\tgroup.add( sprite );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false; // To allow render overlay on top of sprited sphere\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createHUDSprites( texture ) {\n\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material = new THREE.SpriteMaterial( { map: texture } );\n\n\t\t\t\tconst width = material.map.image.width;\n\t\t\t\tconst height = material.map.image.height;\n\n\t\t\t\tspriteTL = new THREE.Sprite( material );\n\t\t\t\tspriteTL.center.set( 0.0, 1.0 );\n\t\t\t\tspriteTL.scale.set( width, height, 1 );\n\t\t\t\tsceneOrtho.add( spriteTL );\n\n\t\t\t\tspriteTR = new THREE.Sprite( material );\n\t\t\t\tspriteTR.center.set( 1.0, 1.0 );\n\t\t\t\tspriteTR.scale.set( width, height, 1 );\n\t\t\t\tsceneOrtho.add( spriteTR );\n\n\t\t\t\tspriteBL = new THREE.Sprite( material );\n\t\t\t\tspriteBL.center.set( 0.0, 0.0 );\n\t\t\t\tspriteBL.scale.set( width, height, 1 );\n\t\t\t\tsceneOrtho.add( spriteBL );\n\n\t\t\t\tspriteBR = new THREE.Sprite( material );\n\t\t\t\tspriteBR.center.set( 1.0, 0.0 );\n\t\t\t\tspriteBR.scale.set( width, height, 1 );\n\t\t\t\tsceneOrtho.add( spriteBR );\n\n\t\t\t\tspriteC = new THREE.Sprite( material );\n\t\t\t\tspriteC.center.set( 0.5, 0.5 );\n\t\t\t\tspriteC.scale.set( width, height, 1 );\n\t\t\t\tsceneOrtho.add( spriteC );\n\n\t\t\t\tupdateHUDSprites();\n\n\t\t\t}\n\n\t\t\tfunction updateHUDSprites() {\n\n\t\t\t\tconst width = window.innerWidth / 2;\n\t\t\t\tconst height = window.innerHeight / 2;\n\n\t\t\t\tspriteTL.position.set( - width, height, 1 ); // top left\n\t\t\t\tspriteTR.position.set( width, height, 1 ); // top right\n\t\t\t\tspriteBL.position.set( - width, - height, 1 ); // bottom left\n\t\t\t\tspriteBR.position.set( width, - height, 1 ); // bottom right\n\t\t\t\tspriteC.position.set( 0, 0, 1 ); // center\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = - width / 2;\n\t\t\t\tcameraOrtho.right = width / 2;\n\t\t\t\tcameraOrtho.top = height / 2;\n\t\t\t\tcameraOrtho.bottom = - height / 2;\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\tupdateHUDSprites();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() / 1000;\n\n\t\t\t\tfor ( let i = 0, l = group.children.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst sprite = group.children[ i ];\n\t\t\t\t\tconst material = sprite.material;\n\t\t\t\t\tconst scale = Math.sin( time + sprite.position.x * 0.01 ) * 0.3 + 1.0;\n\n\t\t\t\t\tlet imageWidth = 1;\n\t\t\t\t\tlet imageHeight = 1;\n\n\t\t\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\n\n\t\t\t\t\t\timageWidth = material.map.image.width;\n\t\t\t\t\t\timageHeight = material.map.image.height;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsprite.material.rotation += 0.1 * ( i / l );\n\t\t\t\t\tsprite.scale.set( scale * imageWidth, scale * imageHeight, 1.0 );\n\n\t\t\t\t\tif ( material.map !== mapC ) {\n\n\t\t\t\t\t\tmaterial.opacity = Math.sin( time + sprite.position.x * 0.01 ) * 0.4 + 0.6;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgroup.rotation.x = time * 0.5;\n\t\t\t\tgroup.rotation.y = time * 0.75;\n\t\t\t\tgroup.rotation.z = time * 1.0;\n\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer.clearDepth();\n\t\t\t\trenderer.render( sceneOrtho, cameraOrtho );\n\n\t\t\t}\n```\n\nThis example three.js - sprites"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates - webgl memory test I"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - webgl memory test I:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 200;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\tfunction createImage() {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 256;\n\t\t\t\tcanvas.height = 256;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'rgb(' + Math.floor( Math.random() * 256 ) + ',' + Math.floor( Math.random() * 256 ) + ',' + Math.floor( Math.random() * 256 ) + ')';\n\t\t\t\tcontext.fillRect( 0, 0, 256, 256 );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 50, Math.random() * 64, Math.random() * 32 );\n\n\t\t\t\tconst texture = new THREE.CanvasTexture( createImage() );\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture, wireframe: true } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tscene.remove( mesh );\n\n\t\t\t\t// clean up\n\n\t\t\t\tgeometry.dispose();\n\t\t\t\tmaterial.dispose();\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n```\n\nThis example three.js - memory test I"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates - webgl memory test II"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - webgl memory test II:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tconst N = 100;\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet geometry;\n\n\t\t\tconst meshes = [];\n\n\t\t\tlet fragmentShader, vertexShader;\n\n\t\t\tinit();\n\t\t\tsetInterval( render, 1000 / 60 );\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tvertexShader = document.getElementById( 'vertexShader' ).textContent;\n\t\t\t\tfragmentShader = document.getElementById( 'fragmentShader' ).textContent;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 2000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tgeometry = new THREE.SphereGeometry( 15, 64, 32 );\n\n\t\t\t\tfor ( let i = 0; i < N; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: generateFragmentShader() } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = ( 0.5 - Math.random() ) * 1000;\n\t\t\t\t\tmesh.position.y = ( 0.5 - Math.random() ) * 1000;\n\t\t\t\t\tmesh.position.z = ( 0.5 - Math.random() ) * 1000;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction generateFragmentShader() {\n\n\t\t\t\treturn fragmentShader.replace( 'XXX', Math.random() + ',' + Math.random() + ',' + Math.random() );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tfor ( let i = 0; i < N; i ++ ) {\n\n\t\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\t\tmesh.material = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: generateFragmentShader() } );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tconsole.log( 'before', renderer.info.programs.length );\n\n\t\t\t\tfor ( let i = 0; i < N; i ++ ) {\n\n\t\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\t\tmesh.material.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tconsole.log( 'after', renderer.info.programs.length );\n\n\t\t\t}\n```\n\nThis example three.js - memory test II"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - test - wide gamut"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - test - wide gamut:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { DisplayP3ColorSpace, DisplayP3ColorSpaceImpl, LinearDisplayP3ColorSpace, LinearDisplayP3ColorSpaceImpl } from 'three/addons/math/ColorSpaces.js';\n\n\t\t\timport WebGL from 'three/addons/capabilities/WebGL.js';\n\n\t\t\tlet container, camera, renderer, loader;\n\t\t\tlet sceneL, sceneR, textureL, textureR;\n\n\t\t\tlet sliderPos = window.innerWidth / 2;\n\n\t\t\tconst slider = document.querySelector( '.slider' );\n\n\t\t\tconst isP3Context = WebGL.isColorSpaceAvailable( DisplayP3ColorSpace );\n\n\t\t\tTHREE.ColorManagement.define( {\n\n\t\t\t\t[ DisplayP3ColorSpace ]: DisplayP3ColorSpaceImpl,\n\t\t\t\t[ LinearDisplayP3ColorSpace ]: LinearDisplayP3ColorSpaceImpl\n\n\t\t\t} );\n\n\t\t\tif ( isP3Context ) {\n\n\t\t\t\tTHREE.ColorManagement.workingColorSpace = LinearDisplayP3ColorSpace;\n\n\t\t\t}\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.querySelector( '.container' );\n\n\t\t\t\tsceneL = new THREE.Scene();\n\t\t\t\tsceneR = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 6;\n\n\t\t\t\tloader = new THREE.TextureLoader();\n\n\t\t\t\tinitTextures();\n\t\t\t\tinitSlider();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setScissorTest( true );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tif ( isP3Context && window.matchMedia( '( color-gamut: p3 )' ).matches ) {\n\n\t\t\t\t\trenderer.outputColorSpace = DisplayP3ColorSpace;\n\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.matchMedia( '( color-gamut: p3 )' ).addEventListener( 'change', onGamutChange );\n\n\t\t\t}\n\n\t\t\tasync function initTextures() {\n\n\t\t\t\tconst path = 'textures/wide_gamut/logo_{colorSpace}.png';\n\n\t\t\t\ttextureL = await loader.loadAsync( path.replace( '{colorSpace}', 'srgb' ) );\n\t\t\t\ttextureR = await loader.loadAsync( path.replace( '{colorSpace}', 'p3' ) );\n\n\t\t\t\ttextureL.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttextureR.colorSpace = DisplayP3ColorSpace;\n\n\t\t\t\tsceneL.background = THREE.TextureUtils.contain( textureL, window.innerWidth / window.innerHeight );\n\t\t\t\tsceneR.background = THREE.TextureUtils.contain( textureR, window.innerWidth / window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction initSlider() {\n\n\t\t\t\tfunction onPointerDown() {\n\n\t\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\t\twindow.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\twindow.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t}\n\n\t\t\t\tfunction onPointerUp() {\n\n\t\t\t\t\twindow.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\twindow.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t}\n\n\t\t\t\tfunction onPointerMove( e ) {\n\n\t\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\t\tupdateSlider( e.pageX );\n\n\t\t\t\t}\n\n\t\t\t\tupdateSlider( sliderPos );\n\n\t\t\t\tslider.style.touchAction = 'none'; // disable touch scroll\n\t\t\t\tslider.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t}\n\n\t\t\tfunction updateSlider( offset ) {\n\n\t\t\t\tsliderPos = Math.max( 10, Math.min( window.innerWidth - 10, offset ) );\n\n\t\t\t\tslider.style.left = sliderPos - ( slider.offsetWidth / 2 ) + 'px';\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tTHREE.TextureUtils.contain( sceneL.background, window.innerWidth / window.innerHeight );\n\t\t\t\tTHREE.TextureUtils.contain( sceneR.background, window.innerWidth / window.innerHeight );\n\n\t\t\t\tupdateSlider( sliderPos );\n\n\t\t\t}\n\n\t\t\tfunction onGamutChange( { matches } ) {\n\n\t\t\t\trenderer.outputColorSpace = isP3Context && matches ? DisplayP3ColorSpace : THREE.SRGBColorSpace;\n\n\t\t\t\ttextureL.needsUpdate = true;\n\t\t\t\ttextureR.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.setScissor( 0, 0, sliderPos, window.innerHeight );\n\t\t\t\trenderer.render( sceneL, camera );\n\n\t\t\t\trenderer.setScissor( sliderPos, 0, window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.render( sceneR, camera );\n\n\t\t\t}\n```\n\nThis example three.js - wide gamut test"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - tone mapping"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - tone mapping:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\t\t\tlet gui, guiExposure = null;\n\n\t\t\tconst params = {\n\t\t\t\texposure: 1.0,\n\t\t\t\ttoneMapping: 'Neutral',\n\t\t\t\tblurriness: 0.3,\n\t\t\t\tintensity: 1.0,\n\t\t\t};\n\n\t\t\tconst toneMappingOptions = {\n\t\t\t\tNone: THREE.NoToneMapping,\n\t\t\t\tLinear: THREE.LinearToneMapping,\n\t\t\t\tReinhard: THREE.ReinhardToneMapping,\n\t\t\t\tCineon: THREE.CineonToneMapping,\n\t\t\t\tACESFilmic: THREE.ACESFilmicToneMapping,\n\t\t\t\tAgX: THREE.AgXToneMapping,\n\t\t\t\tNeutral: THREE.NeutralToneMapping,\n\t\t\t\tCustom: THREE.CustomToneMapping\n\t\t\t};\n\n\t\t\tinit().catch( function ( err ) {\n\n\t\t\t\tconsole.error( err );\n\n\t\t\t} );\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = toneMappingOptions[ params.toneMapping ];\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\t// Set CustomToneMapping to Uncharted2\n\t\t\t\t// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\n\t\t\t\tTHREE.ShaderChunk.tonemapping_pars_fragment = THREE.ShaderChunk.tonemapping_pars_fragment.replace(\n\n\t\t\t\t\t'vec3 CustomToneMapping( vec3 color ) { return color; }',\n\n\t\t\t\t\t`#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\n\n\t\t\t\t\tfloat toneMappingWhitePoint = 1.0;\n\n\t\t\t\t\tvec3 CustomToneMapping( vec3 color ) {\n\t\t\t\t\t\tcolor *= toneMappingExposure;\n\t\t\t\t\t\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n\t\t\t\t\t}`\n\n\t\t\t\t);\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundBlurriness = params.blurriness;\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xfff3ee, 3 ); // simualte sun\n\t\t\t\tlight.position.set( 1, 0.05, 0.7 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// scene.add( new THREE.DirectionalLightHelper( light, 1, 0x000000 ) );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( - 0.02, 0.03, 0.05 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.03;\n\t\t\t\tcontrols.maxDistance = 0.2;\n\t\t\t\tcontrols.target.set( 0, 0.03, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\t\t\t\tgltfLoader.setPath( 'models/gltf/' );\n\n\t\t\t\tconst [ texture, gltf ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'venice_sunset_1k.hdr' ),\n\t\t\t\t\tgltfLoader.loadAsync( 'venice_mask.glb' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tconst toneMappingFolder = gui.addFolder( 'Tone Mapping' );\n\n\t\t\t\ttoneMappingFolder.add( params, 'toneMapping', Object.keys( toneMappingOptions ) )\n\n\t\t\t\t\t.name( 'type' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tupdateGUI( toneMappingFolder );\n\n\t\t\t\t\t\trenderer.toneMapping = toneMappingOptions[ params.toneMapping ];\n\n\t\t\t\t\t} );\n\n\t\t\t\tguiExposure = toneMappingFolder.add( params, 'exposure', 0, 2 )\n\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst backgroundFolder = gui.addFolder( 'Background' );\n\n\t\t\t\tbackgroundFolder.add( params, 'blurriness', 0, 1 )\n\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\tscene.backgroundBlurriness = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tbackgroundFolder.add( params, 'intensity', 0, 1 )\n\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\tscene.backgroundIntensity = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tupdateGUI( toneMappingFolder );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction updateGUI() {\n\n\t\t\t\tif ( params.toneMapping === 'None' ) {\n\n\t\t\t\t\tguiExposure.hide();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tguiExposure.show();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Tone Mapping Venice Mask by DailyArt is licensed under CC Attribution-NonCommercial Venice Sunset from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates - kinect"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - kinect:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, renderer;\n\t\t\tlet geometry, mesh, material;\n\t\t\tlet mouse, center;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst info = document.createElement( 'div' );\n\t\t\t\tinfo.id = 'info';\n\t\t\t\tinfo.innerHTML = '<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - kinect';\n\t\t\t\tdocument.body.appendChild( info );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 0, 0, 500 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tcenter = new THREE.Vector3();\n\t\t\t\tcenter.z = - 1000;\n\n\t\t\t\tconst video = document.getElementById( 'video' );\n\n\t\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\tconst width = 640, height = 480;\n\t\t\t\tconst nearClipping = 850, farClipping = 4000;\n\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst vertices = new Float32Array( width * height * 3 );\n\n\t\t\t\tfor ( let i = 0, j = 0, l = vertices.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\t\tvertices[ i ] = j % width;\n\t\t\t\t\tvertices[ i + 1 ] = Math.floor( j / width );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\n\t\t\t\t\t\t'map': { value: texture },\n\t\t\t\t\t\t'width': { value: width },\n\t\t\t\t\t\t'height': { value: height },\n\t\t\t\t\t\t'nearClipping': { value: nearClipping },\n\t\t\t\t\t\t'farClipping': { value: farClipping },\n\n\t\t\t\t\t\t'pointSize': { value: 2 },\n\t\t\t\t\t\t'zOffset': { value: 1000 }\n\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vs' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fs' ).textContent,\n\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\tdepthTest: false, depthWrite: false,\n\t\t\t\t\ttransparent: true\n\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( material.uniforms.nearClipping, 'value', 1, 10000, 1.0 ).name( 'nearClipping' );\n\t\t\t\tgui.add( material.uniforms.farClipping, 'value', 1, 10000, 1.0 ).name( 'farClipping' );\n\t\t\t\tgui.add( material.uniforms.pointSize, 'value', 1, 10, 1.0 ).name( 'pointSize' );\n\t\t\t\tgui.add( material.uniforms.zOffset, 'value', 0, 4000, 1.0 ).name( 'zOffset' );\n\n\t\t\t\tvideo.play();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tmouse = new THREE.Vector3( 0, 0, 1 );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouse.x = ( event.clientX - window.innerWidth / 2 ) * 8;\n\t\t\t\tmouse.y = ( event.clientY - window.innerHeight / 2 ) * 8;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcamera.position.x += ( mouse.x - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouse.y - camera.position.y ) * 0.05;\n\t\t\t\tcamera.lookAt( center );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - equirectangular video panorama"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - equirectangular video panorama:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet isUserInteracting = false,\n\t\t\t\tlon = 0, lat = 0,\n\t\t\t\tphi = 0, theta = 0,\n\t\t\t\tonPointerDownPointerX = 0,\n\t\t\t\tonPointerDownPointerY = 0,\n\t\t\t\tonPointerDownLon = 0,\n\t\t\t\tonPointerDownLat = 0;\n\n\t\t\tconst distance = .5;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .25, 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 5, 60, 40 );\n\t\t\t\t// invert the geometry on the x-axis so that all of the faces point inward\n\t\t\t\tgeometry.scale( - 1, 1, 1 );\n\n\t\t\t\tconst video = document.getElementById( 'video' );\n\t\t\t\tvideo.play();\n\n\t\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.addEventListener( 'pointerdown', onPointerDown );\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tisUserInteracting = true;\n\n\t\t\t\tonPointerDownPointerX = event.clientX;\n\t\t\t\tonPointerDownPointerY = event.clientY;\n\n\t\t\t\tonPointerDownLon = lon;\n\t\t\t\tonPointerDownLat = lat;\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( isUserInteracting === true ) {\n\n\t\t\t\t\tlon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;\n\t\t\t\t\tlat = ( onPointerDownPointerY - event.clientY ) * 0.1 + onPointerDownLat;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp() {\n\n\t\t\t\tisUserInteracting = false;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tlat = Math.max( - 85, Math.min( 85, lat ) );\n\t\t\t\tphi = THREE.MathUtils.degToRad( 90 - lat );\n\t\t\t\ttheta = THREE.MathUtils.degToRad( lon );\n\n\t\t\t\tcamera.position.x = distance * Math.sin( phi ) * Math.cos( theta );\n\t\t\t\tcamera.position.y = distance * Math.cos( phi );\n\t\t\t\tcamera.position.z = distance * Math.sin( phi ) * Math.sin( theta );\n\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - video panorama"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - watch"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - watch:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport * as TWEEN from 'tween';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { FXAAShader } from 'three/addons/shaders/FXAAShader.js';\n\n\t\t\tlet composer, camera, scene, renderer;\n\t\t\tlet gui, dirLight, pointLight, controls, bloomPass, fxaaPass;\n\t\t\tlet ready = false;\n\n\t\t\tconst meshs = {};\n\t\t\tconst materials = {};\n\t\t\tconst torad = Math.PI / 180;\n\n\t\t\tconst setting = {\n\t\t\t\troughness: 0.09,\n\t\t\t\tmetalness: 1.0,\n\t\t\t\topacity: 0.4,\n\t\t\t\tthreshold: 0,\n\t\t\t\tstrength: 0.08,\n\t\t\t\tradius: 0.0,\n\t\t\t\tpostProcess: false\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.1, 20 );\n\t\t\t\tcamera.position.set( 0.8, 0.5, - 1.5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.7;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'lobe.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\t\t\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\t\t\tscene.backgroundIntensity = 1.0;\n\t\t\t\t\t\tscene.environmentIntensity = 1.5;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\t\t\tloader.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) );\n\t\t\t\t\t\tloader.load( 'rolex.glb', function ( gltf ) {\n\n\t\t\t\t\t\t\tgltf.scene.rotation.x = Math.PI * 0.25;\n\n\t\t\t\t\t\t\tgltf.scene.traverse( ( child ) => {\n\n\t\t\t\t\t\t\t\tif ( child.isMesh || child.isGroup ) {\n\n\t\t\t\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t\t\t\tchild.material.vertexColors = false;\n\t\t\t\t\t\t\t\t\t\tmaterials[ child.material.name ] = child.material;\n\t\t\t\t\t\t\t\t\t\tif ( child.name !== 'glass' ) {\n\n\t\t\t\t\t\t\t\t\t\t\tchild.receiveShadow = true;\n\t\t\t\t\t\t\t\t\t\t    child.castShadow = true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tmeshs[ child.name ] = child;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\tmeshs.glass.material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tcolor: 0x020205,\n\t\t\t\t\t\t\t\ttransparent: true, opacity: setting.opacity,\n\t\t\t\t\t\t\t\tmetalness: 0, roughness: 0,\n\t\t\t\t\t\t\t\tiridescence: 0.3,\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tblending: THREE.AdditiveBlending\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tready = true;\n\n\t\t\t\t\t\t\tcreateGUI();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 0.3;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, - 0.1, 0 );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0xFFFFFF, 6 );\n\t\t\t\tdirLight.position.set( - 0.1, 0.6, 0.4 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tscene.add( dirLight );\n\t\t\t\tconst shadow = dirLight.shadow;\n\t\t\t\tshadow.mapSize.width = shadow.mapSize.height = 1024;\n\t\t\t\tshadow.radius = 8;\n\t\t\t\tshadow.bias = - 0.0005;\n\t\t\t\tconst shadowCam = shadow.camera, s = 0.5;\n\t\t\t\tshadowCam.near = 0.1;\n\t\t\t\tshadowCam.far = 2;\n\t\t\t\tshadowCam.right = shadowCam.top\t= s;\n\t\t\t\tshadowCam.left = shadowCam.bottom = - s;\n\t\t\t\t// debug shadow\n\t\t\t\t//scene.add(  new THREE.CameraHelper(shadowCam) );\n\n\t\t\t\tpointLight = new THREE.PointLight( 0x7b8cad, 1, 0, 2 );\n\t\t\t\tpointLight.position.set( 0.3, - 0.2, - 0.2 );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tmoveCamera();\n\n\t\t\t}\n\n\t\t\tfunction moveCamera() {\n\n\t\t\t\tcontrols.enabled = false;\n\t\t\t\tcontrols.enableDamping = false;\n\n\t\t\t\tconst sph = new THREE.Spherical();\n\t\t\t\tconst target = controls.target;\n\t\t\t\tconst tmp = {\n\t\t\t\t    distance: controls.getDistance(),\n\t\t\t\t    phi: controls.getPolarAngle(),\n\t\t\t\t    theta: controls.getAzimuthalAngle()\n\t\t\t\t};\n\n\t\t\t\tnew TWEEN.Tween( tmp )\n\t\t\t\t\t.to( { distance: 1, theta: - Math.PI * 0.2 }, 6000 )\n\t\t\t\t\t.easing( TWEEN.Easing.Quadratic.Out )\n\t\t\t\t\t.onUpdate( function ( n ) {\n\n\t\t\t\t\t\tsph.set( n.distance, n.phi, n.theta );\n\t\t\t\t\t\tcamera.position.setFromSpherical( sph ).add( target );\n\t\t\t\t\t\tcamera.lookAt( target );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.onComplete( function () {\n\n\t\t\t\t\t\tcontrols.enabled = true;\n\t\t\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.start();\n\n\t\t\t}\n\n\t\t\tfunction postProcess( b ) {\n\n\t\t\t\tif ( b ) {\n\n\t\t\t\t\tif ( composer ) return;\n\n\t\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\t\tbloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );\n\t\t\t\t\tbloomPass.threshold = setting.threshold;\n\t\t\t\t\tbloomPass.strength = setting.strength;\n\t\t\t\t\tbloomPass.radius = setting.radius;\n\n\t\t\t\t\tfxaaPass = new ShaderPass( FXAAShader );\n\t\t\t\t\tconst pixelRatio = renderer.getPixelRatio();\n\t\t\t\t\tfxaaPass.material.uniforms[ 'resolution' ].value.set( 1 / ( window.innerWidth * pixelRatio ), 1 / ( window.innerHeight * pixelRatio ) );\n\n\t\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\t\tcomposer.setPixelRatio( pixelRatio );\n\n\t\t\t\t\tcomposer.addPass( renderPass );\n\t\t\t\t\tcomposer.addPass( bloomPass );\n\t\t\t\t\tcomposer.addPass( fxaaPass );\n\t\t\t\t\tcomposer.addPass( outputPass );\n\t\t\t\t\tcomposer.addPass( fxaaPass );\n\t\t\t\t\tcomposer.addPass( fxaaPass );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! composer ) return;\n\t\t\t\t\tcomposer.dispose();\n\t\t\t\t\tcomposer = null;\n\t\t\t\t\tbloomPass = null;\n\t\t\t\t\tfxaaPass = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tgui.add( setting, 'roughness', 0, 1, 0.01 ).onChange( upMaterial );\n\t\t\t\tgui.add( setting, 'metalness', 0, 1, 0.01 ).onChange( upMaterial );\n\t\t\t\tgui.add( setting, 'opacity', 0, 1, 0.01 ).onChange( upMaterial );\n\n\t\t\t\t//\n\n\t\t\t\tgui.add( setting, 'postProcess' ).onChange( postProcess );\n\t\t\t\tgui.add( setting, 'threshold', 0, 1, 0.01 ).onChange( upBloom );\n\t\t\t\tgui.add( setting, 'strength', 0, 3, 0.01 ).onChange( upBloom );\n\t\t\t\tgui.add( setting, 'radius', 0, 1, 0.01 ).onChange( upBloom );\n\n\t\t\t}\n\n\t\t\tfunction upMaterial() {\n\n\t\t\t\tmaterials.Gold.metalness = materials.Silver.metalness = setting.metalness;\n\t\t\t\tmaterials.Gold.roughness = materials.Silver.roughness = setting.roughness;\n\t\t\t\tmeshs.glass.material.opacity = setting.opacity;\n\n\t\t\t}\n\n\t\t\tfunction upBloom() {\n\n\t\t\t\tif ( ! bloomPass ) return;\n\t\t\t\tbloomPass.threshold = setting.threshold;\n\t\t\t\tbloomPass.strength = setting.strength;\n\t\t\t\tbloomPass.radius = setting.radius;\n\n\t\t\t}\n\n\t\t\tfunction getTime() {\n\n\t\t\t\tconst currentDate = new Date();\n\t\t\t\tlet hour = currentDate.getHours();\n\t\t\t\tconst minute = currentDate.getMinutes();\n\t\t\t\tconst second = currentDate.getSeconds();\n\t\t\t\tlet day = currentDate.getDay();\n\t\t\t\tconst month = currentDate.getMonth();\n\t\t\t\tconst milli = currentDate.getMilliseconds();\n\t\t\t\tif ( hour >= 12 ) hour -= 12;\n\t\t\t\tif ( day > 30 ) day = 30;\n\n\t\t\t\tmeshs.hour.rotation.y = - hour * 30 * torad;\n\t\t\t\tmeshs.minute.rotation.y = - minute * 6 * torad;\n\t\t\t\tmeshs.second.rotation.y = - second * 6 * torad;\n\t\t\t\tmeshs.mini_03.rotation.y = - day * 12 * torad;\n\t\t\t\tmeshs.mini_02.rotation.y = - month * 30 * torad;\n\t\t\t\tmeshs.mini_01.rotation.y = - milli * 0.36 * torad;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tif ( composer ) {\n\n\t\t\t\t\tcomposer.setSize( width, height );\n\t\t\t\t\tif ( fxaaPass ) {\n\n\t\t\t\t\t\tconst pr = renderer.getPixelRatio();\n\t\t\t\t\t\tfxaaPass.material.uniforms[ 'resolution' ].value.set( 1 / ( width * pr ), 1 / ( height * pr ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tTWEEN.update();\n\n\t\t\t\tif ( composer ) composer.render();\n\t\t\t\telse renderer.render( scene, camera );\n\n\t\t\t\tif ( ready ) getTime();\n\n\t\t\t}\n```\n\nThis example three.js - Rolex + aomap - 610 ko"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\n\t\t\timport { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';\n\t\t\timport { DotScreenShader } from 'three/addons/shaders/DotScreenShader.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, renderer, composer;\n\t\t\tlet object;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1, 1000 );\n\n\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 1, 4, 4 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 ).normalize();\n\t\t\t\t\tmesh.position.multiplyScalar( Math.random() * 400 );\n\t\t\t\t\tmesh.rotation.set( Math.random() * 2, Math.random() * 2, Math.random() * 2 );\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 50;\n\t\t\t\t\tobject.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.addPass( new RenderPass( scene, camera ) );\n\n\t\t\t\tconst effect1 = new ShaderPass( DotScreenShader );\n\t\t\t\teffect1.uniforms[ 'scale' ].value = 4;\n\t\t\t\tcomposer.addPass( effect1 );\n\n\t\t\t\tconst effect2 = new ShaderPass( RGBShiftShader );\n\t\t\t\teffect2.uniforms[ 'amount' ].value = 0.0015;\n\t\t\t\tcomposer.addPass( effect2 );\n\n\t\t\t\tconst effect3 = new OutputPass();\n\t\t\t\tcomposer.addPass( effect3 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tobject.rotation.x += 0.005;\n\t\t\t\tobject.rotation.y += 0.01;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - 3d luts"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 3d luts:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { LUTPass } from 'three/addons/postprocessing/LUTPass.js';\n\t\t\timport { LUTCubeLoader } from 'three/addons/loaders/LUTCubeLoader.js';\n\t\t\timport { LUT3dlLoader } from 'three/addons/loaders/LUT3dlLoader.js';\n\t\t\timport { LUTImageLoader } from 'three/addons/loaders/LUTImageLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst params = {\n\t\t\t\tenabled: true,\n\t\t\t\tlut: 'Bourbon 64.CUBE',\n\t\t\t\tintensity: 1\n\t\t\t};\n\n\t\t\tconst lutMap = {\n\t\t\t\t'Bourbon 64.CUBE': null,\n\t\t\t\t'Chemical 168.CUBE': null,\n\t\t\t\t'Clayton 33.CUBE': null,\n\t\t\t\t'Cubicle 99.CUBE': null,\n\t\t\t\t'Remy 24.CUBE': null,\n\t\t\t\t'Presetpro-Cinematic.3dl': null,\n\t\t\t\t'NeutralLUT': null,\n\t\t\t\t'B&WLUT': null,\n\t\t\t\t'NightLUT': null\n\t\t\t};\n\n\t\t\tlet gui;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet composer, lutPass;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmet.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\tObject.keys( lutMap ).forEach( name => {\n\n\t\t\t\t\tif ( /\\.CUBE$/i.test( name ) ) {\n\n\t\t\t\t\t\tnew LUTCubeLoader()\n\t\t\t\t\t\t\t.load( 'luts/' + name, function ( result ) {\n\n\t\t\t\t\t\t\t\tlutMap[ name ] = result;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else if ( /\\LUT$/i.test( name ) ) {\n\n\t\t\t\t\t\tnew LUTImageLoader()\n\t\t\t\t\t\t\t.load( `luts/${name}.png`, function ( result ) {\n\n\t\t\t\t\t\t\t\tlutMap[ name ] = result;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnew LUT3dlLoader()\n\t\t\t\t\t\t\t.load( 'luts/' + name, function ( result ) {\n\n\t\t\t\t\t\t\t\tlutMap[ name ] = result;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.addPass( new RenderPass( scene, camera ) );\n\t\t\t\tcomposer.addPass( new OutputPass() );\n\n\t\t\t\tlutPass = new LUTPass();\n\t\t\t\tcomposer.addPass( lutPass );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tgui.width = 350;\n\t\t\t\tgui.add( params, 'enabled' );\n\t\t\t\tgui.add( params, 'lut', Object.keys( lutMap ) );\n\t\t\t\tgui.add( params, 'intensity' ).min( 0 ).max( 1 );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tlutPass.enabled = params.enabled && Boolean( lutMap[ params.lut ] );\n\t\t\t\tlutPass.intensity = params.intensity;\n\t\t\t\tif ( lutMap[ params.lut ] ) {\n\n\t\t\t\t\tconst lut = lutMap[ params.lut ];\n\t\t\t\t\tlutPass.lut = lut.texture3D;\n\n\t\t\t\t}\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example three.js - 3D LUTs Battle Damaged Sci-fi Helmet by theblueturtle_ Royal Esplanade from HDRI Haven LUTs from RocketStock , FreePresets.com"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { BloomPass } from 'three/addons/postprocessing/BloomPass.js';\n\t\t\timport { FilmPass } from 'three/addons/postprocessing/FilmPass.js';\n\t\t\timport { DotScreenPass } from 'three/addons/postprocessing/DotScreenPass.js';\n\t\t\timport { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';\n\t\t\timport { TexturePass } from 'three/addons/postprocessing/TexturePass.js';\n\n\t\t\timport { BleachBypassShader } from 'three/addons/shaders/BleachBypassShader.js';\n\t\t\timport { ColorifyShader } from 'three/addons/shaders/ColorifyShader.js';\n\t\t\timport { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';\n\t\t\timport { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';\n\t\t\timport { SepiaShader } from 'three/addons/shaders/SepiaShader.js';\n\t\t\timport { VignetteShader } from 'three/addons/shaders/VignetteShader.js';\n\t\t\timport { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet composerScene, composer1, composer2, composer3, composer4;\n\n\t\t\tlet cameraOrtho, cameraPerspective, sceneModel, sceneBG, renderer, mesh, directionalLight;\n\n\t\t\tconst width = window.innerWidth || 2;\n\t\t\tconst height = window.innerHeight || 2;\n\n\t\t\tlet halfWidth = width / 2;\n\t\t\tlet halfHeight = height / 2;\n\n\t\t\tlet quadBG, quadMask, renderScene;\n\n\t\t\tconst delta = 0.01;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( - halfWidth, halfWidth, halfHeight, - halfHeight, - 10000, 10000 );\n\t\t\t\tcameraOrtho.position.z = 100;\n\n\t\t\t\tcameraPerspective = new THREE.PerspectiveCamera( 50, width / height, 1, 10000 );\n\t\t\t\tcameraPerspective.position.z = 900;\n\n\t\t\t\t//\n\n\t\t\t\tsceneModel = new THREE.Scene();\n\t\t\t\tsceneBG = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tdirectionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 0, - 0.1, 1 ).normalize();\n\t\t\t\tsceneModel.add( directionalLight );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tcreateMesh( gltf.scene.children[ 0 ].geometry, sceneModel, 100 );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst diffuseMap = new THREE.TextureLoader().load( 'textures/cube/SwedishRoyalCastle/pz.jpg' );\n\t\t\t\tdiffuseMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst materialColor = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tmap: diffuseMap,\n\t\t\t\t\tdepthTest: false\n\t\t\t\t} );\n\n\t\t\t\tquadBG = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), materialColor );\n\t\t\t\tquadBG.position.z = - 500;\n\t\t\t\tquadBG.scale.set( width, height, 1 );\n\t\t\t\tsceneBG.add( quadBG );\n\n\t\t\t\t//\n\n\t\t\t\tconst sceneMask = new THREE.Scene();\n\n\t\t\t\tquadMask = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) );\n\t\t\t\tquadMask.position.z = - 300;\n\t\t\t\tquadMask.scale.set( width / 2, height / 2, 1 );\n\t\t\t\tsceneMask.add( quadMask );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\t//\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst shaderBleach = BleachBypassShader;\n\t\t\t\tconst shaderSepia = SepiaShader;\n\t\t\t\tconst shaderVignette = VignetteShader;\n\n\t\t\t\tconst effectBleach = new ShaderPass( shaderBleach );\n\t\t\t\tconst effectSepia = new ShaderPass( shaderSepia );\n\t\t\t\tconst effectVignette = new ShaderPass( shaderVignette );\n\t\t\t\tconst gammaCorrection = new ShaderPass( GammaCorrectionShader );\n\n\t\t\t\teffectBleach.uniforms[ 'opacity' ].value = 0.95;\n\n\t\t\t\teffectSepia.uniforms[ 'amount' ].value = 0.9;\n\n\t\t\t\teffectVignette.uniforms[ 'offset' ].value = 1.6;\n\t\t\t\teffectVignette.uniforms[ 'darkness' ].value = 0.95;\n\n\t\t\t\tconst effectBloom = new BloomPass( 0.5 );\n\t\t\t\tconst effectFilm = new FilmPass( 0.35 );\n\t\t\t\tconst effectFilmBW = new FilmPass( 0.35, true );\n\t\t\t\tconst effectDotScreen = new DotScreenPass( new THREE.Vector2( 0, 0 ), 0.5, 0.8 );\n\n\t\t\t\tconst effectHBlur = new ShaderPass( HorizontalBlurShader );\n\t\t\t\tconst effectVBlur = new ShaderPass( VerticalBlurShader );\n\t\t\t\teffectHBlur.uniforms[ 'h' ].value = 2 / ( width / 2 );\n\t\t\t\teffectVBlur.uniforms[ 'v' ].value = 2 / ( height / 2 );\n\n\t\t\t\tconst effectColorify1 = new ShaderPass( ColorifyShader );\n\t\t\t\tconst effectColorify2 = new ShaderPass( ColorifyShader );\n\t\t\t\teffectColorify1.uniforms[ 'color' ] = new THREE.Uniform( new THREE.Color( 1, 0.8, 0.8 ) );\n\t\t\t\teffectColorify2.uniforms[ 'color' ] = new THREE.Uniform( new THREE.Color( 1, 0.75, 0.5 ) );\n\n\t\t\t\tconst clearMask = new ClearMaskPass();\n\t\t\t\tconst renderMask = new MaskPass( sceneModel, cameraPerspective );\n\t\t\t\tconst renderMaskInverse = new MaskPass( sceneModel, cameraPerspective );\n\n\t\t\t\trenderMaskInverse.inverse = true;\n\n\t\t\t\t//\n\n\t\t\t\tconst rtParameters = {\n\t\t\t\t\tstencilBuffer: true\n\t\t\t\t};\n\n\t\t\t\tconst rtWidth = width / 2;\n\t\t\t\tconst rtHeight = height / 2;\n\n\t\t\t\t//\n\n\t\t\t\tconst renderBackground = new RenderPass( sceneBG, cameraOrtho );\n\t\t\t\tconst renderModel = new RenderPass( sceneModel, cameraPerspective );\n\n\t\t\t\trenderModel.clear = false;\n\n\t\t\t\tcomposerScene = new EffectComposer( renderer, new THREE.WebGLRenderTarget( rtWidth * 2, rtHeight * 2, rtParameters ) );\n\n\t\t\t\tcomposerScene.addPass( renderBackground );\n\t\t\t\tcomposerScene.addPass( renderModel );\n\t\t\t\tcomposerScene.addPass( renderMaskInverse );\n\t\t\t\tcomposerScene.addPass( effectHBlur );\n\t\t\t\tcomposerScene.addPass( effectVBlur );\n\t\t\t\tcomposerScene.addPass( clearMask );\n\n\t\t\t\t//\n\n\t\t\t\trenderScene = new TexturePass( composerScene.renderTarget2.texture );\n\n\t\t\t\t//\n\n\t\t\t\tcomposer1 = new EffectComposer( renderer, new THREE.WebGLRenderTarget( rtWidth, rtHeight, rtParameters ) );\n\n\t\t\t\tcomposer1.addPass( renderScene );\n\t\t\t\tcomposer1.addPass( gammaCorrection );\n\t\t\t\tcomposer1.addPass( effectFilmBW );\n\t\t\t\tcomposer1.addPass( effectVignette );\n\n\t\t\t\t//\n\n\t\t\t\tcomposer2 = new EffectComposer( renderer, new THREE.WebGLRenderTarget( rtWidth, rtHeight, rtParameters ) );\n\n\t\t\t\tcomposer2.addPass( renderScene );\n\t\t\t\tcomposer2.addPass( gammaCorrection );\n\t\t\t\tcomposer2.addPass( effectDotScreen );\n\t\t\t\tcomposer2.addPass( renderMask );\n\t\t\t\tcomposer2.addPass( effectColorify1 );\n\t\t\t\tcomposer2.addPass( clearMask );\n\t\t\t\tcomposer2.addPass( renderMaskInverse );\n\t\t\t\tcomposer2.addPass( effectColorify2 );\n\t\t\t\tcomposer2.addPass( clearMask );\n\t\t\t\tcomposer2.addPass( effectVignette );\n\n\t\t\t\t//\n\n\t\t\t\tcomposer3 = new EffectComposer( renderer, new THREE.WebGLRenderTarget( rtWidth, rtHeight, rtParameters ) );\n\n\t\t\t\tcomposer3.addPass( renderScene );\n\t\t\t\tcomposer3.addPass( gammaCorrection );\n\t\t\t\tcomposer3.addPass( effectSepia );\n\t\t\t\tcomposer3.addPass( effectFilm );\n\t\t\t\tcomposer3.addPass( effectVignette );\n\n\t\t\t\t//\n\n\t\t\t\tcomposer4 = new EffectComposer( renderer, new THREE.WebGLRenderTarget( rtWidth, rtHeight, rtParameters ) );\n\n\t\t\t\tcomposer4.addPass( renderScene );\n\t\t\t\tcomposer4.addPass( gammaCorrection );\n\t\t\t\tcomposer4.addPass( effectBloom );\n\t\t\t\tcomposer4.addPass( effectFilm );\n\t\t\t\tcomposer4.addPass( effectBleach );\n\t\t\t\tcomposer4.addPass( effectVignette );\n\n\t\t\t\trenderScene.uniforms[ 'tDiffuse' ].value = composerScene.renderTarget2.texture;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\thalfWidth = window.innerWidth / 2;\n\t\t\t\thalfHeight = window.innerHeight / 2;\n\n\t\t\t\tcameraPerspective.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = - halfWidth;\n\t\t\t\tcameraOrtho.right = halfWidth;\n\t\t\t\tcameraOrtho.top = halfHeight;\n\t\t\t\tcameraOrtho.bottom = - halfHeight;\n\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcomposerScene.setSize( halfWidth * 2, halfHeight * 2 );\n\n\t\t\t\tcomposer1.setSize( halfWidth, halfHeight );\n\t\t\t\tcomposer2.setSize( halfWidth, halfHeight );\n\t\t\t\tcomposer3.setSize( halfWidth, halfHeight );\n\t\t\t\tcomposer4.setSize( halfWidth, halfHeight );\n\n\t\t\t\trenderScene.uniforms[ 'tDiffuse' ].value = composerScene.renderTarget2.texture;\n\n\t\t\t\tquadBG.scale.set( window.innerWidth, window.innerHeight, 1 );\n\t\t\t\tquadMask.scale.set( window.innerWidth / 2, window.innerHeight / 2, 1 );\n\n\t\t\t}\n\n\t\t\tfunction createMesh( geometry, scene, scale ) {\n\n\t\t\t\tconst diffuseMap = new THREE.TextureLoader().load( 'models/gltf/LeePerrySmith/Map-COL.jpg' );\n\t\t\t\tdiffuseMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst mat2 = new THREE.MeshPhongMaterial( {\n\n\t\t\t\t\tcolor: 0xcbcbcb,\n\t\t\t\t\tspecular: 0x080808,\n\t\t\t\t\tshininess: 20,\n\t\t\t\t\tmap: diffuseMap,\n\t\t\t\t\tnormalMap: new THREE.TextureLoader().load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' ),\n\t\t\t\t\tnormalScale: new THREE.Vector2( 0.75, 0.75 )\n\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, mat2 );\n\t\t\t\tmesh.position.set( 0, - 50, 0 );\n\t\t\t\tmesh.scale.set( scale, scale, scale );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.0004;\n\n\t\t\t\tif ( mesh ) mesh.rotation.y = - time;\n\n\t\t\t\trenderer.setViewport( 0, 0, halfWidth, halfHeight );\n\t\t\t\tcomposerScene.render( delta );\n\n\t\t\t\trenderer.setViewport( 0, 0, halfWidth, halfHeight );\n\t\t\t\tcomposer1.render( delta );\n\n\t\t\t\trenderer.setViewport( halfWidth, 0, halfWidth, halfHeight );\n\t\t\t\tcomposer2.render( delta );\n\n\t\t\t\trenderer.setViewport( 0, halfHeight, halfWidth, halfHeight );\n\t\t\t\tcomposer3.render( delta );\n\n\t\t\t\trenderer.setViewport( halfWidth, halfHeight, halfWidth, halfHeight );\n\t\t\t\tcomposer4.render( delta );\n\n\t\t\t}\n```\n\nThis example three.js - webgl postprocessing example Lee Perry-Smith head"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - afterimage"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - afterimage:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, composer;\n\t\t\tlet mesh;\n\n\t\t\tlet afterimagePass;\n\n\t\t\tconst params = {\n\n\t\t\t\tenable: true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1, 1000 );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 150, 150, 150, 2, 2, 2 );\n\t\t\t\tconst material = new THREE.MeshNormalMaterial();\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.addPass( new RenderPass( scene, camera ) );\n\n\t\t\t\tafterimagePass = new AfterimagePass();\n\t\t\t\tcomposer.addPass( afterimagePass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI( { title: 'Damp setting' } );\n\t\t\t\tgui.add( afterimagePass, 'damp', 0, 1 ).step( 0.001 );\n\t\t\t\tgui.add( params, 'enable' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.x += 0.005;\n\t\t\t\tmesh.rotation.y += 0.01;\n\n\t\t\t\tafterimagePass.enabled = params.enable;\n\n\t\t\t\tcomposer.render();\n\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing backgrounds"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing backgrounds:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { TexturePass } from 'three/addons/postprocessing/TexturePass.js';\n\t\t\timport { CubeTexturePass } from 'three/addons/postprocessing/CubeTexturePass.js';\n\t\t\timport { ClearPass } from 'three/addons/postprocessing/ClearPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet scene, renderer, composer;\n\t\t\tlet clearPass, texturePass, renderPass;\n\t\t\tlet cameraP, cubeTexturePassP;\n\t\t\tlet gui, stats;\n\n\t\t\tconst params = {\n\n\t\t\t\tclearPass: true,\n\t\t\t\tclearColor: 'white',\n\t\t\t\tclearAlpha: 1.0,\n\n\t\t\t\ttexturePass: true,\n\t\t\t\ttexturePassOpacity: 1.0,\n\n\t\t\t\tcubeTexturePass: true,\n\t\t\t\tcubeTexturePassOpacity: 1.0,\n\n\t\t\t\trenderPass: true\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tclearGui();\n\n\t\t\tfunction clearGui() {\n\n\t\t\t\tif ( gui ) gui.destroy();\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( params, 'clearPass' );\n\t\t\t\tgui.add( params, 'clearColor', [ 'black', 'white', 'blue', 'green', 'red' ] );\n\t\t\t\tgui.add( params, 'clearAlpha', 0, 1 );\n\n\t\t\t\tgui.add( params, 'texturePass' );\n\t\t\t\tgui.add( params, 'texturePassOpacity', 0, 1 );\n\n\t\t\t\tgui.add( params, 'cubeTexturePass' );\n\t\t\t\tgui.add( params, 'cubeTexturePassOpacity', 0, 1 );\n\n\t\t\t\tgui.add( params, 'renderPass' );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tconst width = window.innerWidth || 1;\n\t\t\t\tconst height = window.innerHeight || 1;\n\t\t\t\tconst aspect = width / height;\n\t\t\t\tconst devicePixelRatio = window.devicePixelRatio || 1;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tcameraP = new THREE.PerspectiveCamera( 65, aspect, 1, 10 );\n\t\t\t\tcameraP.position.z = 7;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xefffef, 500 );\n\t\t\t\tlight.position.z = 10;\n\t\t\t\tlight.position.y = - 10;\n\t\t\t\tlight.position.x = - 10;\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.PointLight( 0xffefef, 500 );\n\t\t\t\tlight2.position.z = 10;\n\t\t\t\tlight2.position.x = - 10;\n\t\t\t\tlight2.position.y = 10;\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tconst light3 = new THREE.PointLight( 0xefefff, 500 );\n\t\t\t\tlight3.position.z = 10;\n\t\t\t\tlight3.position.x = 10;\n\t\t\t\tlight3.position.y = - 10;\n\t\t\t\tscene.add( light3 );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 1, 48, 24 );\n\n\t\t\t\tconst material = new THREE.MeshStandardMaterial();\n\t\t\t\tmaterial.roughness = 0.5 * Math.random() + 0.25;\n\t\t\t\tmaterial.metalness = 0;\n\t\t\t\tmaterial.color.setHSL( Math.random(), 1.0, 0.3 );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tconst genCubeUrls = function ( prefix, postfix ) {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tprefix + 'px' + postfix, prefix + 'nx' + postfix,\n\t\t\t\t\t\tprefix + 'py' + postfix, prefix + 'ny' + postfix,\n\t\t\t\t\t\tprefix + 'pz' + postfix, prefix + 'nz' + postfix\n\t\t\t\t\t];\n\n\t\t\t\t};\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tclearPass = new ClearPass( params.clearColor, params.clearAlpha );\n\t\t\t\tcomposer.addPass( clearPass );\n\n\t\t\t\ttexturePass = new TexturePass();\n\t\t\t\tcomposer.addPass( texturePass );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_diffuse.jpg', function ( map ) {\n\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\ttexturePass.map = map;\n\n\t\t\t\t} );\n\n\t\t\t\tcubeTexturePassP = null;\n\n\t\t\t\tconst ldrUrls = genCubeUrls( 'textures/cube/pisa/', '.png' );\n\t\t\t\tnew THREE.CubeTextureLoader().load( ldrUrls, function ( ldrCubeMap ) {\n\n\t\t\t\t\tcubeTexturePassP = new CubeTexturePass( cameraP, ldrCubeMap );\n\t\t\t\t\tcomposer.insertPass( cubeTexturePassP, 2 );\n\n\t\t\t\t} );\n\n\t\t\t\trenderPass = new RenderPass( scene, cameraP );\n\t\t\t\trenderPass.clear = false;\n\t\t\t\tcomposer.addPass( renderPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\tconst controls = new OrbitControls( cameraP, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\t\t\t\tconst aspect = width / height;\n\n\t\t\t\tcameraP.aspect = aspect;\n\t\t\t\tcameraP.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tcameraP.updateMatrixWorld( true );\n\n\t\t\t\tlet newColor = clearPass.clearColor;\n\n\t\t\t\tswitch ( params.clearColor ) {\n\n\t\t\t\t\tcase 'blue': newColor = 0x0000ff; break;\n\t\t\t\t\tcase 'red': newColor = 0xff0000; break;\n\t\t\t\t\tcase 'green': newColor = 0x00ff00; break;\n\t\t\t\t\tcase 'white': newColor = 0xffffff; break;\n\t\t\t\t\tcase 'black': newColor = 0x000000; break;\n\n\t\t\t\t}\n\n\t\t\t\tclearPass.enabled = params.clearPass;\n\t\t\t\tclearPass.clearColor = newColor;\n\t\t\t\tclearPass.clearAlpha = params.clearAlpha;\n\n\t\t\t\ttexturePass.enabled = params.texturePass;\n\t\t\t\ttexturePass.opacity = params.texturePassOpacity;\n\n\t\t\t\tif ( cubeTexturePassP !== null ) {\n\n\t\t\t\t\tcubeTexturePassP.enabled = params.cubeTexturePass;\n\t\t\t\t\tcubeTexturePassP.opacity = params.cubeTexturePassOpacity;\n\n\t\t\t\t}\n\n\t\t\t\trenderPass.enabled = params.renderPass;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - Backgrounds: ClearPass, TexturePass and CubeTexturePass by Ben Houston"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - scenes transition"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - scenes transition:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderTransitionPass } from 'three/addons/postprocessing/RenderTransitionPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet stats;\n\t\t\tlet renderer, composer, renderTransitionPass;\n\n\t\t\tconst textures = [];\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst params = {\n\t\t\t\tsceneAnimate: true,\n\t\t\t\ttransitionAnimate: true,\n\t\t\t\ttransition: 0,\n\t\t\t\tuseTexture: true,\n\t\t\t\ttexture: 5,\n\t\t\t\tcycle: true,\n\t\t\t\tthreshold: 0.1,\n\t\t\t};\n\n\t\t\tconst fxSceneA = new FXScene( new THREE.BoxGeometry( 2, 2, 2 ), new THREE.Vector3( 0, - 0.4, 0 ), 0xffffff );\n\t\t\tconst fxSceneB = new FXScene( new THREE.IcosahedronGeometry( 1, 1 ), new THREE.Vector3( 0, 0.2, 0.1 ), 0x000000 );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitGUI();\n\t\t\t\tinitTextures();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\trenderTransitionPass = new RenderTransitionPass( fxSceneA.scene, fxSceneA.camera, fxSceneB.scene, fxSceneB.camera );\n\t\t\t\trenderTransitionPass.setTexture( textures[ 0 ] );\n\t\t\t\tcomposer.addPass( renderTransitionPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t}\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tfxSceneA.resize();\n\t\t\t\tfxSceneB.resize();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tnew TWEEN.Tween( params )\n\t\t\t\t.to( { transition: 1 }, 1500 )\n\t\t\t\t.onUpdate( function () {\n\n\t\t\t\t\trenderTransitionPass.setTransition( params.transition );\n\n\t\t\t\t\t// Change the current alpha texture after each transition\n\t\t\t\t\tif ( params.cycle ) {\n\n\t\t\t\t\t\tif ( params.transition == 0 || params.transition == 1 ) {\n\n\t\t\t\t\t\t\tparams.texture = ( params.texture + 1 ) % textures.length;\n\t\t\t\t\t\t\trenderTransitionPass.setTexture( textures[ params.texture ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} )\n\t\t\t\t.repeat( Infinity )\n\t\t\t\t.delay( 2000 )\n\t\t\t\t.yoyo( true )\n\t\t\t\t.start();\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Transition animation\n\t\t\t\tif ( params.transitionAnimate ) TWEEN.update();\n\n\t\t\t\tconst delta = clock.getDelta();\n\t\t\t\tfxSceneA.update( delta );\n\t\t\t\tfxSceneB.update( delta );\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction initTextures() {\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\ttextures[ i ] = loader.load( 'textures/transition/transition' + ( i + 1 ) + '.png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'sceneAnimate' ).name( 'Animate scene' );\n\t\t\t\tgui.add( params, 'transitionAnimate' ).name( 'Animate transition' );\n\t\t\t\tgui.add( params, 'transition', 0, 1, 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\trenderTransitionPass.setTransition( value );\n\n\t\t\t\t} ).listen();\n\n\t\t\t\tgui.add( params, 'useTexture' ).onChange( function ( value ) {\n\n\t\t\t\t\trenderTransitionPass.useTexture( value );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'texture', { Perlin: 0, Squares: 1, Cells: 2, Distort: 3, Gradient: 4, Radial: 5 } ).onChange( function ( value ) {\n\n\t\t\t\t\trenderTransitionPass.setTexture( textures[ value ] );\n\n\t\t\t\t} ).listen();\n\n\t\t\t\tgui.add( params, 'cycle' );\n\n\t\t\t\tgui.add( params, 'threshold', 0, 1, 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\trenderTransitionPass.setTextureThreshold( value );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\n\t\t\tfunction render() {\n\n\t\t\t\t// Prevent render both scenes when it's not necessary\n\t\t\t\tif ( params.transition === 0 ) {\n\n\t\t\t\t\trenderer.render( fxSceneB.scene, fxSceneB.camera );\n\n\t\t\t\t} else if ( params.transition === 1 ) {\n\n\t\t\t\t\trenderer.render( fxSceneA.scene, fxSceneA.camera );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// When 0 < transition < 1 render transition between two scenes\n\t\t\t\t\tcomposer.render();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction FXScene( geometry, rotationSpeed, backgroundColor ) {\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 20;\n\n\t\t\t\t// Setup scene\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( backgroundColor );\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 1, 4 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tthis.rotationSpeed = rotationSpeed;\n\n\t\t\t\tconst color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: color, flatShading: true } );\n\t\t\t\tconst mesh = generateInstancedMesh( geometry, material, 500 );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tthis.scene = scene;\n\t\t\t\tthis.camera = camera;\n\t\t\t\tthis.mesh = mesh;\n\n\t\t\t\tthis.update = function ( delta ) {\n\n\t\t\t\t\tif ( params.sceneAnimate ) {\n\n\t\t\t\t\t\tmesh.rotation.x += this.rotationSpeed.x * delta;\n\t\t\t\t\t\tmesh.rotation.y += this.rotationSpeed.y * delta;\n\t\t\t\t\t\tmesh.rotation.z += this.rotationSpeed.z * delta;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.resize = function () {\n\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction generateInstancedMesh( geometry, material, count ) {\n\n\t\t\t\tconst mesh = new THREE.InstancedMesh( geometry, material, count );\n\n\t\t\t\tconst dummy = new THREE.Object3D();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tdummy.position.x = Math.random() * 100 - 50;\n\t\t\t\t\tdummy.position.y = Math.random() * 60 - 30;\n\t\t\t\t\tdummy.position.z = Math.random() * 80 - 40;\n\n\t\t\t\t\tdummy.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tdummy.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tdummy.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tdummy.scale.x = Math.random() * 2 + 1;\n\n\t\t\t\t\tif ( geometry.type === 'BoxGeometry' ) {\n\n\t\t\t\t\t\tdummy.scale.y = Math.random() * 2 + 1;\n\t\t\t\t\t\tdummy.scale.z = Math.random() * 2 + 1;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdummy.scale.y = dummy.scale.x;\n\t\t\t\t\t\tdummy.scale.z = dummy.scale.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\t\t\t\t\tmesh.setColorAt( i, color.setScalar( 0.1 + 0.9 * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n```\n\nThis example three.js webgl scene transitions by fernandojsg - github"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - depth-of-field"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - depth-of-field:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { BokehPass } from 'three/addons/postprocessing/BokehPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, stats,\n\t\t\t\tsingleMaterial, zmaterial,\n\t\t\t\tparameters, nobjects, cubeMaterial;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet width = window.innerWidth;\n\t\t\tlet height = window.innerHeight;\n\n\t\t\tconst materials = [], objects = [];\n\n\t\t\tconst postprocessing = {};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, width / height, 1, 3000 );\n\t\t\t\tcamera.position.z = 200;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\tparameters = { color: 0xff4900, envMap: textureCube };\n\t\t\t\tcubeMaterial = new THREE.MeshBasicMaterial( parameters );\n\n\t\t\t\tsingleMaterial = false;\n\n\t\t\t\tif ( singleMaterial ) zmaterial = [ cubeMaterial ];\n\n\t\t\t\tconst geo = new THREE.SphereGeometry( 1, 20, 10 );\n\n\t\t\t\tconst xgrid = 14, ygrid = 9, zgrid = 14;\n\n\t\t\t\tnobjects = xgrid * ygrid * zgrid;\n\n\t\t\t\tconst s = 60;\n\t\t\t\tlet count = 0;\n\n\t\t\t\tfor ( let i = 0; i < xgrid; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < ygrid; j ++ ) {\n\n\t\t\t\t\t\tfor ( let k = 0; k < zgrid; k ++ ) {\n\n\t\t\t\t\t\t\tlet mesh;\n\n\t\t\t\t\t\t\tif ( singleMaterial ) {\n\n\t\t\t\t\t\t\t\tmesh = new THREE.Mesh( geo, zmaterial );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmesh = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( parameters ) );\n\t\t\t\t\t\t\t\tmaterials[ count ] = mesh.material;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst x = 200 * ( i - xgrid / 2 );\n\t\t\t\t\t\t\tconst y = 200 * ( j - ygrid / 2 );\n\t\t\t\t\t\t\tconst z = 200 * ( k - zgrid / 2 );\n\n\t\t\t\t\t\t\tmesh.position.set( x, y, z );\n\t\t\t\t\t\t\tmesh.scale.set( s, s, s );\n\n\t\t\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\t\t\tmesh.updateMatrix();\n\n\t\t\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\t\t\tobjects.push( mesh );\n\n\t\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tinitPostprocessing();\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst effectController = {\n\n\t\t\t\t\tfocus: 500.0,\n\t\t\t\t\taperture: 5,\n\t\t\t\t\tmaxblur: 0.01\n\n\t\t\t\t};\n\n\t\t\t\tconst matChanger = function ( ) {\n\n\t\t\t\t\tpostprocessing.bokeh.uniforms[ 'focus' ].value = effectController.focus;\n\t\t\t\t\tpostprocessing.bokeh.uniforms[ 'aperture' ].value = effectController.aperture * 0.00001;\n\t\t\t\t\tpostprocessing.bokeh.uniforms[ 'maxblur' ].value = effectController.maxblur;\n\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( effectController, 'focus', 10.0, 3000.0, 10 ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'aperture', 0, 10, 0.1 ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'maxblur', 0.0, 0.01, 0.001 ).onChange( matChanger );\n\t\t\t\tgui.close();\n\n\t\t\t\tmatChanger();\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\twidth = window.innerWidth;\n\t\t\t\theight = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tpostprocessing.composer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction initPostprocessing() {\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\n\t\t\t\tconst bokehPass = new BokehPass( scene, camera, {\n\t\t\t\t\tfocus: 1.0,\n\t\t\t\t\taperture: 0.025,\n\t\t\t\t\tmaxblur: 0.01\n\t\t\t\t} );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tconst composer = new EffectComposer( renderer );\n\n\t\t\t\tcomposer.addPass( renderPass );\n\t\t\t\tcomposer.addPass( bokehPass );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\tpostprocessing.composer = composer;\n\t\t\t\tpostprocessing.bokeh = bokehPass;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.00005;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.036;\n\t\t\t\tcamera.position.y += ( - ( mouseY ) - camera.position.y ) * 0.036;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tif ( ! singleMaterial ) {\n\n\t\t\t\t\tfor ( let i = 0; i < nobjects; i ++ ) {\n\n\t\t\t\t\t\tconst h = ( 360 * ( i / nobjects + time ) % 360 ) / 360;\n\t\t\t\t\t\tmaterials[ i ].color.setHSL( h, 1, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tpostprocessing.composer.render( 0.1 );\n\n\t\t\t}\n```\n\nThis example three.js - webgl depth-of-field with bokeh example shader by Martins Upitis"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - depth-of-field"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - depth-of-field:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { BokehShader, BokehDepthShader } from 'three/addons/shaders/BokehShader2.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, materialDepth;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet distance = 100;\n\t\t\tlet effectController;\n\n\t\t\tconst postprocessing = { enabled: true };\n\n\t\t\tconst shaderSettings = {\n\t\t\t\trings: 3,\n\t\t\t\tsamples: 4\n\t\t\t};\n\n\t\t\tconst mouse = new THREE.Vector2();\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst target = new THREE.Vector3( 0, 20, - 50 );\n\t\t\tconst planes = [];\n\t\t\tconst leaves = 100;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 3000 );\n\n\t\t\t\tcamera.position.y = 150;\n\t\t\t\tcamera.position.z = 450;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( camera );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst depthShader = BokehDepthShader;\n\n\t\t\t\tmaterialDepth = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: depthShader.uniforms,\n\t\t\t\t\tvertexShader: depthShader.vertexShader,\n\t\t\t\t\tfragmentShader: depthShader.fragmentShader\n\t\t\t\t} );\n\n\t\t\t\tmaterialDepth.uniforms[ 'mNear' ].value = camera.near;\n\t\t\t\tmaterialDepth.uniforms[ 'mFar' ].value = camera.far;\n\n\t\t\t\t// skybox\n\n\t\t\t\tconst r = 'textures/cube/Bridge2/';\n\t\t\t\tconst urls = [ r + 'posx.jpg', r + 'negx.jpg',\n\t\t\t\t\t\t\t r + 'posy.jpg', r + 'negy.jpg',\n\t\t\t\t\t\t\t r + 'posz.jpg', r + 'negz.jpg' ];\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t// plane particles\n\n\t\t\t\tconst planePiece = new THREE.PlaneGeometry( 10, 10, 1, 1 );\n\n\t\t\t\tconst planeMat = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xffffff * 0.4,\n\t\t\t\t\tshininess: 0.5,\n\t\t\t\t\tspecular: 0xffffff,\n\t\t\t\t\tenvMap: textureCube,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tforceSinglePass: true\n\t\t\t\t} );\n\n\t\t\t\tconst rand = Math.random;\n\n\t\t\t\tfor ( let i = 0; i < leaves; i ++ ) {\n\n\t\t\t\t\tconst plane = new THREE.Mesh( planePiece, planeMat );\n\t\t\t\t\tplane.rotation.set( rand(), rand(), rand() );\n\t\t\t\t\tplane.rotation.dx = rand() * 0.1;\n\t\t\t\t\tplane.rotation.dy = rand() * 0.1;\n\t\t\t\t\tplane.rotation.dz = rand() * 0.1;\n\n\t\t\t\t\tplane.position.set( rand() * 150, 0 + rand() * 300, rand() * 150 );\n\t\t\t\t\tplane.position.dx = ( rand() - 0.5 );\n\t\t\t\t\tplane.position.dz = ( rand() - 0.5 );\n\t\t\t\t\tscene.add( plane );\n\t\t\t\t\tplanes.push( plane );\n\n\t\t\t\t}\n\n\t\t\t\t// adding Monkeys\n\n\t\t\t\tconst loader2 = new THREE.BufferGeometryLoader();\n\t\t\t\tloader2.load( 'models/json/suzanne_buffergeometry.json', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tspecular: 0xffffff,\n\t\t\t\t\t\tenvMap: textureCube,\n\t\t\t\t\t\tshininess: 50,\n\t\t\t\t\t\treflectivity: 1.0,\n\t\t\t\t\t\tflatShading: true\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst monkeys = 20;\n\n\t\t\t\t\tfor ( let i = 0; i < monkeys; i ++ ) {\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tmesh.position.z = Math.cos( i / monkeys * Math.PI * 2 ) * 200;\n\t\t\t\t\t\tmesh.position.y = Math.sin( i / monkeys * Math.PI * 3 ) * 20;\n\t\t\t\t\t\tmesh.position.x = Math.sin( i / monkeys * Math.PI * 2 ) * 200;\n\n\t\t\t\t\t\tmesh.rotation.y = i / monkeys * Math.PI * 2;\n\n\t\t\t\t\t\tmesh.scale.setScalar( 30 );\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// add balls\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 1, 20, 20 );\n\n\t\t\t\tfor ( let i = 0; i < 20; i ++ ) {\n\n\t\t\t\t\tconst ballmaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tcolor: 0xffffff * Math.random(),\n\t\t\t\t\t\tshininess: 0.5,\n\t\t\t\t\t\tspecular: 0xffffff,\n\t\t\t\t\t\tenvMap: textureCube } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, ballmaterial );\n\n\t\t\t\t\tmesh.position.x = ( Math.random() - 0.5 ) * 200;\n\t\t\t\t\tmesh.position.y = Math.random() * 50;\n\t\t\t\t\tmesh.position.z = ( Math.random() - 0.5 ) * 200;\n\t\t\t\t\tmesh.scale.multiplyScalar( 10 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst directionalLight1 = new THREE.DirectionalLight( 0xffffff, 6 );\n\t\t\t\tdirectionalLight1.position.set( 2, 1.2, 10 ).normalize();\n\t\t\t\tscene.add( directionalLight1 );\n\n\t\t\t\tconst directionalLight2 = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight2.position.set( - 2, 1.2, - 10 ).normalize();\n\t\t\t\tscene.add( directionalLight2 );\n\n\t\t\t\tinitPostprocessing();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\teffectController = {\n\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tjsDepthCalculation: true,\n\t\t\t\t\tshaderFocus: false,\n\n\t\t\t\t\tfstop: 2.2,\n\t\t\t\t\tmaxblur: 1.0,\n\n\t\t\t\t\tshowFocus: false,\n\t\t\t\t\tfocalDepth: 2.8,\n\t\t\t\t\tmanualdof: false,\n\t\t\t\t\tvignetting: false,\n\t\t\t\t\tdepthblur: false,\n\n\t\t\t\t\tthreshold: 0.5,\n\t\t\t\t\tgain: 2.0,\n\t\t\t\t\tbias: 0.5,\n\t\t\t\t\tfringe: 0.7,\n\n\t\t\t\t\tfocalLength: 35,\n\t\t\t\t\tnoise: true,\n\t\t\t\t\tpentagon: false,\n\n\t\t\t\t\tdithering: 0.0001\n\n\t\t\t\t};\n\n\t\t\t\tconst matChanger = function () {\n\n\t\t\t\t\tfor ( const e in effectController ) {\n\n\t\t\t\t\t\tif ( e in postprocessing.bokeh_uniforms ) {\n\n\t\t\t\t\t\t\tpostprocessing.bokeh_uniforms[ e ].value = effectController[ e ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpostprocessing.enabled = effectController.enabled;\n\t\t\t\t\tpostprocessing.bokeh_uniforms[ 'znear' ].value = camera.near;\n\t\t\t\t\tpostprocessing.bokeh_uniforms[ 'zfar' ].value = camera.far;\n\t\t\t\t\tcamera.setFocalLength( effectController.focalLength );\n\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( effectController, 'enabled' ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'jsDepthCalculation' ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'shaderFocus' ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'focalDepth', 0.0, 200.0 ).listen().onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'fstop', 0.1, 22, 0.001 ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'maxblur', 0.0, 5.0, 0.025 ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'showFocus' ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'manualdof' ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'vignetting' ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'depthblur' ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'threshold', 0, 1, 0.001 ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'gain', 0, 100, 0.001 ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'bias', 0, 3, 0.001 ).onChange( matChanger );\n\t\t\t\tgui.add( effectController, 'fringe', 0, 5, 0.001 ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'focalLength', 16, 80, 0.001 ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'noise' ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'dithering', 0, 0.001, 0.0001 ).onChange( matChanger );\n\n\t\t\t\tgui.add( effectController, 'pentagon' ).onChange( matChanger );\n\n\t\t\t\tgui.add( shaderSettings, 'rings', 1, 8 ).step( 1 ).onChange( shaderUpdate );\n\t\t\t\tgui.add( shaderSettings, 'samples', 1, 13 ).step( 1 ).onChange( shaderUpdate );\n\n\t\t\t\tmatChanger();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tpostprocessing.rtTextureDepth.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tpostprocessing.rtTextureColor.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'textureWidth' ].value = window.innerWidth;\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'textureHeight' ].value = window.innerHeight;\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouse.x = ( event.clientX - windowHalfX ) / windowHalfX;\n\t\t\t\tmouse.y = - ( event.clientY - windowHalfY ) / windowHalfY;\n\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'focusCoords' ].value.set( event.clientX / window.innerWidth, 1 - ( event.clientY / window.innerHeight ) );\n\n\t\t\t}\n\n\t\t\tfunction initPostprocessing() {\n\n\t\t\t\tpostprocessing.scene = new THREE.Scene();\n\n\t\t\t\tpostprocessing.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );\n\t\t\t\tpostprocessing.camera.position.z = 100;\n\n\t\t\t\tpostprocessing.scene.add( postprocessing.camera );\n\n\t\t\t\tpostprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType } );\n\t\t\t\tpostprocessing.rtTextureColor = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType } );\n\n\t\t\t\tconst bokeh_shader = BokehShader;\n\n\t\t\t\tpostprocessing.bokeh_uniforms = THREE.UniformsUtils.clone( bokeh_shader.uniforms );\n\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'tColor' ].value = postprocessing.rtTextureColor.texture;\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'tDepth' ].value = postprocessing.rtTextureDepth.texture;\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'textureWidth' ].value = window.innerWidth;\n\t\t\t\tpostprocessing.bokeh_uniforms[ 'textureHeight' ].value = window.innerHeight;\n\n\t\t\t\tpostprocessing.materialBokeh = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: postprocessing.bokeh_uniforms,\n\t\t\t\t\tvertexShader: bokeh_shader.vertexShader,\n\t\t\t\t\tfragmentShader: bokeh_shader.fragmentShader,\n\t\t\t\t\tdefines: {\n\t\t\t\t\t\tRINGS: shaderSettings.rings,\n\t\t\t\t\t\tSAMPLES: shaderSettings.samples\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tpostprocessing.quad = new THREE.Mesh( new THREE.PlaneGeometry( window.innerWidth, window.innerHeight ), postprocessing.materialBokeh );\n\t\t\t\tpostprocessing.quad.position.z = - 500;\n\t\t\t\tpostprocessing.scene.add( postprocessing.quad );\n\n\t\t\t}\n\n\t\t\tfunction shaderUpdate() {\n\n\t\t\t\tpostprocessing.materialBokeh.defines.RINGS = shaderSettings.rings;\n\t\t\t\tpostprocessing.materialBokeh.defines.SAMPLES = shaderSettings.samples;\n\t\t\t\tpostprocessing.materialBokeh.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction linearize( depth ) {\n\n\t\t\t\tconst zfar = camera.far;\n\t\t\t\tconst znear = camera.near;\n\t\t\t\treturn - zfar * znear / ( depth * ( zfar - znear ) - zfar );\n\n\t\t\t}\n\n\t\t\tfunction smoothstep( near, far, depth ) {\n\n\t\t\t\tconst x = saturate( ( depth - near ) / ( far - near ) );\n\t\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t\t}\n\n\t\t\tfunction saturate( x ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, x ) );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.00015;\n\n\t\t\t\tcamera.position.x = Math.cos( time ) * 400;\n\t\t\t\tcamera.position.z = Math.sin( time ) * 500;\n\t\t\t\tcamera.position.y = Math.sin( time / 1.4 ) * 100;\n\n\t\t\t\tcamera.lookAt( target );\n\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\tif ( effectController.jsDepthCalculation ) {\n\n\t\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObjects( scene.children, true );\n\n\t\t\t\t\tconst targetDistance = ( intersects.length > 0 ) ? intersects[ 0 ].distance : 1000;\n\n\t\t\t\t\tdistance += ( targetDistance - distance ) * 0.03;\n\n\t\t\t\t\tconst sdistance = smoothstep( camera.near, camera.far, distance );\n\n\t\t\t\t\tconst ldistance = linearize( 1 - sdistance );\n\n\t\t\t\t\tpostprocessing.bokeh_uniforms[ 'focalDepth' ].value = ldistance;\n\n\t\t\t\t\teffectController[ 'focalDepth' ] = ldistance;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < leaves; i ++ ) {\n\n\t\t\t\t\tconst plane = planes[ i ];\n\t\t\t\t\tplane.rotation.x += plane.rotation.dx;\n\t\t\t\t\tplane.rotation.y += plane.rotation.dy;\n\t\t\t\t\tplane.rotation.z += plane.rotation.dz;\n\t\t\t\t\tplane.position.y -= 2;\n\t\t\t\t\tplane.position.x += plane.position.dx;\n\t\t\t\t\tplane.position.z += plane.position.dz;\n\n\t\t\t\t\tif ( plane.position.y < 0 ) plane.position.y += 300;\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( postprocessing.enabled ) {\n\n\t\t\t\t\trenderer.clear();\n\n\t\t\t\t\t// render scene into texture\n\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureColor );\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t\t// render depth into texture\n\n\t\t\t\t\tscene.overrideMaterial = materialDepth;\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureDepth );\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( scene, camera );\n\t\t\t\t\tscene.overrideMaterial = null;\n\n\t\t\t\t\t// render bokeh composite\n\n\t\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\t\trenderer.render( postprocessing.scene, postprocessing.camera );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.overrideMaterial = null;\n\n\t\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - webgl realistic depth-of-field bokeh example shader ported from Martins Upitis"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates WebGL  - postprocessing - FXAA"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL  - postprocessing - FXAA:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { FXAAPass } from 'three/addons/postprocessing/FXAAPass.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls, container;\n\n\t\t\tlet composer1, composer2, fxaaPass;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 2000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d );\n\t\t\t\themiLight.position.set( 0, 1000, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3000, 1000, - 1000 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.TetrahedronGeometry( 10 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xf73232, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = Math.random() * 500 - 250;\n\t\t\t\t\tmesh.position.y = Math.random() * 500 - 250;\n\t\t\t\t\tmesh.position.z = Math.random() * 500 - 250;\n\n\t\t\t\t\tmesh.scale.setScalar( Math.random() * 2 + 1 );\n\n\t\t\t\t\tmesh.rotation.x = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.y = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.z = Math.random() * Math.PI;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( container.offsetWidth, container.offsetHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\trenderPass.clearAlpha = 0;\n\n\t\t\t\t//\n\n\t\t\t\tfxaaPass = new FXAAPass();\n\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tcomposer1 = new EffectComposer( renderer );\n\t\t\t\tcomposer1.addPass( renderPass );\n\t\t\t\tcomposer1.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\tcomposer2 = new EffectComposer( renderer );\n\t\t\t\tcomposer2.addPass( renderPass );\n\t\t\t\tcomposer2.addPass( outputPass );\n\n\t\t\t\t// FXAA is engineered to be applied towards the end of engine post processing after conversion to low dynamic range and conversion to the sRGB color space for display.\n\n\t\t\t\tcomposer2.addPass( fxaaPass );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = container.offsetWidth / container.offsetHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( container.offsetWidth, container.offsetHeight );\n\t\t\t\tcomposer1.setSize( container.offsetWidth, container.offsetHeight );\n\t\t\t\tcomposer2.setSize( container.offsetWidth, container.offsetHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst halfWidth = container.offsetWidth / 2;\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 0, 0, halfWidth - 1, container.offsetHeight );\n\t\t\t\tcomposer1.render();\n\n\t\t\t\trenderer.setScissor( halfWidth, 0, halfWidth, container.offsetHeight );\n\t\t\t\tcomposer2.render();\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n```\n\nThis example three.js - postprocessing - FXAA Left: No FXAA, Right: FXAA"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - digital glitch"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - digital glitch:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, composer;\n\t\t\tlet object, light;\n\n\t\t\tlet glitchPass;\n\n\t\t\tconst button = document.querySelector( '#startButton' );\n\t\t\tbutton.addEventListener( 'click', function () {\n\n\t\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\t\toverlay.remove();\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction updateOptions() {\n\n\t\t\t\tconst wildGlitch = document.getElementById( 'wildGlitch' );\n\t\t\t\tglitchPass.goWild = wildGlitch.checked;\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1, 1000 );\n\n\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 1, 4, 4 );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random(), flatShading: true } );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 ).normalize();\n\t\t\t\t\tmesh.position.multiplyScalar( Math.random() * 400 );\n\t\t\t\t\tmesh.rotation.set( Math.random() * 2, Math.random() * 2, Math.random() * 2 );\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 50;\n\t\t\t\t\tobject.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tlight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.addPass( new RenderPass( scene, camera ) );\n\n\t\t\t\tglitchPass = new GlitchPass();\n\t\t\t\tcomposer.addPass( glitchPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst wildGlitchOption = document.getElementById( 'wildGlitch' );\n\t\t\t\twildGlitchOption.addEventListener( 'change', updateOptions );\n\n\t\t\t\tupdateOptions();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tobject.rotation.x += 0.005;\n\t\t\t\tobject.rotation.y += 0.01;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example Glitch me wild:"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - godrays"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - godrays:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GodRaysFakeSunShader, GodRaysDepthMaskShader, GodRaysCombineShader, GodRaysGenerateShader } from 'three/addons/shaders/GodRaysShader.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, materialDepth;\n\n\t\t\tlet sphereMesh;\n\n\t\t\tconst sunPosition = new THREE.Vector3( 0, 1000, - 1000 );\n\t\t\tconst clipPosition = new THREE.Vector4();\n\t\t\tconst screenSpacePosition = new THREE.Vector3();\n\n\t\t\tconst postprocessing = { enabled: true };\n\n\t\t\tconst orbitRadius = 200;\n\n\t\t\tconst bgColor = 0x000511;\n\t\t\tconst sunColor = 0xffee00;\n\n\t\t\t// Use a smaller size for some of the god-ray render targets for better performance.\n\t\t\tconst godrayRenderTargetResolutionMultiplier = 1.0 / 4.0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 3000 );\n\t\t\t\tcamera.position.z = 200;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tmaterialDepth = new THREE.MeshDepthMaterial();\n\n\t\t\t\t// tree\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/tree.obj', function ( object ) {\n\n\t\t\t\t\tobject.position.set( 0, - 150, - 150 );\n\t\t\t\t\tobject.scale.multiplyScalar( 400 );\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t// sphere\n\n\t\t\t\tconst geo = new THREE.SphereGeometry( 1, 20, 10 );\n\t\t\t\tsphereMesh = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );\n\t\t\t\tsphereMesh.scale.multiplyScalar( 20 );\n\t\t\t\tscene.add( sphereMesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setClearColor( 0xffffff );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 50;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tinitPostprocessing( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst renderTargetWidth = window.innerWidth;\n\t\t\t\tconst renderTargetHeight = window.innerHeight;\n\n\t\t\t\tcamera.aspect = renderTargetWidth / renderTargetHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( renderTargetWidth, renderTargetHeight );\n\t\t\t\tpostprocessing.rtTextureColors.setSize( renderTargetWidth, renderTargetHeight );\n\t\t\t\tpostprocessing.rtTextureDepth.setSize( renderTargetWidth, renderTargetHeight );\n\t\t\t\tpostprocessing.rtTextureDepthMask.setSize( renderTargetWidth, renderTargetHeight );\n\n\t\t\t\tconst adjustedWidth = renderTargetWidth * godrayRenderTargetResolutionMultiplier;\n\t\t\t\tconst adjustedHeight = renderTargetHeight * godrayRenderTargetResolutionMultiplier;\n\t\t\t\tpostprocessing.rtTextureGodRays1.setSize( adjustedWidth, adjustedHeight );\n\t\t\t\tpostprocessing.rtTextureGodRays2.setSize( adjustedWidth, adjustedHeight );\n\n\t\t\t}\n\n\t\t\tfunction initPostprocessing( renderTargetWidth, renderTargetHeight ) {\n\n\t\t\t\tpostprocessing.scene = new THREE.Scene();\n\n\t\t\t\tpostprocessing.camera = new THREE.OrthographicCamera( - 0.5, 0.5, 0.5, - 0.5, - 10000, 10000 );\n\t\t\t\tpostprocessing.camera.position.z = 100;\n\n\t\t\t\tpostprocessing.scene.add( postprocessing.camera );\n\n\t\t\t\tpostprocessing.rtTextureColors = new THREE.WebGLRenderTarget( renderTargetWidth, renderTargetHeight, { type: THREE.HalfFloatType } );\n\n\t\t\t\t// I would have this quarter size and use it as one of the ping-pong render\n\t\t\t\t// targets but the aliasing causes some temporal flickering\n\n\t\t\t\tpostprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( renderTargetWidth, renderTargetHeight, { type: THREE.HalfFloatType } );\n\t\t\t\tpostprocessing.rtTextureDepthMask = new THREE.WebGLRenderTarget( renderTargetWidth, renderTargetHeight, { type: THREE.HalfFloatType } );\n\n\t\t\t\t// The ping-pong render targets can use an adjusted resolution to minimize cost\n\n\t\t\t\tconst adjustedWidth = renderTargetWidth * godrayRenderTargetResolutionMultiplier;\n\t\t\t\tconst adjustedHeight = renderTargetHeight * godrayRenderTargetResolutionMultiplier;\n\t\t\t\tpostprocessing.rtTextureGodRays1 = new THREE.WebGLRenderTarget( adjustedWidth, adjustedHeight, { type: THREE.HalfFloatType } );\n\t\t\t\tpostprocessing.rtTextureGodRays2 = new THREE.WebGLRenderTarget( adjustedWidth, adjustedHeight, { type: THREE.HalfFloatType } );\n\n\t\t\t\t// god-ray shaders\n\n\t\t\t\tconst godraysMaskShader = GodRaysDepthMaskShader;\n\t\t\t\tpostprocessing.godrayMaskUniforms = THREE.UniformsUtils.clone( godraysMaskShader.uniforms );\n\t\t\t\tpostprocessing.materialGodraysDepthMask = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: postprocessing.godrayMaskUniforms,\n\t\t\t\t\tvertexShader: godraysMaskShader.vertexShader,\n\t\t\t\t\tfragmentShader: godraysMaskShader.fragmentShader\n\n\t\t\t\t} );\n\n\t\t\t\tconst godraysGenShader = GodRaysGenerateShader;\n\t\t\t\tpostprocessing.godrayGenUniforms = THREE.UniformsUtils.clone( godraysGenShader.uniforms );\n\t\t\t\tpostprocessing.materialGodraysGenerate = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: postprocessing.godrayGenUniforms,\n\t\t\t\t\tvertexShader: godraysGenShader.vertexShader,\n\t\t\t\t\tfragmentShader: godraysGenShader.fragmentShader\n\n\t\t\t\t} );\n\n\t\t\t\tconst godraysCombineShader = GodRaysCombineShader;\n\t\t\t\tpostprocessing.godrayCombineUniforms = THREE.UniformsUtils.clone( godraysCombineShader.uniforms );\n\t\t\t\tpostprocessing.materialGodraysCombine = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: postprocessing.godrayCombineUniforms,\n\t\t\t\t\tvertexShader: godraysCombineShader.vertexShader,\n\t\t\t\t\tfragmentShader: godraysCombineShader.fragmentShader\n\n\t\t\t\t} );\n\n\t\t\t\tconst godraysFakeSunShader = GodRaysFakeSunShader;\n\t\t\t\tpostprocessing.godraysFakeSunUniforms = THREE.UniformsUtils.clone( godraysFakeSunShader.uniforms );\n\t\t\t\tpostprocessing.materialGodraysFakeSun = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: postprocessing.godraysFakeSunUniforms,\n\t\t\t\t\tvertexShader: godraysFakeSunShader.vertexShader,\n\t\t\t\t\tfragmentShader: godraysFakeSunShader.fragmentShader\n\n\t\t\t\t} );\n\n\t\t\t\tpostprocessing.godraysFakeSunUniforms.bgColor.value.setHex( bgColor );\n\t\t\t\tpostprocessing.godraysFakeSunUniforms.sunColor.value.setHex( sunColor );\n\n\t\t\t\tpostprocessing.godrayCombineUniforms.fGodRayIntensity.value = 0.75;\n\n\t\t\t\tpostprocessing.quad = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 1.0, 1.0 ),\n\t\t\t\t\tpostprocessing.materialGodraysGenerate\n\t\t\t\t);\n\t\t\t\tpostprocessing.quad.position.z = - 9900;\n\t\t\t\tpostprocessing.scene.add( postprocessing.quad );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction getStepSize( filterLen, tapsPerPass, pass ) {\n\n\t\t\t\treturn filterLen * Math.pow( tapsPerPass, - pass );\n\n\t\t\t}\n\n\t\t\tfunction filterGodRays( inputTex, renderTarget, stepSize ) {\n\n\t\t\t\tpostprocessing.scene.overrideMaterial = postprocessing.materialGodraysGenerate;\n\n\t\t\t\tpostprocessing.godrayGenUniforms[ 'fStepSize' ].value = stepSize;\n\t\t\t\tpostprocessing.godrayGenUniforms[ 'tInput' ].value = inputTex;\n\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( postprocessing.scene, postprocessing.camera );\n\t\t\t\tpostprocessing.scene.overrideMaterial = null;\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() / 4000;\n\n\t\t\t\tsphereMesh.position.x = orbitRadius * Math.cos( time );\n\t\t\t\tsphereMesh.position.z = orbitRadius * Math.sin( time ) - 100;\n\n\t\t\t\tif ( postprocessing.enabled ) {\n\n\t\t\t\t\tclipPosition.x = sunPosition.x;\n\t\t\t\t\tclipPosition.y = sunPosition.y;\n\t\t\t\t\tclipPosition.z = sunPosition.z;\n\t\t\t\t\tclipPosition.w = 1;\n\n\t\t\t\t\tclipPosition.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t\t\t\t\t// perspective divide (produce NDC space)\n\n\t\t\t\t\tclipPosition.x /= clipPosition.w;\n\t\t\t\t\tclipPosition.y /= clipPosition.w;\n\n\t\t\t\t\tscreenSpacePosition.x = ( clipPosition.x + 1 ) / 2; // transform from [-1,1] to [0,1]\n\t\t\t\t\tscreenSpacePosition.y = ( clipPosition.y + 1 ) / 2; // transform from [-1,1] to [0,1]\n\t\t\t\t\tscreenSpacePosition.z = clipPosition.z; // needs to stay in clip space for visibility checks\n\n\t\t\t\t\t// Give it to the god-ray and sun shaders\n\n\t\t\t\t\tpostprocessing.godrayGenUniforms[ 'vSunPositionScreenSpace' ].value.copy( screenSpacePosition );\n\t\t\t\t\tpostprocessing.godraysFakeSunUniforms[ 'vSunPositionScreenSpace' ].value.copy( screenSpacePosition );\n\n\t\t\t\t\t// -- Draw sky and sun --\n\n\t\t\t\t\t// Clear colors and depths, will clear to sky color\n\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureColors );\n\t\t\t\t\trenderer.clear( true, true, false );\n\n\t\t\t\t\t// Sun render. Runs a shader that gives a brightness based on the screen\n\t\t\t\t\t// space distance to the sun. Not very efficient, so i make a scissor\n\t\t\t\t\t// rectangle around the suns position to avoid rendering surrounding pixels.\n\n\t\t\t\t\tconst sunsqH = 0.74 * window.innerHeight; // 0.74 depends on extent of sun from shader\n\t\t\t\t\tconst sunsqW = 0.74 * window.innerHeight; // both depend on height because sun is aspect-corrected\n\n\t\t\t\t\tscreenSpacePosition.x *= window.innerWidth;\n\t\t\t\t\tscreenSpacePosition.y *= window.innerHeight;\n\n\t\t\t\t\trenderer.setScissor( screenSpacePosition.x - sunsqW / 2, screenSpacePosition.y - sunsqH / 2, sunsqW, sunsqH );\n\t\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\t\tpostprocessing.godraysFakeSunUniforms[ 'fAspect' ].value = window.innerWidth / window.innerHeight;\n\n\t\t\t\t\tpostprocessing.scene.overrideMaterial = postprocessing.materialGodraysFakeSun;\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureColors );\n\t\t\t\t\trenderer.render( postprocessing.scene, postprocessing.camera );\n\n\t\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t\t\t// -- Draw scene objects --\n\n\t\t\t\t\t// Colors\n\n\t\t\t\t\tscene.overrideMaterial = null;\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureColors );\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t\t// Depth\n\n\t\t\t\t\tscene.overrideMaterial = materialDepth;\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureDepth );\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tpostprocessing.godrayMaskUniforms[ 'tInput' ].value = postprocessing.rtTextureDepth.texture;\n\n\t\t\t\t\tpostprocessing.scene.overrideMaterial = postprocessing.materialGodraysDepthMask;\n\t\t\t\t\trenderer.setRenderTarget( postprocessing.rtTextureDepthMask );\n\t\t\t\t\trenderer.render( postprocessing.scene, postprocessing.camera );\n\n\t\t\t\t\t// -- Render god-rays --\n\n\t\t\t\t\t// Maximum length of god-rays (in texture space [0,1]X[0,1])\n\n\t\t\t\t\tconst filterLen = 1.0;\n\n\t\t\t\t\t// Samples taken by filter\n\n\t\t\t\t\tconst TAPS_PER_PASS = 6.0;\n\n\t\t\t\t\t// Pass order could equivalently be 3,2,1 (instead of 1,2,3), which\n\t\t\t\t\t// would start with a small filter support and grow to large. however\n\t\t\t\t\t// the large-to-small order produces less objectionable aliasing artifacts that\n\t\t\t\t\t// appear as a glimmer along the length of the beams\n\n\t\t\t\t\t// pass 1 - render into first ping-pong target\n\t\t\t\t\tfilterGodRays( postprocessing.rtTextureDepthMask.texture, postprocessing.rtTextureGodRays2, getStepSize( filterLen, TAPS_PER_PASS, 1.0 ) );\n\n\t\t\t\t\t// pass 2 - render into second ping-pong target\n\t\t\t\t\tfilterGodRays( postprocessing.rtTextureGodRays2.texture, postprocessing.rtTextureGodRays1, getStepSize( filterLen, TAPS_PER_PASS, 2.0 ) );\n\n\t\t\t\t\t// pass 3 - 1st RT\n\t\t\t\t\tfilterGodRays( postprocessing.rtTextureGodRays1.texture, postprocessing.rtTextureGodRays2, getStepSize( filterLen, TAPS_PER_PASS, 3.0 ) );\n\n\t\t\t\t\t// final pass - composite god-rays onto colors\n\n\t\t\t\t\tpostprocessing.godrayCombineUniforms[ 'tColors' ].value = postprocessing.rtTextureColors.texture;\n\t\t\t\t\tpostprocessing.godrayCombineUniforms[ 'tGodRays' ].value = postprocessing.rtTextureGodRays2.texture;\n\n\t\t\t\t\tpostprocessing.scene.overrideMaterial = postprocessing.materialGodraysCombine;\n\n\t\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\t\trenderer.render( postprocessing.scene, postprocessing.camera );\n\t\t\t\t\tpostprocessing.scene.overrideMaterial = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - webgl god-rays example - tree by stanloshka"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - GTAO"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - GTAO:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, composer, controls, clock, stats, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\t\tloader.setPath( 'models/gltf/' );\n\n\t\t\t\tclock = new THREE.Clock();\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfe3dd );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 5, 2, 8 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.update();\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tcomposer.addPass( renderPass );\n\n\t\t\t\tconst gtaoPass = new GTAOPass( scene, camera, width, height );\n\t\t\t\tgtaoPass.output = GTAOPass.OUTPUT.Denoise;\n\t\t\t\tcomposer.addPass( gtaoPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\tloader.load( 'LittlestTokyo.glb', ( gltf ) => {\n\n\t\t\t\t\tconst model = gltf.scene;\n\t\t\t\t\tmodel.position.set( 1, 1, 0 );\n\t\t\t\t\tmodel.scale.set( 0.01, 0.01, 0.01 );\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\t\tconst box = new THREE.Box3().setFromObject( scene );\n\t\t\t\t\tgtaoPass.setSceneClipBox( box );\n\n\t\t\t\t}, undefined, ( e ) => console.error( e ) );\n\n\t\t\t\t// Init gui\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( gtaoPass, 'output', {\n\t\t\t\t\t'Default': GTAOPass.OUTPUT.Default,\n\t\t\t\t\t'Diffuse': GTAOPass.OUTPUT.Diffuse,\n\t\t\t\t\t'AO Only': GTAOPass.OUTPUT.AO,\n\t\t\t\t\t'AO Only + Denoise': GTAOPass.OUTPUT.Denoise,\n\t\t\t\t\t'Depth': GTAOPass.OUTPUT.Depth,\n\t\t\t\t\t'Normal': GTAOPass.OUTPUT.Normal\n\t\t\t\t} ).onChange( function ( value ) {\n\n\t\t\t\t\tgtaoPass.output = value;\n\n\t\t\t\t} );\n\n\t\t\t\tconst aoParameters = {\n\t\t\t\t\tradius: 0.25,\n\t\t\t\t\tdistanceExponent: 1.,\n\t\t\t\t\tthickness: 1.,\n\t\t\t\t\tscale: 1.,\n\t\t\t\t\tsamples: 16,\n\t\t\t\t\tdistanceFallOff: 1.,\n\t\t\t\t\tscreenSpaceRadius: false,\n\t\t\t\t};\n\t\t\t\tconst pdParameters = {\n\t\t\t\t\tlumaPhi: 10.,\n\t\t\t\t\tdepthPhi: 2.,\n\t\t\t\t\tnormalPhi: 3.,\n\t\t\t\t\tradius: 4.,\n\t\t\t\t\tradiusExponent: 1.,\n\t\t\t\t\trings: 2.,\n\t\t\t\t\tsamples: 16,\n\t\t\t\t};\n\t\t\t\tgtaoPass.updateGtaoMaterial( aoParameters );\n\t\t\t\tgtaoPass.updatePdMaterial( pdParameters );\n\t\t\t\tgui.add( gtaoPass, 'blendIntensity' ).min( 0 ).max( 1 ).step( 0.01 );\n\t\t\t\tgui.add( aoParameters, 'radius' ).min( 0.01 ).max( 1 ).step( 0.01 ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( aoParameters, 'distanceExponent' ).min( 1 ).max( 4 ).step( 0.01 ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( aoParameters, 'thickness' ).min( 0.01 ).max( 10 ).step( 0.01 ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( aoParameters, 'distanceFallOff' ).min( 0 ).max( 1 ).step( 0.01 ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( aoParameters, 'scale' ).min( 0.01 ).max( 2.0 ).step( 0.01 ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( aoParameters, 'samples' ).min( 2 ).max( 32 ).step( 1 ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( aoParameters, 'screenSpaceRadius' ).onChange( () => gtaoPass.updateGtaoMaterial( aoParameters ) );\n\t\t\t\tgui.add( pdParameters, 'lumaPhi' ).min( 0 ).max( 20 ).step( 0.01 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\tgui.add( pdParameters, 'depthPhi' ).min( 0.01 ).max( 20 ).step( 0.01 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\tgui.add( pdParameters, 'normalPhi' ).min( 0.01 ).max( 20 ).step( 0.01 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\tgui.add( pdParameters, 'radius' ).min( 0 ).max( 32 ).step( 1 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\tgui.add( pdParameters, 'radiusExponent' ).min( 0.1 ).max( 4. ).step( 0.1 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\tgui.add( pdParameters, 'rings' ).min( 1 ).max( 16 ).step( 0.125 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\tgui.add( pdParameters, 'samples' ).min( 2 ).max( 32 ).step( 1 ).onChange( () => gtaoPass.updatePdMaterial( pdParameters ) );\n\t\t\t\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.begin();\n\t\t\t\tcomposer.render();\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - Ground Truth Ambient Occlusion (GTAO) by Rabbid76"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing RGB Halftone"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing RGB Halftone:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';\n\n\t\t\tlet renderer, clock, camera, stats;\n\n\t\t\tconst rotationSpeed = Math.PI / 64;\n\n\t\t\tlet composer, group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 12;\n\n\t\t\t\tstats = new Stats();\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// camera controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// scene\n\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 100, 1, 100 ), new THREE.MeshPhongMaterial( {} ) );\n\t\t\t\tfloor.position.y = - 10;\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 250 );\n\t\t\t\tlight.position.y = 2;\n\t\t\t\tgroup.add( floor, light );\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst mat = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {},\n\n\t\t\t\t\tvertexShader: [\n\t\t\t\t\t\t'varying vec2 vUV;',\n\t\t\t\t\t\t'varying vec3 vNormal;',\n\n\t\t\t\t\t\t'void main() {',\n\n\t\t\t\t\t\t'vUV = uv;',\n\t\t\t\t\t\t'vNormal = vec3( normal );',\n\t\t\t\t\t\t'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t\t\t\t'}'\n\t\t\t\t\t].join( '\\n' ),\n\n\t\t\t\t\tfragmentShader: [\n\t\t\t\t\t\t'varying vec2 vUV;',\n\t\t\t\t\t\t'varying vec3 vNormal;',\n\n\t\t\t\t\t\t'void main() {',\n\n\t\t\t\t\t\t'vec4 c = vec4( abs( vNormal ) + vec3( vUV, 0.0 ), 0.0 );',\n\t\t\t\t\t\t'gl_FragColor = c;',\n\n\t\t\t\t\t\t'}'\n\t\t\t\t\t].join( '\\n' )\n\t\t\t\t} );\n\n\t\t\t\tfor ( let i = 0; i < 50; ++ i ) {\n\n\t\t\t\t\t// fill scene with coloured cubes\n\t\t\t\t\tconst mesh = new THREE.Mesh( new THREE.BoxGeometry( 2, 2, 2 ), mat );\n\t\t\t\t\tmesh.position.set( Math.random() * 16 - 8, Math.random() * 16 - 8, Math.random() * 16 - 8 );\n\t\t\t\t\tmesh.rotation.set( Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2 );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// post-processing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tconst params = {\n\t\t\t\t\tshape: 1,\n\t\t\t\t\tradius: 4,\n\t\t\t\t\trotateR: Math.PI / 12,\n\t\t\t\t\trotateB: Math.PI / 12 * 2,\n\t\t\t\t\trotateG: Math.PI / 12 * 3,\n\t\t\t\t\tscatter: 0,\n\t\t\t\t\tblending: 1,\n\t\t\t\t\tblendingMode: 1,\n\t\t\t\t\tgreyscale: false,\n\t\t\t\t\tdisable: false\n\t\t\t\t};\n\t\t\t\tconst halftonePass = new HalftonePass( params );\n\t\t\t\tcomposer.addPass( renderPass );\n\t\t\t\tcomposer.addPass( halftonePass );\n\n\t\t\t\twindow.onresize = function () {\n\n\t\t\t\t\t// resize composer\n\t\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t};\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst controller = {\n\t\t\t\t\tradius: halftonePass.uniforms[ 'radius' ].value,\n\t\t\t\t\trotateR: halftonePass.uniforms[ 'rotateR' ].value / ( Math.PI / 180 ),\n\t\t\t\t\trotateG: halftonePass.uniforms[ 'rotateG' ].value / ( Math.PI / 180 ),\n\t\t\t\t\trotateB: halftonePass.uniforms[ 'rotateB' ].value / ( Math.PI / 180 ),\n\t\t\t\t\tscatter: halftonePass.uniforms[ 'scatter' ].value,\n\t\t\t\t\tshape: halftonePass.uniforms[ 'shape' ].value,\n\t\t\t\t\tgreyscale: halftonePass.uniforms[ 'greyscale' ].value,\n\t\t\t\t\tblending: halftonePass.uniforms[ 'blending' ].value,\n\t\t\t\t\tblendingMode: halftonePass.uniforms[ 'blendingMode' ].value,\n\t\t\t\t\tdisable: halftonePass.uniforms[ 'disable' ].value\n\t\t\t\t};\n\n\t\t\t\tfunction onGUIChange() {\n\n\t\t\t\t\t// update uniforms\n\t\t\t\t\thalftonePass.uniforms[ 'radius' ].value = controller.radius;\n\t\t\t\t\thalftonePass.uniforms[ 'rotateR' ].value = controller.rotateR * ( Math.PI / 180 );\n\t\t\t\t\thalftonePass.uniforms[ 'rotateG' ].value = controller.rotateG * ( Math.PI / 180 );\n\t\t\t\t\thalftonePass.uniforms[ 'rotateB' ].value = controller.rotateB * ( Math.PI / 180 );\n\t\t\t\t\thalftonePass.uniforms[ 'scatter' ].value = controller.scatter;\n\t\t\t\t\thalftonePass.uniforms[ 'shape' ].value = controller.shape;\n\t\t\t\t\thalftonePass.uniforms[ 'greyscale' ].value = controller.greyscale;\n\t\t\t\t\thalftonePass.uniforms[ 'blending' ].value = controller.blending;\n\t\t\t\t\thalftonePass.uniforms[ 'blendingMode' ].value = controller.blendingMode;\n\t\t\t\t\thalftonePass.uniforms[ 'disable' ].value = controller.disable;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( controller, 'shape', { 'Dot': 1, 'Ellipse': 2, 'Line': 3, 'Square': 4 } ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'radius', 1, 25 ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'rotateR', 0, 90 ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'rotateG', 0, 90 ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'rotateB', 0, 90 ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'scatter', 0, 1, 0.01 ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'greyscale' ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'blending', 0, 1, 0.01 ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'blendingMode', { 'Linear': 1, 'Multiply': 2, 'Add': 3, 'Lighter': 4, 'Darker': 5 } ).onChange( onGUIChange );\n\t\t\t\tgui.add( controller, 'disable' ).onChange( onGUIChange );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\t\t\t\tstats.update();\n\t\t\t\tgroup.rotation.y += delta * rotationSpeed;\n\t\t\t\tcomposer.render( delta );\n\n\t\t\t}\n```\n\nThis example three.js - RGB Halftone post-processing by Xavier Burrow"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - masking"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - masking:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { TexturePass } from 'three/addons/postprocessing/TexturePass.js';\n\t\t\timport { ClearPass } from 'three/addons/postprocessing/ClearPass.js';\n\t\t\timport { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, composer, renderer;\n\t\t\tlet box, torus;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tconst scene1 = new THREE.Scene();\n\t\t\t\tconst scene2 = new THREE.Scene();\n\n\t\t\t\tbox = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ) );\n\t\t\t\tscene1.add( box );\n\n\t\t\t\ttorus = new THREE.Mesh( new THREE.TorusGeometry( 3, 1, 16, 32 ) );\n\t\t\t\tscene2.add( torus );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setClearColor( 0xe0e0e0 );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst clearPass = new ClearPass();\n\n\t\t\t\tconst clearMaskPass = new ClearMaskPass();\n\n\t\t\t\tconst maskPass1 = new MaskPass( scene1, camera );\n\t\t\t\tconst maskPass2 = new MaskPass( scene2, camera );\n\n\t\t\t\tconst texture1 = new THREE.TextureLoader().load( 'textures/758px-Canestra_di_frutta_(Caravaggio).jpg' );\n\t\t\t\ttexture1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture1.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture1.generateMipmaps = false;\n\t\t\t\tconst texture2 = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );\n\t\t\t\ttexture2.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst texturePass1 = new TexturePass( texture1 );\n\t\t\t\tconst texturePass2 = new TexturePass( texture2 );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tconst parameters = {\n\t\t\t\t\tstencilBuffer: true\n\t\t\t\t};\n\n\t\t\t\tconst renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, parameters );\n\n\t\t\t\tcomposer = new EffectComposer( renderer, renderTarget );\n\t\t\t\tcomposer.addPass( clearPass );\n\t\t\t\tcomposer.addPass( maskPass1 );\n\t\t\t\tcomposer.addPass( texturePass1 );\n\t\t\t\tcomposer.addPass( clearMaskPass );\n\t\t\t\tcomposer.addPass( maskPass2 );\n\t\t\t\tcomposer.addPass( texturePass2 );\n\t\t\t\tcomposer.addPass( clearMaskPass );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() * 0.001 + 6000;\n\n\t\t\t\tbox.position.x = Math.cos( time / 1.5 ) * 2;\n\t\t\t\tbox.position.y = Math.sin( time ) * 2;\n\t\t\t\tbox.rotation.x = time;\n\t\t\t\tbox.rotation.y = time / 2;\n\n\t\t\t\ttorus.position.x = Math.cos( time ) * 2;\n\t\t\t\ttorus.position.y = Math.sin( time / 1.5 ) * 2;\n\t\t\t\ttorus.rotation.x = time;\n\t\t\t\ttorus.rotation.y = time / 2;\n\n\t\t\t\trenderer.clear();\n\t\t\t\tcomposer.render( time );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - GTAO"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - GTAO:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { MeshPostProcessingMaterial } from 'three/addons/materials/MeshPostProcessingMaterial.js';\n\n\t\t\tlet renderer, camera, scene, composer, controls, stats;\n\t\t\tconst sceneParameters = {\n\t\t\t\toutput: 0,\n\t\t\t\tenvMapIntensity: 1.0,\n\t\t\t\tambientLightIntensity: 0.0,\n\t\t\t\tlightIntensity: 50,\n\t\t\t\tshadow: true,\n\t\t\t};\n\t\t\tconst aoParameters = {\n\t\t\t\tradius: 0.5,\n\t\t\t\tdistanceExponent: 2.,\n\t\t\t\tthickness: 10.,\n\t\t\t\tscale: 1.,\n\t\t\t\tsamples: 16,\n\t\t\t\tdistanceFallOff: 1.,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.shadowMap.enabled = sceneParameters.shadow;\n\n\t\t\t\tconst plyLoader = new PLYLoader();\n\t\t\t\tconst rgbeloader = new RGBELoader();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 50 );\n\t\t\t\tcamera.position.set( 0, 3, 5 );\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tconst gtaoPass = new GTAOPass( scene, camera, width, height );\n\t\t\t\tgtaoPass.output = GTAOPass.OUTPUT.Off;\n\t\t\t\tconst renderPasse = new RenderPass( scene, camera );\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tcomposer.addPass( gtaoPass );\n\t\t\t\tcomposer.addPass( renderPasse );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\trgbeloader.load( 'textures/equirectangular/royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t} );\n\t\t\t\n\t\t\t\tconst groundMaterial = new MeshPostProcessingMaterial( { color: 0x7f7f7f, envMapIntensity: sceneParameters.envMapIntensity, aoPassMap: gtaoPass.gtaoMap } );\n\t\t\t\tconst objectMaterial = new MeshPostProcessingMaterial( { color: 0xffffff, roughness: 0.5, metalness: 0.5, envMapIntensity: sceneParameters.envMapIntensity, aoPassMap: gtaoPass.gtaoMap } );\n\t\t\t\tconst emissiveMaterial = new MeshPostProcessingMaterial( { color: 0, emissive: 0xffffff, aoPassMap: gtaoPass.gtaoMap } );\n\t\t\t\tplyLoader.load( 'models/ply/binary/Lucy100k.ply', ( geometry ) => {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\tconst lucy = new THREE.Mesh( geometry, objectMaterial );\n\t\t\t\t\tlucy.receiveShadow = true;\n\t\t\t\t\tlucy.castShadow = true;\n\t\t\t\t\tlucy.scale.setScalar( 0.001 );\n\t\t\t\t\tlucy.rotation.set( 0, Math.PI, 0 );\n\t\t\t\t\tlucy.position.set( 0.04, 1.8, 0.02 );\n\t\t\t\t\tscene.add( lucy );\n\n\t\t\t\t} );\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, sceneParameters.ambientLightIntensity );\n\t\t\t\tconst lightGroup = new THREE.Group();\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 6, 6 );\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 0.5, 0.5, 1, 64 );\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.5, 32, 32 );\n\t\t\t\tconst lightSphereGeometry = new THREE.SphereGeometry( 0.1, 32, 32 );\n\t\t\t\tscene.background = new THREE.Color( 0xbfe3dd );\n\t\t\t\tscene.add( ambientLight );\n\t\t\t\tscene.add( lightGroup );\n\t\t\t\tconst targetObject = new THREE.Object3D();\n\t\t\t\ttargetObject.position.set( 0, 1, 0 );\n\t\t\t\tscene.add( targetObject );\n\t\t\t\tconst lightColors = [ 0xff4040, 0x40ff40, 0x4040ff ];\n\t\t\t\tfor ( let j = 0; j < 3; ++ j ) {\n\n\t\t\t\t\tconst light = new THREE.SpotLight( lightColors[ j ], sceneParameters.lightIntensity, 0, Math.PI / 9 );\n\t\t\t\t\tlight.castShadow = true;\n\t\t\t\t\tlight.shadow.camera.far = 15;\n\t\t\t\t\tlight.position.set( 5 * Math.cos( Math.PI * j * 2 / 3 ), 2.5, 5 * Math.sin( Math.PI * j * 2 / 3 ) );\n\t\t\t\t\tlight.target = targetObject;\n\t\t\t\t\tlightGroup.add( light );\n\n\t\t\t\t}\n\n\t\t\t\tconst groundPlane = new THREE.Mesh( planeGeometry, groundMaterial );\n\t\t\t\tgroundPlane.rotation.x = - Math.PI / 2;\n\t\t\t\tgroundPlane.position.set( 0, 0, 0 );\n\t\t\t\tgroundPlane.receiveShadow = true;\n\t\t\t\tscene.add( groundPlane );\n\t\t\t\tconst pedestal = new THREE.Mesh( cylinderGeometry, groundMaterial );\n\t\t\t\tpedestal.position.set( 0, 0.5, 0 );\n\t\t\t\tpedestal.receiveShadow = true;\n\t\t\t\tpedestal.castShadow = true;\n\t\t\t\tscene.add( pedestal );\n\t\t\t\tconst sphereMesh = new THREE.InstancedMesh( sphereGeometry, objectMaterial, 6 );\n\t\t\t\tsphereMesh.receiveShadow = true;\n\t\t\t\tsphereMesh.castShadow = true;\n\t\t\t\tscene.add( sphereMesh );\n\t\t\t\t[ ...Array( 6 ).keys() ].forEach( ( i ) => sphereMesh.setMatrixAt( i, new THREE.Matrix4().makeTranslation( Math.cos( Math.PI * i / 3 ), 0.5, Math.sin( Math.PI * i / 3 ) ) ) );\n\t\t\t\tconst lightSphereMesh = new THREE.InstancedMesh( lightSphereGeometry, emissiveMaterial, 4 );\n\t\t\t\tscene.add( lightSphereMesh );\n\t\t\t\t[ ...Array( 4 ).keys() ].forEach( ( i ) => lightSphereMesh.setMatrixAt( i, new THREE.Matrix4().makeTranslation( 0.4 * Math.cos( Math.PI * ( i + 0.5 ) / 2 ), 1.1, 0.45 * Math.sin( Math.PI * ( i + 0.5 ) / 2 ) ) ) );\n\n\t\t\t\tconst updateGtaoMaterial = () => gtaoPass.updateGtaoMaterial( aoParameters );\n\t\t\t\tconst updateOutput = () => {\n\n\t\t\t\t\tcomposer.removePass( gtaoPass );\n\t\t\t\t\tcomposer.insertPass( gtaoPass, sceneParameters.output == 1 ? 1 : 0 );\n\n\t\t\t\t\tswitch ( sceneParameters.output ) {\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tgtaoPass.output = GTAOPass.OUTPUT.Off;\n\t\t\t\t\t\t\tgtaoPass.enabled = true;\n\t\t\t\t\t\t\trenderPasse.enabled = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tgtaoPass.output = GTAOPass.OUTPUT.Default;\n\t\t\t\t\t\t\tgtaoPass.enabled = true;\n\t\t\t\t\t\t\trenderPasse.enabled = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tgtaoPass.output = GTAOPass.OUTPUT.Diffuse;\n\t\t\t\t\t\t\tgtaoPass.enabled = false;\n\t\t\t\t\t\t\trenderPasse.enabled = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tgtaoPass.output = GTAOPass.OUTPUT.Denoise;\n\t\t\t\t\t\t\tgtaoPass.enabled = true;\n\t\t\t\t\t\t\trenderPasse.enabled = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroundMaterial.aoPassMap = sceneParameters.output === 0 ? gtaoPass.gtaoMap : null;\n\t\t\t\t\tobjectMaterial.aoPassMap = sceneParameters.output === 0 ? gtaoPass.gtaoMap : null;\n\n\t\t\t\t};\n\n\t\t\t\tupdateOutput();\n\t\t\t\tupdateGtaoMaterial();\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( sceneParameters, 'output', {\n\t\t\t\t\t'material AO': 0,\n\t\t\t\t\t'post blended AO': 1,\n\t\t\t\t\t'only diffuse': 2,\n\t\t\t\t\t'only AO': 3,\n\n\t\t\t\t} ).onChange( () => updateOutput() );\n\t\t\t\tgui.add( sceneParameters, 'envMapIntensity' ).min( 0 ).max( 1 ).step( 0.01 ).onChange( () => {\n\n\t\t\t\t\tgroundMaterial.envMapIntensity = sceneParameters.envMapIntensity;\n\t\t\t\t\tobjectMaterial.envMapIntensity = sceneParameters.envMapIntensity;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( sceneParameters, 'ambientLightIntensity' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( () => {\n\n\t\t\t\t\tambientLight.intensity = sceneParameters.ambientLightIntensity;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( sceneParameters, 'lightIntensity' ).min( 0 ).max( 100 ).step( 1 ).onChange( () => {\n\n\t\t\t\t\tlightGroup.children.forEach( light => light.intensity = sceneParameters.lightIntensity );\n\n\t\t\t\t} );\n\t\t\t\tgui.add( sceneParameters, 'shadow' ).onChange( ( value ) => {\n\n\t\t\t\t\trenderer.shadowMap.enabled = value;\n\t\t\t\t\tlightGroup.children.forEach( light => light.castShadow = value );\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.add( aoParameters, 'radius' ).min( 0.01 ).max( 2 ).step( 0.01 ).onChange( () => updateGtaoMaterial() );\n\t\t\t\tgui.add( aoParameters, 'distanceExponent' ).min( 1 ).max( 4 ).step( 0.01 ).onChange( () => updateGtaoMaterial() );\n\t\t\t\tgui.add( aoParameters, 'thickness' ).min( 0.01 ).max( 10 ).step( 0.01 ).onChange( () => updateGtaoMaterial() );\n\t\t\t\tgui.add( aoParameters, 'distanceFallOff' ).min( 0 ).max( 1 ).step( 0.01 ).onChange( () => updateGtaoMaterial() );\n\t\t\t\tgui.add( aoParameters, 'scale' ).min( 0.01 ).max( 2.0 ).step( 0.01 ).onChange( () => updateGtaoMaterial() );\n\t\t\t\tgui.add( aoParameters, 'samples' ).min( 2 ).max( 32 ).step( 1 ).onChange( () => updateGtaoMaterial() );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\tstats.begin();\n\t\t\t\tcomposer.render();\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - Mesh Post Processing Material by Rabbid76 Improved application of the AO passes by using the AO directly in the material shader instead of simply blending with the whole scene"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing manual ssaa"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing manual ssaa:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet scene, renderer, composer;\n\t\t\tlet cameraP, ssaaRenderPassP;\n\t\t\tlet cameraO, ssaaRenderPassO;\n\t\t\tlet gui, stats;\n\n\t\t\tconst params = {\n\t\t\t\tsampleLevel: 4,\n\t\t\t\tunbiased: true,\n\t\t\t\tcamera: 'perspective',\n\t\t\t\tclearColor: 'black',\n\t\t\t\tclearAlpha: 1.0,\n\t\t\t\tviewOffsetX: 0,\n\t\t\t\tautoRotate: true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tclearGui();\n\n\t\t\tfunction clearGui() {\n\n\t\t\t\tif ( gui ) gui.destroy();\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( params, 'unbiased' );\n\t\t\t\tgui.add( params, 'sampleLevel', {\n\t\t\t\t\t'Level 0: 1 Sample': 0,\n\t\t\t\t\t'Level 1: 2 Samples': 1,\n\t\t\t\t\t'Level 2: 4 Samples': 2,\n\t\t\t\t\t'Level 3: 8 Samples': 3,\n\t\t\t\t\t'Level 4: 16 Samples': 4,\n\t\t\t\t\t'Level 5: 32 Samples': 5\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'camera', [ 'perspective', 'orthographic' ] );\n\t\t\t\tgui.add( params, 'clearColor', [ 'black', 'white', 'blue', 'green', 'red' ] );\n\t\t\t\tgui.add( params, 'clearAlpha', 0, 1 );\n\t\t\t\tgui.add( params, 'viewOffsetX', - 100, 100 );\n\t\t\t\tgui.add( params, 'autoRotate' );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tconst width = window.innerWidth || 1;\n\t\t\t\tconst height = window.innerHeight || 1;\n\t\t\t\tconst aspect = width / height;\n\t\t\t\tconst devicePixelRatio = window.devicePixelRatio || 1;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcameraP = new THREE.PerspectiveCamera( 65, aspect, 3, 10 );\n\t\t\t\tcameraP.position.z = 7;\n\t\t\t\tcameraP.setViewOffset( width, height, params.viewOffsetX, 0, width, height );\n\n\t\t\t\tcameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 3, 10 );\n\t\t\t\tcameraO.position.z = 7;\n\n\t\t\t\tconst fov = THREE.MathUtils.degToRad( cameraP.fov );\n\t\t\t\tconst hyperfocus = ( cameraP.near + cameraP.far ) / 2;\n\t\t\t\tconst _height = 2 * Math.tan( fov / 2 ) * hyperfocus;\n\t\t\t\tcameraO.zoom = height / _height;\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xefffef, 500 );\n\t\t\t\tlight.position.z = 10;\n\t\t\t\tlight.position.y = - 10;\n\t\t\t\tlight.position.x = - 10;\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.PointLight( 0xffefef, 500 );\n\t\t\t\tlight2.position.z = 10;\n\t\t\t\tlight2.position.x = - 10;\n\t\t\t\tlight2.position.y = 10;\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tconst light3 = new THREE.PointLight( 0xefefff, 500 );\n\t\t\t\tlight3.position.z = 10;\n\t\t\t\tlight3.position.x = 10;\n\t\t\t\tlight3.position.y = - 10;\n\t\t\t\tscene.add( light3 );\n\n\t\t\t\tconst light4 = new THREE.AmbientLight( 0xffffff, 0.2 );\n\t\t\t\tscene.add( light4 );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 3, 48, 24 );\n\n\t\t\t\tfor ( let i = 0; i < 120; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial();\n\t\t\t\t\tmaterial.roughness = 0.5 * Math.random() + 0.25;\n\t\t\t\t\tmaterial.metalness = 0;\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 1.0, 0.3 );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.y = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.z = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.rotation.x = Math.random();\n\t\t\t\t\tmesh.rotation.y = Math.random();\n\t\t\t\t\tmesh.rotation.z = Math.random();\n\n\t\t\t\t\tmesh.scale.setScalar( Math.random() * 0.2 + 0.05 );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.setPixelRatio( 1 ); // ensure pixel ratio is always 1 for performance reasons\n\t\t\t\tssaaRenderPassP = new SSAARenderPass( scene, cameraP );\n\t\t\t\tcomposer.addPass( ssaaRenderPassP );\n\t\t\t\tssaaRenderPassO = new SSAARenderPass( scene, cameraO );\n\t\t\t\tcomposer.addPass( ssaaRenderPassO );\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\t\t\t\tconst aspect = width / height;\n\n\t\t\t\tcameraP.aspect = aspect;\n\t\t\t\tcameraP.setViewOffset( width, height, params.viewOffsetX, 0, width, height );\n\t\t\t\tcameraO.updateProjectionMatrix();\n\n\t\t\t\tcameraO.left = - height * aspect;\n\t\t\t\tcameraO.right = height * aspect;\n\t\t\t\tcameraO.top = height;\n\t\t\t\tcameraO.bottom = - height;\n\t\t\t\tcameraO.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tif ( params.autoRotate ) {\n\n\t\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\t\tconst child = scene.children[ i ];\n\n\t\t\t\t\t\tchild.rotation.x += 0.005;\n\t\t\t\t\t\tchild.rotation.y += 0.01;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet newColor = ssaaRenderPassP.clearColor;\n\n\t\t\t\tswitch ( params.clearColor ) {\n\n\t\t\t\t\tcase 'blue': newColor = 0x0000ff; break;\n\t\t\t\t\tcase 'red': newColor = 0xff0000; break;\n\t\t\t\t\tcase 'green': newColor = 0x00ff00; break;\n\t\t\t\t\tcase 'white': newColor = 0xffffff; break;\n\t\t\t\t\tcase 'black': newColor = 0x000000; break;\n\n\t\t\t\t}\n\n\t\t\t\tssaaRenderPassP.clearColor = ssaaRenderPassO.clearColor = newColor;\n\t\t\t\tssaaRenderPassP.clearAlpha = ssaaRenderPassO.clearAlpha = params.clearAlpha;\n\n\t\t\t\tssaaRenderPassP.sampleLevel = ssaaRenderPassO.sampleLevel = params.sampleLevel;\n\t\t\t\tssaaRenderPassP.unbiased = ssaaRenderPassO.unbiased = params.unbiased;\n\n\t\t\t\tssaaRenderPassP.enabled = ( params.camera === 'perspective' );\n\t\t\t\tssaaRenderPassO.enabled = ( params.camera === 'orthographic' );\n\n\t\t\t\tcameraP.view.offsetX = params.viewOffsetX;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - Unbiased Manual Supersampling Anti-Aliasing (SSAA) pass by Ben Houston This example shows how to unbias the rounding errors accumulated using high number of SSAA samples on a 8-bit per channel buffer. Turn off the \"unbiased\" feature to see the banding that results from accumulated rounding errors."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - post processing - Outline Pass"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - post processing - Outline Pass:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { FXAAShader } from 'three/addons/shaders/FXAAShader.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet composer, effectFXAA, outlinePass;\n\n\t\t\tlet selectedObjects = [];\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tconst obj3d = new THREE.Object3D();\n\t\t\tconst group = new THREE.Group();\n\n\t\t\tconst params = {\n\t\t\t\tedgeStrength: 3.0,\n\t\t\t\tedgeGlow: 0.0,\n\t\t\t\tedgeThickness: 1.0,\n\t\t\t\tpulsePeriod: 0,\n\t\t\t\trotate: false,\n\t\t\t\tusePatternTexture: false\n\t\t\t};\n\n\t\t\t// Init gui\n\n\t\t\tconst gui = new GUI( { width: 280 } );\n\n\t\t\tgui.add( params, 'edgeStrength', 0.01, 10 ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.edgeStrength = Number( value );\n\n\t\t\t} );\n\n\t\t\tgui.add( params, 'edgeGlow', 0.0, 1 ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.edgeGlow = Number( value );\n\n\t\t\t} );\n\n\t\t\tgui.add( params, 'edgeThickness', 1, 4 ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.edgeThickness = Number( value );\n\n\t\t\t} );\n\n\t\t\tgui.add( params, 'pulsePeriod', 0.0, 5 ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.pulsePeriod = Number( value );\n\n\t\t\t} );\n\n\t\t\tgui.add( params, 'rotate' );\n\n\t\t\tgui.add( params, 'usePatternTexture' ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.usePatternTexture = value;\n\n\t\t\t} );\n\n\t\t\tfunction Configuration() {\n\n\t\t\t\tthis.visibleEdgeColor = '#ffffff';\n\t\t\t\tthis.hiddenEdgeColor = '#190a05';\n\n\t\t\t}\n\n\t\t\tconst conf = new Configuration();\n\n\t\t\tgui.addColor( conf, 'visibleEdgeColor' ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.visibleEdgeColor.set( value );\n\n\t\t\t} );\n\n\t\t\tgui.addColor( conf, 'hiddenEdgeColor' ).onChange( function ( value ) {\n\n\t\t\t\toutlinePass.hiddenEdgeColor.set( value );\n\n\t\t\t} );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\t// todo - support pixelRatio in this demo\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 8 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 20;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa, 0.6 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xddffdd, 2 );\n\t\t\t\tlight.position.set( 5, 5, 5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\n\t\t\t\tconst d = 10;\n\n\t\t\t\tlight.shadow.camera.left = - d;\n\t\t\t\tlight.shadow.camera.right = d;\n\t\t\t\tlight.shadow.camera.top = d;\n\t\t\t\tlight.shadow.camera.bottom = - d;\n\t\t\t\tlight.shadow.camera.far = 25;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/tree.obj', function ( object ) {\n\n\t\t\t\t\tlet scale = 1.0;\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child instanceof THREE.Mesh ) {\n\n\t\t\t\t\t\t\tchild.geometry.center();\n\t\t\t\t\t\t\tchild.geometry.computeBoundingSphere();\n\t\t\t\t\t\t\tscale = 0.2 * child.geometry.boundingSphere.radius;\n\n\t\t\t\t\t\t\tconst phongMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shininess: 5 } );\n\t\t\t\t\t\t\tchild.material = phongMaterial;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\t\t\t\t\t\t\tchild.castShadow = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tobject.position.y = 1;\n\t\t\t\t\tobject.scale.divideScalar( scale );\n\t\t\t\t\tobj3d.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\tgroup.add( obj3d );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 3, 48, 24 );\n\n\t\t\t\tfor ( let i = 0; i < 20; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 1.0, 0.3 );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.y = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.z = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.scale.multiplyScalar( Math.random() * 0.3 + 0.1 );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tconst floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 12, 12 );\n\t\t\t\tconst floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloorMesh.rotation.x -= Math.PI * 0.5;\n\t\t\t\tfloorMesh.position.y -= 1.5;\n\t\t\t\tgroup.add( floorMesh );\n\t\t\t\tfloorMesh.receiveShadow = true;\n\n\t\t\t\tconst torusGeometry = new THREE.TorusGeometry( 1, 0.3, 16, 100 );\n\t\t\t\tconst torusMaterial = new THREE.MeshPhongMaterial( { color: 0xffaaff } );\n\t\t\t\tconst torus = new THREE.Mesh( torusGeometry, torusMaterial );\n\t\t\t\ttorus.position.z = - 4;\n\t\t\t\tgroup.add( torus );\n\t\t\t\ttorus.receiveShadow = true;\n\t\t\t\ttorus.castShadow = true;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tcomposer.addPass( renderPass );\n\n\t\t\t\toutlinePass = new OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );\n\t\t\t\tcomposer.addPass( outlinePass );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\ttextureLoader.load( 'textures/tri_pattern.jpg', function ( texture ) {\n\n\t\t\t\t\toutlinePass.patternTexture = texture;\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t} );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\teffectFXAA = new ShaderPass( FXAAShader );\n\t\t\t\teffectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );\n\t\t\t\tcomposer.addPass( effectFXAA );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\trenderer.domElement.style.touchAction = 'none';\n\t\t\t\trenderer.domElement.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\t\tcheckIntersection();\n\n\t\t\t\t}\n\n\t\t\t\tfunction addSelectedObject( object ) {\n\n\t\t\t\t\tselectedObjects = [];\n\t\t\t\t\tselectedObjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t\tfunction checkIntersection() {\n\n\t\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObject( scene, true );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tconst selectedObject = intersects[ 0 ].object;\n\t\t\t\t\t\taddSelectedObject( selectedObject );\n\t\t\t\t\t\toutlinePass.selectedObjects = selectedObjects;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// outlinePass.selectedObjects = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t\teffectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tconst timer = performance.now();\n\n\t\t\t\tif ( params.rotate ) {\n\n\t\t\t\t\tgroup.rotation.y = timer * 0.0001;\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tcomposer.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - Outline Pass by Prashant Sharma and Ben Houston"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - post processing - pixelation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - post processing - pixelation:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\timport { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';\n\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\tlet camera, scene, renderer, composer, crystalMesh, clock;\n\t\tlet gui, params;\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tconst aspectRatio = window.innerWidth / window.innerHeight;\n\n\t\t\tcamera = new THREE.OrthographicCamera( - aspectRatio, aspectRatio, 1, - 1, 0.1, 10 );\n\t\t\tcamera.position.y = 2 * Math.tan( Math.PI / 6 );\n\t\t\tcamera.position.z = 2;\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x151729 );\n\n\t\t\tclock = new THREE.Clock();\n\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t//renderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\tconst renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );\n\t\t\tcomposer.addPass( renderPixelatedPass );\n\n\t\t\tconst outputPass = new OutputPass();\n\t\t\tcomposer.addPass( outputPass );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.maxZoom = 2;\n\n\t\t\t// gui\n\n\t\t\tgui = new GUI();\n\t\t\tparams = { pixelSize: 6, normalEdgeStrength: .3, depthEdgeStrength: .4, pixelAlignedPanning: true };\n\t\t\tgui.add( params, 'pixelSize' ).min( 1 ).max( 16 ).step( 1 )\n\t\t\t\t.onChange( () => {\n\n\t\t\t\t\trenderPixelatedPass.setPixelSize( params.pixelSize );\n\n\t\t\t\t} );\n\t\t\tgui.add( renderPixelatedPass, 'normalEdgeStrength' ).min( 0 ).max( 2 ).step( .05 );\n\t\t\tgui.add( renderPixelatedPass, 'depthEdgeStrength' ).min( 0 ).max( 1 ).step( .05 );\n\t\t\tgui.add( params, 'pixelAlignedPanning' );\n\n\t\t\t// textures\n\n\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\tconst texChecker = pixelTexture( loader.load( 'textures/checker.png' ) );\n\t\t\tconst texChecker2 = pixelTexture( loader.load( 'textures/checker.png' ) );\n\t\t\ttexChecker.repeat.set( 3, 3 );\n\t\t\ttexChecker2.repeat.set( 1.5, 1.5 );\n\n\t\t\t// meshes\n\n\t\t\tconst boxMaterial = new THREE.MeshPhongMaterial( { map: texChecker2 } );\n\n\t\t\tfunction addBox( boxSideLength, x, z, rotation ) {\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.BoxGeometry( boxSideLength, boxSideLength, boxSideLength ), boxMaterial );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tmesh.rotation.y = rotation;\n\t\t\t\tmesh.position.y = boxSideLength / 2;\n\t\t\t\tmesh.position.set( x, boxSideLength / 2 + .0001, z );\n\t\t\t\tscene.add( mesh );\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\taddBox( .4, 0, 0, Math.PI / 4 );\n\t\t\taddBox( .5, - .5, - .5, Math.PI / 4 );\n\n\t\t\tconst planeSideLength = 2;\n\t\t\tconst planeMesh = new THREE.Mesh(\n\t\t\t\tnew THREE.PlaneGeometry( planeSideLength, planeSideLength ),\n\t\t\t\tnew THREE.MeshPhongMaterial( { map: texChecker } )\n\t\t\t);\n\t\t\tplaneMesh.receiveShadow = true;\n\t\t\tplaneMesh.rotation.x = - Math.PI / 2;\n\t\t\tscene.add( planeMesh );\n\n\t\t\tconst radius = .2;\n\t\t\tconst geometry = new THREE.IcosahedronGeometry( radius );\n\t\t\tcrystalMesh = new THREE.Mesh(\n\t\t\t\tgeometry,\n\t\t\t\tnew THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x68b7e9,\n\t\t\t\t\temissive: 0x4f7e8b,\n\t\t\t\t\tshininess: 10,\n\t\t\t\t\tspecular: 0xffffff\n\t\t\t\t} )\n\t\t\t);\n\t\t\tcrystalMesh.receiveShadow = true;\n\t\t\tcrystalMesh.castShadow = true;\n\t\t\tscene.add( crystalMesh );\n\n\t\t\t// lights\n\n\t\t\tscene.add( new THREE.AmbientLight( 0x757f8e, 3 ) );\n\n\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xfffecd, 1.5 );\n\t\t\tdirectionalLight.position.set( 100, 100, 100 );\n\t\t\tdirectionalLight.castShadow = true;\n\t\t\tdirectionalLight.shadow.mapSize.set( 2048, 2048 );\n\t\t\tscene.add( directionalLight );\n\n\t\t\tconst spotLight = new THREE.SpotLight( 0xffc100, 10, 10, Math.PI / 16, .02, 2 );\n\t\t\tspotLight.position.set( 2, 2, 0 );\n\t\t\tconst target = spotLight.target;\n\t\t\tscene.add( target );\n\t\t\ttarget.position.set( 0, 0, 0 );\n\t\t\tspotLight.castShadow = true;\n\t\t\tscene.add( spotLight );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tconst aspectRatio = window.innerWidth / window.innerHeight;\n\t\t\tcamera.left = - aspectRatio;\n\t\t\tcamera.right = aspectRatio;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst t = clock.getElapsedTime();\n\n\t\t\tcrystalMesh.material.emissiveIntensity = Math.sin( t * 3 ) * .5 + .5;\n\t\t\tcrystalMesh.position.y = .7 + Math.sin( t * 2 ) * .05;\n\t\t\tcrystalMesh.rotation.y = stopGoEased( t, 2, 4 ) * 2 * Math.PI;\n\n\t\t\tconst rendererSize = renderer.getSize( new THREE.Vector2() );\n\t\t\tconst aspectRatio = rendererSize.x / rendererSize.y;\n\t\t\tif ( params[ 'pixelAlignedPanning' ] ) {\n\n\t\t\t\tpixelAlignFrustum( camera, aspectRatio, Math.floor( rendererSize.x / params[ 'pixelSize' ] ),\n\t\t\t\t\tMath.floor( rendererSize.y / params[ 'pixelSize' ] ) );\n\n\t\t\t} else if ( camera.left != - aspectRatio || camera.top != 1.0 ) {\n\n\t\t\t\t// Reset the Camera Frustum if it has been modified\n\t\t\t\tcamera.left = - aspectRatio;\n\t\t\t\tcamera.right = aspectRatio;\n\t\t\t\tcamera.top = 1.0;\n\t\t\t\tcamera.bottom = - 1.0;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tcomposer.render();\n\n\t\t}\n\n\t\t// Helper functions\n\n\t\tfunction pixelTexture( texture ) {\n\n\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\ttexture.generateMipmaps = false;\n\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction easeInOutCubic( x ) {\n\n\t\t\treturn x ** 2 * 3 - x ** 3 * 2;\n\n\t\t}\n\n\t\tfunction linearStep( x, edge0, edge1 ) {\n\n\t\t\tconst w = edge1 - edge0;\n\t\t\tconst m = 1 / w;\n\t\t\tconst y0 = - m * edge0;\n\t\t\treturn THREE.MathUtils.clamp( y0 + m * x, 0, 1 );\n\n\t\t}\n\n\t\tfunction stopGoEased( x, downtime, period ) {\n\n\t\t\tconst cycle = ( x / period ) | 0;\n\t\t\tconst tween = x - cycle * period;\n\t\t\tconst linStep = easeInOutCubic( linearStep( tween, downtime, period ) );\n\t\t\treturn cycle + linStep;\n\n\t\t}\n\n\t\tfunction pixelAlignFrustum( camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight ) {\n\n\t\t\t// 0. Get Pixel Grid Units\n\t\t\tconst worldScreenWidth = ( ( camera.right - camera.left ) / camera.zoom );\n\t\t\tconst worldScreenHeight = ( ( camera.top - camera.bottom ) / camera.zoom );\n\t\t\tconst pixelWidth = worldScreenWidth / pixelsPerScreenWidth;\n\t\t\tconst pixelHeight = worldScreenHeight / pixelsPerScreenHeight;\n\n\t\t\t// 1. Project the current camera position along its local rotation bases\n\t\t\tconst camPos = new THREE.Vector3(); camera.getWorldPosition( camPos );\n\t\t\tconst camRot = new THREE.Quaternion(); camera.getWorldQuaternion( camRot );\n\t\t\tconst camRight = new THREE.Vector3( 1.0, 0.0, 0.0 ).applyQuaternion( camRot );\n\t\t\tconst camUp = new THREE.Vector3( 0.0, 1.0, 0.0 ).applyQuaternion( camRot );\n\t\t\tconst camPosRight = camPos.dot( camRight );\n\t\t\tconst camPosUp = camPos.dot( camUp );\n\n\t\t\t// 2. Find how far along its position is along these bases in pixel units\n\t\t\tconst camPosRightPx = camPosRight / pixelWidth;\n\t\t\tconst camPosUpPx = camPosUp / pixelHeight;\n\n\t\t\t// 3. Find the fractional pixel units and convert to world units\n\t\t\tconst fractX = camPosRightPx - Math.round( camPosRightPx );\n\t\t\tconst fractY = camPosUpPx - Math.round( camPosUpPx );\n\n\t\t\t// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid\n\t\t\tcamera.left = - aspectRatio - ( fractX * pixelWidth );\n\t\t\tcamera.right = aspectRatio - ( fractX * pixelWidth );\n\t\t\tcamera.top = 1.0 - ( fractY * pixelHeight );\n\t\t\tcamera.bottom = - 1.0 - ( fractY * pixelHeight );\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n```\n\nThis example three.js - Pixelation pass with optional single pixel outlines by Kody King"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing procedural effects"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing procedural effects:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet postCamera, postScene, renderer;\n\t\t\tlet postMaterial, noiseRandom1DMaterial, noiseRandom2DMaterial, noiseRandom3DMaterial, postQuad;\n\t\t\tlet stats;\n\n\t\t\tconst params = { procedure: 'noiseRandom3D' };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// Setup post processing stage\n\t\t\t\tpostCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\t\tnoiseRandom1DMaterial = new THREE.ShaderMaterial( {\n\t\t\t\t\tvertexShader: document.querySelector( '#procedural-vert' ).textContent.trim(),\n\t\t\t\t\tfragmentShader: document.querySelector( '#noiseRandom1D-frag' ).textContent.trim()\n\t\t\t\t} );\n\t\t\t\tnoiseRandom2DMaterial = new THREE.ShaderMaterial( {\n\t\t\t\t\tvertexShader: document.querySelector( '#procedural-vert' ).textContent.trim(),\n\t\t\t\t\tfragmentShader: document.querySelector( '#noiseRandom2D-frag' ).textContent.trim()\n\t\t\t\t} );\n\t\t\t\tnoiseRandom3DMaterial = new THREE.ShaderMaterial( {\n\t\t\t\t\tvertexShader: document.querySelector( '#procedural-vert' ).textContent.trim(),\n\t\t\t\t\tfragmentShader: document.querySelector( '#noiseRandom3D-frag' ).textContent.trim()\n\t\t\t\t} );\n\t\t\t\tpostMaterial = noiseRandom3DMaterial;\n\t\t\t\tconst postPlane = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tpostQuad = new THREE.Mesh( postPlane, postMaterial );\n\t\t\t\tpostScene = new THREE.Scene();\n\t\t\t\tpostScene.add( postQuad );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'procedure', [ 'noiseRandom1D', 'noiseRandom2D', 'noiseRandom3D' ] );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tswitch ( params.procedure ) {\n\n\t\t\t\t\tcase 'noiseRandom1D': postMaterial = noiseRandom1DMaterial; break;\n\t\t\t\t\tcase 'noiseRandom2D': postMaterial = noiseRandom2DMaterial; break;\n\t\t\t\t\tcase 'noiseRandom3D': postMaterial = noiseRandom3DMaterial; break;\n\n\t\t\t\t}\n\n\t\t\t\tpostQuad.material = postMaterial;\n\n\t\t\t\t// render post FX\n\t\t\t\trenderer.render( postScene, postCamera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Procedural Effects Example by Ben Houston"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - post processing - Scalable Ambient Occlusion (SAO)"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - post processing - Scalable Ambient Occlusion (SAO):\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { SAOPass } from 'three/addons/postprocessing/SAOPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet composer, renderPass, saoPass;\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 65, width / height, 3, 10 );\n\t\t\t\tcamera.position.z = 7;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tgroup = new THREE.Object3D();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xefffef, 500 );\n\t\t\t\tlight.position.z = 10;\n\t\t\t\tlight.position.y = - 10;\n\t\t\t\tlight.position.x = - 10;\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.PointLight( 0xffefef, 500 );\n\t\t\t\tlight2.position.z = 10;\n\t\t\t\tlight2.position.x = - 10;\n\t\t\t\tlight2.position.y = 10;\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tconst light3 = new THREE.PointLight( 0xefefff, 500 );\n\t\t\t\tlight3.position.z = 10;\n\t\t\t\tlight3.position.x = 10;\n\t\t\t\tlight3.position.y = - 10;\n\t\t\t\tscene.add( light3 );\n\n\t\t\t\tconst light4 = new THREE.AmbientLight( 0xffffff, 0.2 );\n\t\t\t\tscene.add( light4 );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 3, 48, 24 );\n\n\t\t\t\tfor ( let i = 0; i < 120; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial();\n\t\t\t\t\tmaterial.roughness = 0.5 * Math.random() + 0.25;\n\t\t\t\t\tmaterial.metalness = 0;\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 1.0, 0.3 );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.y = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.z = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.rotation.x = Math.random();\n\t\t\t\t\tmesh.rotation.y = Math.random();\n\t\t\t\t\tmesh.rotation.z = Math.random();\n\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 0.2 + 0.05;\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\trenderPass = new RenderPass( scene, camera );\n\t\t\t\tcomposer.addPass( renderPass );\n\t\t\t\tsaoPass = new SAOPass( scene, camera );\n\t\t\t\tcomposer.addPass( saoPass );\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t// Init gui\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( saoPass.params, 'output', {\n\t\t\t\t\t'Default': SAOPass.OUTPUT.Default,\n\t\t\t\t\t'SAO Only': SAOPass.OUTPUT.SAO,\n\t\t\t\t\t'Normal': SAOPass.OUTPUT.Normal\n\t\t\t\t} ).onChange( function ( value ) {\n\n\t\t\t\t\tsaoPass.params.output = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( saoPass.params, 'saoBias', - 1, 1 );\n\t\t\t\tgui.add( saoPass.params, 'saoIntensity', 0, 1 );\n\t\t\t\tgui.add( saoPass.params, 'saoScale', 0, 10 );\n\t\t\t\tgui.add( saoPass.params, 'saoKernelRadius', 1, 100 );\n\t\t\t\tgui.add( saoPass.params, 'saoMinResolution', 0, 1 );\n\t\t\t\tgui.add( saoPass.params, 'saoBlur' );\n\t\t\t\tgui.add( saoPass.params, 'saoBlurRadius', 0, 200 );\n\t\t\t\tgui.add( saoPass.params, 'saoBlurStdDev', 0.5, 150 );\n\t\t\t\tgui.add( saoPass.params, 'saoBlurDepthCutoff', 0.0, 0.1 );\n\t\t\t\tgui.add( saoPass, 'enabled' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth || 1;\n\t\t\t\tconst height = window.innerHeight || 1;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\tcomposer.setSize( width, height );\n\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = performance.now();\n\t\t\t\tgroup.rotation.x = timer * 0.0002;\n\t\t\t\tgroup.rotation.y = timer * 0.0001;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example three.js - Scalable Ambient Occlusion (SAO) shader by Ben Houston / Post-processing pass by Ludobaka"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing smaa"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing smaa:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, composer, stats, smaaPass;\n\n\t\t\tconst params = {\n\t\t\t\tenabled: true,\n\t\t\t\tautoRotate: true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 120, 120, 120 );\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.position.x = - 100;\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' );\n\t\t\t\ttexture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.position.x = 100;\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.addPass( new RenderPass( scene, camera ) );\n\n\t\t\t\tsmaaPass = new SMAAPass();\n\t\t\t\tcomposer.addPass( smaaPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst smaaFolder = gui.addFolder( 'SMAA' );\n\t\t\t\tsmaaFolder.add( params, 'enabled' );\n\n\t\t\t\tconst sceneFolder = gui.addFolder( 'Scene' );\n\t\t\t\tsceneFolder.add( params, 'autoRotate' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tif ( params.autoRotate === true ) {\n\n\t\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\t\tconst child = scene.children[ i ];\n\n\t\t\t\t\t\tchild.rotation.x += 0.005;\n\t\t\t\t\t\tchild.rotation.y += 0.01;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tsmaaPass.enabled = params.enabled;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - post-processing SMAA"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - sobel (edge detection)"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - sobel (edge detection):\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\n\t\t\timport { LuminosityShader } from 'three/addons/shaders/LuminosityShader.js';\n\t\t\timport { SobelOperatorShader } from 'three/addons/shaders/SobelOperatorShader.js';\n\n\t\t\tlet camera, scene, renderer, composer;\n\n\t\t\tlet effectSobel;\n\n\t\t\tconst params = {\n\t\t\t\tenable: true\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 1, 3 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 1, 0.3, 256, 32 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffff00 } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xe7e7e7 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 20 );\n\t\t\t\tcamera.add( pointLight );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tcomposer.addPass( renderPass );\n\n\t\t\t\t// color to grayscale conversion\n\n\t\t\t\tconst effectGrayScale = new ShaderPass( LuminosityShader );\n\t\t\t\tcomposer.addPass( effectGrayScale );\n\n\t\t\t\t// you might want to use a gaussian blur filter before\n\t\t\t\t// the next pass to improve the result of the Sobel operator\n\n\t\t\t\t// Sobel operator\n\n\t\t\t\teffectSobel = new ShaderPass( SobelOperatorShader );\n\t\t\t\teffectSobel.uniforms[ 'resolution' ].value.x = window.innerWidth * window.devicePixelRatio;\n\t\t\t\teffectSobel.uniforms[ 'resolution' ].value.y = window.innerHeight * window.devicePixelRatio;\n\t\t\t\tcomposer.addPass( effectSobel );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'enable' );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\teffectSobel.uniforms[ 'resolution' ].value.x = window.innerWidth * window.devicePixelRatio;\n\t\t\t\teffectSobel.uniforms[ 'resolution' ].value.y = window.innerHeight * window.devicePixelRatio;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( params.enable === true ) {\n\n\t\t\t\t\tcomposer.render();\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - webgl - postprocessing sobel (edge detection)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - Screen Space Ambient Occlusion"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - Screen Space Ambient Occlusion:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet composer;\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 100, 700 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xaaaaaa );\n\n\t\t\t\tscene.add( new THREE.DirectionalLight( 0xffffff, 4 ) );\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff ) );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 10, 10, 10 );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( {\n\t\t\t\t\t\tcolor: Math.random() * 0xffffff\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 400 - 200;\n\t\t\t\t\tmesh.position.y = Math.random() * 400 - 200;\n\t\t\t\t\tmesh.position.z = Math.random() * 400 - 200;\n\t\t\t\t\tmesh.rotation.x = Math.random();\n\t\t\t\t\tmesh.rotation.y = Math.random();\n\t\t\t\t\tmesh.rotation.z = Math.random();\n\n\t\t\t\t\tmesh.scale.setScalar( Math.random() * 10 + 2 );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tcomposer.addPass( renderPass );\n\n\t\t\t\tconst ssaoPass = new SSAOPass( scene, camera, width, height );\n\t\t\t\tcomposer.addPass( ssaoPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t// Init gui\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( ssaoPass, 'output', {\n\t\t\t\t\t'Default': SSAOPass.OUTPUT.Default,\n\t\t\t\t\t'SSAO Only': SSAOPass.OUTPUT.SSAO,\n\t\t\t\t\t'SSAO Only + Blur': SSAOPass.OUTPUT.Blur,\n\t\t\t\t\t'Depth': SSAOPass.OUTPUT.Depth,\n\t\t\t\t\t'Normal': SSAOPass.OUTPUT.Normal\n\t\t\t\t} ).onChange( function ( value ) {\n\n\t\t\t\t\tssaoPass.output = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( ssaoPass, 'kernelRadius' ).min( 0 ).max( 32 );\n\t\t\t\tgui.add( ssaoPass, 'minDistance' ).min( 0.001 ).max( 0.02 );\n\t\t\t\tgui.add( ssaoPass, 'maxDistance' ).min( 0.01 ).max( 0.3 );\n\t\t\t\tgui.add( ssaoPass, 'enabled' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = performance.now();\n\t\t\t\tgroup.rotation.x = timer * 0.0002;\n\t\t\t\tgroup.rotation.y = timer * 0.0001;\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example three.js - screen space ambient occlusion"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - Screen Space Reflection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - Screen Space Reflection:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\timport { SSRPass } from 'three/addons/postprocessing/SSRPass.js';\n\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\timport { ReflectorForSSRPass } from 'three/addons/objects/ReflectorForSSRPass.js';\n\n\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\tconst params = {\n\t\t\tenableSSR: true,\n\t\t\tautoRotate: true,\n\t\t\totherMeshes: true,\n\t\t\tgroundReflector: true,\n\t\t};\n\t\tlet composer;\n\t\tlet ssrPass;\n\t\tlet gui;\n\t\tlet stats;\n\t\tlet controls;\n\t\tlet camera, scene, renderer;\n\t\tconst otherMeshes = [];\n\t\tlet groundReflector;\n\t\tconst selects = [];\n\n\t\tconst container = document.querySelector( '#container' );\n\n\t\t// Configure and create Draco decoder.\n\t\tconst dracoLoader = new DRACOLoader();\n\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 15 );\n\t\t\tcamera.position.set( 0.13271600513224902, 0.3489546826045913, 0.43921296427927076 );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x443333 );\n\t\t\tscene.fog = new THREE.Fog( 0x443333, 1, 4 );\n\n\t\t\t// Ground\n\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\tnew THREE.PlaneGeometry( 8, 8 ),\n\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xcbcbcb } )\n\t\t\t);\n\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\tplane.position.y = - 0.0001;\n\t\t\t// plane.receiveShadow = true;\n\t\t\tscene.add( plane );\n\n\t\t\t// Lights\n\t\t\tconst hemiLight = new THREE.HemisphereLight( 0x8d7c7c, 0x494966, 3 );\n\t\t\tscene.add( hemiLight );\n\n\t\t\tconst spotLight = new THREE.SpotLight();\n\t\t\tspotLight.intensity = 8;\n\t\t\tspotLight.angle = Math.PI / 16;\n\t\t\tspotLight.penumbra = 0.5;\n\t\t\t// spotLight.castShadow = true;\n\t\t\tspotLight.position.set( - 1, 1, 1 );\n\t\t\tscene.add( spotLight );\n\n\t\t\tdracoLoader.load( 'models/draco/bunny.drc', function ( geometry ) {\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xa5a5a5 } );\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.position.y = - 0.0365;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tselects.push( mesh );\n\n\t\t\t\t// Release decoder resources.\n\t\t\t\tdracoLoader.dispose();\n\n\t\t\t} );\n\n\t\t\tlet geometry, material, mesh;\n\n\t\t\tgeometry = new THREE.BoxGeometry( .05, .05, .05 );\n\t\t\tmaterial = new THREE.MeshStandardMaterial( { color: 'green' } );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( - .12, .025, .015 );\n\t\t\tscene.add( mesh );\n\t\t\totherMeshes.push( mesh );\n\t\t\tselects.push( mesh );\n\n\t\t\tgeometry = new THREE.IcosahedronGeometry( .025, 4 );\n\t\t\tmaterial = new THREE.MeshStandardMaterial( { color: 'cyan' } );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( - .05, .025, .08 );\n\t\t\tscene.add( mesh );\n\t\t\totherMeshes.push( mesh );\n\t\t\tselects.push( mesh );\n\n\t\t\tgeometry = new THREE.ConeGeometry( .025, .05, 64 );\n\t\t\tmaterial = new THREE.MeshStandardMaterial( { color: 'yellow' } );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( - .05, .025, - .055 );\n\t\t\tscene.add( mesh );\n\t\t\totherMeshes.push( mesh );\n\t\t\tselects.push( mesh );\n\n\t\t\tgeometry = new THREE.PlaneGeometry( 1, 1 );\n\t\t\tgroundReflector = new ReflectorForSSRPass( geometry, {\n\t\t\t\tclipBias: 0.0003,\n\t\t\t\ttextureWidth: window.innerWidth,\n\t\t\t\ttextureHeight: window.innerHeight,\n\t\t\t\tcolor: 0x888888,\n\t\t\t\tuseDepthTexture: true,\n\t\t\t} );\n\t\t\tgroundReflector.material.depthWrite = false;\n\t\t\tgroundReflector.rotation.x = - Math.PI / 2;\n\t\t\tgroundReflector.visible = false;\n\t\t\tscene.add( groundReflector );\n\n\t\t\t// renderer\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: false } );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.enableDamping = true;\n\t\t\tcontrols.target.set( 0, 0.0635, 0 );\n\t\t\tcontrols.update();\n\t\t\tcontrols.enabled = ! params.autoRotate;\n\n\t\t\t// STATS\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t// composer\n\n\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\tssrPass = new SSRPass( {\n\t\t\t\trenderer,\n\t\t\t\tscene,\n\t\t\t\tcamera,\n\t\t\t\twidth: innerWidth,\n\t\t\t\theight: innerHeight,\n\t\t\t\tgroundReflector: params.groundReflector ? groundReflector : null,\n\t\t\t\tselects: params.groundReflector ? selects : null\n\t\t\t} );\n\n\t\t\tcomposer.addPass( ssrPass );\n\t\t\tcomposer.addPass( new OutputPass() );\n\n\t\t\t// GUI\n\n\t\t\tgui = new GUI( { width: 260 } );\n\t\t\tgui.add( params, 'enableSSR' ).name( 'Enable SSR' );\n\t\t\tgui.add( params, 'groundReflector' ).onChange( () => {\n\n\t\t\t\tif ( params.groundReflector ) {\n\n\t\t\t\t\tssrPass.groundReflector = groundReflector,\n\t\t\t\t\tssrPass.selects = selects;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tssrPass.groundReflector = null,\n\t\t\t\t\tssrPass.selects = null;\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\tssrPass.thickness = 0.018;\n\t\t\tgui.add( ssrPass, 'thickness' ).min( 0 ).max( .1 ).step( .0001 );\n\t\t\tssrPass.infiniteThick = false;\n\t\t\tgui.add( ssrPass, 'infiniteThick' );\n\t\t\tgui.add( params, 'autoRotate' ).onChange( () => {\n\n\t\t\t\tcontrols.enabled = ! params.autoRotate;\n\n\t\t\t} );\n\n\t\t\tconst folder = gui.addFolder( 'more settings' );\n\t\t\tfolder.add( ssrPass, 'fresnel' ).onChange( ()=>{\n\n\t\t\t\tgroundReflector.fresnel = ssrPass.fresnel;\n\n\t\t\t} );\n\t\t\tfolder.add( ssrPass, 'distanceAttenuation' ).onChange( ()=>{\n\n\t\t\t\tgroundReflector.distanceAttenuation = ssrPass.distanceAttenuation;\n\n\t\t\t} );\n\t\t\tssrPass.maxDistance = .1;\n\t\t\tgroundReflector.maxDistance = ssrPass.maxDistance;\n\t\t\tfolder.add( ssrPass, 'maxDistance' ).min( 0 ).max( .5 ).step( .001 ).onChange( ()=>{\n\n\t\t\t\tgroundReflector.maxDistance = ssrPass.maxDistance;\n\n\t\t\t} );\n\t\t\tfolder.add( params, 'otherMeshes' ).onChange( () => {\n\n\t\t\t\tif ( params.otherMeshes ) {\n\n\t\t\t\t\totherMeshes.forEach( mesh => mesh.visible = true );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherMeshes.forEach( mesh => mesh.visible = false );\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\tfolder.add( ssrPass, 'bouncing' );\n\t\t\tfolder.add( ssrPass, 'output', {\n\t\t\t\t'Default': SSRPass.OUTPUT.Default,\n\t\t\t\t'SSR Only': SSRPass.OUTPUT.SSR,\n\t\t\t\t'Beauty': SSRPass.OUTPUT.Beauty,\n\t\t\t\t'Depth': SSRPass.OUTPUT.Depth,\n\t\t\t\t'Normal': SSRPass.OUTPUT.Normal,\n\t\t\t\t'Metalness': SSRPass.OUTPUT.Metalness,\n\t\t\t} ).onChange( function ( value ) {\n\n\t\t\t\tssrPass.output = value;\n\n\t\t\t} );\n\t\t\tssrPass.opacity = 1;\n\t\t\tgroundReflector.opacity = ssrPass.opacity;\n\t\t\tfolder.add( ssrPass, 'opacity' ).min( 0 ).max( 1 ).onChange( ()=>{\n\n\t\t\t\tgroundReflector.opacity = ssrPass.opacity;\n\n\t\t\t} );\n\t\t\tfolder.add( ssrPass, 'blur' );\n\t\t\t// folder.open()\n\t\t\t// gui.close()\n\n\t\t}\n\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tcomposer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tgroundReflector.getRenderTarget().setSize( window.innerWidth, window.innerHeight );\n\t\t\tgroundReflector.resolution.set( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tstats.begin();\n\t\t\trender();\n\t\t\tstats.end();\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\tif ( params.autoRotate ) {\n\n\t\t\t\tconst timer = Date.now() * 0.0003;\n\n\t\t\t\tcamera.position.x = Math.sin( timer ) * 0.5;\n\t\t\t\tcamera.position.y = 0.2135;\n\t\t\t\tcamera.position.z = Math.cos( timer ) * 0.5;\n\t\t\t\tcamera.lookAt( 0, 0.0635, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t}\n\n\t\t\tif ( params.enableSSR ) {\n\n\t\t\t\t// TODO: groundReflector has full ground info, need use it to solve reflection gaps problem on objects when camera near ground.\n\t\t\t\t// TODO: the normal and depth info where groundReflector reflected need to be changed.\n\t\t\t\tcomposer.render();\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t}\n```\n\nThis example three.js - SSRPass demo by Vis ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing manual taa and ssaa"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing manual taa and ssaa:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, scene, renderer, composer, taaRenderPass, renderPass;\n\t\t\tlet gui, stats;\n\t\t\tlet index = 0;\n\n\t\t\tconst param = { TAAEnabled: '1', TAASampleLevel: 0 };\n\n\t\t\tinit();\n\n\t\t\tclearGui();\n\n\t\t\tfunction clearGui() {\n\n\t\t\t\tif ( gui ) gui.destroy();\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( param, 'TAAEnabled', {\n\t\t\t\t\t'Disabled': '0',\n\t\t\t\t\t'Enabled': '1'\n\t\t\t\t} ).onFinishChange( function () {\n\n\t\t\t\t\tif ( taaRenderPass ) {\n\n\t\t\t\t\t\ttaaRenderPass.enabled = ( param.TAAEnabled === '1' );\n\t\t\t\t\t\trenderPass.enabled = ( param.TAAEnabled !== '1' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'TAASampleLevel', {\n\t\t\t\t\t'Level 0: 1 Sample': 0,\n\t\t\t\t\t'Level 1: 2 Samples': 1,\n\t\t\t\t\t'Level 2: 4 Samples': 2,\n\t\t\t\t\t'Level 3: 8 Samples': 3,\n\t\t\t\t\t'Level 4: 16 Samples': 4,\n\t\t\t\t\t'Level 5: 32 Samples': 5\n\t\t\t\t} ).onFinishChange( function () {\n\n\t\t\t\t\tif ( taaRenderPass ) {\n\n\t\t\t\t\t\ttaaRenderPass.sampleLevel = param.TAASampleLevel;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 120, 120, 120 );\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.position.x = - 100;\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' );\n\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\ttexture.anisotropy = 1;\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.position.x = 100;\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\n\t\t\t\ttaaRenderPass = new TAARenderPass( scene, camera );\n\t\t\t\ttaaRenderPass.unbiased = false;\n\t\t\t\tcomposer.addPass( taaRenderPass );\n\n\t\t\t\trenderPass = new RenderPass( scene, camera );\n\t\t\t\trenderPass.enabled = false;\n\t\t\t\tcomposer.addPass( renderPass );\n\n\t\t\t\tconst outputPass = new OutputPass();\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tindex ++;\n\n\t\t\t\tif ( Math.round( index / 200 ) % 2 === 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\t\tconst child = scene.children[ i ];\n\n\t\t\t\t\t\tchild.rotation.x += 0.005;\n\t\t\t\t\t\tchild.rotation.y += 0.01;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( taaRenderPass ) taaRenderPass.accumulate = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( taaRenderPass ) taaRenderPass.accumulate = true;\n\n\t\t\t\t}\n\n\t\t\t\tcomposer.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Temporal Anti-Aliasing (TAA) pass by Ben Houston When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result. Texture interpolation, mipmapping and anisotropic sampling is disabled to emphasize the effect SSAA levels have one the resulting render quality."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - unreal bloom"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - unreal bloom:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet camera, stats;\n\t\t\tlet composer, renderer, mixer, clock;\n\n\t\t\tconst params = {\n\t\t\t\tthreshold: 0,\n\t\t\t\tstrength: 1,\n\t\t\t\tradius: 0,\n\t\t\t\texposure: 1\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 5, 2.5, - 3.5 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 100 );\n\t\t\t\tcamera.add( pointLight );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/PrimaryIonDrive.glb' );\n\n\t\t\t\tconst model = gltf.scene;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\t\t\t\tconst clip = gltf.animations[ 0 ];\n\t\t\t\tmixer.clipAction( clip.optimize() ).play();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst renderScene = new RenderPass( scene, camera );\n\n\t\t\t\tconst bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );\n\t\t\t\tbloomPass.threshold = params.threshold;\n\t\t\t\tbloomPass.strength = params.strength;\n\t\t\t\tbloomPass.radius = params.radius;\n\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\tcomposer = new EffectComposer( renderer );\n\t\t\t\tcomposer.addPass( renderScene );\n\t\t\t\tcomposer.addPass( bloomPass );\n\t\t\t\tcomposer.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.5;\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 8;\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\n\t\t\t\tbloomFolder.add( params, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {\n\n\t\t\t\t\tbloomPass.threshold = Number( value );\n\n\t\t\t\t} );\n\n\t\t\t\tbloomFolder.add( params, 'strength', 0.0, 3.0 ).onChange( function ( value ) {\n\n\t\t\t\t\tbloomPass.strength = Number( value );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'radius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tbloomPass.radius = Number( value );\n\n\t\t\t\t} );\n\n\t\t\t\tconst toneMappingFolder = gui.addFolder( 'tone mapping' );\n\n\t\t\t\ttoneMappingFolder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {\n\n\t\t\t\t\trenderer.toneMappingExposure = Math.pow( value, 4.0 );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tcomposer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcomposer.render();\n\n\t\t\t}\n```\n\nThis example three.js - Bloom pass by Prashant Sharma and Ben Houston Model: Primary Ion Drive by Mike Murdock , CC Attribution."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_postprocessing example that demonstrates webgl - postprocessing - unreal bloom selective"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - postprocessing - unreal bloom selective:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n\t\t\timport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tconst BLOOM_SCENE = 1;\n\n\t\t\tconst bloomLayer = new THREE.Layers();\n\t\t\tbloomLayer.set( BLOOM_SCENE );\n\n\t\t\tconst params = {\n\t\t\t\tthreshold: 0,\n\t\t\t\tstrength: 1,\n\t\t\t\tradius: 0.5,\n\t\t\t\texposure: 1\n\t\t\t};\n\n\t\t\tconst darkMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );\n\t\t\tconst materials = {};\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );\n\t\t\tcamera.position.set( 0, 0, 20 );\n\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.maxPolarAngle = Math.PI * 0.5;\n\t\t\tcontrols.minDistance = 1;\n\t\t\tcontrols.maxDistance = 100;\n\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\tconst renderScene = new RenderPass( scene, camera );\n\n\t\t\tconst bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );\n\t\t\tbloomPass.threshold = params.threshold;\n\t\t\tbloomPass.strength = params.strength;\n\t\t\tbloomPass.radius = params.radius;\n\n\t\t\tconst bloomComposer = new EffectComposer( renderer );\n\t\t\tbloomComposer.renderToScreen = false;\n\t\t\tbloomComposer.addPass( renderScene );\n\t\t\tbloomComposer.addPass( bloomPass );\n\n\t\t\tconst mixPass = new ShaderPass(\n\t\t\t\tnew THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tbaseTexture: { value: null },\n\t\t\t\t\t\tbloomTexture: { value: bloomComposer.renderTarget2.texture }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\n\t\t\t\t\tdefines: {}\n\t\t\t\t} ), 'baseTexture'\n\t\t\t);\n\t\t\tmixPass.needsSwap = true;\n\n\t\t\tconst outputPass = new OutputPass();\n\n\t\t\tconst finalComposer = new EffectComposer( renderer );\n\t\t\tfinalComposer.addPass( renderScene );\n\t\t\tfinalComposer.addPass( mixPass );\n\t\t\tfinalComposer.addPass( outputPass );\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\twindow.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\tconst gui = new GUI();\n\n\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\n\t\t\tbloomFolder.add( params, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {\n\n\t\t\t\tbloomPass.threshold = Number( value );\n\t\t\t\trender();\n\n\t\t\t} );\n\n\t\t\tbloomFolder.add( params, 'strength', 0.0, 3 ).onChange( function ( value ) {\n\n\t\t\t\tbloomPass.strength = Number( value );\n\t\t\t\trender();\n\n\t\t\t} );\n\n\t\t\tbloomFolder.add( params, 'radius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\tbloomPass.radius = Number( value );\n\t\t\t\trender();\n\n\t\t\t} );\n\n\t\t\tconst toneMappingFolder = gui.addFolder( 'tone mapping' );\n\n\t\t\ttoneMappingFolder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {\n\n\t\t\t\trenderer.toneMappingExposure = Math.pow( value, 4.0 );\n\t\t\t\trender();\n\n\t\t\t} );\n\n\t\t\tsetupScene();\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\traycaster.setFromCamera( mouse, camera );\n\t\t\t\tconst intersects = raycaster.intersectObjects( scene.children, false );\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst object = intersects[ 0 ].object;\n\t\t\t\t\tobject.layers.toggle( BLOOM_SCENE );\n\t\t\t\t\trender();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\tbloomComposer.setSize( width, height );\n\t\t\t\tfinalComposer.setSize( width, height );\n\n\t\t\t\trender();\n\n\t\t\t};\n\n\t\t\tfunction setupScene() {\n\n\t\t\t\tscene.traverse( disposeMaterial );\n\t\t\t\tscene.children.length = 0;\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 15 );\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tconst color = new THREE.Color();\n\t\t\t\t\tcolor.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: color } );\n\t\t\t\t\tconst sphere = new THREE.Mesh( geometry, material );\n\t\t\t\t\tsphere.position.x = Math.random() * 10 - 5;\n\t\t\t\t\tsphere.position.y = Math.random() * 10 - 5;\n\t\t\t\t\tsphere.position.z = Math.random() * 10 - 5;\n\t\t\t\t\tsphere.position.normalize().multiplyScalar( Math.random() * 4.0 + 2.0 );\n\t\t\t\t\tsphere.scale.setScalar( Math.random() * Math.random() + 0.5 );\n\t\t\t\t\tscene.add( sphere );\n\n\t\t\t\t\tif ( Math.random() < 0.25 ) sphere.layers.enable( BLOOM_SCENE );\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction disposeMaterial( obj ) {\n\n\t\t\t\tif ( obj.material ) {\n\n\t\t\t\t\tobj.material.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tscene.traverse( darkenNonBloomed );\n\t\t\t\tbloomComposer.render();\n\t\t\t\tscene.traverse( restoreMaterial );\n\n\t\t\t\t// render the entire scene, then render bloom scene on top\n\t\t\t\tfinalComposer.render();\n\n\t\t\t}\n\n\t\t\tfunction darkenNonBloomed( obj ) {\n\n\t\t\t\tif ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {\n\n\t\t\t\t\tmaterials[ obj.uuid ] = obj.material;\n\t\t\t\t\tobj.material = darkMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction restoreMaterial( obj ) {\n\n\t\t\t\tif ( materials[ obj.uuid ] ) {\n\n\t\t\t\t\tobj.material = materials[ obj.uuid ];\n\t\t\t\t\tdelete materials[ obj.uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js Click on a sphere to toggle bloom By Temdog007"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffffff, 4.5 );\n\t\t\t\tlight2.position.set( 0, - 1, 0 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst triangles = 160000;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst normals = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst n = 800, n2 = n / 2;\t// triangles spread in the cube\n\t\t\t\tconst d = 12, d2 = d / 2;\t// individual triangle size\n\n\t\t\t\tconst pA = new THREE.Vector3();\n\t\t\t\tconst pB = new THREE.Vector3();\n\t\t\t\tconst pC = new THREE.Vector3();\n\n\t\t\t\tconst cb = new THREE.Vector3();\n\t\t\t\tconst ab = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < triangles; i ++ ) {\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tconst ax = x + Math.random() * d - d2;\n\t\t\t\t\tconst ay = y + Math.random() * d - d2;\n\t\t\t\t\tconst az = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst bx = x + Math.random() * d - d2;\n\t\t\t\t\tconst by = y + Math.random() * d - d2;\n\t\t\t\t\tconst bz = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst cx = x + Math.random() * d - d2;\n\t\t\t\t\tconst cy = y + Math.random() * d - d2;\n\t\t\t\t\tconst cz = z + Math.random() * d - d2;\n\n\t\t\t\t\tpositions.push( ax, ay, az );\n\t\t\t\t\tpositions.push( bx, by, bz );\n\t\t\t\t\tpositions.push( cx, cy, cz );\n\n\t\t\t\t\t// flat face normals\n\n\t\t\t\t\tpA.set( ax, ay, az );\n\t\t\t\t\tpB.set( bx, by, bz );\n\t\t\t\t\tpC.set( cx, cy, cz );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\tconst nx = cb.x;\n\t\t\t\t\tconst ny = cb.y;\n\t\t\t\t\tconst nz = cb.z;\n\n\t\t\t\t\tnormals.push( nx, ny, nz );\n\t\t\t\t\tnormals.push( nx, ny, nz );\n\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tconst vx = ( x / n ) + 0.5;\n\t\t\t\t\tconst vy = ( y / n ) + 0.5;\n\t\t\t\t\tconst vz = ( z / n ) + 0.5;\n\n\t\t\t\t\tcolor.setRGB( vx, vy, vz );\n\n\t\t\t\t\tconst alpha = Math.random();\n\n\t\t\t\t\tcolors.push( color.r, color.g, color.b, alpha );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b, alpha );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tfunction disposeArray() {\n\n\t\t\t\t\tthis.array = null;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ).onUpload( disposeArray ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ).onUpload( disposeArray ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 4 ).onUpload( disposeArray ) );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xd5d5d5, specular: 0xffffff, shininess: 250,\n\t\t\t\t\tside: THREE.DoubleSide, vertexColors: true, transparent: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tmesh.rotation.x = time * 0.25;\n\t\t\t\tmesh.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates WebGL 2 - buffergeometry - integer attributes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL 2 - buffergeometry - integer attributes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );\n\t\t\t\tcamera.position.z = 2500;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst triangles = 10000;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst uvs = [];\n\t\t\t\tconst textureIndices = [];\n\n\t\t\t\tconst n = 800, n2 = n / 2; // triangles spread in the cube\n\t\t\t\tconst d = 50, d2 = d / 2; // individual triangle size\n\n\t\t\t\tfor ( let i = 0; i < triangles; i ++ ) {\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tconst ax = x + Math.random() * d - d2;\n\t\t\t\t\tconst ay = y + Math.random() * d - d2;\n\t\t\t\t\tconst az = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst bx = x + Math.random() * d - d2;\n\t\t\t\t\tconst by = y + Math.random() * d - d2;\n\t\t\t\t\tconst bz = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst cx = x + Math.random() * d - d2;\n\t\t\t\t\tconst cy = y + Math.random() * d - d2;\n\t\t\t\t\tconst cz = z + Math.random() * d - d2;\n\n\t\t\t\t\tpositions.push( ax, ay, az );\n\t\t\t\t\tpositions.push( bx, by, bz );\n\t\t\t\t\tpositions.push( cx, cy, cz );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( 0, 0 );\n\t\t\t\t\tuvs.push( 0.5, 1 );\n\t\t\t\t\tuvs.push( 1, 0 );\n\n\t\t\t\t\t// texture indices\n\n\t\t\t\t\tconst t = i % 3;\n\t\t\t\t\ttextureIndices.push( t, t, t );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\t\t\t\tgeometry.setAttribute( 'textureIndex', new THREE.Int16BufferAttribute( textureIndices, 1 ) );\n\t\t\t\tgeometry.attributes.textureIndex.gpuType = THREE.IntType;\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\t// material\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tconst map1 = loader.load( 'textures/crate.gif' );\n\t\t\t\tconst map2 = loader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tconst map3 = loader.load( 'textures/terrain/grasslight-big.jpg' );\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tuTextures: {\n\t\t\t\t\t\t\tvalue: [ map1, map2, map3 ]\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: /* glsl */`\n\t\t\t\t\t\tin int textureIndex;\n\n\t\t\t\t\t\tflat out int vIndex; // \"flat\" indicates that the value will not be interpolated (required for integer attributes)\n\t\t\t\t\t\tout vec2 vUv;\n\n\t\t\t\t\t\tvoid main()\t{\n\n\t\t\t\t\t\t\tvIndex = textureIndex;\n\t\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t`,\n\t\t\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t\t\tflat in int vIndex;\n\t\t\t\t\t\tin vec2 vUv;\n\n\t\t\t\t\t\tuniform sampler2D uTextures[ 3 ];\n\n\t\t\t\t\t\tout vec4 outColor;\n\n\t\t\t\t\t\tvoid main()\t{\n\n\t\t\t\t\t\t\tif ( vIndex == 0 ) outColor = texture( uTextures[ 0 ], vUv );\n\t\t\t\t\t\t\telse if ( vIndex == 1 ) outColor = texture( uTextures[ 1 ], vUv );\n\t\t\t\t\t\t\telse if ( vIndex == 2 ) outColor = texture( uTextures[ 2 ], vUv );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t`,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t} );\n\n\t\t\t\t// mesh\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tmesh.rotation.x = time * 0.25;\n\t\t\t\tmesh.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGL 2 - buffergeometry - integer attributes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates WebGL 2 - buffergeometry - attributes - none"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL 2 - buffergeometry - attributes - none:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst triangleCount = 10000;\n\t\t\t\tconst vertexCountPerTriangle = 3;\n\t\t\t\tconst vertexCount = triangleCount * vertexCountPerTriangle;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setDrawRange( 0, vertexCount );\n\n\t\t\t\t// material\n\n\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tseed: { value: 42 },\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t} );\n\n\t\t\t\t// mesh\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.frustumCulled = false;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\tfunction animate( time ) {\n\n\t\t\t\tmesh.rotation.x = time / 1000.0 * 0.25;\n\t\t\t\tmesh.rotation.y = time / 1000.0 * 0.50;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGL 2 - buffergeometry - attributes - none"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffer geometry custom attributes - particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffer geometry custom attributes - particles:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet particleSystem, uniforms, geometry;\n\n\t\t\tconst particles = 100000;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tuniforms = {\n\n\t\t\t\t\tpointTexture: { value: new THREE.TextureLoader().load( 'textures/sprites/spark1.png' ) }\n\n\t\t\t\t};\n\n\t\t\t\tconst shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\n\n\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\tvertexColors: true\n\n\t\t\t\t} );\n\n\n\t\t\t\tconst radius = 200;\n\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\t\t\t\tconst sizes = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < particles; i ++ ) {\n\n\t\t\t\t\tpositions.push( ( Math.random() * 2 - 1 ) * radius );\n\t\t\t\t\tpositions.push( ( Math.random() * 2 - 1 ) * radius );\n\t\t\t\t\tpositions.push( ( Math.random() * 2 - 1 ) * radius );\n\n\t\t\t\t\tcolor.setHSL( i / particles, 1.0, 0.5 );\n\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t\tsizes.push( 20 );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ).setUsage( THREE.DynamicDrawUsage ) );\n\n\t\t\t\tparticleSystem = new THREE.Points( geometry, shaderMaterial );\n\n\t\t\t\tscene.add( particleSystem );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.005;\n\n\t\t\t\tparticleSystem.rotation.z = 0.01 * time;\n\n\t\t\t\tconst sizes = geometry.attributes.size.array;\n\n\t\t\t\tfor ( let i = 0; i < particles; i ++ ) {\n\n\t\t\t\t\tsizes[ i ] = 10 * ( 1 + Math.sin( 0.1 * i + time ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.attributes.size.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry custom attributes - particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - lines drawrange"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - lines drawrange:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet group;\n\t\t\tlet container, stats;\n\t\t\tconst particlesData = [];\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet positions, colors;\n\t\t\tlet particles;\n\t\t\tlet pointCloud;\n\t\t\tlet particlePositions;\n\t\t\tlet linesMesh;\n\n\t\t\tconst maxParticleCount = 1000;\n\t\t\tlet particleCount = 500;\n\t\t\tconst r = 800;\n\t\t\tconst rHalf = r / 2;\n\n\t\t\tconst effectController = {\n\t\t\t\tshowDots: true,\n\t\t\t\tshowLines: true,\n\t\t\t\tminDistance: 150,\n\t\t\t\tlimitConnections: false,\n\t\t\t\tmaxConnections: 20,\n\t\t\t\tparticleCount: 500\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( effectController, 'showDots' ).onChange( function ( value ) {\n\n\t\t\t\t\tpointCloud.visible = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( effectController, 'showLines' ).onChange( function ( value ) {\n\n\t\t\t\t\tlinesMesh.visible = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( effectController, 'minDistance', 10, 300 );\n\t\t\t\tgui.add( effectController, 'limitConnections' );\n\t\t\t\tgui.add( effectController, 'maxConnections', 0, 30, 1 );\n\t\t\t\tgui.add( effectController, 'particleCount', 0, maxParticleCount, 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tparticleCount = value;\n\t\t\t\t\tparticles.setDrawRange( 0, particleCount );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitGUI();\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );\n\t\t\t\tcamera.position.z = 1750;\n\n\t\t\t\tconst controls = new OrbitControls( camera, container );\n\t\t\t\tcontrols.minDistance = 1000;\n\t\t\t\tcontrols.maxDistance = 3000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );\n\t\t\t\thelper.material.color.setHex( 0x474747 );\n\t\t\t\thelper.material.blending = THREE.AdditiveBlending;\n\t\t\t\thelper.material.transparent = true;\n\t\t\t\tgroup.add( helper );\n\n\t\t\t\tconst segments = maxParticleCount * maxParticleCount;\n\n\t\t\t\tpositions = new Float32Array( segments * 3 );\n\t\t\t\tcolors = new Float32Array( segments * 3 );\n\n\t\t\t\tconst pMaterial = new THREE.PointsMaterial( {\n\t\t\t\t\tcolor: 0xFFFFFF,\n\t\t\t\t\tsize: 3,\n\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\tsizeAttenuation: false\n\t\t\t\t} );\n\n\t\t\t\tparticles = new THREE.BufferGeometry();\n\t\t\t\tparticlePositions = new Float32Array( maxParticleCount * 3 );\n\n\t\t\t\tfor ( let i = 0; i < maxParticleCount; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * r - r / 2;\n\t\t\t\t\tconst y = Math.random() * r - r / 2;\n\t\t\t\t\tconst z = Math.random() * r - r / 2;\n\n\t\t\t\t\tparticlePositions[ i * 3 ] = x;\n\t\t\t\t\tparticlePositions[ i * 3 + 1 ] = y;\n\t\t\t\t\tparticlePositions[ i * 3 + 2 ] = z;\n\n\t\t\t\t\t// add it to the geometry\n\t\t\t\t\tparticlesData.push( {\n\t\t\t\t\t\tvelocity: new THREE.Vector3( - 1 + Math.random() * 2, - 1 + Math.random() * 2, - 1 + Math.random() * 2 ),\n\t\t\t\t\t\tnumConnections: 0\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tparticles.setDrawRange( 0, particleCount );\n\t\t\t\tparticles.setAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setUsage( THREE.DynamicDrawUsage ) );\n\n\t\t\t\t// create the particle system\n\t\t\t\tpointCloud = new THREE.Points( particles, pMaterial );\n\t\t\t\tgroup.add( pointCloud );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tgeometry.setDrawRange( 0, 0 );\n\n\t\t\t\tconst material = new THREE.LineBasicMaterial( {\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tlinesMesh = new THREE.LineSegments( geometry, material );\n\t\t\t\tgroup.add( linesMesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tlet vertexpos = 0;\n\t\t\t\tlet colorpos = 0;\n\t\t\t\tlet numConnected = 0;\n\n\t\t\t\tfor ( let i = 0; i < particleCount; i ++ )\n\t\t\t\t\tparticlesData[ i ].numConnections = 0;\n\n\t\t\t\tfor ( let i = 0; i < particleCount; i ++ ) {\n\n\t\t\t\t\t// get the particle\n\t\t\t\t\tconst particleData = particlesData[ i ];\n\n\t\t\t\t\tparticlePositions[ i * 3 ] += particleData.velocity.x;\n\t\t\t\t\tparticlePositions[ i * 3 + 1 ] += particleData.velocity.y;\n\t\t\t\t\tparticlePositions[ i * 3 + 2 ] += particleData.velocity.z;\n\n\t\t\t\t\tif ( particlePositions[ i * 3 + 1 ] < - rHalf || particlePositions[ i * 3 + 1 ] > rHalf )\n\t\t\t\t\t\tparticleData.velocity.y = - particleData.velocity.y;\n\n\t\t\t\t\tif ( particlePositions[ i * 3 ] < - rHalf || particlePositions[ i * 3 ] > rHalf )\n\t\t\t\t\t\tparticleData.velocity.x = - particleData.velocity.x;\n\n\t\t\t\t\tif ( particlePositions[ i * 3 + 2 ] < - rHalf || particlePositions[ i * 3 + 2 ] > rHalf )\n\t\t\t\t\t\tparticleData.velocity.z = - particleData.velocity.z;\n\n\t\t\t\t\tif ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// Check collision\n\t\t\t\t\tfor ( let j = i + 1; j < particleCount; j ++ ) {\n\n\t\t\t\t\t\tconst particleDataB = particlesData[ j ];\n\t\t\t\t\t\tif ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tconst dx = particlePositions[ i * 3 ] - particlePositions[ j * 3 ];\n\t\t\t\t\t\tconst dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];\n\t\t\t\t\t\tconst dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];\n\t\t\t\t\t\tconst dist = Math.sqrt( dx * dx + dy * dy + dz * dz );\n\n\t\t\t\t\t\tif ( dist < effectController.minDistance ) {\n\n\t\t\t\t\t\t\tparticleData.numConnections ++;\n\t\t\t\t\t\t\tparticleDataB.numConnections ++;\n\n\t\t\t\t\t\t\tconst alpha = 1.0 - dist / effectController.minDistance;\n\n\t\t\t\t\t\t\tpositions[ vertexpos ++ ] = particlePositions[ i * 3 ];\n\t\t\t\t\t\t\tpositions[ vertexpos ++ ] = particlePositions[ i * 3 + 1 ];\n\t\t\t\t\t\t\tpositions[ vertexpos ++ ] = particlePositions[ i * 3 + 2 ];\n\n\t\t\t\t\t\t\tpositions[ vertexpos ++ ] = particlePositions[ j * 3 ];\n\t\t\t\t\t\t\tpositions[ vertexpos ++ ] = particlePositions[ j * 3 + 1 ];\n\t\t\t\t\t\t\tpositions[ vertexpos ++ ] = particlePositions[ j * 3 + 2 ];\n\n\t\t\t\t\t\t\tcolors[ colorpos ++ ] = alpha;\n\t\t\t\t\t\t\tcolors[ colorpos ++ ] = alpha;\n\t\t\t\t\t\t\tcolors[ colorpos ++ ] = alpha;\n\n\t\t\t\t\t\t\tcolors[ colorpos ++ ] = alpha;\n\t\t\t\t\t\t\tcolors[ colorpos ++ ] = alpha;\n\t\t\t\t\t\t\tcolors[ colorpos ++ ] = alpha;\n\n\t\t\t\t\t\t\tnumConnected ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tlinesMesh.geometry.setDrawRange( 0, numConnected * 2 );\n\t\t\t\tlinesMesh.geometry.attributes.position.needsUpdate = true;\n\t\t\t\tlinesMesh.geometry.attributes.color.needsUpdate = true;\n\n\t\t\t\tpointCloud.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tgroup.rotation.y = time * 0.1;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry drawrange by fernandojsg"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - custom VBOs"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - custom VBOs:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet points;\n\n\t\t\tconst particles = 300000;\n\t\t\tlet drawCount = 10000;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 3500 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst positions2 = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst n = 1000, n2 = n / 2; // particles spread in the cube\n\n\t\t\t\tfor ( let i = 0; i < particles; i ++ ) {\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tpositions.push( x, y, z );\n\t\t\t\t\tpositions2.push( z * 0.3, x * 0.3, y * 0.3 );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tconst vx = ( x / n ) + 0.5;\n\t\t\t\t\tconst vy = ( y / n ) + 0.5;\n\t\t\t\t\tconst vz = ( z / n ) + 0.5;\n\n\t\t\t\t\tcolor.setRGB( vx, vy, vz, THREE.SRGBColorSpace );\n\n\t\t\t\t\tconst hex = color.getHex( THREE.LinearSRGBColorSpace );\n\t\t\t\t\tcolors.push( hex >> 16 & 255, hex >> 8 & 255, hex & 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst gl = renderer.getContext();\n\n\t\t\t\tconst pos = gl.createBuffer();\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, pos );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, new Float32Array( positions ), gl.STATIC_DRAW );\n\n\t\t\t\tconst pos2 = gl.createBuffer();\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, pos2 );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, new Float32Array( positions2 ), gl.STATIC_DRAW );\n\n\t\t\t\tconst rgb = gl.createBuffer();\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, rgb );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, new Uint8Array( colors ), gl.STATIC_DRAW );\n\n\t\t\t\tconst posAttr1 = new THREE.GLBufferAttribute( pos, gl.FLOAT, 3, 4, particles );\n\t\t\t\tconst posAttr2 = new THREE.GLBufferAttribute( pos2, gl.FLOAT, 3, 4, particles );\n\t\t\t\tgeometry.setAttribute( 'position', posAttr1 );\n\n\t\t\t\tsetInterval( function () {\n\n\t\t\t\t\tconst attr = geometry.getAttribute( 'position' );\n\n\t\t\t\t\tgeometry.setAttribute( 'position', ( attr === posAttr1 ) ? posAttr2 : posAttr1 );\n\n\t\t\t\t}, 2000 );\n\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.GLBufferAttribute( rgb, gl.UNSIGNED_BYTE, 3, 1, particles, true ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.PointsMaterial( { size: 15, vertexColors: true } );\n\n\t\t\t\tpoints = new THREE.Points( geometry, material );\n\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere().set( new THREE.Vector3(), 500 );\n\n\t\t\t\tscene.add( points );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tdrawCount = ( Math.max( 5000, drawCount ) + Math.floor( 500 * Math.random() ) ) % particles;\n\t\t\t\tpoints.geometry.setDrawRange( 0, drawCount );\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tpoints.rotation.x = time * 0.1;\n\t\t\t\tpoints.rotation.y = time * 0.2;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - custom VBOs"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - indexed"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - indexed:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );\n\t\t\t\tcamera.position.z = 64;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\n\t\t\t\t//\n\n\t\t\t\tconst light = new THREE.HemisphereLight();\n\t\t\t\tlight.intensity = 3;\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst indices = [];\n\n\t\t\t\tconst vertices = [];\n\t\t\t\tconst normals = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst size = 20;\n\t\t\t\tconst segments = 10;\n\n\t\t\t\tconst halfSize = size / 2;\n\t\t\t\tconst segmentSize = size / segments;\n\n\t\t\t\tconst _color = new THREE.Color();\n\n\t\t\t\t// generate vertices, normals and color data for a simple grid geometry\n\n\t\t\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\t\t\tconst y = ( i * segmentSize ) - halfSize;\n\n\t\t\t\t\tfor ( let j = 0; j <= segments; j ++ ) {\n\n\t\t\t\t\t\tconst x = ( j * segmentSize ) - halfSize;\n\n\t\t\t\t\t\tvertices.push( x, - y, 0 );\n\t\t\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t\t\tconst r = ( x / size ) + 0.5;\n\t\t\t\t\t\tconst g = ( y / size ) + 0.5;\n\n\t\t\t\t\t\t_color.setRGB( r, g, 1, THREE.SRGBColorSpace );\n\n\t\t\t\t\t\tcolors.push( _color.r, _color.g, _color.b );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// generate indices (data for element array buffer)\n\n\t\t\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < segments; j ++ ) {\n\n\t\t\t\t\t\tconst a = i * ( segments + 1 ) + ( j + 1 );\n\t\t\t\t\t\tconst b = i * ( segments + 1 ) + j;\n\t\t\t\t\t\tconst c = ( i + 1 ) * ( segments + 1 ) + j;\n\t\t\t\t\t\tconst d = ( i + 1 ) * ( segments + 1 ) + ( j + 1 );\n\n\t\t\t\t\t\t// generate two faces (triangles) per iteration\n\n\t\t\t\t\t\tindices.push( a, b, d ); // face one\n\t\t\t\t\t\tindices.push( b, c, d ); // face two\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tvertexColors: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( material, 'wireframe' );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tmesh.rotation.x = time * 0.25;\n\t\t\t\tmesh.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - indexed"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - instancing test (single triangle)"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instancing test (single triangle):\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\tlet container, stats;\n\n\t\tlet camera, scene, renderer;\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10 );\n\t\t\tcamera.position.z = 2;\n\n\t\t\tscene = new THREE.Scene();\n\n\t\t\t// geometry\n\n\t\t\tconst vector = new THREE.Vector4();\n\n\t\t\tconst instances = 50000;\n\n\t\t\tconst positions = [];\n\t\t\tconst offsets = [];\n\t\t\tconst colors = [];\n\t\t\tconst orientationsStart = [];\n\t\t\tconst orientationsEnd = [];\n\n\t\t\tpositions.push( 0.025, - 0.025, 0 );\n\t\t\tpositions.push( - 0.025, 0.025, 0 );\n\t\t\tpositions.push( 0, 0, 0.025 );\n\n\t\t\t// instanced attributes\n\n\t\t\tfor ( let i = 0; i < instances; i ++ ) {\n\n\t\t\t\t// offsets\n\n\t\t\t\toffsets.push( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );\n\n\t\t\t\t// colors\n\n\t\t\t\tcolors.push( Math.random(), Math.random(), Math.random(), Math.random() );\n\n\t\t\t\t// orientation start\n\n\t\t\t\tvector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );\n\t\t\t\tvector.normalize();\n\n\t\t\t\torientationsStart.push( vector.x, vector.y, vector.z, vector.w );\n\n\t\t\t\t// orientation end\n\n\t\t\t\tvector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );\n\t\t\t\tvector.normalize();\n\n\t\t\t\torientationsEnd.push( vector.x, vector.y, vector.z, vector.w );\n\n\t\t\t}\n\n\t\t\tconst geometry = new THREE.InstancedBufferGeometry();\n\t\t\tgeometry.instanceCount = instances; // set so its initialized for dat.GUI, will be set in first draw otherwise\n\n\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\n\t\t\tgeometry.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );\n\t\t\tgeometry.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );\n\t\t\tgeometry.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientationsStart ), 4 ) );\n\t\t\tgeometry.setAttribute( 'orientationEnd', new THREE.InstancedBufferAttribute( new Float32Array( orientationsEnd ), 4 ) );\n\n\t\t\t// material\n\n\t\t\tconst material = new THREE.RawShaderMaterial( {\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t'time': { value: 1.0 },\n\t\t\t\t\t'sineTime': { value: 1.0 }\n\t\t\t\t},\n\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent,\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\tforceSinglePass: true,\n\t\t\t\ttransparent: true\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\tconst gui = new GUI( { width: 350 } );\n\t\t\tgui.add( geometry, 'instanceCount', 0, instances );\n\n\t\t\t//\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction animate() {\n\n\t\t\tconst time = performance.now();\n\n\t\t\tconst object = scene.children[ 0 ];\n\n\t\t\tobject.rotation.y = time * 0.0005;\n\t\t\tobject.material.uniforms[ 'time' ].value = time * 0.005;\n\t\t\tobject.material.uniforms[ 'sineTime' ].value = Math.sin( object.material.uniforms[ 'time' ].value * 0.05 );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update();\n\n\t\t}\n```\n\nThis example three.js - instancing demo (single triangle) Sorry your graphics card + browser does not support hardware instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - instanced particles - billboards - colors"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - instanced particles - billboards - colors:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\tlet container, stats;\n\n\t\tlet camera, scene, renderer;\n\t\tlet geometry, material, mesh;\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcontainer = document.createElement( 'div' );\n\t\t\tdocument.body.appendChild( container );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\tcamera.position.z = 1400;\n\n\t\t\tscene = new THREE.Scene();\n\n\t\t\tconst circleGeometry = new THREE.CircleGeometry( 1, 6 );\n\n\t\t\tgeometry = new THREE.InstancedBufferGeometry();\n\t\t\tgeometry.index = circleGeometry.index;\n\t\t\tgeometry.attributes = circleGeometry.attributes;\n\n\t\t\tconst particleCount = 75000;\n\n\t\t\tconst translateArray = new Float32Array( particleCount * 3 );\n\n\t\t\tfor ( let i = 0, i3 = 0, l = particleCount; i < l; i ++, i3 += 3 ) {\n\n\t\t\t\ttranslateArray[ i3 + 0 ] = Math.random() * 2 - 1;\n\t\t\t\ttranslateArray[ i3 + 1 ] = Math.random() * 2 - 1;\n\t\t\t\ttranslateArray[ i3 + 2 ] = Math.random() * 2 - 1;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'translate', new THREE.InstancedBufferAttribute( translateArray, 3 ) );\n\n\t\t\tmaterial = new THREE.RawShaderMaterial( {\n\t\t\t\tuniforms: {\n\t\t\t\t\t'map': { value: new THREE.TextureLoader().load( 'textures/sprites/circle.png' ) },\n\t\t\t\t\t'time': { value: 0.0 }\n\t\t\t\t},\n\t\t\t\tvertexShader: document.getElementById( 'vshader' ).textContent,\n\t\t\t\tfragmentShader: document.getElementById( 'fshader' ).textContent,\n\t\t\t\tdepthTest: true,\n\t\t\t\tdepthWrite: true\n\t\t\t} );\n\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.scale.set( 500, 500, 500 );\n\t\t\tscene.add( mesh );\n\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst time = performance.now() * 0.0005;\n\n\t\t\tmaterial.uniforms[ 'time' ].value = time;\n\n\t\t\tmesh.rotation.x = time * 0.2;\n\t\t\tmesh.rotation.y = time * 0.4;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update();\n\n\t\t}\n```\n\nThis example three.js - instanced circle billboards - colors Sorry, your graphics card + browser does not support hardware instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - indexed instancing (single box), interleaved buffers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - indexed instancing (single box), interleaved buffers:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\tlet container, stats;\n\t\tlet camera, scene, renderer, mesh;\n\n\t\tconst instances = 5000;\n\t\tlet lastTime = 0;\n\n\t\tconst moveQ = new THREE.Quaternion( 0.5, 0.5, 0.5, 0.0 ).normalize();\n\t\tconst tmpQ = new THREE.Quaternion();\n\t\tconst tmpM = new THREE.Matrix4();\n\t\tconst currentM = new THREE.Matrix4();\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x101010 );\n\n\t\t\t// geometry\n\n\t\t\tconst geometry = new THREE.InstancedBufferGeometry();\n\n\t\t\t// per mesh data x,y,z,w,u,v,s,t for 4-element alignment\n\t\t\t// only use x,y,z and u,v; but x, y, z, nx, ny, nz, u, v would be a good layout\n\t\t\tconst vertexBuffer = new THREE.InterleavedBuffer( new Float32Array( [\n\t\t\t\t// Front\n\t\t\t\t- 1, 1, 1, 0, 0, 0, 0, 0,\n\t\t\t\t1, 1, 1, 0, 1, 0, 0, 0,\n\t\t\t\t- 1, - 1, 1, 0, 0, 1, 0, 0,\n\t\t\t\t1, - 1, 1, 0, 1, 1, 0, 0,\n\t\t\t\t// Back\n\t\t\t\t1, 1, - 1, 0, 1, 0, 0, 0,\n\t\t\t\t- 1, 1, - 1, 0, 0, 0, 0, 0,\n\t\t\t\t1, - 1, - 1, 0, 1, 1, 0, 0,\n\t\t\t\t- 1, - 1, - 1, 0, 0, 1, 0, 0,\n\t\t\t\t// Left\n\t\t\t\t- 1, 1, - 1, 0, 1, 1, 0, 0,\n\t\t\t\t- 1, 1, 1, 0, 1, 0, 0, 0,\n\t\t\t\t- 1, - 1, - 1, 0, 0, 1, 0, 0,\n\t\t\t\t- 1, - 1, 1, 0, 0, 0, 0, 0,\n\t\t\t\t// Right\n\t\t\t\t1, 1, 1, 0, 1, 0, 0, 0,\n\t\t\t\t1, 1, - 1, 0, 1, 1, 0, 0,\n\t\t\t\t1, - 1, 1, 0, 0, 0, 0, 0,\n\t\t\t\t1, - 1, - 1, 0, 0, 1, 0, 0,\n\t\t\t\t// Top\n\t\t\t\t- 1, 1, 1, 0, 0, 0, 0, 0,\n\t\t\t\t1, 1, 1, 0, 1, 0, 0, 0,\n\t\t\t\t- 1, 1, - 1, 0, 0, 1, 0, 0,\n\t\t\t\t1, 1, - 1, 0, 1, 1, 0, 0,\n\t\t\t\t// Bottom\n\t\t\t\t1, - 1, 1, 0, 1, 0, 0, 0,\n\t\t\t\t- 1, - 1, 1, 0, 0, 0, 0, 0,\n\t\t\t\t1, - 1, - 1, 0, 1, 1, 0, 0,\n\t\t\t\t- 1, - 1, - 1, 0, 0, 1, 0, 0\n\t\t\t] ), 8 );\n\n\t\t\t// Use vertexBuffer, starting at offset 0, 3 items in position attribute\n\t\t\tconst positions = new THREE.InterleavedBufferAttribute( vertexBuffer, 3, 0 );\n\t\t\tgeometry.setAttribute( 'position', positions );\n\t\t\t// Use vertexBuffer, starting at offset 4, 2 items in uv attribute\n\t\t\tconst uvs = new THREE.InterleavedBufferAttribute( vertexBuffer, 2, 4 );\n\t\t\tgeometry.setAttribute( 'uv', uvs );\n\n\t\t\tconst indices = new Uint16Array( [\n\t\t\t\t0, 2, 1,\n\t\t\t\t2, 3, 1,\n\t\t\t\t4, 6, 5,\n\t\t\t\t6, 7, 5,\n\t\t\t\t8, 10, 9,\n\t\t\t\t10, 11, 9,\n\t\t\t\t12, 14, 13,\n\t\t\t\t14, 15, 13,\n\t\t\t\t16, 17, 18,\n\t\t\t\t18, 17, 19,\n\t\t\t\t20, 21, 22,\n\t\t\t\t22, 21, 23\n\t\t\t] );\n\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\n\t\t\t// material\n\n\t\t\tconst material = new THREE.MeshBasicMaterial();\n\t\t\tmaterial.map = new THREE.TextureLoader().load( 'textures/crate.gif' );\n\t\t\tmaterial.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\tmaterial.map.flipY = false;\n\n\t\t\t// per instance data\n\n\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\tconst offset = new THREE.Vector3();\n\t\t\tconst orientation = new THREE.Quaternion();\n\t\t\tconst scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\tlet x, y, z, w;\n\n\t\t\tmesh = new THREE.InstancedMesh( geometry, material, instances );\n\n\t\t\tfor ( let i = 0; i < instances; i ++ ) {\n\n\t\t\t\t// offsets\n\n\t\t\t\tx = Math.random() * 100 - 50;\n\t\t\t\ty = Math.random() * 100 - 50;\n\t\t\t\tz = Math.random() * 100 - 50;\n\n\t\t\t\toffset.set( x, y, z ).normalize();\n\t\t\t\toffset.multiplyScalar( 5 ); // move out at least 5 units from center in current direction\n\t\t\t\toffset.set( x + offset.x, y + offset.y, z + offset.z );\n\n\t\t\t\t// orientations\n\n\t\t\t\tx = Math.random() * 2 - 1;\n\t\t\t\ty = Math.random() * 2 - 1;\n\t\t\t\tz = Math.random() * 2 - 1;\n\t\t\t\tw = Math.random() * 2 - 1;\n\n\t\t\t\torientation.set( x, y, z, w ).normalize();\n\n\t\t\t\tmatrix.compose( offset, orientation, scale );\n\n\t\t\t\tmesh.setMatrixAt( i, matrix );\n\n\t\t\t}\n\n\t\t\tscene.add( mesh );\n\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tstats = new Stats();\n\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction animate() {\n\n\t\t\tconst time = performance.now();\n\n\t\t\tmesh.rotation.y = time * 0.00005;\n\n\t\t\tconst delta = ( time - lastTime ) / 5000;\n\t\t\ttmpQ.set( moveQ.x * delta, moveQ.y * delta, moveQ.z * delta, 1 ).normalize();\n\t\t\ttmpM.makeRotationFromQuaternion( tmpQ );\n\n\t\t\tfor ( let i = 0, il = instances; i < il; i ++ ) {\n\n\t\t\t\tmesh.getMatrixAt( i, currentM );\n\t\t\t\tcurrentM.multiply( tmpM );\n\t\t\t\tmesh.setMatrixAt( i, currentM );\n\n\t\t\t}\n\n\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\t\t\tmesh.computeBoundingSphere();\n\n\t\t\tlastTime = time;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tstats.update();\n\n\t\t}\n```\n\nThis example three.js - indexed instancing (single box), interleaved buffers Sorry your graphics card + browser does not support hardware instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - lines"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - lines:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats, timer;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet line;\n\n\t\t\tconst segments = 10000;\n\t\t\tconst r = 800;\n\t\t\tlet t = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 4000 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst material = new THREE.LineBasicMaterial( { vertexColors: true } );\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * r - r / 2;\n\t\t\t\t\tconst y = Math.random() * r - r / 2;\n\t\t\t\t\tconst z = Math.random() * r - r / 2;\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tcolors.push( ( x / r ) + 0.5 );\n\t\t\t\t\tcolors.push( ( y / r ) + 0.5 );\n\t\t\t\t\tcolors.push( ( z / r ) + 0.5 );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\t\t\t\tgenerateMorphTargets( geometry );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tline = new THREE.Line( geometry, material );\n\t\t\t\tscene.add( line );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\tconst delta = timer.getDelta();\n\t\t\t\tconst time = timer.getElapsed();\n\n\t\t\t\tline.rotation.x = time * 0.25;\n\t\t\t\tline.rotation.y = time * 0.5;\n\n\t\t\t\tt += delta * 0.5;\n\t\t\t\tline.morphTargetInfluences[ 0 ] = Math.abs( Math.sin( t ) );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction generateMorphTargets( geometry ) {\n\n\t\t\t\tconst data = [];\n\n\t\t\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * r - r / 2;\n\t\t\t\t\tconst y = Math.random() * r - r / 2;\n\t\t\t\t\tconst z = Math.random() * r - r / 2;\n\n\t\t\t\t\tdata.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\tconst morphTarget = new THREE.Float32BufferAttribute( data, 3 );\n\t\t\t\tmorphTarget.name = 'target1';\n\n\t\t\t\tgeometry.morphAttributes.position = [ morphTarget ];\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - lines"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - lines - indexed"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - lines - indexed:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet parent_node;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 9000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst material = new THREE.LineBasicMaterial( { vertexColors: true } );\n\n\t\t\t\tconst indices = [];\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tlet next_positions_index = 0;\n\n\t\t\t\t//\n\n\t\t\t\tconst iteration_count = 4;\n\t\t\t\tconst rangle = 60 * Math.PI / 180.0;\n\n\t\t\t\tfunction add_vertex( v ) {\n\n\t\t\t\t\tpositions.push( v.x, v.y, v.z );\n\t\t\t\t\tcolors.push( Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, 1 );\n\n\t\t\t\t\treturn next_positions_index ++;\n\n\t\t\t\t}\n\n\t\t\t\t// simple Koch curve\n\n\t\t\t\tfunction snowflake_iteration( p0, p4, depth ) {\n\n\t\t\t\t\tif ( -- depth < 0 ) {\n\n\t\t\t\t\t\tconst i = next_positions_index - 1; // p0 already there\n\t\t\t\t\t\tadd_vertex( p4 );\n\t\t\t\t\t\tindices.push( i, i + 1 );\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst v = p4.clone().sub( p0 );\n\t\t\t\t\tconst v_tier = v.clone().multiplyScalar( 1 / 3 );\n\t\t\t\t\tconst p1 = p0.clone().add( v_tier );\n\n\t\t\t\t\tconst angle = Math.atan2( v.y, v.x ) + rangle;\n\t\t\t\t\tconst length = v_tier.length();\n\t\t\t\t\tconst p2 = p1.clone();\n\t\t\t\t\tp2.x += Math.cos( angle ) * length;\n\t\t\t\t\tp2.y += Math.sin( angle ) * length;\n\n\t\t\t\t\tconst p3 = p0.clone().add( v_tier ).add( v_tier );\n\n\t\t\t\t\tsnowflake_iteration( p0, p1, depth );\n\t\t\t\t\tsnowflake_iteration( p1, p2, depth );\n\t\t\t\t\tsnowflake_iteration( p2, p3, depth );\n\t\t\t\t\tsnowflake_iteration( p3, p4, depth );\n\n\t\t\t\t}\n\n\t\t\t\tfunction snowflake( points, loop, x_offset ) {\n\n\t\t\t\t\tfor ( let iteration = 0; iteration != iteration_count; iteration ++ ) {\n\n\t\t\t\t\t\tadd_vertex( points[ 0 ] );\n\n\t\t\t\t\t\tfor ( let p_index = 0, p_count = points.length - 1; p_index != p_count; p_index ++ ) {\n\n\t\t\t\t\t\t\tsnowflake_iteration( points[ p_index ], points[ p_index + 1 ], iteration );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( loop ) snowflake_iteration( points[ points.length - 1 ], points[ 0 ], iteration );\n\n\t\t\t\t\t\t// translate input curve for next iteration\n\n\t\t\t\t\t\tfor ( let p_index = 0, p_count = points.length; p_index != p_count; p_index ++ ) {\n\n\t\t\t\t\t\t\tpoints[ p_index ].x += x_offset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet y = 0;\n\n\t\t\t\tsnowflake(\n\t\t\t\t\t[\n\t\t\t\t\t\tnew THREE.Vector3( 0, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 500, y, 0 )\n\t\t\t\t\t],\n\t\t\t\t\tfalse, 600\n\t\t\t\t);\n\n\t\t\t\ty += 600;\n\t\t\t\tsnowflake(\n\t\t\t\t\t[\n\t\t\t\t\t\tnew THREE.Vector3( 0, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y + 400, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 500, y, 0 )\n\t\t\t\t\t],\n\t\t\t\t\ttrue, 600\n\t\t\t\t);\n\n\t\t\t\ty += 600;\n\t\t\t\tsnowflake(\n\t\t\t\t\t[\n\t\t\t\t\t\tnew THREE.Vector3( 0, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 500, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 500, y + 500, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 0, y + 500, 0 )\n\t\t\t\t\t],\n\t\t\t\t\ttrue, 600\n\t\t\t\t);\n\n\t\t\t\ty += 1000;\n\t\t\t\tsnowflake(\n\t\t\t\t\t[\n\t\t\t\t\t\tnew THREE.Vector3( 250, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 500, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y + 250, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 0, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y - 250, 0 ),\n\t\t\t\t\t\tnew THREE.Vector3( 250, y, 0 )\n\t\t\t\t\t],\n\t\t\t\t\tfalse, 600\n\t\t\t\t);\n\n\t\t\t\t//\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tconst lineSegments = new THREE.LineSegments( geometry, material );\n\t\t\t\tlineSegments.position.x -= 1200;\n\t\t\t\tlineSegments.position.y -= 1200;\n\n\t\t\t\tparent_node = new THREE.Object3D();\n\t\t\t\tparent_node.add( lineSegments );\n\n\t\t\t\tscene.add( parent_node );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tparent_node.rotation.z = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - lines - indexed"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - particles:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet points;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 3500 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t//\n\n\t\t\t\tconst particles = 500000;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst n = 1000, n2 = n / 2; // particles spread in the cube\n\n\t\t\t\tfor ( let i = 0; i < particles; i ++ ) {\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tconst vx = ( x / n ) + 0.5;\n\t\t\t\t\tconst vy = ( y / n ) + 0.5;\n\t\t\t\t\tconst vz = ( z / n ) + 0.5;\n\n\t\t\t\t\tcolor.setRGB( vx, vy, vz, THREE.SRGBColorSpace );\n\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.PointsMaterial( { size: 15, vertexColors: true } );\n\n\t\t\t\tpoints = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( points );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tpoints.rotation.x = time * 0.25;\n\t\t\t\tpoints.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - particles:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet points;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 3500 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t//\n\n\t\t\t\tconst particles = 500000;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\t// create a generic buffer of binary data (a single particle has 16 bytes of data)\n\n\t\t\t\tconst arrayBuffer = new ArrayBuffer( particles * 16 );\n\n\t\t\t\t// the following typed arrays share the same buffer\n\n\t\t\t\tconst interleavedFloat32Buffer = new Float32Array( arrayBuffer );\n\t\t\t\tconst interleavedUint8Buffer = new Uint8Array( arrayBuffer );\n\n\t\t\t\t//\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst n = 1000, n2 = n / 2; // particles spread in the cube\n\n\t\t\t\tfor ( let i = 0; i < interleavedFloat32Buffer.length; i += 4 ) {\n\n\t\t\t\t\t// position (first 12 bytes)\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tinterleavedFloat32Buffer[ i + 0 ] = x;\n\t\t\t\t\tinterleavedFloat32Buffer[ i + 1 ] = y;\n\t\t\t\t\tinterleavedFloat32Buffer[ i + 2 ] = z;\n\n\t\t\t\t\t// color (last 4 bytes)\n\n\t\t\t\t\tconst vx = ( x / n ) + 0.5;\n\t\t\t\t\tconst vy = ( y / n ) + 0.5;\n\t\t\t\t\tconst vz = ( z / n ) + 0.5;\n\n\t\t\t\t\tcolor.setRGB( vx, vy, vz, THREE.SRGBColorSpace );\n\n\t\t\t\t\tconst j = ( i + 3 ) * 4;\n\n\t\t\t\t\tinterleavedUint8Buffer[ j + 0 ] = color.r * 255;\n\t\t\t\t\tinterleavedUint8Buffer[ j + 1 ] = color.g * 255;\n\t\t\t\t\tinterleavedUint8Buffer[ j + 2 ] = color.b * 255;\n\t\t\t\t\tinterleavedUint8Buffer[ j + 3 ] = 0; // not needed\n\n\t\t\t\t}\n\n\t\t\t\tconst interleavedBuffer32 = new THREE.InterleavedBuffer( interleavedFloat32Buffer, 4 );\n\t\t\t\tconst interleavedBuffer8 = new THREE.InterleavedBuffer( interleavedUint8Buffer, 16 );\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer32, 3, 0, false ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.InterleavedBufferAttribute( interleavedBuffer8, 3, 12, true ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.PointsMaterial( { size: 15, vertexColors: true } );\n\n\t\t\t\tpoints = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( points );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tpoints.rotation.x = time * 0.25;\n\t\t\t\tpoints.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - raw shader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - raw shader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10 );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x101010 );\n\n\t\t\t\t// geometry\n\t\t\t\t// nr of triangles with 3 vertices per triangle\n\t\t\t\tconst vertexCount = 200 * 3;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\t\t// adding x,y,z\n\t\t\t\t\tpositions.push( Math.random() - 0.5 );\n\t\t\t\t\tpositions.push( Math.random() - 0.5 );\n\t\t\t\t\tpositions.push( Math.random() - 0.5 );\n\n\t\t\t\t\t// adding r,g,b,a\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.Float32BufferAttribute( positions, 3 );\n\t\t\t\tconst colorAttribute = new THREE.Uint8BufferAttribute( colors, 4 );\n\n\t\t\t\tcolorAttribute.normalized = true; // this will map the buffer values to 0.0f - +1.0f in the shader\n\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t// material\n\n\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\ttime: { value: 1.0 }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\ttransparent: true\n\n\t\t\t\t} );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now();\n\n\t\t\t\tconst object = scene.children[ 0 ];\n\n\t\t\t\tobject.rotation.y = time * 0.0005;\n\t\t\t\tobject.material.uniforms.time.value = time * 0.005;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - raw shader demo"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - selective - draw"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - selective - draw:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet geometry, mesh;\n\t\t\tconst numLat = 100;\n\t\t\tconst numLng = 200;\n\t\t\tlet numLinesCulled = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.z = 3.5;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\taddLines( 1.0 );\n\n\t\t\t\tconst hideLinesButton = document.getElementById( 'hideLines' );\n\t\t\t\thideLinesButton.addEventListener( 'click', hideLines );\n\n\t\t\t\tconst showAllLinesButton = document.getElementById( 'showAllLines' );\n\t\t\t\tshowAllLinesButton.addEventListener( 'click', showAllLines );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\tfunction addLines( radius ) {\n\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\tconst linePositions = new Float32Array( numLat * numLng * 3 * 2 );\n\t\t\t\tconst lineColors = new Float32Array( numLat * numLng * 3 * 2 );\n\t\t\t\tconst visible = new Float32Array( numLat * numLng * 2 );\n\n\t\t\t\tfor ( let i = 0; i < numLat; ++ i ) {\n\n\t\t\t\t\tfor ( let j = 0; j < numLng; ++ j ) {\n\n\t\t\t\t\t\tconst lat = ( Math.random() * Math.PI ) / 50.0 + i / numLat * Math.PI;\n\t\t\t\t\t\tconst lng = ( Math.random() * Math.PI ) / 50.0 + j / numLng * 2 * Math.PI;\n\n\t\t\t\t\t\tconst index = i * numLng + j;\n\n\t\t\t\t\t\tlinePositions[ index * 6 + 0 ] = 0;\n\t\t\t\t\t\tlinePositions[ index * 6 + 1 ] = 0;\n\t\t\t\t\t\tlinePositions[ index * 6 + 2 ] = 0;\n\t\t\t\t\t\tlinePositions[ index * 6 + 3 ] = radius * Math.sin( lat ) * Math.cos( lng );\n\t\t\t\t\t\tlinePositions[ index * 6 + 4 ] = radius * Math.cos( lat );\n\t\t\t\t\t\tlinePositions[ index * 6 + 5 ] = radius * Math.sin( lat ) * Math.sin( lng );\n\n\t\t\t\t\t\tconst color = new THREE.Color( 0xffffff );\n\n\t\t\t\t\t\tcolor.setHSL( lat / Math.PI, 1.0, 0.2 );\n\t\t\t\t\t\tlineColors[ index * 6 + 0 ] = color.r;\n\t\t\t\t\t\tlineColors[ index * 6 + 1 ] = color.g;\n\t\t\t\t\t\tlineColors[ index * 6 + 2 ] = color.b;\n\n\t\t\t\t\t\tcolor.setHSL( lat / Math.PI, 1.0, 0.7 );\n\t\t\t\t\t\tlineColors[ index * 6 + 3 ] = color.r;\n\t\t\t\t\t\tlineColors[ index * 6 + 4 ] = color.g;\n\t\t\t\t\t\tlineColors[ index * 6 + 5 ] = color.b;\n\n\t\t\t\t\t\t// non-0 is visible\n\t\t\t\t\t\tvisible[ index * 2 + 0 ] = 1.0;\n\t\t\t\t\t\tvisible[ index * 2 + 1 ] = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( linePositions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'vertColor', new THREE.BufferAttribute( lineColors, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'visible', new THREE.BufferAttribute( visible, 1 ) );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tconst shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.LineSegments( geometry, shaderMaterial );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tupdateCount();\n\n\t\t\t}\n\n\t\t\tfunction updateCount() {\n\n\t\t\t\tconst str = '1 draw call, ' + numLat * numLng + ' lines, ' + numLinesCulled + ' culled (<a target=\"_blank\" href=\"http://callum.com\">author</a>)';\n\t\t\t\tdocument.getElementById( 'title' ).innerHTML = str.replace( /\\B(?=(\\d{3})+(?!\\d))/g, ',' );\n\n\t\t\t}\n\n\t\t\tfunction hideLines() {\n\n\t\t\t\tfor ( let i = 0; i < geometry.attributes.visible.array.length; i += 2 ) {\n\n\t\t\t\t\tif ( Math.random() > 0.75 ) {\n\n\t\t\t\t\t\tif ( geometry.attributes.visible.array[ i + 0 ] ) {\n\n\t\t\t\t\t\t\t++ numLinesCulled;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.attributes.visible.array[ i + 0 ] = 0;\n\t\t\t\t\t\tgeometry.attributes.visible.array[ i + 1 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.attributes.visible.needsUpdate = true;\n\n\t\t\t\tupdateCount();\n\n\t\t\t}\n\n\t\t\tfunction showAllLines() {\n\n\t\t\t\tnumLinesCulled = 0;\n\n\t\t\t\tfor ( let i = 0; i < geometry.attributes.visible.array.length; i += 2 ) {\n\n\t\t\t\t\tgeometry.attributes.visible.array[ i + 0 ] = 1;\n\t\t\t\t\tgeometry.attributes.visible.array[ i + 1 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.attributes.visible.needsUpdate = true;\n\n\t\t\t\tupdateCount();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tmesh.rotation.x = time * 0.25;\n\t\t\t\tmesh.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js buffergeometry - selective - draw"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - buffergeometry - uint"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - buffergeometry - uint:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );\n\t\t\t\tcamera.position.z = 2750;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 3500 );\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffffff, 4.5 );\n\t\t\t\tlight2.position.set( 0, - 1, 0 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst triangles = 500000;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst normals = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst n = 800, n2 = n / 2;\t// triangles spread in the cube\n\t\t\t\tconst d = 12, d2 = d / 2;\t// individual triangle size\n\n\t\t\t\tconst pA = new THREE.Vector3();\n\t\t\t\tconst pB = new THREE.Vector3();\n\t\t\t\tconst pC = new THREE.Vector3();\n\n\t\t\t\tconst cb = new THREE.Vector3();\n\t\t\t\tconst ab = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < triangles; i ++ ) {\n\n\t\t\t\t\t// positions\n\n\t\t\t\t\tconst x = Math.random() * n - n2;\n\t\t\t\t\tconst y = Math.random() * n - n2;\n\t\t\t\t\tconst z = Math.random() * n - n2;\n\n\t\t\t\t\tconst ax = x + Math.random() * d - d2;\n\t\t\t\t\tconst ay = y + Math.random() * d - d2;\n\t\t\t\t\tconst az = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst bx = x + Math.random() * d - d2;\n\t\t\t\t\tconst by = y + Math.random() * d - d2;\n\t\t\t\t\tconst bz = z + Math.random() * d - d2;\n\n\t\t\t\t\tconst cx = x + Math.random() * d - d2;\n\t\t\t\t\tconst cy = y + Math.random() * d - d2;\n\t\t\t\t\tconst cz = z + Math.random() * d - d2;\n\n\t\t\t\t\tpositions.push( ax, ay, az );\n\t\t\t\t\tpositions.push( bx, by, bz );\n\t\t\t\t\tpositions.push( cx, cy, cz );\n\n\t\t\t\t\t// flat face normals\n\n\t\t\t\t\tpA.set( ax, ay, az );\n\t\t\t\t\tpB.set( bx, by, bz );\n\t\t\t\t\tpC.set( cx, cy, cz );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\tconst nx = cb.x;\n\t\t\t\t\tconst ny = cb.y;\n\t\t\t\t\tconst nz = cb.z;\n\n\t\t\t\t\tnormals.push( nx * 32767, ny * 32767, nz * 32767 );\n\t\t\t\t\tnormals.push( nx * 32767, ny * 32767, nz * 32767 );\n\t\t\t\t\tnormals.push( nx * 32767, ny * 32767, nz * 32767 );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tconst vx = ( x / n ) + 0.5;\n\t\t\t\t\tconst vy = ( y / n ) + 0.5;\n\t\t\t\t\tconst vz = ( z / n ) + 0.5;\n\n\t\t\t\t\tcolor.setRGB( vx, vy, vz );\n\n\t\t\t\t\tcolors.push( color.r * 255, color.g * 255, color.b * 255 );\n\t\t\t\t\tcolors.push( color.r * 255, color.g * 255, color.b * 255 );\n\t\t\t\t\tcolors.push( color.r * 255, color.g * 255, color.b * 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.Float32BufferAttribute( positions, 3 );\n\t\t\t\tconst normalAttribute = new THREE.Int16BufferAttribute( normals, 3 );\n\t\t\t\tconst colorAttribute = new THREE.Uint8BufferAttribute( colors, 3 );\n\n\t\t\t\tnormalAttribute.normalized = true; // this will map the buffer values to 0.0f - +1.0f in the shader\n\t\t\t\tcolorAttribute.normalized = true;\n\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xd5d5d5, specular: 0xffffff, shininess: 250,\n\t\t\t\t\tside: THREE.DoubleSide, vertexColors: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tmesh.rotation.x = time * 0.25;\n\t\t\t\tmesh.rotation.y = time * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - buffergeometry - uint"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates WebGL 2 - clip cull distance"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL 2 - clip cull distance:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, controls, clock, scene, renderer, stats;\n\n\t\t\tlet material;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10 );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tif ( renderer.extensions.has( 'WEBGL_clip_cull_distance' ) === false ) {\n\n\t\t\t\t\tdocument.getElementById( 'notSupported' ).style.display = '';\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst ext = renderer\n\t\t\t\t\t.getContext()\n\t\t\t\t\t.getExtension( 'WEBGL_clip_cull_distance' );\n\t\t\t\tconst gl = renderer.getContext();\n\n\t\t\t\tgl.enable( ext.CLIP_DISTANCE0_WEBGL );\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst vertexCount = 200 * 3;\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\t\t// adding x,y,z\n\t\t\t\t\tpositions.push( Math.random() - 0.5 );\n\t\t\t\t\tpositions.push( Math.random() - 0.5 );\n\t\t\t\t\tpositions.push( Math.random() - 0.5 );\n\n\t\t\t\t\t// adding r,g,b,a\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\t\t\t\t\tcolors.push( Math.random() * 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.Float32BufferAttribute( positions, 3 );\n\t\t\t\tconst colorAttribute = new THREE.Uint8BufferAttribute( colors, 4 );\n\t\t\t\tcolorAttribute.normalized = true;\n\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t// material\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\ttime: { value: 1.0 }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\tvertexColors: true\n\n\t\t\t\t} );\n\n\t\t\t\tmaterial.extensions.clipCullDistance = true;\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\tstats.update();\n\n\t\t\t\tmaterial.uniforms.time.value = clock.getElapsedTime();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - vertex shader clipping via WEBGL_clip_cull_distance WEBGL_clip_cull_distance not supported"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - custom attributes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - custom attributes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet sphere, uniforms;\n\n\t\t\tlet displacement, noise;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\n\t\t\t\tuniforms = {\n\n\t\t\t\t\t'amplitude': { value: 1.0 },\n\t\t\t\t\t'color': { value: new THREE.Color( 0xff2200 ) },\n\t\t\t\t\t'colorTexture': { value: new THREE.TextureLoader().load( 'textures/water.jpg' ) }\n\n\t\t\t\t};\n\n\t\t\t\tuniforms[ 'colorTexture' ].value.wrapS = uniforms[ 'colorTexture' ].value.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent\n\n\t\t\t\t} );\n\n\n\t\t\t\tconst radius = 50, segments = 128, rings = 64;\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( radius, segments, rings );\n\n\t\t\t\tdisplacement = new Float32Array( geometry.attributes.position.count );\n\t\t\t\tnoise = new Float32Array( geometry.attributes.position.count );\n\n\t\t\t\tfor ( let i = 0; i < displacement.length; i ++ ) {\n\n\t\t\t\t\tnoise[ i ] = Math.random() * 5;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'displacement', new THREE.BufferAttribute( displacement, 1 ) );\n\n\t\t\t\tsphere = new THREE.Mesh( geometry, shaderMaterial );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.01;\n\n\t\t\t\tsphere.rotation.y = sphere.rotation.z = 0.01 * time;\n\n\t\t\t\tuniforms[ 'amplitude' ].value = 2.5 * Math.sin( sphere.rotation.y * 0.125 );\n\t\t\t\tuniforms[ 'color' ].value.offsetHSL( 0.0005, 0, 0 );\n\n\t\t\t\tfor ( let i = 0; i < displacement.length; i ++ ) {\n\n\t\t\t\t\tdisplacement[ i ] = Math.sin( 0.1 * i + time );\n\n\t\t\t\t\tnoise[ i ] += 0.5 * ( 0.5 - Math.random() );\n\t\t\t\t\tnoise[ i ] = THREE.MathUtils.clamp( noise[ i ], - 5, 5 );\n\n\t\t\t\t\tdisplacement[ i ] += noise[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tsphere.geometry.attributes.displacement.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - custom attributes example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - custom attributes [lines]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - custom attributes [lines]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet line, uniforms;\n\n\t\t\tconst loader = new FontLoader();\n\t\t\tloader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {\n\n\t\t\t\tinit( font );\n\n\t\t\t} );\n\n\t\t\tfunction init( font ) {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x050505 );\n\n\t\t\t\tuniforms = {\n\n\t\t\t\t\tamplitude: { value: 5.0 },\n\t\t\t\t\topacity: { value: 0.3 },\n\t\t\t\t\tcolor: { value: new THREE.Color( 0xffffff ) }\n\n\t\t\t\t};\n\n\t\t\t\tconst shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\n\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\ttransparent: true\n\n\t\t\t\t} );\n\n\n\t\t\t\tconst geometry = new TextGeometry( 'three.js', {\n\n\t\t\t\t\tfont: font,\n\n\t\t\t\t\tsize: 50,\n\t\t\t\t\tdepth: 15,\n\t\t\t\t\tcurveSegments: 10,\n\n\t\t\t\t\tbevelThickness: 5,\n\t\t\t\t\tbevelSize: 1.5,\n\t\t\t\t\tbevelEnabled: true,\n\t\t\t\t\tbevelSegments: 10,\n\n\t\t\t\t} );\n\n\t\t\t\tgeometry.center();\n\n\t\t\t\tconst count = geometry.attributes.position.count;\n\n\t\t\t\tconst displacement = new THREE.Float32BufferAttribute( count * 3, 3 );\n\t\t\t\tgeometry.setAttribute( 'displacement', displacement );\n\n\t\t\t\tconst customColor = new THREE.Float32BufferAttribute( count * 3, 3 );\n\t\t\t\tgeometry.setAttribute( 'customColor', customColor );\n\n\t\t\t\tconst color = new THREE.Color( 0xffffff );\n\n\t\t\t\tfor ( let i = 0, l = customColor.count; i < l; i ++ ) {\n\n\t\t\t\t\tcolor.setHSL( i / l, 0.5, 0.5 );\n\t\t\t\t\tcolor.toArray( customColor.array, i * customColor.itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tline = new THREE.Line( geometry, shaderMaterial );\n\t\t\t\tline.rotation.x = 0.2;\n\t\t\t\tscene.add( line );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\tline.rotation.y = 0.25 * time;\n\n\t\t\t\tuniforms.amplitude.value = Math.sin( 0.5 * time );\n\t\t\t\tuniforms.color.value.offsetHSL( 0.0005, 0, 0 );\n\n\t\t\t\tconst attributes = line.geometry.attributes;\n\t\t\t\tconst array = attributes.displacement.array;\n\n\t\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tarray[ i ] += 0.3 * ( 0.5 - Math.random() );\n\t\t\t\t\tarray[ i + 1 ] += 0.3 * ( 0.5 - Math.random() );\n\t\t\t\t\tarray[ i + 2 ] += 0.3 * ( 0.5 - Math.random() );\n\n\t\t\t\t}\n\n\t\t\t\tattributes.displacement.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - custom attributes example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - custom attributes [particles]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - custom attributes [particles]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet sphere;\n\n\t\t\tconst WIDTH = window.innerWidth;\n\t\t\tconst HEIGHT = window.innerHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 10000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst amount = 100000;\n\t\t\t\tconst radius = 200;\n\n\t\t\t\tconst positions = new Float32Array( amount * 3 );\n\t\t\t\tconst colors = new Float32Array( amount * 3 );\n\t\t\t\tconst sizes = new Float32Array( amount );\n\n\t\t\t\tconst vertex = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color( 0xffffff );\n\n\t\t\t\tfor ( let i = 0; i < amount; i ++ ) {\n\n\t\t\t\t\tvertex.x = ( Math.random() * 2 - 1 ) * radius;\n\t\t\t\t\tvertex.y = ( Math.random() * 2 - 1 ) * radius;\n\t\t\t\t\tvertex.z = ( Math.random() * 2 - 1 ) * radius;\n\t\t\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t\t\t\tif ( vertex.x < 0 ) {\n\n\t\t\t\t\t\tcolor.setHSL( 0.5 + 0.1 * ( i / amount ), 0.7, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcolor.setHSL( 0.0 + 0.1 * ( i / amount ), 0.9, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.toArray( colors, i * 3 );\n\n\t\t\t\t\tsizes[ i ] = 10;\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tcolor: { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\t\tpointTexture: { value: new THREE.TextureLoader().load( 'textures/sprites/spark1.png' ) }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\n\n\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\ttransparent: true\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tsphere = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( WIDTH, HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.005;\n\n\t\t\t\tsphere.rotation.z = 0.01 * time;\n\n\t\t\t\tconst geometry = sphere.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\n\t\t\t\tfor ( let i = 0; i < attributes.size.array.length; i ++ ) {\n\n\t\t\t\t\tattributes.size.array[ i ] = 14 + 13 * Math.sin( 0.1 * i + time );\n\n\t\t\t\t}\n\n\t\t\t\tattributes.size.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - custom attributes example - particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - custom attributes [particles][billboards]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - custom attributes [particles][billboards]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\t\t\tlet sphere, length1;\n\n\t\t\tconst WIDTH = window.innerWidth;\n\t\t\tconst HEIGHT = window.innerHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 10000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst radius = 100, segments = 68, rings = 38;\n\n\t\t\t\tlet sphereGeometry = new THREE.SphereGeometry( radius, segments, rings );\n\t\t\t\tlet boxGeometry = new THREE.BoxGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10 );\n\n\t\t\t\t// if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data\n\n\t\t\t\tsphereGeometry.deleteAttribute( 'normal' );\n\t\t\t\tsphereGeometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxGeometry.deleteAttribute( 'normal' );\n\t\t\t\tboxGeometry.deleteAttribute( 'uv' );\n\n\t\t\t\tsphereGeometry = BufferGeometryUtils.mergeVertices( sphereGeometry );\n\t\t\t\tboxGeometry = BufferGeometryUtils.mergeVertices( boxGeometry );\n\n\t\t\t\tconst combinedGeometry = BufferGeometryUtils.mergeGeometries( [ sphereGeometry, boxGeometry ] );\n\t\t\t\tconst positionAttribute = combinedGeometry.getAttribute( 'position' );\n\n\t\t\t\tconst colors = [];\n\t\t\t\tconst sizes = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\t\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\t\tlength1 = sphereGeometry.getAttribute( 'position' ).count;\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\tif ( i < length1 ) {\n\n\t\t\t\t\t\tcolor.setHSL( 0.01 + 0.1 * ( i / length1 ), 0.99, ( vertex.y + radius ) / ( 4 * radius ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcolor.setHSL( 0.6, 0.75, 0.25 + vertex.y / ( 2 * radius ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.toArray( colors, i * 3 );\n\n\t\t\t\t\tsizes[ i ] = i < length1 ? 10 : 40;\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'ca', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/sprites/disc.png' );\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tcolor: { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\t\tpointTexture: { value: texture }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\n\t\t\t\t\ttransparent: true\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tsphere = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( WIDTH, HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction sortPoints() {\n\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\t// Model View Projection matrix\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t\tmatrix.multiply( sphere.matrixWorld );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = sphere.geometry;\n\n\t\t\t\tlet index = geometry.getIndex();\n\t\t\t\tconst positions = geometry.getAttribute( 'position' ).array;\n\t\t\t\tconst length = positions.length / 3;\n\n\t\t\t\tif ( index === null ) {\n\n\t\t\t\t\tconst array = new Uint16Array( length );\n\n\t\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = new THREE.BufferAttribute( array, 1 );\n\n\t\t\t\t\tgeometry.setIndex( index );\n\n\t\t\t\t}\n\n\t\t\t\tconst sortArray = [];\n\n\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tvector.fromArray( positions, i * 3 );\n\t\t\t\t\tvector.applyMatrix4( matrix );\n\n\t\t\t\t\tsortArray.push( [ vector.z, i ] );\n\n\t\t\t\t}\n\n\t\t\t\tfunction numericalSort( a, b ) {\n\n\t\t\t\t\treturn b[ 0 ] - a[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tsortArray.sort( numericalSort );\n\n\t\t\t\tconst indices = index.array;\n\n\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = sortArray[ i ][ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.index.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.005;\n\n\t\t\t\tsphere.rotation.y = 0.02 * time;\n\t\t\t\tsphere.rotation.z = 0.02 * time;\n\n\t\t\t\tconst geometry = sphere.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\n\t\t\t\tfor ( let i = 0; i < attributes.size.array.length; i ++ ) {\n\n\t\t\t\t\tif ( i < length1 ) {\n\n\t\t\t\t\t\tattributes.size.array[ i ] = 16 + 12 * Math.sin( 0.1 * i + time );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tattributes.size.needsUpdate = true;\n\n\t\t\t\tsortPoints();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - custom attributes example - particles - billboards"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - custom attributes [particles][billboards][alphatest]"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - custom attributes [particles][billboards][alphatest]:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tlet renderer, scene, camera, stats;\n\n\t\t\tlet object;\n\n\t\t\tlet vertices1;\n\n\t\t\tconst WIDTH = window.innerWidth;\n\t\t\tconst HEIGHT = window.innerHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 1000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tlet radius = 100;\n\t\t\t\tconst inner = 0.6 * radius;\n\t\t\t\tconst vertex = new THREE.Vector3();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < 100000; i ++ ) {\n\n\t\t\t\t\tvertex.x = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.y = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.z = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.multiplyScalar( radius );\n\n\t\t\t\t\tif ( ( vertex.x > inner || vertex.x < - inner ) ||\n\t\t\t\t\t\t( vertex.y > inner || vertex.y < - inner ) ||\n\t\t\t\t\t\t( vertex.z > inner || vertex.z < - inner ) )\n\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t\tvertices1 = vertices.length / 3;\n\n\t\t\t\tradius = 200;\n\n\t\t\t\tlet boxGeometry1 = new THREE.BoxGeometry( radius, 0.1 * radius, 0.1 * radius, 50, 5, 5 );\n\n\t\t\t\t// if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data\n\n\t\t\t\tboxGeometry1.deleteAttribute( 'normal' );\n\t\t\t\tboxGeometry1.deleteAttribute( 'uv' );\n\n\t\t\t\tboxGeometry1 = BufferGeometryUtils.mergeVertices( boxGeometry1 );\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst position = new THREE.Vector3();\n\t\t\t\tconst rotation = new THREE.Euler();\n\t\t\t\tconst quaternion = new THREE.Quaternion();\n\t\t\t\tconst scale = new THREE.Vector3( 1, 1, 1 );\n\n\t\t\t\tfunction addGeo( geo, x, y, z, ry ) {\n\n\t\t\t\t\tposition.set( x, y, z );\n\t\t\t\t\trotation.set( 0, ry, 0 );\n\n\t\t\t\t\tmatrix.compose( position, quaternion.setFromEuler( rotation ), scale );\n\n\t\t\t\t\tconst positionAttribute = geo.getAttribute( 'position' );\n\n\t\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\tvertex.applyMatrix4( matrix );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// side 1\n\n\t\t\t\taddGeo( boxGeometry1, 0, 110, 110, 0 );\n\t\t\t\taddGeo( boxGeometry1, 0, 110, - 110, 0 );\n\t\t\t\taddGeo( boxGeometry1, 0, - 110, 110, 0 );\n\t\t\t\taddGeo( boxGeometry1, 0, - 110, - 110, 0 );\n\n\t\t\t\t// side 2\n\n\t\t\t\taddGeo( boxGeometry1, 110, 110, 0, Math.PI / 2 );\n\t\t\t\taddGeo( boxGeometry1, 110, - 110, 0, Math.PI / 2 );\n\t\t\t\taddGeo( boxGeometry1, - 110, 110, 0, Math.PI / 2 );\n\t\t\t\taddGeo( boxGeometry1, - 110, - 110, 0, Math.PI / 2 );\n\n\t\t\t\t// corner edges\n\n\t\t\t\tlet boxGeometry2 = new THREE.BoxGeometry( 0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5 );\n\n\t\t\t\tboxGeometry2.deleteAttribute( 'normal' );\n\t\t\t\tboxGeometry2.deleteAttribute( 'uv' );\n\n\t\t\t\tboxGeometry2 = BufferGeometryUtils.mergeVertices( boxGeometry2 );\n\n\t\t\t\taddGeo( boxGeometry2, 110, 0, 110, 0 );\n\t\t\t\taddGeo( boxGeometry2, 110, 0, - 110, 0 );\n\t\t\t\taddGeo( boxGeometry2, - 110, 0, 110, 0 );\n\t\t\t\taddGeo( boxGeometry2, - 110, 0, - 110, 0 );\n\n\t\t\t\tconst positionAttribute = new THREE.Float32BufferAttribute( vertices, 3 );\n\n\t\t\t\tconst colors = [];\n\t\t\t\tconst sizes = [];\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tif ( i < vertices1 ) {\n\n\t\t\t\t\t\tcolor.setHSL( 0.5 + 0.2 * ( i / vertices1 ), 1, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcolor.setHSL( 0.1, 1, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.toArray( colors, i * 3 );\n\n\t\t\t\t\tsizes[ i ] = i < vertices1 ? 10 : 40;\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'ca', new THREE.Float32BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/sprites/ball.png' );\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tamplitude: { value: 1.0 },\n\t\t\t\t\t\tcolor: { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\t\tpointTexture: { value: texture }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tobject = new THREE.Points( geometry, material );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( WIDTH, HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.01;\n\n\t\t\t\tobject.rotation.y = object.rotation.z = 0.02 * time;\n\n\t\t\t\tconst geometry = object.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\n\t\t\t\tfor ( let i = 0; i < attributes.size.array.length; i ++ ) {\n\n\t\t\t\t\tif ( i < vertices1 ) {\n\n\t\t\t\t\t\tattributes.size.array[ i ] = Math.max( 0, 26 + 32 * Math.sin( 0.1 * i + 0.6 * time ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tattributes.size.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - custom attributes example - billboards - alphatest"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - gpgpu - flocking"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - gpgpu - flocking:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n\n\t\t\t/* TEXTURE WIDTH FOR SIMULATION */\n\t\t\tconst WIDTH = 32;\n\n\t\t\tconst BIRDS = WIDTH * WIDTH;\n\n\t\t\t// Custom Geometry - using 3 triangles each. No UVs, no normals currently.\n\t\t\tclass BirdGeometry extends THREE.BufferGeometry {\n\n\t\t\t\tconstructor() {\n\n\t\t\t\t\tsuper();\n\n\t\t\t\t\tconst trianglesPerBird = 3;\n\t\t\t\t\tconst triangles = BIRDS * trianglesPerBird;\n\t\t\t\t\tconst points = triangles * 3;\n\n\t\t\t\t\tconst vertices = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );\n\t\t\t\t\tconst birdColors = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );\n\t\t\t\t\tconst references = new THREE.BufferAttribute( new Float32Array( points * 2 ), 2 );\n\t\t\t\t\tconst birdVertex = new THREE.BufferAttribute( new Float32Array( points ), 1 );\n\n\t\t\t\t\tthis.setAttribute( 'position', vertices );\n\t\t\t\t\tthis.setAttribute( 'birdColor', birdColors );\n\t\t\t\t\tthis.setAttribute( 'reference', references );\n\t\t\t\t\tthis.setAttribute( 'birdVertex', birdVertex );\n\n\t\t\t\t\t// this.setAttribute( 'normal', new Float32Array( points * 3 ), 3 );\n\n\n\t\t\t\t\tlet v = 0;\n\n\t\t\t\t\tfunction verts_push() {\n\n\t\t\t\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\t\t\tvertices.array[ v ++ ] = arguments[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wingsSpan = 20;\n\n\t\t\t\t\tfor ( let f = 0; f < BIRDS; f ++ ) {\n\n\t\t\t\t\t\t// Body\n\n\t\t\t\t\t\tverts_push(\n\t\t\t\t\t\t\t0, - 0, - 20,\n\t\t\t\t\t\t\t0, 4, - 20,\n\t\t\t\t\t\t\t0, 0, 30\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Wings\n\n\t\t\t\t\t\tverts_push(\n\t\t\t\t\t\t\t0, 0, - 15,\n\t\t\t\t\t\t\t- wingsSpan, 0, 0,\n\t\t\t\t\t\t\t0, 0, 15\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tverts_push(\n\t\t\t\t\t\t\t0, 0, 15,\n\t\t\t\t\t\t\twingsSpan, 0, 0,\n\t\t\t\t\t\t\t0, 0, - 15\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let v = 0; v < triangles * 3; v ++ ) {\n\n\t\t\t\t\t\tconst triangleIndex = ~ ~ ( v / 3 );\n\t\t\t\t\t\tconst birdIndex = ~ ~ ( triangleIndex / trianglesPerBird );\n\t\t\t\t\t\tconst x = ( birdIndex % WIDTH ) / WIDTH;\n\t\t\t\t\t\tconst y = ~ ~ ( birdIndex / WIDTH ) / WIDTH;\n\n\t\t\t\t\t\tconst c = new THREE.Color(\n\t\t\t\t\t\t\t0x666666 +\n\t\t\t\t\t\t\t~ ~ ( v / 9 ) / BIRDS * 0x666666\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbirdColors.array[ v * 3 + 0 ] = c.r;\n\t\t\t\t\t\tbirdColors.array[ v * 3 + 1 ] = c.g;\n\t\t\t\t\t\tbirdColors.array[ v * 3 + 2 ] = c.b;\n\n\t\t\t\t\t\treferences.array[ v * 2 ] = x;\n\t\t\t\t\t\treferences.array[ v * 2 + 1 ] = y;\n\n\t\t\t\t\t\tbirdVertex.array[ v ] = v % 9;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.scale( 0.2, 0.2, 0.2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tconst BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;\n\n\t\t\tlet last = performance.now();\n\n\t\t\tlet gpuCompute;\n\t\t\tlet velocityVariable;\n\t\t\tlet positionVariable;\n\t\t\tlet positionUniforms;\n\t\t\tlet velocityUniforms;\n\t\t\tlet birdUniforms;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );\n\t\t\t\tcamera.position.z = 350;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\t\t\t\tscene.fog = new THREE.Fog( 0xffffff, 100, 1000 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tinitComputeRenderer();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\n\t\t\t\tconst effectController = {\n\t\t\t\t\tseparation: 20.0,\n\t\t\t\t\talignment: 20.0,\n\t\t\t\t\tcohesion: 20.0,\n\t\t\t\t\tfreedom: 0.75\n\t\t\t\t};\n\n\t\t\t\tconst valuesChanger = function () {\n\n\t\t\t\t\tvelocityUniforms[ 'separationDistance' ].value = effectController.separation;\n\t\t\t\t\tvelocityUniforms[ 'alignmentDistance' ].value = effectController.alignment;\n\t\t\t\t\tvelocityUniforms[ 'cohesionDistance' ].value = effectController.cohesion;\n\t\t\t\t\tvelocityUniforms[ 'freedomFactor' ].value = effectController.freedom;\n\n\t\t\t\t};\n\n\t\t\t\tvaluesChanger();\n\n\t\t\t\tgui.add( effectController, 'separation', 0.0, 100.0, 1.0 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'alignment', 0.0, 100, 0.001 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'cohesion', 0.0, 100, 0.025 ).onChange( valuesChanger );\n\t\t\t\tgui.close();\n\n\t\t\t\tinitBirds();\n\n\t\t\t}\n\n\t\t\tfunction initComputeRenderer() {\n\n\t\t\t\tgpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );\n\n\t\t\t\tconst dtPosition = gpuCompute.createTexture();\n\t\t\t\tconst dtVelocity = gpuCompute.createTexture();\n\t\t\t\tfillPositionTexture( dtPosition );\n\t\t\t\tfillVelocityTexture( dtVelocity );\n\n\t\t\t\tvelocityVariable = gpuCompute.addVariable( 'textureVelocity', document.getElementById( 'fragmentShaderVelocity' ).textContent, dtVelocity );\n\t\t\t\tpositionVariable = gpuCompute.addVariable( 'texturePosition', document.getElementById( 'fragmentShaderPosition' ).textContent, dtPosition );\n\n\t\t\t\tgpuCompute.setVariableDependencies( velocityVariable, [ positionVariable, velocityVariable ] );\n\t\t\t\tgpuCompute.setVariableDependencies( positionVariable, [ positionVariable, velocityVariable ] );\n\n\t\t\t\tpositionUniforms = positionVariable.material.uniforms;\n\t\t\t\tvelocityUniforms = velocityVariable.material.uniforms;\n\n\t\t\t\tpositionUniforms[ 'time' ] = { value: 0.0 };\n\t\t\t\tpositionUniforms[ 'delta' ] = { value: 0.0 };\n\t\t\t\tvelocityUniforms[ 'time' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'delta' ] = { value: 0.0 };\n\t\t\t\tvelocityUniforms[ 'testing' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'separationDistance' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'alignmentDistance' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'cohesionDistance' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'freedomFactor' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'predator' ] = { value: new THREE.Vector3() };\n\t\t\t\tvelocityVariable.material.defines.BOUNDS = BOUNDS.toFixed( 2 );\n\n\t\t\t\tvelocityVariable.wrapS = THREE.RepeatWrapping;\n\t\t\t\tvelocityVariable.wrapT = THREE.RepeatWrapping;\n\t\t\t\tpositionVariable.wrapS = THREE.RepeatWrapping;\n\t\t\t\tpositionVariable.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst error = gpuCompute.init();\n\n\t\t\t\tif ( error !== null ) {\n\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initBirds() {\n\n\t\t\t\tconst geometry = new BirdGeometry();\n\n\t\t\t\t// For Vertex and Fragment\n\t\t\t\tbirdUniforms = {\n\t\t\t\t\t'color': { value: new THREE.Color( 0xff2200 ) },\n\t\t\t\t\t'texturePosition': { value: null },\n\t\t\t\t\t'textureVelocity': { value: null },\n\t\t\t\t\t'time': { value: 1.0 },\n\t\t\t\t\t'delta': { value: 0.0 }\n\t\t\t\t};\n\n\t\t\t\t// THREE.ShaderMaterial\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: birdUniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'birdVS' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'birdFS' ).textContent,\n\t\t\t\t\tside: THREE.DoubleSide\n\n\t\t\t\t} );\n\n\t\t\t\tconst birdMesh = new THREE.Mesh( geometry, material );\n\t\t\t\tbirdMesh.rotation.y = Math.PI / 2;\n\t\t\t\tbirdMesh.matrixAutoUpdate = false;\n\t\t\t\tbirdMesh.updateMatrix();\n\n\t\t\t\tscene.add( birdMesh );\n\n\t\t\t}\n\n\t\t\tfunction fillPositionTexture( texture ) {\n\n\t\t\t\tconst theArray = texture.image.data;\n\n\t\t\t\tfor ( let k = 0, kl = theArray.length; k < kl; k += 4 ) {\n\n\t\t\t\t\tconst x = Math.random() * BOUNDS - BOUNDS_HALF;\n\t\t\t\t\tconst y = Math.random() * BOUNDS - BOUNDS_HALF;\n\t\t\t\t\tconst z = Math.random() * BOUNDS - BOUNDS_HALF;\n\n\t\t\t\t\ttheArray[ k + 0 ] = x;\n\t\t\t\t\ttheArray[ k + 1 ] = y;\n\t\t\t\t\ttheArray[ k + 2 ] = z;\n\t\t\t\t\ttheArray[ k + 3 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction fillVelocityTexture( texture ) {\n\n\t\t\t\tconst theArray = texture.image.data;\n\n\t\t\t\tfor ( let k = 0, kl = theArray.length; k < kl; k += 4 ) {\n\n\t\t\t\t\tconst x = Math.random() - 0.5;\n\t\t\t\t\tconst y = Math.random() - 0.5;\n\t\t\t\t\tconst z = Math.random() - 0.5;\n\n\t\t\t\t\ttheArray[ k + 0 ] = x * 10;\n\t\t\t\t\ttheArray[ k + 1 ] = y * 10;\n\t\t\t\t\ttheArray[ k + 2 ] = z * 10;\n\t\t\t\t\ttheArray[ k + 3 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst now = performance.now();\n\t\t\t\tlet delta = ( now - last ) / 1000;\n\n\t\t\t\tif ( delta > 1 ) delta = 1; // safety cap on large deltas\n\t\t\t\tlast = now;\n\n\t\t\t\tpositionUniforms[ 'time' ].value = now;\n\t\t\t\tpositionUniforms[ 'delta' ].value = delta;\n\t\t\t\tvelocityUniforms[ 'time' ].value = now;\n\t\t\t\tvelocityUniforms[ 'delta' ].value = delta;\n\t\t\t\tbirdUniforms[ 'time' ].value = now;\n\t\t\t\tbirdUniforms[ 'delta' ].value = delta;\n\n\t\t\t\tvelocityUniforms[ 'predator' ].value.set( 0.5 * mouseX / windowHalfX, - 0.5 * mouseY / windowHalfY, 0 );\n\n\t\t\t\tmouseX = 10000;\n\t\t\t\tmouseY = 10000;\n\n\t\t\t\tgpuCompute.compute();\n\n\t\t\t\tbirdUniforms[ 'texturePosition' ].value = gpuCompute.getCurrentRenderTarget( positionVariable ).texture;\n\t\t\t\tbirdUniforms[ 'textureVelocity' ].value = gpuCompute.getCurrentRenderTarget( velocityVariable ).texture;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl gpgpu birds Move mouse to disturb birds."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - gpgpu - flocking"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - gpgpu - flocking:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n\n\t\t\t/* TEXTURE WIDTH FOR SIMULATION */\n\t\t\tconst WIDTH = 64;\n\t\t\tconst BIRDS = WIDTH * WIDTH;\n\n\t\t\t/* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */\n\t\t\tconst BirdGeometry = new THREE.BufferGeometry();\n\t\t\tlet textureAnimation, durationAnimation, birdMesh, materialShader, indicesPerBird;\n\n\t\t\tfunction nextPowerOf2( n ) {\n\n\t\t\t\treturn Math.pow( 2, Math.ceil( Math.log( n ) / Math.log( 2 ) ) );\n\n\t\t\t}\n\n\t\t\tMath.lerp = function ( value1, value2, amount ) {\n\n\t\t\t\tamount = Math.max( Math.min( amount, 1 ), 0 );\n\t\t\t\treturn value1 + ( value2 - value1 ) * amount;\n\n\t\t\t};\n\n\t\t\tconst gltfs = [ 'models/gltf/Parrot.glb', 'models/gltf/Flamingo.glb' ];\n\t\t\tconst colors = [ 0xccFFFF, 0xffdeff ];\n\t\t\tconst sizes = [ 0.2, 0.1 ];\n\t\t\tconst selectModel = Math.floor( Math.random() * gltfs.length );\n\t\t\tnew GLTFLoader().load( gltfs[ selectModel ], function ( gltf ) {\n\n\t\t\t\tconst animations = gltf.animations;\n\t\t\t\tdurationAnimation = Math.round( animations[ 0 ].duration * 60 );\n\t\t\t\tconst birdGeo = gltf.scene.children[ 0 ].geometry;\n\t\t\t\tconst morphAttributes = birdGeo.morphAttributes.position;\n\t\t\t\tconst tHeight = nextPowerOf2( durationAnimation );\n\t\t\t\tconst tWidth = nextPowerOf2( birdGeo.getAttribute( 'position' ).count );\n\t\t\t\tindicesPerBird = birdGeo.index.count;\n\t\t\t\tconst tData = new Float32Array( 4 * tWidth * tHeight );\n\n\t\t\t\tfor ( let i = 0; i < tWidth; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < tHeight; j ++ ) {\n\n\t\t\t\t\t\tconst offset = j * tWidth * 4;\n\n\t\t\t\t\t\tconst curMorph = Math.floor( j / durationAnimation * morphAttributes.length );\n\t\t\t\t\t\tconst nextMorph = ( Math.floor( j / durationAnimation * morphAttributes.length ) + 1 ) % morphAttributes.length;\n\t\t\t\t\t\tconst lerpAmount = j / durationAnimation * morphAttributes.length % 1;\n\n\t\t\t\t\t\tif ( j < durationAnimation ) {\n\n\t\t\t\t\t\t\tlet d0, d1;\n\n\t\t\t\t\t\t\td0 = morphAttributes[ curMorph ].array[ i * 3 ];\n\t\t\t\t\t\t\td1 = morphAttributes[ nextMorph ].array[ i * 3 ];\n\n\t\t\t\t\t\t\tif ( d0 !== undefined && d1 !== undefined ) tData[ offset + i * 4 ] = Math.lerp( d0, d1, lerpAmount );\n\n\t\t\t\t\t\t\td0 = morphAttributes[ curMorph ].array[ i * 3 + 1 ];\n\t\t\t\t\t\t\td1 = morphAttributes[ nextMorph ].array[ i * 3 + 1 ];\n\n\t\t\t\t\t\t\tif ( d0 !== undefined && d1 !== undefined ) tData[ offset + i * 4 + 1 ] = Math.lerp( d0, d1, lerpAmount );\n\n\t\t\t\t\t\t\td0 = morphAttributes[ curMorph ].array[ i * 3 + 2 ];\n\t\t\t\t\t\t\td1 = morphAttributes[ nextMorph ].array[ i * 3 + 2 ];\n\n\t\t\t\t\t\t\tif ( d0 !== undefined && d1 !== undefined ) tData[ offset + i * 4 + 2 ] = Math.lerp( d0, d1, lerpAmount );\n\n\t\t\t\t\t\t\ttData[ offset + i * 4 + 3 ] = 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttextureAnimation = new THREE.DataTexture( tData, tWidth, tHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\t\t\ttextureAnimation.needsUpdate = true;\n\n\t\t\t\tconst vertices = [], color = [], reference = [], seeds = [], indices = [];\n\t\t\t\tconst totalVertices = birdGeo.getAttribute( 'position' ).count * 3 * BIRDS;\n\t\t\t\tfor ( let i = 0; i < totalVertices; i ++ ) {\n\n\t\t\t\t\tconst bIndex = i % ( birdGeo.getAttribute( 'position' ).count * 3 );\n\t\t\t\t\tvertices.push( birdGeo.getAttribute( 'position' ).array[ bIndex ] );\n\t\t\t\t\tcolor.push( birdGeo.getAttribute( 'color' ).array[ bIndex ] );\n\n\t\t\t\t}\n\n\t\t\t\tlet r = Math.random();\n\t\t\t\tfor ( let i = 0; i < birdGeo.getAttribute( 'position' ).count * BIRDS; i ++ ) {\n\n\t\t\t\t\tconst bIndex = i % ( birdGeo.getAttribute( 'position' ).count );\n\t\t\t\t\tconst bird = Math.floor( i / birdGeo.getAttribute( 'position' ).count );\n\t\t\t\t\tif ( bIndex == 0 ) r = Math.random();\n\t\t\t\t\tconst j = ~ ~ bird;\n\t\t\t\t\tconst x = ( j % WIDTH ) / WIDTH;\n\t\t\t\t\tconst y = ~ ~ ( j / WIDTH ) / WIDTH;\n\t\t\t\t\treference.push( x, y, bIndex / tWidth, durationAnimation / tHeight );\n\t\t\t\t\tseeds.push( bird, r, Math.random(), Math.random() );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < birdGeo.index.array.length * BIRDS; i ++ ) {\n\n\t\t\t\t\tconst offset = Math.floor( i / birdGeo.index.array.length ) * ( birdGeo.getAttribute( 'position' ).count );\n\t\t\t\t\tindices.push( birdGeo.index.array[ i % birdGeo.index.array.length ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tBirdGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );\n\t\t\t\tBirdGeometry.setAttribute( 'birdColor', new THREE.BufferAttribute( new Float32Array( color ), 3 ) );\n\t\t\t\tBirdGeometry.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array( color ), 3 ) );\n\t\t\t\tBirdGeometry.setAttribute( 'reference', new THREE.BufferAttribute( new Float32Array( reference ), 4 ) );\n\t\t\t\tBirdGeometry.setAttribute( 'seeds', new THREE.BufferAttribute( new Float32Array( seeds ), 4 ) );\n\n\t\t\t\tBirdGeometry.setIndex( indices );\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tconst BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;\n\n\t\t\tlet last = performance.now();\n\n\t\t\tlet gpuCompute;\n\t\t\tlet velocityVariable;\n\t\t\tlet positionVariable;\n\t\t\tlet positionUniforms;\n\t\t\tlet velocityUniforms;\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );\n\t\t\t\tcamera.position.z = 350;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( colors[ selectModel ] );\n\t\t\t\tscene.fog = new THREE.Fog( colors[ selectModel ], 100, 1000 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( colors[ selectModel ], 0xffffff, 4.5 );\n\t\t\t\themiLight.color.setHSL( 0.6, 1, 0.6, THREE.SRGBColorSpace );\n\t\t\t\themiLight.groundColor.setHSL( 0.095, 1, 0.75, THREE.SRGBColorSpace );\n\t\t\t\themiLight.position.set( 0, 50, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0x00CED1, 2.0 );\n\t\t\t\tdirLight.color.setHSL( 0.1, 1, 0.95, THREE.SRGBColorSpace );\n\t\t\t\tdirLight.position.set( - 1, 1.75, 1 );\n\t\t\t\tdirLight.position.multiplyScalar( 30 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tinitComputeRenderer();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst effectController = {\n\n\t\t\t\t\tseparation: 20.0,\n\t\t\t\t\talignment: 20.0,\n\t\t\t\t\tcohesion: 20.0,\n\t\t\t\t\tfreedom: 0.75,\n\t\t\t\t\tsize: sizes[ selectModel ],\n\t\t\t\t\tcount: Math.floor( BIRDS / 4 )\n\n\t\t\t\t};\n\n\t\t\t\tconst valuesChanger = function () {\n\n\t\t\t\t\tvelocityUniforms[ 'separationDistance' ].value = effectController.separation;\n\t\t\t\t\tvelocityUniforms[ 'alignmentDistance' ].value = effectController.alignment;\n\t\t\t\t\tvelocityUniforms[ 'cohesionDistance' ].value = effectController.cohesion;\n\t\t\t\t\tvelocityUniforms[ 'freedomFactor' ].value = effectController.freedom;\n\t\t\t\t\tif ( materialShader ) materialShader.uniforms[ 'size' ].value = effectController.size;\n\t\t\t\t\tBirdGeometry.setDrawRange( 0, indicesPerBird * effectController.count );\n\n\t\t\t\t};\n\n\t\t\t\tvaluesChanger();\n\n\t\t\t\tgui.add( effectController, 'separation', 0.0, 100.0, 1.0 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'alignment', 0.0, 100, 0.001 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'cohesion', 0.0, 100, 0.025 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'size', 0, 1, 0.01 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'count', 0, BIRDS, 1 ).onChange( valuesChanger );\n\t\t\t\tgui.close();\n\n\t\t\t\tinitBirds( effectController );\n\n\t\t\t}\n\n\t\t\tfunction initComputeRenderer() {\n\n\t\t\t\tgpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );\n\n\t\t\t\tconst dtPosition = gpuCompute.createTexture();\n\t\t\t\tconst dtVelocity = gpuCompute.createTexture();\n\t\t\t\tfillPositionTexture( dtPosition );\n\t\t\t\tfillVelocityTexture( dtVelocity );\n\n\t\t\t\tvelocityVariable = gpuCompute.addVariable( 'textureVelocity', document.getElementById( 'fragmentShaderVelocity' ).textContent, dtVelocity );\n\t\t\t\tpositionVariable = gpuCompute.addVariable( 'texturePosition', document.getElementById( 'fragmentShaderPosition' ).textContent, dtPosition );\n\n\t\t\t\tgpuCompute.setVariableDependencies( velocityVariable, [ positionVariable, velocityVariable ] );\n\t\t\t\tgpuCompute.setVariableDependencies( positionVariable, [ positionVariable, velocityVariable ] );\n\n\t\t\t\tpositionUniforms = positionVariable.material.uniforms;\n\t\t\t\tvelocityUniforms = velocityVariable.material.uniforms;\n\n\t\t\t\tpositionUniforms[ 'time' ] = { value: 0.0 };\n\t\t\t\tpositionUniforms[ 'delta' ] = { value: 0.0 };\n\t\t\t\tvelocityUniforms[ 'time' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'delta' ] = { value: 0.0 };\n\t\t\t\tvelocityUniforms[ 'testing' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'separationDistance' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'alignmentDistance' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'cohesionDistance' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'freedomFactor' ] = { value: 1.0 };\n\t\t\t\tvelocityUniforms[ 'predator' ] = { value: new THREE.Vector3() };\n\t\t\t\tvelocityVariable.material.defines.BOUNDS = BOUNDS.toFixed( 2 );\n\n\t\t\t\tvelocityVariable.wrapS = THREE.RepeatWrapping;\n\t\t\t\tvelocityVariable.wrapT = THREE.RepeatWrapping;\n\t\t\t\tpositionVariable.wrapS = THREE.RepeatWrapping;\n\t\t\t\tpositionVariable.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst error = gpuCompute.init();\n\n\t\t\t\tif ( error !== null ) {\n\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initBirds( effectController ) {\n\n\t\t\t\tconst geometry = BirdGeometry;\n\n\t\t\t\tconst m = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tflatShading: true,\n\t\t\t\t\troughness: 1,\n\t\t\t\t\tmetalness: 0\n\t\t\t\t} );\n\n\t\t\t\tm.onBeforeCompile = ( shader ) => {\n\n\t\t\t\t\tshader.uniforms.texturePosition = { value: null };\n\t\t\t\t\tshader.uniforms.textureVelocity = { value: null };\n\t\t\t\t\tshader.uniforms.textureAnimation = { value: textureAnimation };\n\t\t\t\t\tshader.uniforms.time = { value: 1.0 };\n\t\t\t\t\tshader.uniforms.size = { value: effectController.size };\n\t\t\t\t\tshader.uniforms.delta = { value: 0.0 };\n\n\t\t\t\t\tlet token = '#define STANDARD';\n\n\t\t\t\t\tlet insert = /* glsl */`\n\t\t\t\t\t\tattribute vec4 reference;\n\t\t\t\t\t\tattribute vec4 seeds;\n\t\t\t\t\t\tattribute vec3 birdColor;\n\t\t\t\t\t\tuniform sampler2D texturePosition;\n\t\t\t\t\t\tuniform sampler2D textureVelocity;\n\t\t\t\t\t\tuniform sampler2D textureAnimation;\n\t\t\t\t\t\tuniform float size;\n\t\t\t\t\t\tuniform float time;\n\t\t\t\t\t`;\n\n\t\t\t\t\tshader.vertexShader = shader.vertexShader.replace( token, token + insert );\n\n\t\t\t\t\ttoken = '#include <begin_vertex>';\n\n\t\t\t\t\tinsert = /* glsl */`\n\t\t\t\t\t\tvec4 tmpPos = texture2D( texturePosition, reference.xy );\n\n\t\t\t\t\t\tvec3 pos = tmpPos.xyz;\n\t\t\t\t\t\tvec3 velocity = normalize(texture2D( textureVelocity, reference.xy ).xyz);\n\t\t\t\t\t\tvec3 aniPos = texture2D( textureAnimation, vec2( reference.z, mod( time + ( seeds.x ) * ( ( 0.0004 + seeds.y / 10000.0) + normalize( velocity ) / 20000.0 ), reference.w ) ) ).xyz;\n\t\t\t\t\t\tvec3 newPosition = position;\n\n\t\t\t\t\t\tnewPosition = mat3( modelMatrix ) * ( newPosition + aniPos );\n\t\t\t\t\t\tnewPosition *= size + seeds.y * size * 0.2;\n\n\t\t\t\t\t\tvelocity.z *= -1.;\n\t\t\t\t\t\tfloat xz = length( velocity.xz );\n\t\t\t\t\t\tfloat xyz = 1.;\n\t\t\t\t\t\tfloat x = sqrt( 1. - velocity.y * velocity.y );\n\n\t\t\t\t\t\tfloat cosry = velocity.x / xz;\n\t\t\t\t\t\tfloat sinry = velocity.z / xz;\n\n\t\t\t\t\t\tfloat cosrz = x / xyz;\n\t\t\t\t\t\tfloat sinrz = velocity.y / xyz;\n\n\t\t\t\t\t\tmat3 maty =  mat3( cosry, 0, -sinry, 0    , 1, 0     , sinry, 0, cosry );\n\t\t\t\t\t\tmat3 matz =  mat3( cosrz , sinrz, 0, -sinrz, cosrz, 0, 0     , 0    , 1 );\n\n\t\t\t\t\t\tnewPosition =  maty * matz * newPosition;\n\t\t\t\t\t\tnewPosition += pos;\n\n\t\t\t\t\t\tvec3 transformed = vec3( newPosition );\n\t\t\t\t\t`;\n\n\t\t\t\t\tshader.vertexShader = shader.vertexShader.replace( token, insert );\n\n\t\t\t\t\tmaterialShader = shader;\n\n\t\t\t\t};\n\n\t\t\t\tbirdMesh = new THREE.Mesh( geometry, m );\n\t\t\t\tbirdMesh.rotation.y = Math.PI / 2;\n\n\t\t\t\tbirdMesh.castShadow = true;\n\t\t\t\tbirdMesh.receiveShadow = true;\n\n\t\t\t\tscene.add( birdMesh );\n\n\t\t\t}\n\n\t\t\tfunction fillPositionTexture( texture ) {\n\n\t\t\t\tconst theArray = texture.image.data;\n\n\t\t\t\tfor ( let k = 0, kl = theArray.length; k < kl; k += 4 ) {\n\n\t\t\t\t\tconst x = Math.random() * BOUNDS - BOUNDS_HALF;\n\t\t\t\t\tconst y = Math.random() * BOUNDS - BOUNDS_HALF;\n\t\t\t\t\tconst z = Math.random() * BOUNDS - BOUNDS_HALF;\n\n\t\t\t\t\ttheArray[ k + 0 ] = x;\n\t\t\t\t\ttheArray[ k + 1 ] = y;\n\t\t\t\t\ttheArray[ k + 2 ] = z;\n\t\t\t\t\ttheArray[ k + 3 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction fillVelocityTexture( texture ) {\n\n\t\t\t\tconst theArray = texture.image.data;\n\n\t\t\t\tfor ( let k = 0, kl = theArray.length; k < kl; k += 4 ) {\n\n\t\t\t\t\tconst x = Math.random() - 0.5;\n\t\t\t\t\tconst y = Math.random() - 0.5;\n\t\t\t\t\tconst z = Math.random() - 0.5;\n\n\t\t\t\t\ttheArray[ k + 0 ] = x * 10;\n\t\t\t\t\ttheArray[ k + 1 ] = y * 10;\n\t\t\t\t\ttheArray[ k + 2 ] = z * 10;\n\t\t\t\t\ttheArray[ k + 3 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst now = performance.now();\n\t\t\t\tlet delta = ( now - last ) / 1000;\n\n\t\t\t\tif ( delta > 1 ) delta = 1; // safety cap on large deltas\n\t\t\t\tlast = now;\n\n\t\t\t\tpositionUniforms[ 'time' ].value = now;\n\t\t\t\tpositionUniforms[ 'delta' ].value = delta;\n\t\t\t\tvelocityUniforms[ 'time' ].value = now;\n\t\t\t\tvelocityUniforms[ 'delta' ].value = delta;\n\t\t\t\tif ( materialShader ) materialShader.uniforms[ 'time' ].value = now / 1000;\n\t\t\t\tif ( materialShader ) materialShader.uniforms[ 'delta' ].value = delta;\n\n\t\t\t\tvelocityUniforms[ 'predator' ].value.set( 0.5 * mouseX / windowHalfX, - 0.5 * mouseY / windowHalfY, 0 );\n\n\t\t\t\tmouseX = 10000;\n\t\t\t\tmouseY = 10000;\n\n\t\t\t\tgpuCompute.compute();\n\n\t\t\t\tif ( materialShader ) materialShader.uniforms[ 'texturePosition' ].value = gpuCompute.getCurrentRenderTarget( positionVariable ).texture;\n\t\t\t\tif ( materialShader ) materialShader.uniforms[ 'textureVelocity' ].value = gpuCompute.getCurrentRenderTarget( velocityVariable ).texture;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl gpgpu birds + GLTF mesh Flamingo by mirada from rome Move mouse to disturb birds."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - gpgpu - water"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - gpgpu - water:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n\t\t\timport { SimplexNoise } from 'three/addons/math/SimplexNoise.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\t// Texture width for simulation\n\t\t\tconst WIDTH = 128;\n\n\t\t\t// Water size in system units\n\t\t\tconst BOUNDS = 6;\n\t\t\tconst BOUNDS_HALF = BOUNDS * 0.5;\n\n\t\t\tlet tmpHeightmap = null;\n\t\t\tconst tmpQuat = new THREE.Quaternion();\n\t\t\tconst tmpQuatX = new THREE.Quaternion();\n\t\t\tconst tmpQuatZ = new THREE.Quaternion();\n\t\t\tlet duckModel = null;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet mousedown = false;\n\t\t\tconst mouseCoords = new THREE.Vector2();\n\t\t\tconst raycaster = new THREE.Raycaster();\n\n\t\t\tlet sun;\n\t\t\tlet waterMesh;\n\t\t\tlet poolBorder;\n\t\t\tlet meshRay;\n\t\t\tlet gpuCompute;\n\t\t\tlet heightmapVariable;\n\t\t\tlet smoothShader;\n\t\t\tlet readWaterLevelShader;\n\t\t\tlet readWaterLevelRenderTarget;\n\t\t\tlet readWaterLevelImage;\n\t\t\tconst waterNormal = new THREE.Vector3();\n\n\t\t\tconst NUM_DUCK = 12;\n\t\t\tconst ducks = [];\n\t\t\tlet ducksEnabled = true;\n\n\t\t\tconst simplex = new SimplexNoise();\n\n\t\t\tlet frame = 0;\n\n\t\t\tconst effectController = {\n\t\t\t\tmouseSize: 0.2,\n\t\t\t\tmouseDeep: 0.01,\n\t\t\t\tviscosity: 0.93,\n\t\t\t\tspeed: 5,\n\t\t\t\tducksEnabled: ducksEnabled,\n\t\t\t\twireframe: false,\n\t\t\t\tshadow: false,\n\t\t\t};\n\n\t\t\tinit();\n\n\n\t\t\tasync function init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\t\tcamera.position.set( 0, 2.00, 4 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tsun = new THREE.DirectionalLight( 0xFFFFFF, 4.0 );\n\t\t\t\tsun.position.set( - 1, 2.6, 1.4 );\n\t\t\t\tscene.add( sun );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\t\t\t\tcontainer.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\n\t\t\t\tconst rgbeLoader = new RGBELoader().setPath( './textures/equirectangular/' );\n\t\t\t\tconst glbloader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\tglbloader.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) );\n\n\t\t\t\tconst [ env, model ] = await Promise.all( [ rgbeLoader.loadAsync( 'blouberg_sunrise_2_1k.hdr' ), glbloader.loadAsync( 'duck.glb' ) ] );\n\t\t\t\tenv.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\tscene.environment = env;\n\t\t\t\tscene.background = env;\n\t\t\t\tscene.backgroundBlurriness = 0.3;\n\t\t\t\tscene.environmentIntensity = 1.25;\n\n\t\t\t\tduckModel = model.scene.children[ 0 ];\n\t\t\t\tduckModel.receiveShadow = true;\n\t\t\t\tduckModel.castShadow = true;\n\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.domElement.style.right = '0px';\n\n\t\t\t\tconst valuesChanger = function () {\n\n\t\t\t\t\theightmapVariable.material.uniforms[ 'mouseSize' ].value = effectController.mouseSize;\n\t\t\t\t\theightmapVariable.material.uniforms[ 'deep' ].value = effectController.mouseDeep;\n\t\t\t\t\theightmapVariable.material.uniforms[ 'viscosity' ].value = effectController.viscosity;\n\t\t\t\t\tducksEnabled = effectController.ducksEnabled;\n\n\t\t\t\t\tlet i = NUM_DUCK;\n\t\t\t\t\twhile ( i -- ) {\n\n\t\t\t\t\t\tif ( ducks[ i ] ) ducks[ i ].visible = ducksEnabled;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tgui.add( effectController, 'mouseSize', 0.1, 1.0, 0.1 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'mouseDeep', 0.01, 1.0, 0.01 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'viscosity', 0.9, 0.999, 0.001 ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'speed', 1, 6, 1 );\n\t\t\t\tgui.add( effectController, 'ducksEnabled' ).onChange( valuesChanger );\n\t\t\t\tgui.add( effectController, 'wireframe' ).onChange( ( v )=>{\n\n\t\t\t\t\twaterMesh.material.wireframe = v;\n\t\t\t\t\tpoolBorder.material.wireframe = v;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( effectController, 'shadow' ).onChange( addShadow );\n\n\t\t\t\t//const buttonSmooth = { smoothWater: function () {smoothWater();} };\n\t\t\t\t//gui.add( buttonSmooth, 'smoothWater' );\n\n\n\t\t\t\tinitWater();\n\n\t\t\t\tcreateducks();\n\n\t\t\t\tvaluesChanger();\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t}\n\n\n\t\t\tfunction initWater() {\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1 );\n\n\t\t\t\tconst material = new WaterMaterial( {\n\t\t\t\t\tcolor: 0x9bd2ec,\n\t\t\t\t\tmetalness: 0.9,\n\t\t\t\t\troughness: 0,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 0.8,\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\twaterMesh = new THREE.Mesh( geometry, material );\n\t\t\t\twaterMesh.rotation.x = - Math.PI * 0.5;\n\t\t\t\twaterMesh.matrixAutoUpdate = false;\n\t\t\t\twaterMesh.updateMatrix();\n\n\t\t\t\twaterMesh.receiveShadow = true;\n\t\t\t\twaterMesh.castShadow = true;\n\n\t\t\t\tscene.add( waterMesh );\n\n\t\t\t\t// pool border\n\t\t\t\tconst borderGeom = new THREE.TorusGeometry( 4.2, 0.1, 12, 4 );\n\t\t\t\tborderGeom.rotateX( Math.PI * 0.5 );\n\t\t\t\tborderGeom.rotateY( Math.PI * 0.25 );\n\t\t\t\tpoolBorder = new THREE.Mesh( borderGeom, new THREE.MeshStandardMaterial( { color: 0x908877, roughness: 0.2 } ) );\n\t\t\t\tscene.add( poolBorder );\n\t\t\t\tborderGeom.receiveShadow = true;\n\t\t\t\tborderGeom.castShadow = true;\n\n\t\t\t\t// THREE.Mesh just for mouse raycasting\n\t\t\t\tconst geometryRay = new THREE.PlaneGeometry( BOUNDS, BOUNDS, 1, 1 );\n\t\t\t\tmeshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );\n\t\t\t\tmeshRay.rotation.x = - Math.PI / 2;\n\t\t\t\tmeshRay.matrixAutoUpdate = false;\n\t\t\t\tmeshRay.updateMatrix();\n\t\t\t\tscene.add( meshRay );\n\n\n\t\t\t\t// Creates the gpu computation class and sets it up\n\n\t\t\t\tgpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );\n\n\t\t\t\tconst heightmap0 = gpuCompute.createTexture();\n\n\t\t\t\tfillTexture( heightmap0 );\n\n\t\t\t\theightmapVariable = gpuCompute.addVariable( 'heightmap', shaderChange.heightmap_frag, heightmap0 );\n\n\t\t\t\tgpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );\n\n\t\t\t\theightmapVariable.material.uniforms[ 'mousePos' ] = { value: new THREE.Vector2( 10000, 10000 ) };\n\t\t\t\theightmapVariable.material.uniforms[ 'mouseSize' ] = { value: 0.2 };\n\t\t\t\theightmapVariable.material.uniforms[ 'viscosity' ] = { value: 0.93 };\n\t\t\t\theightmapVariable.material.uniforms[ 'deep' ] = { value: 0.01 };\n\t\t\t\theightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );\n\n\t\t\t\tconst error = gpuCompute.init();\n\t\t\t\tif ( error !== null ) console.error( error );\n\n\t\t\t\t// Create compute shader to smooth the water surface and velocity\n\t\t\t\tsmoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { smoothTexture: { value: null } } );\n\n\t\t\t\t// Create compute shader to read water level\n\t\t\t\treadWaterLevelShader = gpuCompute.createShaderMaterial( document.getElementById( 'readWaterLevelFragmentShader' ).textContent, {\n\t\t\t\t\tpoint1: { value: new THREE.Vector2() },\n\t\t\t\t\tlevelTexture: { value: null }\n\t\t\t\t} );\n\t\t\t\treadWaterLevelShader.defines.WIDTH = WIDTH.toFixed( 1 );\n\t\t\t\treadWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed( 1 );\n\n\t\t\t\t// Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation\n\t\t\t\treadWaterLevelImage = new Uint8Array( 4 * 1 * 4 );\n\n\t\t\t\treadWaterLevelRenderTarget = new THREE.WebGLRenderTarget( 4, 1, {\n\t\t\t\t\twrapS: THREE.ClampToEdgeWrapping,\n\t\t\t\t\twrapT: THREE.ClampToEdgeWrapping,\n\t\t\t\t\tminFilter: THREE.NearestFilter,\n\t\t\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\t\ttype: THREE.UnsignedByteType,\n\t\t\t\t\tdepthBuffer: false\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction fillTexture( texture ) {\n\n\t\t\t\tconst waterMaxHeight = 0.1;\n\n\t\t\t\tfunction noise( x, y ) {\n\n\t\t\t\t\tlet multR = waterMaxHeight;\n\t\t\t\t\tlet mult = 0.025;\n\t\t\t\t\tlet r = 0;\n\t\t\t\t\tfor ( let i = 0; i < 15; i ++ ) {\n\n\t\t\t\t\t\tr += multR * simplex.noise( x * mult, y * mult );\n\t\t\t\t\t\tmultR *= 0.53 + 0.025 * i;\n\t\t\t\t\t\tmult *= 1.25;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn r;\n\n\t\t\t\t}\n\n\t\t\t\tconst pixels = texture.image.data;\n\n\t\t\t\tlet p = 0;\n\t\t\t\tfor ( let j = 0; j < WIDTH; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < WIDTH; i ++ ) {\n\n\t\t\t\t\t\tconst x = i * 128 / WIDTH;\n\t\t\t\t\t\tconst y = j * 128 / WIDTH;\n\n\t\t\t\t\t\tpixels[ p + 0 ] = noise( x, y );\n\t\t\t\t\t\tpixels[ p + 1 ] = pixels[ p + 0 ];\n\t\t\t\t\t\tpixels[ p + 2 ] = 0;\n\t\t\t\t\t\tpixels[ p + 3 ] = 1;\n\n\t\t\t\t\t\tp += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addShadow( v ) {\n\n\t\t\t\trenderer.shadowMap.enabled = v;\n\t\t\t\tsun.castShadow = v;\n\n\t\t\t\tif ( v ) {\n\n\t\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\t\t\tconst shadow = sun.shadow;\n\t\t\t\t\tshadow.mapSize.width = shadow.mapSize.height = 2048;\n\t\t\t\t\tshadow.radius = 2;\n\t\t\t\t\tshadow.bias = - 0.0005;\n\t\t\t\t\tconst shadowCam = shadow.camera, s = 5;\n\t\t\t\t\tshadowCam.near = 0.1;\n\t\t\t\t\tshadowCam.far = 6;\n\t\t\t\t\tshadowCam.right = shadowCam.top\t= s;\n\t\t\t\t\tshadowCam.left = shadowCam.bottom = - s;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( sun.shadow ) sun.shadow.dispose();\n\n\t\t\t\t}\n\n\t\t\t\t// debug shadow\n\t\t\t\t//scene.add(  new THREE.CameraHelper(shadowCam) );\n\n\t\t\t}\n\n\t\t\tfunction smoothWater() {\n\n\t\t\t\tconst currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );\n\t\t\t\tconst alternateRenderTarget = gpuCompute.getAlternateRenderTarget( heightmapVariable );\n\n\t\t\t\tfor ( let i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\tsmoothShader.uniforms[ 'smoothTexture' ].value = currentRenderTarget.texture;\n\t\t\t\t\tgpuCompute.doRenderTarget( smoothShader, alternateRenderTarget );\n\n\t\t\t\t\tsmoothShader.uniforms[ 'smoothTexture' ].value = alternateRenderTarget.texture;\n\t\t\t\t\tgpuCompute.doRenderTarget( smoothShader, currentRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createducks() {\n\n\t\t\t\tfor ( let i = 0; i < NUM_DUCK; i ++ ) {\n\n\t\t\t\t\tlet sphere = duckModel;\n\t\t\t\t\tif ( i < NUM_DUCK - 1 ) {\n\n\t\t\t\t\t\tsphere = duckModel.clone();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsphere.position.x = ( Math.random() - 0.5 ) * BOUNDS * 0.7;\n\t\t\t\t\tsphere.position.z = ( Math.random() - 0.5 ) * BOUNDS * 0.7;\n\n\t\t\t\t\tsphere.userData.velocity = new THREE.Vector3();\n\n\t\t\t\t\tscene.add( sphere );\n\n\t\t\t\t\tducks[ i ] = sphere;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction duckDynamics() {\n\n\t\t\t\treadWaterLevelShader.uniforms[ 'levelTexture' ].value = tmpHeightmap;\n\n\t\t\t\tfor ( let i = 0; i < NUM_DUCK; i ++ ) {\n\n\t\t\t\t\tconst sphere = ducks[ i ];\n\n\t\t\t\t\tif ( sphere ) {\n\n\t\t\t\t\t\t// Read water level and orientation\n\t\t\t\t\t\tconst u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;\n\t\t\t\t\t\tconst v = 1 - ( 0.5 * sphere.position.z / BOUNDS_HALF + 0.5 );\n\t\t\t\t\t\treadWaterLevelShader.uniforms[ 'point1' ].value.set( u, v );\n\t\t\t\t\t\tgpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );\n\n\t\t\t\t\t\trenderer.readRenderTargetPixels( readWaterLevelRenderTarget, 0, 0, 4, 1, readWaterLevelImage );\n\t\t\t\t\t\tconst pixels = new Float32Array( readWaterLevelImage.buffer );\n\n\t\t\t\t\t\t// Get orientation\n\t\t\t\t\t\twaterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );\n\n\t\t\t\t\t\tconst pos = sphere.position;\n\n\t\t\t\t\t\tconst startPos = pos.clone();\n\n\t\t\t\t\t\t// Set height\n\t\t\t\t\t\tpos.y = pixels[ 0 ];\n\n\t\t\t\t\t\t// Move sphere\n\t\t\t\t\t\twaterNormal.multiplyScalar( 0.01 );\n\t\t\t\t\t\tsphere.userData.velocity.add( waterNormal );\n\t\t\t\t\t\tsphere.userData.velocity.multiplyScalar( 0.998 );\n\t\t\t\t\t\tpos.add( sphere.userData.velocity );\n\n\n\n\t\t\t\t\t\tconst decal = 0.001;\n\t\t\t\t\t\tconst limit = BOUNDS_HALF - 0.2;\n\n\t\t\t\t\t\tif ( pos.x < - limit ) {\n\n\t\t\t\t\t\t\tpos.x = - limit + decal;\n\t\t\t\t\t\t\tsphere.userData.velocity.x *= - 0.3;\n\n\t\t\t\t\t\t} else if ( pos.x > limit ) {\n\n\t\t\t\t\t\t\tpos.x = limit - decal;\n\t\t\t\t\t\t\tsphere.userData.velocity.x *= - 0.3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( pos.z < - limit ) {\n\n\t\t\t\t\t\t\tpos.z = - limit + decal;\n\t\t\t\t\t\t\tsphere.userData.velocity.z *= - 0.3;\n\n\t\t\t\t\t\t} else if ( pos.z > limit ) {\n\n\t\t\t\t\t\t\tpos.z = limit - decal;\n\t\t\t\t\t\t\tsphere.userData.velocity.z *= - 0.3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// duck orientation test\n\n\t\t\t\t\t\tconst startNormal = new THREE.Vector3( pixels[ 1 ], 1, - pixels[ 2 ] ).normalize();\n\n\t\t\t\t\t\tconst dir = startPos.sub( pos );\n\t\t\t\t\t\tdir.y = 0;\n\t\t\t\t\t\tdir.normalize();\n\n\t\t\t\t\t\tconst yAxis = new THREE.Vector3( 0, 1, 0 );\n\t\t\t\t\t\tconst zAxis = new THREE.Vector3( 0, 0, - 1 );\n\t\t\t\t\t\ttmpQuatX.setFromUnitVectors( zAxis, dir );\n\t\t\t\t\t\ttmpQuatZ.setFromUnitVectors( yAxis, startNormal );\n\t\t\t\t\t\ttmpQuat.multiplyQuaternions( tmpQuatZ, tmpQuatX );\n\t\t\t\t\t\tsphere.quaternion.slerp( tmpQuat, 0.017 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown() {\n\n\t\t\t\tmousedown = true;\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp() {\n\n\t\t\t\tmousedown = false;\n\t\t\t\tcontrols.enabled = true;\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tconst dom = renderer.domElement;\n\t\t\t\tmouseCoords.set( ( event.clientX / dom.clientWidth ) * 2 - 1, - ( event.clientY / dom.clientHeight ) * 2 + 1 );\n\n\t\t\t}\n\n\t\t\tfunction raycast() {\n\n\t\t\t\t// Set uniforms: mouse interaction\n\t\t\t\tconst uniforms = heightmapVariable.material.uniforms;\n\t\t\t\tif ( mousedown ) {\n\n\t\t\t\t\traycaster.setFromCamera( mouseCoords, camera );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObject( meshRay );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tconst point = intersects[ 0 ].point;\n\t\t\t\t\t\tuniforms[ 'mousePos' ].value.set( point.x, point.z );\n\t\t\t\t\t\tif ( controls.enabled ) controls.enabled = false;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms[ 'mousePos' ].value.set( 10000, 10000 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms[ 'mousePos' ].value.set( 10000, 10000 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\traycast();\n\n\t\t\t\tframe ++;\n\n\t\t\t\tif ( frame >= 7 - effectController.speed ) {\n\n\t\t\t\t\t// Do the gpu computation\n\t\t\t\t\tgpuCompute.compute();\n\t\t\t\t\ttmpHeightmap = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;\n\n\t\t\t\t\tif ( ducksEnabled ) duckDynamics();\n\n\t\t\t\t\t// Get compute output in custom uniform\n\t\t\t\t\tif ( waterMesh ) waterMesh.material.heightmap = tmpHeightmap;\n\n\t\t\t\t\tframe = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Render\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\n\t\t\t//----------------------\n\n\t\t\tclass WaterMaterial extends THREE.MeshStandardMaterial {\n\n\t\t\t\tconstructor( parameters ) {\n\n\t\t\t\t\tsuper();\n\n\t\t\t\t\tthis.defines = {\n\n\t\t\t\t\t\t'STANDARD': '',\n\t\t\t\t\t\t'USE_UV': '',\n\t\t\t\t\t\t'WIDTH': WIDTH.toFixed( 1 ),\n\t\t\t\t\t\t'BOUNDS': BOUNDS.toFixed( 1 ),\n\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.extra = {};\n\n\t\t\t\t\tthis.addParameter( 'heightmap', null );\n\n\t\t\t\t\tthis.setValues( parameters );\n\n\t\t\t\t}\n\n\t\t\t\taddParameter( name, value ) {\n\n\t\t\t\t\tthis.extra[ name ] = value;\n\t\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\t\tget: () => ( this.extra[ name ] ),\n\t\t\t\t\t\tset: ( v ) => {\n\n\t\t\t\t\t\t\tthis.extra[ name ] = v;\n\t\t\t\t\t\t\tif ( this.userData.shader ) this.userData.shader.uniforms[ name ].value = this.extra[ name ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tonBeforeCompile( shader ) {\n\n\t\t\t\t\tfor ( const name in this.extra ) {\n\n\t\t\t\t\t\tshader.uniforms[ name ] = { value: this.extra[ name ] };\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshader.vertexShader = shader.vertexShader.replace( '#include <common>', shaderChange.common );\n\t\t\t\t\t//shader.vertexShader = 'uniform sampler2D heightmap;\\n' + shader.vertexShader;\n\t\t\t\t\tshader.vertexShader = shader.vertexShader.replace( '#include <beginnormal_vertex>', shaderChange.beginnormal_vertex );\n\t\t\t\t\tshader.vertexShader = shader.vertexShader.replace( '#include <begin_vertex>', shaderChange.begin_vertex );\n\n\t\t\t\t\tthis.userData.shader = shader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst shaderChange = {\n\n\t\t\t\theightmap_frag: /* glsl */`\n\t\t\t\t#include <common>\n\n\t\t\t\tuniform vec2 mousePos;\n\t\t\t\tuniform float mouseSize;\n\t\t\t\tuniform float viscosity;\n\t\t\t\tuniform float deep;\n\n\t\t\t\tvoid main()\t{\n\n\t\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\n\n\t\t\t\t\tvec2 uv = gl_FragCoord.xy * cellSize;\n\n\t\t\t\t\t// heightmapValue.x == height from previous frame\n\t\t\t\t\t// heightmapValue.y == height from penultimate frame\n\t\t\t\t\t// heightmapValue.z, heightmapValue.w not used\n\t\t\t\t\tvec4 heightmapValue = texture2D( heightmap, uv );\n\n\t\t\t\t\t// Get neighbours\n\t\t\t\t\tvec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );\n\t\t\t\t\tvec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );\n\t\t\t\t\tvec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );\n\t\t\t\t\tvec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );\n\n\t\t\t\t\t//float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosity;\n\t\t\t\t\tfloat newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - (heightmapValue.y) ) * viscosity;\n\n\n\t\t\t\t\t// Mouse influence\n\t\t\t\t\tfloat mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );\n\t\t\t\t\t//newHeight += ( cos( mousePhase ) + 1.0 ) * 0.28 * 10.0;\n\t\t\t\t\tnewHeight -= ( cos( mousePhase ) + 1.0 ) * deep;\n\n\t\t\t\t\theightmapValue.y = heightmapValue.x;\n\t\t\t\t\theightmapValue.x = newHeight;\n\n\t\t\t\t\tgl_FragColor = heightmapValue;\n\n\t\t\t\t}\n\t\t\t\t`,\n\t\t\t\t// FOR MATERIAL\n\t\t\t\tcommon: /* glsl */`\n\t\t\t\t#include <common>\n\t\t\t\tuniform sampler2D heightmap;\n\t\t\t\t`,\n\t\t\t\tbeginnormal_vertex: /* glsl */`\n\t\t\t\tvec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );\n\t\t\t\tvec3 objectNormal = vec3(\n\t\t\t\t( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,\n\t\t\t\t( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,\n\t\t\t\t1.0 );\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`,\n\t\t\t\tbegin_vertex: /* glsl */`\n\t\t\t\tfloat heightValue = texture2D( heightmap, uv ).x;\n\t\t\t\tvec3 transformed = vec3( position.x, position.y, heightValue );\n\t\t\t\t#ifdef USE_ALPHAHASH\n\t\t\t\t\tvPosition = vec3( position );\n\t\t\t\t#endif\n\t\t\t\t`,\n\t\t\t};\n```\n\nThis example three.js - webgl gpgpu water Click and Move mouse to disturb water."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - gpgpu - protoplanet"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - gpgpu - protoplanet:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n\n\t\t\t// Texture width for simulation (each texel is a debris particle)\n\t\t\tconst WIDTH = 64;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, geometry;\n\n\t\t\tconst PARTICLES = WIDTH * WIDTH;\n\n\t\t\tlet gpuCompute;\n\t\t\tlet velocityVariable;\n\t\t\tlet positionVariable;\n\t\t\tlet velocityUniforms;\n\t\t\tlet particleUniforms;\n\t\t\tlet effectController;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 5, 15000 );\n\t\t\t\tcamera.position.y = 120;\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 1000;\n\n\t\t\t\teffectController = {\n\t\t\t\t\t// Can be changed dynamically\n\t\t\t\t\tgravityConstant: 100.0,\n\t\t\t\t\tdensity: 0.45,\n\n\t\t\t\t\t// Must restart simulation\n\t\t\t\t\tradius: 300,\n\t\t\t\t\theight: 8,\n\t\t\t\t\texponent: 0.4,\n\t\t\t\t\tmaxMass: 15.0,\n\t\t\t\t\tvelocity: 70,\n\t\t\t\t\tvelocityExponent: 0.2,\n\t\t\t\t\trandVelocity: 0.001\n\t\t\t\t};\n\n\t\t\t\tinitComputeRenderer();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tinitGUI();\n\n\t\t\t\tinitProtoplanets();\n\n\t\t\t\tdynamicValuesChanger();\n\n\t\t\t}\n\n\t\t\tfunction initComputeRenderer() {\n\n\t\t\t\tgpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );\n\n\t\t\t\tconst dtPosition = gpuCompute.createTexture();\n\t\t\t\tconst dtVelocity = gpuCompute.createTexture();\n\n\t\t\t\tfillTextures( dtPosition, dtVelocity );\n\n\t\t\t\tvelocityVariable = gpuCompute.addVariable( 'textureVelocity', document.getElementById( 'computeShaderVelocity' ).textContent, dtVelocity );\n\t\t\t\tpositionVariable = gpuCompute.addVariable( 'texturePosition', document.getElementById( 'computeShaderPosition' ).textContent, dtPosition );\n\n\t\t\t\tgpuCompute.setVariableDependencies( velocityVariable, [ positionVariable, velocityVariable ] );\n\t\t\t\tgpuCompute.setVariableDependencies( positionVariable, [ positionVariable, velocityVariable ] );\n\n\t\t\t\tvelocityUniforms = velocityVariable.material.uniforms;\n\n\t\t\t\tvelocityUniforms[ 'gravityConstant' ] = { value: 0.0 };\n\t\t\t\tvelocityUniforms[ 'density' ] = { value: 0.0 };\n\n\t\t\t\tconst error = gpuCompute.init();\n\n\t\t\t\tif ( error !== null ) {\n\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction restartSimulation() {\n\n\t\t\t\tconst dtPosition = gpuCompute.createTexture();\n\t\t\t\tconst dtVelocity = gpuCompute.createTexture();\n\n\t\t\t\tfillTextures( dtPosition, dtVelocity );\n\n\t\t\t\tgpuCompute.renderTexture( dtPosition, positionVariable.renderTargets[ 0 ] );\n\t\t\t\tgpuCompute.renderTexture( dtPosition, positionVariable.renderTargets[ 1 ] );\n\t\t\t\tgpuCompute.renderTexture( dtVelocity, velocityVariable.renderTargets[ 0 ] );\n\t\t\t\tgpuCompute.renderTexture( dtVelocity, velocityVariable.renderTargets[ 1 ] );\n\n\t\t\t}\n\n\t\t\tfunction initProtoplanets() {\n\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\n\t\t\t\tconst positions = new Float32Array( PARTICLES * 3 );\n\t\t\t\tlet p = 0;\n\n\t\t\t\tfor ( let i = 0; i < PARTICLES; i ++ ) {\n\n\t\t\t\t\tpositions[ p ++ ] = ( Math.random() * 2 - 1 ) * effectController.radius;\n\t\t\t\t\tpositions[ p ++ ] = 0; //( Math.random() * 2 - 1 ) * effectController.radius;\n\t\t\t\t\tpositions[ p ++ ] = ( Math.random() * 2 - 1 ) * effectController.radius;\n\n\t\t\t\t}\n\n\t\t\t\tconst uvs = new Float32Array( PARTICLES * 2 );\n\t\t\t\tp = 0;\n\n\t\t\t\tfor ( let j = 0; j < WIDTH; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < WIDTH; i ++ ) {\n\n\t\t\t\t\t\tuvs[ p ++ ] = i / ( WIDTH - 1 );\n\t\t\t\t\t\tuvs[ p ++ ] = j / ( WIDTH - 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t\t\t\tparticleUniforms = {\n\t\t\t\t\t'texturePosition': { value: null },\n\t\t\t\t\t'textureVelocity': { value: null },\n\t\t\t\t\t'cameraConstant': { value: getCameraConstant( camera ) },\n\t\t\t\t\t'density': { value: 0.0 }\n\t\t\t\t};\n\n\t\t\t\t// THREE.ShaderMaterial\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: particleUniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'particleVertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'particleFragmentShader' ).textContent\n\t\t\t\t} );\n\n\t\t\t\tconst particles = new THREE.Points( geometry, material );\n\t\t\t\tparticles.matrixAutoUpdate = false;\n\t\t\t\tparticles.updateMatrix();\n\n\t\t\t\tscene.add( particles );\n\n\t\t\t}\n\n\t\t\tfunction fillTextures( texturePosition, textureVelocity ) {\n\n\t\t\t\tconst posArray = texturePosition.image.data;\n\t\t\t\tconst velArray = textureVelocity.image.data;\n\n\t\t\t\tconst radius = effectController.radius;\n\t\t\t\tconst height = effectController.height;\n\t\t\t\tconst exponent = effectController.exponent;\n\t\t\t\tconst maxMass = effectController.maxMass * 1024 / PARTICLES;\n\t\t\t\tconst maxVel = effectController.velocity;\n\t\t\t\tconst velExponent = effectController.velocityExponent;\n\t\t\t\tconst randVel = effectController.randVelocity;\n\n\t\t\t\tfor ( let k = 0, kl = posArray.length; k < kl; k += 4 ) {\n\n\t\t\t\t\t// Position\n\t\t\t\t\tlet x, z, rr;\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\tx = ( Math.random() * 2 - 1 );\n\t\t\t\t\t\tz = ( Math.random() * 2 - 1 );\n\t\t\t\t\t\trr = x * x + z * z;\n\n\t\t\t\t\t} while ( rr > 1 );\n\n\t\t\t\t\trr = Math.sqrt( rr );\n\n\t\t\t\t\tconst rExp = radius * Math.pow( rr, exponent );\n\n\t\t\t\t\t// Velocity\n\t\t\t\t\tconst vel = maxVel * Math.pow( rr, velExponent );\n\n\t\t\t\t\tconst vx = vel * z + ( Math.random() * 2 - 1 ) * randVel;\n\t\t\t\t\tconst vy = ( Math.random() * 2 - 1 ) * randVel * 0.05;\n\t\t\t\t\tconst vz = - vel * x + ( Math.random() * 2 - 1 ) * randVel;\n\n\t\t\t\t\tx *= rExp;\n\t\t\t\t\tz *= rExp;\n\t\t\t\t\tconst y = ( Math.random() * 2 - 1 ) * height;\n\n\t\t\t\t\tconst mass = Math.random() * maxMass + 1;\n\n\t\t\t\t\t// Fill in texture values\n\t\t\t\t\tposArray[ k + 0 ] = x;\n\t\t\t\t\tposArray[ k + 1 ] = y;\n\t\t\t\t\tposArray[ k + 2 ] = z;\n\t\t\t\t\tposArray[ k + 3 ] = 1;\n\n\t\t\t\t\tvelArray[ k + 0 ] = vx;\n\t\t\t\t\tvelArray[ k + 1 ] = vy;\n\t\t\t\t\tvelArray[ k + 2 ] = vz;\n\t\t\t\t\tvelArray[ k + 3 ] = mass;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tparticleUniforms[ 'cameraConstant' ].value = getCameraConstant( camera );\n\n\t\t\t}\n\n\t\t\tfunction dynamicValuesChanger() {\n\n\t\t\t\tvelocityUniforms[ 'gravityConstant' ].value = effectController.gravityConstant;\n\t\t\t\tvelocityUniforms[ 'density' ].value = effectController.density;\n\t\t\t\tparticleUniforms[ 'density' ].value = effectController.density;\n\n\t\t\t}\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\tconst gui = new GUI( { width: 280 } );\n\n\t\t\t\tconst folder1 = gui.addFolder( 'Dynamic parameters' );\n\n\t\t\t\tfolder1.add( effectController, 'gravityConstant', 0.0, 1000.0, 0.05 ).onChange( dynamicValuesChanger );\n\t\t\t\tfolder1.add( effectController, 'density', 0.0, 10.0, 0.001 ).onChange( dynamicValuesChanger );\n\n\t\t\t\tconst folder2 = gui.addFolder( 'Static parameters' );\n\n\t\t\t\tfolder2.add( effectController, 'radius', 10.0, 1000.0, 1.0 );\n\t\t\t\tfolder2.add( effectController, 'height', 0.0, 50.0, 0.01 );\n\t\t\t\tfolder2.add( effectController, 'exponent', 0.0, 2.0, 0.001 );\n\t\t\t\tfolder2.add( effectController, 'maxMass', 1.0, 50.0, 0.1 );\n\t\t\t\tfolder2.add( effectController, 'velocity', 0.0, 150.0, 0.1 );\n\t\t\t\tfolder2.add( effectController, 'velocityExponent', 0.0, 1.0, 0.01 );\n\t\t\t\tfolder2.add( effectController, 'randVelocity', 0.0, 50.0, 0.1 );\n\n\t\t\t\tconst buttonRestart = {\n\t\t\t\t\trestartSimulation: function () {\n\n\t\t\t\t\t\trestartSimulation();\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfolder2.add( buttonRestart, 'restartSimulation' );\n\n\t\t\t\tfolder1.open();\n\t\t\t\tfolder2.open();\n\n\t\t\t}\n\n\t\t\tfunction getCameraConstant( camera ) {\n\n\t\t\t\treturn window.innerHeight / ( Math.tan( THREE.MathUtils.DEG2RAD * 0.5 * camera.fov ) / camera.zoom );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tgpuCompute.compute();\n\n\t\t\t\tparticleUniforms[ 'texturePosition' ].value = gpuCompute.getCurrentRenderTarget( positionVariable ).texture;\n\t\t\t\tparticleUniforms[ 'textureVelocity' ].value = gpuCompute.getCurrentRenderTarget( velocityVariable ).texture;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgl gpgpu debris"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_material example that demonstrates webgl - materials - modified"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - materials - modified:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 20;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tconst geometry = gltf.scene.children[ 0 ].geometry;\n\n\t\t\t\t\tlet mesh = new THREE.Mesh( geometry, buildTwistMaterial( 2.0 ) );\n\t\t\t\t\tmesh.position.x = - 3.5;\n\t\t\t\t\tmesh.position.y = - 0.5;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, buildTwistMaterial( - 2.0 ) );\n\t\t\t\t\tmesh.position.x = 3.5;\n\t\t\t\t\tmesh.position.y = - 0.5;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction buildTwistMaterial( amount ) {\n\n\t\t\t\tconst material = new THREE.MeshNormalMaterial();\n\t\t\t\tmaterial.onBeforeCompile = function ( shader ) {\n\n\t\t\t\t\tshader.uniforms.time = { value: 0 };\n\n\t\t\t\t\tshader.vertexShader = 'uniform float time;\\n' + shader.vertexShader;\n\t\t\t\t\tshader.vertexShader = shader.vertexShader.replace(\n\t\t\t\t\t\t'#include <begin_vertex>',\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t`float theta = sin( time + position.y ) / ${ amount.toFixed( 1 ) };`,\n\t\t\t\t\t\t\t'float c = cos( theta );',\n\t\t\t\t\t\t\t'float s = sin( theta );',\n\t\t\t\t\t\t\t'mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );',\n\t\t\t\t\t\t\t'vec3 transformed = vec3( position ) * m;',\n\t\t\t\t\t\t\t'vNormal = vNormal * m;'\n\t\t\t\t\t\t].join( '\\n' )\n\t\t\t\t\t);\n\n\t\t\t\t\tmaterial.userData.shader = shader;\n\n\t\t\t\t};\n\n\t\t\t\t// Make sure WebGLRenderer doesn't reuse a single program\n\n\t\t\t\tmaterial.customProgramCacheKey = function () {\n\n\t\t\t\t\treturn amount.toFixed( 1 );\n\n\t\t\t\t};\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tconst shader = child.material.userData.shader;\n\n\t\t\t\t\t\tif ( shader ) {\n\n\t\t\t\t\t\t\tshader.uniforms.time.value = performance.now() / 1000;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js wegbl - modified material. Lee Perry-Smith head."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - Multiple Render Targets"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - Multiple Render Targets:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet renderTarget;\n\t\t\tlet postScene, postCamera;\n\n\t\t\tconst parameters = {\n\t\t\t\tsamples: 4,\n\t\t\t\twireframe: false\n\t\t\t};\n\n\t\t\tconst gui = new GUI();\n\t\t\tgui.add( parameters, 'samples', 0, 4 ).step( 1 );\n\t\t\tgui.add( parameters, 'wireframe' );\n\t\t\tgui.onChange( render );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Create a multi render target with Float buffers\n\n\t\t\t\trenderTarget = new THREE.WebGLRenderTarget(\n\t\t\t\t\twindow.innerWidth * window.devicePixelRatio,\n\t\t\t\t\twindow.innerHeight * window.devicePixelRatio,\n\t\t\t\t\t{\n\t\t\t\t\t\tcount: 2,\n\t\t\t\t\t\tminFilter: THREE.NearestFilter,\n\t\t\t\t\t\tmagFilter: THREE.NearestFilter\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Name our G-Buffer attachments for debugging\n\n\t\t\t\trenderTarget.textures[ 0 ].name = 'diffuse';\n\t\t\t\trenderTarget.textures[ 1 ].name = 'normal';\n\n\t\t\t\t// Scene setup\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tconst diffuse = loader.load( 'textures/hardwood2_diffuse.jpg', render );\n\t\t\t\tdiffuse.wrapS = THREE.RepeatWrapping;\n\t\t\t\tdiffuse.wrapT = THREE.RepeatWrapping;\n\t\t\t\tdiffuse.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tscene.add( new THREE.Mesh(\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1, 0.3, 128, 32 ),\n\t\t\t\t\tnew THREE.RawShaderMaterial( {\n\t\t\t\t\t\tname: 'G-Buffer Shader',\n\t\t\t\t\t\tvertexShader: document.querySelector( '#gbuffer-vert' ).textContent.trim(),\n\t\t\t\t\t\tfragmentShader: document.querySelector( '#gbuffer-frag' ).textContent.trim(),\n\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\ttDiffuse: { value: diffuse },\n\t\t\t\t\t\t\trepeat: { value: new THREE.Vector2( 5, 0.5 ) }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t\t} )\n\t\t\t\t) );\n\n\t\t\t\t// PostProcessing setup\n\n\t\t\t\tpostScene = new THREE.Scene();\n\t\t\t\tpostCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n\t\t\t\tpostScene.add( new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew THREE.RawShaderMaterial( {\n\t\t\t\t\t\tname: 'Post-FX Shader',\n\t\t\t\t\t\tvertexShader: document.querySelector( '#render-vert' ).textContent.trim(),\n\t\t\t\t\t\tfragmentShader: document.querySelector( '#render-frag' ).textContent.trim(),\n\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\ttDiffuse: { value: renderTarget.textures[ 0 ] },\n\t\t\t\t\t\t\ttNormal: { value: renderTarget.textures[ 1 ] },\n\t\t\t\t\t\t},\n\t\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t\t} )\n\t\t\t\t) );\n\n\t\t\t\t// Controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tconst dpr = renderer.getPixelRatio();\n\t\t\t\trenderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderTarget.samples = parameters.samples;\n\n\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.material !== undefined ) {\n\n\t\t\t\t\t\tchild.material.wireframe = parameters.wireframe;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// render scene into target\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// render post FX\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.render( postScene, postCamera );\n\n\t\t\t}\n```\n\nThis example threejs webgl - Multiple RenderTargets"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates WebGL 2 - Multisampled Renderbuffers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL 2 - Multisampled Renderbuffers:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, renderer, group, container;\n\n\t\t\tlet composer1, composer2;\n\n\t\t\tconst params = {\n\n\t\t\t\tanimate: true,\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 10, 2000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\t\t\t\tscene.fog = new THREE.Fog( 0xcccccc, 100, 1500 );\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x222222, 5 );\n\t\t\t\themiLight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\t//\n\n\t\t\t\tgroup = new THREE.Group();\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 10, 64, 40 );\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( {\n\t\t\t\t\tcolor: 0xee0808,\n\t\t\t\t\tpolygonOffset: true,\n\t\t\t\t\tpolygonOffsetFactor: 1, // positive value pushes polygon further away\n\t\t\t\t\tpolygonOffsetUnits: 1\n\n\t\t\t\t} );\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 600 - 300;\n\t\t\t\t\tmesh.position.y = Math.random() * 600 - 300;\n\t\t\t\t\tmesh.position.z = Math.random() * 600 - 300;\n\t\t\t\t\tmesh.rotation.x = Math.random();\n\t\t\t\t\tmesh.rotation.z = Math.random();\n\t\t\t\t\tmesh.scale.setScalar( Math.random() * 5 + 5 );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\t\tmesh2.position.copy( mesh.position );\n\t\t\t\t\tmesh2.rotation.copy( mesh.rotation );\n\t\t\t\t\tmesh2.scale.copy( mesh.scale );\n\t\t\t\t\tgroup.add( mesh2 );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( container.offsetWidth, container.offsetHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst size = renderer.getDrawingBufferSize( new THREE.Vector2() );\n\t\t\t\tconst renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, { samples: 4, type: THREE.HalfFloatType } );\n\n\t\t\t\tconst renderPass = new RenderPass( scene, camera );\n\t\t\t\tconst outputPass = new OutputPass();\n\n\t\t\t\t//\n\n\t\t\t\tcomposer1 = new EffectComposer( renderer );\n\t\t\t\tcomposer1.addPass( renderPass );\n\t\t\t\tcomposer1.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\tcomposer2 = new EffectComposer( renderer, renderTarget );\n\t\t\t\tcomposer2.addPass( renderPass );\n\t\t\t\tcomposer2.addPass( outputPass );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'animate' );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = container.offsetWidth / container.offsetHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( container.offsetWidth, container.offsetHeight );\n\t\t\t\tcomposer1.setSize( container.offsetWidth, container.offsetHeight );\n\t\t\t\tcomposer2.setSize( container.offsetWidth, container.offsetHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst halfWidth = container.offsetWidth / 2;\n\n\t\t\t\tif ( params.animate ) {\n\n\t\t\t\t\tgroup.rotation.y += 0.002;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 0, 0, halfWidth - 1, container.offsetHeight );\n\t\t\t\tcomposer1.render();\n\n\t\t\t\trenderer.setScissor( halfWidth, 0, halfWidth, container.offsetHeight );\n\t\t\t\tcomposer2.render();\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n```\n\nThis example three.js - Multisampled Renderbuffers Left: WebGLRenderTarget, Right: WebGLRenderTarget (multisampled)."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - 2D texture array framebuffer attachment"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 2D texture array framebuffer attachment:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { unzipSync } from 'three/addons/libs/fflate.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst DIMENSIONS = {\n\t\t\t\twidth: 256,\n\t\t\t\theight: 256,\n\t\t\t\tdepth: 109\n\t\t\t};\n\n\t\t\tconst params = {\n\t\t\t\tintensity: 1\n\t\t\t};\n\n\t\t\t/** Post-processing objects */\n\n\t\t\tconst postProcessScene = new THREE.Scene();\n\t\t\tconst postProcessCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n\t\t\tconst renderTarget = new THREE.WebGLArrayRenderTarget( DIMENSIONS.width, DIMENSIONS.height, DIMENSIONS.depth );\n\t\t\trenderTarget.texture.format = THREE.RedFormat;\n\n\t\t\tconst postProcessMaterial = new THREE.ShaderMaterial( {\n\t\t\t\tuniforms: {\n\t\t\t\t\tuTexture: { value: null },\n\t\t\t\t\tuDepth: { value: 55 },\n\t\t\t\t\tuIntensity: { value: 1.0 }\n\t\t\t\t},\n\t\t\t\tvertexShader: document.getElementById( 'vertex-postprocess' ).textContent.trim(),\n\t\t\t\tfragmentShader: document.getElementById( 'fragment-postprocess' ).textContent.trim()\n\t\t\t} );\n\n\t\t\tlet depthStep = 0.4;\n\n\t\t\tlet camera, scene, mesh, renderer, stats;\n\n\t\t\tconst planeWidth = 50;\n\t\t\tconst planeHeight = 50;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.z = 70;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t/** Post-processing scene */\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst screenQuad = new THREE.Mesh( planeGeometry, postProcessMaterial );\n\t\t\t\tpostProcessScene.add( screenQuad );\n\n\t\t\t\t// 2D Texture array is available on WebGL 2.0\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'intensity', 0, 1 ).step( 0.01 ).onChange( value => postProcessMaterial.uniforms.uIntensity.value = value );\n\t\t\t\tgui.open();\n\n\t\t\t\t// width 256, height 256, depth 109, 8-bit, zip archived raw data\n\n\t\t\t\tnew THREE.FileLoader()\n\t\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t\t.load( 'textures/3d/head256x256x109.zip', function ( data ) {\n\n\t\t\t\t\t\tconst zip = unzipSync( new Uint8Array( data ) );\n\t\t\t\t\t\tconst array = new Uint8Array( zip[ 'head256x256x109' ].buffer );\n\n\t\t\t\t\t\tconst texture = new THREE.DataArrayTexture( array, DIMENSIONS.width, DIMENSIONS.height, DIMENSIONS.depth );\n\t\t\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\t\tdiffuse: { value: renderTarget.texture },\n\t\t\t\t\t\t\t\tdepth: { value: 55 },\n\t\t\t\t\t\t\t\tsize: { value: new THREE.Vector2( planeWidth, planeHeight ) }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvertexShader: document.getElementById( 'vs' ).textContent.trim(),\n\t\t\t\t\t\t\tfragmentShader: document.getElementById( 'fs' ).textContent.trim()\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tpostProcessMaterial.uniforms.uTexture.value = texture;\n\n\t\t\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tlet value = mesh.material.uniforms[ 'depth' ].value;\n\n\t\t\t\tvalue += depthStep;\n\n\t\t\t\tif ( value > 109.0 || value < 0.0 ) {\n\n\t\t\t\t\tif ( value > 1.0 ) value = 109.0 * 2.0 - value;\n\t\t\t\t\tif ( value < 0.0 ) value = - value;\n\n\t\t\t\t\tdepthStep = - depthStep;\n\n\t\t\t\t}\n\n\t\t\t\tmesh.material.uniforms[ 'depth' ].value = value;\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Renders the 2D array into the render target `renderTarget`.\n\t\t\t */\n\t\t\tfunction renderTo2DArray() {\n\n\t\t\t\tconst layer = Math.floor( mesh.material.uniforms[ 'depth' ].value );\n\t\t\t\tpostProcessMaterial.uniforms.uDepth.value = layer;\n\t\t\t\trenderer.setRenderTarget( renderTarget, layer );\n\t\t\t\trenderer.render( postProcessScene, postProcessCamera );\n\t\t\t\trenderer.setRenderTarget( null );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\t// Step 1 - Render the input DataArrayTexture into render target\n\t\t\t\trenderTo2DArray();\n\n\t\t\t\t// Step 2 - Renders the scene containing the plane with a material\n\t\t\t\t// sampling the render target texture.\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 2D Texture array framebuffer color attachment This example shows how to render to an array of 2D texture. WebGL2 allows to render to specific \"layers\" in 3D texture and array of textures. Scanned head data by Divine Augustine licensed under CPOL"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_geometry example that demonstrates webgl - reverse depth buffer"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - reverse depth buffer:\n\n```javascript\n// https://webgpu.github.io/webgpu-samples/?sample=reversedZ\n\t\t\timport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\t\t\timport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\t\t\timport { OutputPass } from 'three/addons/postprocessing/OutputPass.js';\n\n\t\t\tlet stats, camera, scene;\n\t\t\tlet normalRenderer, logarithmicRenderer, reverseRenderer;\n\t\t\tlet normalComposer, logarithmicComposer, reverseComposer;\n\t\t\tconst meshes = [];\n\n\t\t\tconst renderTarget = new THREE.WebGLRenderTarget();\n\t\t\trenderTarget.depthTexture = new THREE.DepthTexture();\n\t\t\trenderTarget.depthTexture.type = THREE.FloatType;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 72, 0.33 * window.innerWidth / window.innerHeight, 5, 9999 );\n\t\t\t\tcamera.position.z = 12;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst xCount = 1;\n\t\t\t\tconst yCount = 5;\n\t\t\t\tconst numInstances = xCount * yCount;\n\n\t\t\t\tconst d = 0.0001; // half distance between two planes\n\t\t\t\tconst o = 0.5; // half x offset to shift planes so they are only partially overlapping\n\n\t\t\t\tconst positions = new Float32Array( [\n\t\t\t\t\t- 1 - o, - 1, d,\n\t\t\t\t\t1 - o, - 1, d,\n\t\t\t\t\t- 1 - o, 1, d,\n\t\t\t\t\t1 - o, - 1, d,\n\t\t\t\t\t1 - o, 1, d,\n\t\t\t\t\t- 1 - o, 1, d,\n\n\t\t\t\t\t- 1 + o, - 1, - d,\n\t\t\t\t\t1 + o, - 1, - d,\n\t\t\t\t\t- 1 + o, 1, - d,\n\t\t\t\t\t1 + o, - 1, - d,\n\t\t\t\t\t1 + o, 1, - d,\n\t\t\t\t\t- 1 + o, 1, - d,\n\t\t\t\t] );\n\n\t\t\t\tconst colors = new Float32Array( [\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t1, 0, 0,\n\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t] );\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { vertexColors: true } );\n\n\t\t\t\tfor ( let i = 0; i < numInstances; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmeshes.push( mesh );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tfor ( let x = 0; x < xCount; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < yCount; y ++ ) {\n\n\t\t\t\t\t\tconst z = - 800 * i;\n\t\t\t\t\t\tconst s = 1 + 50 * i;\n\n\t\t\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\t\t\tmesh.position.set(\n\t\t\t\t\t\t\tx - xCount / 2 + 0.5,\n\t\t\t\t\t\t\t( 4.0 - 0.2 * z ) * ( y - yCount / 2 + 1.0 ),\n\t\t\t\t\t\t\tz\n\t\t\t\t\t\t);\n\t\t\t\t\t\tmesh.scale.setScalar( s );\n\n\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst normalContainer = document.getElementById( 'container_normal' );\n\t\t\t\tnormalRenderer = new THREE.WebGLRenderer();\n\t\t\t\tnormalRenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\tnormalRenderer.setSize( 0.33 * window.innerWidth, window.innerHeight );\n\t\t\t\tnormalRenderer.domElement.style.position = 'relative';\n\t\t\t\tnormalContainer.appendChild( normalRenderer.domElement );\n\n\t\t\t\tnormalComposer = new EffectComposer( normalRenderer, renderTarget );\n\t\t\t\tnormalComposer.addPass( new RenderPass( scene, camera ) );\n\t\t\t\tnormalComposer.addPass( new OutputPass() );\n\n\t\t\t\tconst logarithmicContainer = document.getElementById( 'container_logarithmic' );\n\t\t\t\tlogarithmicRenderer = new THREE.WebGLRenderer( { logarithmicDepthBuffer: true } );\n\t\t\t\tlogarithmicRenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\tlogarithmicRenderer.setSize( 0.33 * window.innerWidth, window.innerHeight );\n\t\t\t\tlogarithmicRenderer.domElement.style.position = 'relative';\n\t\t\t\tlogarithmicContainer.appendChild( logarithmicRenderer.domElement );\n\n\t\t\t\tlogarithmicComposer = new EffectComposer( logarithmicRenderer, renderTarget );\n\t\t\t\tlogarithmicComposer.addPass( new RenderPass( scene, camera ) );\n\t\t\t\tlogarithmicComposer.addPass( new OutputPass() );\n\n\t\t\t\tconst reverseContainer = document.getElementById( 'container_reverse' );\n\t\t\t\treverseRenderer = new THREE.WebGLRenderer( { reverseDepthBuffer: true } );\n\t\t\t\treverseRenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\treverseRenderer.setSize( 0.33 * window.innerWidth, window.innerHeight );\n\t\t\t\treverseRenderer.domElement.style.position = 'relative';\n\t\t\t\treverseContainer.appendChild( reverseRenderer.domElement );\n\n\t\t\t\treverseComposer = new EffectComposer( reverseRenderer, renderTarget );\n\t\t\t\treverseComposer.addPass( new RenderPass( scene, camera ) );\n\t\t\t\treverseComposer.addPass( new OutputPass() );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\tconst now = performance.now() / 1000;\n\n\t\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\t\tconst angle = THREE.MathUtils.degToRad( 30 );\n\t\t\t\t\tconst axis = new THREE.Vector3( Math.sin( now ), Math.cos( now ), 0 );\n\t\t\t\t\tmeshes[ i ].quaternion.setFromAxisAngle( axis, angle );\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tnormalComposer.render();\n\t\t\t\tlogarithmicComposer.render();\n\t\t\t\treverseComposer.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = 0.33 * window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\t\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\t\tnormalComposer.setSize( width * dpr, height * dpr );\n\t\t\t\tlogarithmicComposer.setSize( width * dpr, height * dpr );\n\t\t\t\treverseComposer.setSize( width * dpr, height * dpr );\n\n\t\t\t\tnormalRenderer.setSize( width, height );\n\t\t\t\tlogarithmicRenderer.setSize( width, height );\n\t\t\t\treverseRenderer.setSize( width, height );\n\n\t\t\t\tcamera.aspect = 0.33 * window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n```\n\nThis example three.js - reverse depth buffer"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - cascaded shadow maps"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - cascaded shadow maps:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { CSM } from 'three/addons/csm/CSM.js';\n\t\t\timport { CSMHelper } from 'three/addons/csm/CSMHelper.js';\n\n\t\t\tlet renderer, scene, camera, orthoCamera, controls, csm, csmHelper;\n\n\t\t\tconst params = {\n\t\t\t\torthographic: false,\n\t\t\t\tfade: false,\n\t\t\t\tshadows: true,\n\t\t\t\tfar: 1000,\n\t\t\t\tmode: 'practical',\n\t\t\t\tlightX: - 1,\n\t\t\t\tlightY: - 1,\n\t\t\t\tlightZ: - 1,\n\t\t\t\tmargin: 100,\n\t\t\t\tlightFar: 5000,\n\t\t\t\tlightNear: 1,\n\t\t\t\tautoUpdateHelper: true,\n\t\t\t\tupdateHelper: function () {\n\n\t\t\t\t\tcsmHelper.update();\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction updateOrthoCamera() {\n\n\t\t\t\tconst size = controls.target.distanceTo( camera.position );\n\t\t\t\tconst aspect = camera.aspect;\n\n\t\t\t\torthoCamera.left = size * aspect / - 2;\n\t\t\t\torthoCamera.right = size * aspect / 2;\n\n\t\t\t\torthoCamera.top = size / 2;\n\t\t\t\torthoCamera.bottom = size / - 2;\n\t\t\t\torthoCamera.position.copy( camera.position );\n\t\t\t\torthoCamera.rotation.copy( camera.rotation );\n\t\t\t\torthoCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( '#454e61' );\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 5000 );\n\t\t\t\torthoCamera = new THREE.OrthographicCamera();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.shadowMap.enabled = params.shadows;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcamera.position.set( 60, 60, 0 );\n\t\t\t\tcontrols.target = new THREE.Vector3( - 100, 10, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 1.5 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst additionalDirectionalLight = new THREE.DirectionalLight( 0x000020, 1.5 );\n\t\t\t\tadditionalDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );\n\t\t\t\tscene.add( additionalDirectionalLight );\n\n\t\t\t\tcsm = new CSM( {\n\t\t\t\t\tmaxFar: params.far,\n\t\t\t\t\tcascades: 4,\n\t\t\t\t\tmode: params.mode,\n\t\t\t\t\tparent: scene,\n\t\t\t\t\tshadowMapSize: 1024,\n\t\t\t\t\tlightDirection: new THREE.Vector3( params.lightX, params.lightY, params.lightZ ).normalize(),\n\t\t\t\t\tcamera: camera\n\t\t\t\t} );\n\n\t\t\t\tcsmHelper = new CSMHelper( csm );\n\t\t\t\tcsmHelper.visible = false;\n\t\t\t\tscene.add( csmHelper );\n\n\t\t\t\tconst floorMaterial = new THREE.MeshPhongMaterial( { color: '#252a34' } );\n\t\t\t\tcsm.setupMaterial( floorMaterial );\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.PlaneGeometry( 10000, 10000, 8, 8 ), floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.castShadow = true;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tconst material1 = new THREE.MeshPhongMaterial( { color: '#08d9d6' } );\n\t\t\t\tcsm.setupMaterial( material1 );\n\n\t\t\t\tconst material2 = new THREE.MeshPhongMaterial( { color: '#ff2e63' } );\n\t\t\t\tcsm.setupMaterial( material2 );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 10, 10, 10 );\n\n\t\t\t\tfor ( let i = 0; i < 40; i ++ ) {\n\n\t\t\t\t\tconst cube1 = new THREE.Mesh( geometry, i % 2 === 0 ? material1 : material2 );\n\t\t\t\t\tcube1.castShadow = true;\n\t\t\t\t\tcube1.receiveShadow = true;\n\t\t\t\t\tscene.add( cube1 );\n\t\t\t\t\tcube1.position.set( - i * 25, 20, 30 );\n\t\t\t\t\tcube1.scale.y = Math.random() * 2 + 6;\n\n\t\t\t\t\tconst cube2 = new THREE.Mesh( geometry, i % 2 === 0 ? material2 : material1 );\n\t\t\t\t\tcube2.castShadow = true;\n\t\t\t\t\tcube2.receiveShadow = true;\n\t\t\t\t\tscene.add( cube2 );\n\t\t\t\t\tcube2.position.set( - i * 25, 20, - 30 );\n\t\t\t\t\tcube2.scale.y = Math.random() * 2 + 6;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'orthographic' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.camera = value ? orthoCamera : camera;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'fade' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.fade = value;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'shadows' ).onChange( function ( value ) {\n\n\t\t\t\t\trenderer.shadowMap.enabled = value;\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.material ) {\n\n\t\t\t\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'far', 1, 5000 ).step( 1 ).name( 'shadow far' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.maxFar = value;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'mode', [ 'uniform', 'logarithmic', 'practical' ] ).name( 'frustum split mode' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.mode = value;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightX', - 1, 1 ).name( 'light direction x' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.lightDirection.x = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightY', - 1, 1 ).name( 'light direction y' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.lightDirection.y = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightZ', - 1, 1 ).name( 'light direction z' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.lightDirection.z = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'margin', 0, 200 ).name( 'light margin' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.lightMargin = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightNear', 1, 10000 ).name( 'light near' ).onChange( function ( value ) {\n\n\t\t\t\t\tfor ( let i = 0; i < csm.lights.length; i ++ ) {\n\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.near = value;\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.updateProjectionMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightFar', 1, 10000 ).name( 'light far' ).onChange( function ( value ) {\n\n\t\t\t\t\tfor ( let i = 0; i < csm.lights.length; i ++ ) {\n\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.far = value;\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.updateProjectionMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tconst helperFolder = gui.addFolder( 'helper' );\n\n\t\t\t\thelperFolder.add( csmHelper, 'visible' );\n\n\t\t\t\thelperFolder.add( csmHelper, 'displayFrustum' ).onChange( function () {\n\n\t\t\t\t\tcsmHelper.updateVisibility();\n\n\t\t\t\t} );\n\n\t\t\t\thelperFolder.add( csmHelper, 'displayPlanes' ).onChange( function () {\n\n\t\t\t\t\tcsmHelper.updateVisibility();\n\n\t\t\t\t} );\n\n\t\t\t\thelperFolder.add( csmHelper, 'displayShadowBounds' ).onChange( function () {\n\n\t\t\t\t\tcsmHelper.updateVisibility();\n\n\t\t\t\t} );\n\n\t\t\t\thelperFolder.add( params, 'autoUpdateHelper' ).name( 'auto update' );\n\n\t\t\t\thelperFolder.add( params, 'updateHelper' ).name( 'update' );\n\n\t\t\t\thelperFolder.open();\n\n\t\t\t\twindow.addEventListener( 'resize', function () {\n\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\tupdateOrthoCamera();\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcamera.updateMatrixWorld();\n\t\t\t\tcsm.update();\n\t\t\t\tcontrols.update();\n\n\t\t\t\tif ( params.orthographic ) {\n\n\t\t\t\t\tupdateOrthoCamera();\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t\tif ( params.autoUpdateHelper ) {\n\n\t\t\t\t\t\tcsmHelper.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( scene, orthoCamera );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( params.autoUpdateHelper ) {\n\n\t\t\t\t\t\tcsmHelper.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js webgl - cascaded shadow maps by StrandedKitty ( original repository )"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - percent closer soft-shadows"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - percent closer soft-shadows:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0xcce0ff, 5, 100 );\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );\n\n\t\t\t\t// We use this particular camera position in order to expose a bug that can sometimes happen presumably\n\t\t\t\t// due to lack of precision when interpolating values over really large triangles.\n\t\t\t\t// It reproduced on at least NVIDIA GTX 1080 and GTX 1050 Ti GPUs when the ground plane was not\n\t\t\t\t// subdivided into segments.\n\t\t\t\tcamera.position.x = 7;\n\t\t\t\tcamera.position.y = 13;\n\t\t\t\tcamera.position.z = 7;\n\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xf0f6ff, 4.5 );\n\t\t\t\tlight.position.set( 2, 8, 4 );\n\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\t\t\t\tlight.shadow.camera.far = 20;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// scene.add( new DirectionalLightHelper( light ) );\n\t\t\t\tscene.add( new THREE.CameraHelper( light.shadow.camera ) );\n\n\t\t\t\t// group\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.3, 20, 20 );\n\n\t\t\t\tfor ( let i = 0; i < 20; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: Math.random() * 0xffffff } );\n\n\t\t\t\t\tconst sphere = new THREE.Mesh( geometry, material );\n\t\t\t\t\tsphere.position.x = Math.random() - 0.5;\n\t\t\t\t\tsphere.position.z = Math.random() - 0.5;\n\t\t\t\t\tsphere.position.normalize();\n\t\t\t\t\tsphere.position.multiplyScalar( Math.random() * 2 + 1 );\n\t\t\t\t\tsphere.castShadow = true;\n\t\t\t\t\tsphere.receiveShadow = true;\n\t\t\t\t\tsphere.userData.phase = Math.random() * Math.PI;\n\t\t\t\t\tgroup.add( sphere );\n\n\t\t\t\t}\n\n\t\t\t\t// ground\n\n\t\t\t\tconst groundMaterial = new THREE.MeshPhongMaterial( { color: 0x898989 } );\n\n\t\t\t\tconst ground = new THREE.Mesh( new THREE.PlaneGeometry( 20000, 20000, 8, 8 ), groundMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// column\n\n\t\t\t\tconst column = new THREE.Mesh( new THREE.BoxGeometry( 1, 4, 1 ), groundMaterial );\n\t\t\t\tcolumn.position.y = 2;\n\t\t\t\tcolumn.castShadow = true;\n\t\t\t\tcolumn.receiveShadow = true;\n\t\t\t\tscene.add( column );\n\n\t\t\t\t// overwrite shadowmap code\n\n\t\t\t\tlet shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n\n\t\t\t\tshader = shader.replace(\n\t\t\t\t\t'#ifdef USE_SHADOWMAP',\n\t\t\t\t\t'#ifdef USE_SHADOWMAP' +\n\t\t\t\t\tdocument.getElementById( 'PCSS' ).textContent\n\t\t\t\t);\n\n\t\t\t\tshader = shader.replace(\n\t\t\t\t\t'#if defined( SHADOWMAP_TYPE_PCF )',\n\t\t\t\t\tdocument.getElementById( 'PCSSGetShadow' ).textContent +\n\t\t\t\t\t'#if defined( SHADOWMAP_TYPE_PCF )'\n\t\t\t\t);\n\n\t\t\t\tTHREE.ShaderChunk.shadowmap_pars_fragment = shader;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setClearColor( scene.fog.color );\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.5;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 75;\n\t\t\t\tcontrols.target.set( 0, 2.5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// performance monitor\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 1000;\n\n\t\t\t\tgroup.traverse( function ( child ) {\n\n\t\t\t\t\tif ( 'phase' in child.userData ) {\n\n\t\t\t\t\t\tchild.position.y = Math.abs( Math.sin( time + child.userData.phase ) ) * 4 + 0.3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example Percent Closer Soft-Shadows (PCSS) by spidersharma03"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_lighting example that demonstrates webgl - progressive lightmap accumulation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - progressive lightmap accumulation:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\t\timport { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';\n\n\t\t\t// ShadowMap + LightMap Res and Number of Directional Lights\n\t\t\tconst shadowMapRes = 512, lightMapRes = 1024, lightCount = 8;\n\t\t\tlet camera, scene, renderer, controls, control, control2,\n\t\t\t\tobject = new THREE.Mesh(), lightOrigin = null, progressiveSurfacemap;\n\t\t\tconst dirLights = [], lightmapObjects = [];\n\t\t\tconst params = { 'Enable': true, 'Blur Edges': true, 'Blend Window': 200,\n\t\t\t\t\t\t\t 'Light Radius': 50, 'Ambient Weight': 0.5, 'Debug Lightmap': false };\n\t\t\tinit();\n\t\t\tcreateGUI();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 100, 200 );\n\t\t\t\tcamera.name = 'Camera';\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x949494 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x949494, 1000, 3000 );\n\n\t\t\t\t// progressive lightmap\n\t\t\t\tprogressiveSurfacemap = new ProgressiveLightMap( renderer, lightMapRes );\n\n\t\t\t\t// directional lighting \"origin\"\n\t\t\t\tlightOrigin = new THREE.Group();\n\t\t\t\tlightOrigin.position.set( 60, 150, 100 );\n\t\t\t\tscene.add( lightOrigin );\n\n\t\t\t\t// transform gizmo\n\t\t\t\tcontrol = new TransformControls( camera, renderer.domElement );\n\t\t\t\tcontrol.addEventListener( 'dragging-changed', ( event ) => {\n\n\t\t\t\t\tcontrols.enabled = ! event.value;\n\n\t\t\t\t} );\n\t\t\t\tcontrol.attach( lightOrigin );\n\t\t\t\tscene.add( control.getHelper() );\n\n\t\t\t\t// create 8 directional lights to speed up the convergence\n\t\t\t\tfor ( let l = 0; l < lightCount; l ++ ) {\n\n\t\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, Math.PI / lightCount );\n\t\t\t\t\tdirLight.name = 'Dir. Light ' + l;\n\t\t\t\t\tdirLight.position.set( 200, 200, 200 );\n\t\t\t\t\tdirLight.castShadow = true;\n\t\t\t\t\tdirLight.shadow.camera.near = 100;\n\t\t\t\t\tdirLight.shadow.camera.far = 5000;\n\t\t\t\t\tdirLight.shadow.camera.right = 150;\n\t\t\t\t\tdirLight.shadow.camera.left = - 150;\n\t\t\t\t\tdirLight.shadow.camera.top = 150;\n\t\t\t\t\tdirLight.shadow.camera.bottom = - 150;\n\t\t\t\t\tdirLight.shadow.mapSize.width = shadowMapRes;\n\t\t\t\t\tdirLight.shadow.mapSize.height = shadowMapRes;\n\t\t\t\t\tlightmapObjects.push( dirLight );\n\t\t\t\t\tdirLights.push( dirLight );\n\n\t\t\t\t}\n\n\t\t\t\t// ground\n\t\t\t\tconst groundMesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 600, 600 ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xffffff, depthWrite: true } )\n\t\t\t\t);\n\t\t\t\tgroundMesh.position.y = - 0.1;\n\t\t\t\tgroundMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tgroundMesh.name = 'Ground Mesh';\n\t\t\t\tlightmapObjects.push( groundMesh );\n\t\t\t\tscene.add( groundMesh );\n\n\t\t\t\t// model\n\t\t\t\tfunction loadModel() {\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tchild.name = 'Loaded Mesh';\n\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\t\t\t\t\t\t\tchild.material = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t\t\t// This adds the model to the lightmap\n\t\t\t\t\t\t\tlightmapObjects.push( child );\n\t\t\t\t\t\t\tprogressiveSurfacemap.addObjectsToLightMap( lightmapObjects );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tchild.layers.disableAll(); // Disable Rendering for this\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tscene.add( object );\n\t\t\t\t\tobject.scale.set( 2, 2, 2 );\n\t\t\t\t\tobject.position.set( 0, - 16, 0 );\n\t\t\t\t\tcontrol2 = new TransformControls( camera, renderer.domElement );\n\t\t\t\t\tcontrol2.addEventListener( 'dragging-changed', ( event ) => {\n\n\t\t\t\t\t\tcontrols.enabled = ! event.value;\n\n\t\t\t\t\t} );\n\t\t\t\t\tcontrol2.attach( object );\n\t\t\t\t\tscene.add( control2.getHelper() );\n\t\t\t\t\tconst lightTarget = new THREE.Group();\n\t\t\t\t\tlightTarget.position.set( 0, 20, 0 );\n\t\t\t\t\tfor ( let l = 0; l < dirLights.length; l ++ ) {\n\n\t\t\t\t\t\tdirLights[ l ].target = lightTarget;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.add( lightTarget );\n\n\t\t\t\t}\n\n\t\t\t\tconst manager = new THREE.LoadingManager( loadModel );\n\t\t\t\tconst loader = new GLTFLoader( manager );\n\t\t\t\tloader.load( 'models/gltf/ShadowmappableMesh.glb', function ( obj ) {\n\n\t\t\t\t\tobject = obj.scene.children[ 0 ];\n\n\t\t\t\t} );\n\n\t\t\t\t// controls\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\t\t\t\tcontrols.screenSpacePanning = true;\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 500;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.5;\n\t\t\t\tcontrols.target.set( 0, 100, 0 );\n\t\t\t\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tconst gui = new GUI( { title: 'Accumulation Settings' } );\n\t\t\t\tgui.add( params, 'Enable' );\n\t\t\t\tgui.add( params, 'Blur Edges' );\n\t\t\t\tgui.add( params, 'Blend Window', 1, 500 ).step( 1 );\n\t\t\t\tgui.add( params, 'Light Radius', 0, 200 ).step( 10 );\n\t\t\t\tgui.add( params, 'Ambient Weight', 0, 1 ).step( 0.1 );\n\t\t\t\tgui.add( params, 'Debug Lightmap' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Update the inertia on the orbit controls\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// Accumulate Surface Maps\n\t\t\t\tif ( params[ 'Enable' ] ) {\n\n\t\t\t\t\tprogressiveSurfacemap.update( camera, params[ 'Blend Window' ], params[ 'Blur Edges' ] );\n\n\t\t\t\t\tif ( ! progressiveSurfacemap.firstUpdate ) {\n\n\t\t\t\t\t\tprogressiveSurfacemap.showDebugLightmap( params[ 'Debug Lightmap' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Manually Update the Directional Lights\n\t\t\t\tfor ( let l = 0; l < dirLights.length; l ++ ) {\n\n\t\t\t\t\t// Sometimes they will be sampled from the target direction\n\t\t\t\t\t// Sometimes they will be uniformly sampled from the upper hemisphere\n\t\t\t\t\tif ( Math.random() > params[ 'Ambient Weight' ] ) {\n\n\t\t\t\t\t\tdirLights[ l ].position.set(\n\t\t\t\t\t\t\tlightOrigin.position.x + ( Math.random() * params[ 'Light Radius' ] ),\n\t\t\t\t\t\t\tlightOrigin.position.y + ( Math.random() * params[ 'Light Radius' ] ),\n\t\t\t\t\t\t\tlightOrigin.position.z + ( Math.random() * params[ 'Light Radius' ] ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Uniform Hemispherical Surface Distribution for Ambient Occlusion\n\t\t\t\t\t\tconst lambda = Math.acos( 2 * Math.random() - 1 ) - ( 3.14159 / 2.0 );\n\t\t\t\t\t\tconst phi = 2 * 3.14159 * Math.random();\n\t\t\t\t\t\tdirLights[ l ].position.set(\n\t\t\t\t\t\t\t        ( ( Math.cos( lambda ) * Math.cos( phi ) ) * 300 ) + object.position.x,\n\t\t\t\t\t\t\tMath.abs( ( Math.cos( lambda ) * Math.sin( phi ) ) * 300 ) + object.position.y + 20,\n\t\t\t\t\t\t\t          ( Math.sin( lambda ) * 300 ) + object.position.z\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Render Scene\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Progressive Lightmaps by zalo [Inspired by evanw's Lightmap Generation ]"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - simple global illumination"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - simple global illumination:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tclass GIMesh extends THREE.Mesh {\n\n\t\t\t\tcopy( source ) {\n\n\t\t\t\t\tsuper.copy( source );\n\n\t\t\t\t\tthis.geometry = source.geometry.clone();\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst SimpleGI = function ( renderer, scene ) {\n\n\t\t\t\tconst SIZE = 32, SIZE2 = SIZE * SIZE;\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 90, 1, 0.01, 100 );\n\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t\tlet clone = scene.clone();\n\t\t\t\tclone.matrixWorldAutoUpdate = false;\n\n\t\t\t\tconst rt = new THREE.WebGLRenderTarget( SIZE, SIZE );\n\n\t\t\t\tconst normalMatrix = new THREE.Matrix3();\n\n\t\t\t\tconst position = new THREE.Vector3();\n\t\t\t\tconst normal = new THREE.Vector3();\n\n\t\t\t\tlet bounces = 0;\n\t\t\t\tlet currentVertex = 0;\n\n\t\t\t\tconst color = new Float32Array( 3 );\n\t\t\t\tconst buffer = new Uint8Array( SIZE2 * 4 );\n\n\t\t\t\tfunction compute() {\n\n\t\t\t\t\tif ( bounces === 3 ) return;\n\n\t\t\t\t\tconst object = scene.children[ 0 ]; // torusKnot\n\t\t\t\t\tconst geometry = object.geometry;\n\n\t\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\t\tconst positions = attributes.position.array;\n\t\t\t\t\tconst normals = attributes.normal.array;\n\n\t\t\t\t\tif ( attributes.color === undefined ) {\n\n\t\t\t\t\t\tconst colors = new Float32Array( positions.length );\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst colors = attributes.color.array;\n\n\t\t\t\t\tconst startVertex = currentVertex;\n\t\t\t\t\tconst totalVertex = positions.length / 3;\n\n\t\t\t\t\tfor ( let i = 0; i < 32; i ++ ) {\n\n\t\t\t\t\t\tif ( currentVertex >= totalVertex ) break;\n\n\t\t\t\t\t\tposition.fromArray( positions, currentVertex * 3 );\n\t\t\t\t\t\tposition.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\t\tnormal.fromArray( normals, currentVertex * 3 );\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix.getNormalMatrix( object.matrixWorld ) ).normalize();\n\n\t\t\t\t\t\tcamera.position.copy( position );\n\t\t\t\t\t\tcamera.lookAt( position.add( normal ) );\n\n\t\t\t\t\t\trenderer.setRenderTarget( rt );\n\t\t\t\t\t\trenderer.render( clone, camera );\n\n\t\t\t\t\t\trenderer.readRenderTargetPixels( rt, 0, 0, SIZE, SIZE, buffer );\n\n\t\t\t\t\t\tcolor[ 0 ] = 0;\n\t\t\t\t\t\tcolor[ 1 ] = 0;\n\t\t\t\t\t\tcolor[ 2 ] = 0;\n\n\t\t\t\t\t\tfor ( let k = 0, kl = buffer.length; k < kl; k += 4 ) {\n\n\t\t\t\t\t\t\tcolor[ 0 ] += buffer[ k + 0 ];\n\t\t\t\t\t\t\tcolor[ 1 ] += buffer[ k + 1 ];\n\t\t\t\t\t\t\tcolor[ 2 ] += buffer[ k + 2 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolors[ currentVertex * 3 + 0 ] = color[ 0 ] / ( SIZE2 * 255 );\n\t\t\t\t\t\tcolors[ currentVertex * 3 + 1 ] = color[ 1 ] / ( SIZE2 * 255 );\n\t\t\t\t\t\tcolors[ currentVertex * 3 + 2 ] = color[ 2 ] / ( SIZE2 * 255 );\n\n\t\t\t\t\t\tcurrentVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tattributes.color.addUpdateRange( startVertex * 3, ( currentVertex - startVertex ) * 3 );\n\t\t\t\t\tattributes.color.needsUpdate = true;\n\n\t\t\t\t\tif ( currentVertex >= totalVertex ) {\n\n\t\t\t\t\t\tclone = scene.clone();\n\t\t\t\t\t\tclone.matrixWorldAutoUpdate = false;\n\n\t\t\t\t\t\tbounces ++;\n\t\t\t\t\t\tcurrentVertex = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trequestAnimationFrame( compute );\n\n\t\t\t\t}\n\n\t\t\t\trequestAnimationFrame( compute );\n\n\t\t\t};\n\n\t\t\t//\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// torus knot\n\n\t\t\t\tconst torusGeometry = new THREE.TorusKnotGeometry( 0.75, 0.3, 128, 32, 1 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { vertexColors: true } );\n\n\t\t\t\tconst torusKnot = new GIMesh( torusGeometry, material );\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\t// room\n\n\t\t\t\tconst materials = [];\n\n\t\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\t\tmaterials.push( new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, side: THREE.BackSide } ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 3, 3, 3 );\n\n\t\t\t\tconst box = new THREE.Mesh( boxGeometry, materials );\n\t\t\t\tscene.add( box );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tnew SimpleGI( renderer, scene );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - simple global illumination ( article )"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - 2D texture array"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 2D texture array:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { unzipSync } from 'three/addons/libs/fflate.module.js';\n\n\t\t\tlet camera, scene, mesh, renderer, stats;\n\n\t\t\tconst planeWidth = 50;\n\t\t\tconst planeHeight = 50;\n\n\t\t\tlet depthStep = 0.4;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.z = 70;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// width 256, height 256, depth 109, 8-bit, zip archived raw data\n\n\t\t\t\tnew THREE.FileLoader()\n\t\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t\t.load( 'textures/3d/head256x256x109.zip', function ( data ) {\n\n\t\t\t\t\t\tconst zip = unzipSync( new Uint8Array( data ) );\n\t\t\t\t\t\tconst array = new Uint8Array( zip[ 'head256x256x109' ].buffer );\n\n\t\t\t\t\t\tconst texture = new THREE.DataArrayTexture( array, 256, 256, 109 );\n\t\t\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\t\tdiffuse: { value: texture },\n\t\t\t\t\t\t\t\tdepth: { value: 55 },\n\t\t\t\t\t\t\t\tsize: { value: new THREE.Vector2( planeWidth, planeHeight ) }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvertexShader: document.getElementById( 'vs' ).textContent.trim(),\n\t\t\t\t\t\t\tfragmentShader: document.getElementById( 'fs' ).textContent.trim(),\n\t\t\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t} );\n\n\t\t\t\t// 2D Texture array is available on WebGL 2.0\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tlet value = mesh.material.uniforms[ 'depth' ].value;\n\n\t\t\t\t\tvalue += depthStep;\n\n\t\t\t\t\tif ( value > 109.0 || value < 0.0 ) {\n\n\t\t\t\t\t\tif ( value > 1.0 ) value = 109.0 * 2.0 - value;\n\t\t\t\t\t\tif ( value < 0.0 ) value = - value;\n\n\t\t\t\t\t\tdepthStep = - depthStep;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.material.uniforms[ 'depth' ].value = value;\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 2D Texture array Scanned head data by Divine Augustine licensed under CPOL"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - 2D compressed texture array"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 2D compressed texture array:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\n\t\t\tlet camera, scene, mesh, renderer, stats, clock;\n\n\t\t\tconst planeWidth = 50;\n\t\t\tconst planeHeight = 25;\n\n\t\t\tlet depthStep = 1;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.z = 70;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst ktx2Loader = new KTX2Loader();\n\t\t\t\tktx2Loader.setTranscoderPath( 'jsm/libs/basis/' );\n\t\t\t\tktx2Loader.detectSupport( renderer );\n\n\t\t\t\tktx2Loader.load( 'textures/spiritedaway.ktx2', function ( texturearray ) {\n\n\t\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\tdiffuse: { value: texturearray },\n\t\t\t\t\t\t\tdepth: { value: 55 },\n\t\t\t\t\t\t\tsize: { value: new THREE.Vector2( planeWidth, planeHeight ) }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvertexShader: document.getElementById( 'vs' ).textContent.trim(),\n\t\t\t\t\t\tfragmentShader: document.getElementById( 'fs' ).textContent.trim(),\n\t\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tconst delta = clock.getDelta() * 10;\n\n\t\t\t\t\tdepthStep += delta;\n\n\t\t\t\t\tconst value = depthStep % 5;\n\n\t\t\t\t\tmesh.material.uniforms[ 'depth' ].value = value;\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 2D Compressed Texture Array Loop from the movie Spirited away by the Studio Ghibli"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - texture array layer update"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - texture array layer update:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\n\t\t\tlet camera, scene, mesh, renderer;\n\n\t\t\tconst planeWidth = 20;\n\t\t\tconst planeHeight = 10;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.z = 70;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Configure the renderer.\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// Configure the KTX2 loader.\n\n\t\t\t\tconst ktx2Loader = new KTX2Loader();\n\t\t\t\tktx2Loader.setTranscoderPath( 'jsm/libs/basis/' );\n\t\t\t\tktx2Loader.detectSupport( renderer );\n\n\t\t\t\t// Load several KTX2 textures which will later be used to modify\n\t\t\t\t// specific texture array layers.\n\n\t\t\t\tconst spiritedaway = await ktx2Loader.loadAsync( 'textures/spiritedaway.ktx2' );\n\n\t\t\t\t// Create a texture array for rendering.\n\n\t\t\t\tconst layerByteLength = THREE.TextureUtils.getByteLength(\n\t\t\t\t\tspiritedaway.image.width,\n\t\t\t\t\tspiritedaway.image.height,\n\t\t\t\t\tspiritedaway.format,\n\t\t\t\t\tspiritedaway.type,\n\t\t\t\t);\n\n\t\t\t\tconst textureArray = new THREE.CompressedArrayTexture( [\n\t\t\t\t\t{\n\t\t\t\t\t\tdata: new Uint8Array( layerByteLength * 3 ),\n\t\t\t\t\t\twidth: spiritedaway.image.width,\n\t\t\t\t\t\theight: spiritedaway.image.height,\n\t\t\t\t\t}\n\t\t\t\t], spiritedaway.image.width, spiritedaway.image.height, 3, spiritedaway.format, spiritedaway.type );\n\n\t\t\t\t// Setup the GUI\n\n\t\t\t\tconst formData = {\n\t\t\t\t\tsrcLayer: 0,\n\t\t\t\t\tdestLayer: 0,\n\t\t\t\t\ttransfer() {\n\n\t\t\t\t\t\tconst layerElementLength = layerByteLength / spiritedaway.mipmaps[ 0 ].data.BYTES_PER_ELEMENT;\n\t\t\t\t\t\ttextureArray.mipmaps[ 0 ].data.set(\n\t\t\t\t\t\t\tspiritedaway.mipmaps[ 0 ].data.subarray(\n\t\t\t\t\t\t\t\tlayerElementLength * ( formData.srcLayer % spiritedaway.image.depth ),\n\t\t\t\t\t\t\t\tlayerElementLength * ( ( formData.srcLayer % spiritedaway.image.depth ) + 1 ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tlayerByteLength * formData.destLayer,\n\t\t\t\t\t\t);\n\t\t\t\t\t\ttextureArray.addLayerUpdate( formData.destLayer );\n\t\t\t\t\t\ttextureArray.needsUpdate = true;\n\n\t\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( formData, 'srcLayer', 0, spiritedaway.image.depth - 1, 1 );\n\t\t\t\tgui.add( formData, 'destLayer', 0, textureArray.image.depth - 1, 1 );\n\t\t\t\tgui.add( formData, 'transfer' );\n\n\t\t\t\t/// Setup the scene.\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tdiffuse: { value: textureArray },\n\t\t\t\t\t\tsize: { value: new THREE.Vector2( planeWidth, planeHeight ) }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vs' ).textContent.trim(),\n\t\t\t\t\tfragmentShader: document.getElementById( 'fs' ).textContent.trim(),\n\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t} );\n\n\t\t\t\tconst geometry = new THREE.InstancedBufferGeometry();\n\t\t\t\tgeometry.copy( new THREE.PlaneGeometry( planeWidth, planeHeight ) );\n\t\t\t\tgeometry.instanceCount = 3;\n\n\t\t\t\tconst instancedIndexAttribute = new THREE.InstancedBufferAttribute(\n\t\t\t\t\tnew Uint16Array( [ 0, 1, 2 ] ), 1, false, 1\n\t\t\t\t);\n\t\t\t\tinstancedIndexAttribute.gpuType = THREE.IntType;\n\t\t\t\tgeometry.setAttribute( 'instancedIndex', instancedIndexAttribute );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, 3 );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// Initialize the texture array by first rendering the spirited away\n\t\t\t\t// frames in order.\n\n\t\t\t\ttextureArray.mipmaps[ 0 ].data.set(\n\t\t\t\t\tspiritedaway.mipmaps[ 0 ].data.subarray( 0, textureArray.mipmaps[ 0 ].data.length )\n\t\t\t\t);\n\t\t\t\ttextureArray.needsUpdate = true;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 2D Compressed Texture Array Layer Updates Loop from the movie Spirited away by the Studio Ghibli"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - volume rendering example"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - volume rendering example:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { NRRDLoader } from 'three/addons/loaders/NRRDLoader.js';\n\t\timport { VolumeRenderShader1 } from 'three/addons/shaders/VolumeShader.js';\n\n\t\tlet renderer,\n\t\t\tscene,\n\t\t\tcamera,\n\t\t\tcontrols,\n\t\t\tmaterial,\n\t\t\tvolconfig,\n\t\t\tcmtextures;\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tscene = new THREE.Scene();\n\n\t\t\t// Create renderer\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t// Create camera (The volume renderer does not work very well with perspective yet)\n\t\t\tconst h = 512; // frustum height\n\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera = new THREE.OrthographicCamera( - h * aspect / 2, h * aspect / 2, h / 2, - h / 2, 1, 1000 );\n\t\t\tcamera.position.set( - 64, - 64, 128 );\n\t\t\tcamera.up.set( 0, 0, 1 ); // In our data, z is up\n\n\t\t\t// Create controls\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\tcontrols.target.set( 64, 64, 128 );\n\t\t\tcontrols.minZoom = 0.5;\n\t\t\tcontrols.maxZoom = 4;\n\t\t\tcontrols.enablePan = false;\n\t\t\tcontrols.update();\n\n\t\t\t// scene.add( new AxesHelper( 128 ) );\n\n\t\t\t// Lighting is baked into the shader a.t.m.\n\t\t\t// let dirLight = new DirectionalLight( 0xffffff );\n\n\t\t\t// The gui for interaction\n\t\t\tvolconfig = { clim1: 0, clim2: 1, renderstyle: 'iso', isothreshold: 0.15, colormap: 'viridis' };\n\t\t\tconst gui = new GUI();\n\t\t\tgui.add( volconfig, 'clim1', 0, 1, 0.01 ).onChange( updateUniforms );\n\t\t\tgui.add( volconfig, 'clim2', 0, 1, 0.01 ).onChange( updateUniforms );\n\t\t\tgui.add( volconfig, 'colormap', { gray: 'gray', viridis: 'viridis' } ).onChange( updateUniforms );\n\t\t\tgui.add( volconfig, 'renderstyle', { mip: 'mip', iso: 'iso' } ).onChange( updateUniforms );\n\t\t\tgui.add( volconfig, 'isothreshold', 0, 1, 0.01 ).onChange( updateUniforms );\n\n\t\t\t// Load the data ...\n\t\t\tnew NRRDLoader().load( 'models/nrrd/stent.nrrd', function ( volume ) {\n\n\t\t\t\t// Texture to hold the volume. We have scalars, so we put our data in the red channel.\n\t\t\t\t// THREEJS will select R32F (33326) based on the THREE.RedFormat and THREE.FloatType.\n\t\t\t\t// Also see https://www.khronos.org/registry/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE\n\t\t\t\t// TODO: look the dtype up in the volume metadata\n\t\t\t\tconst texture = new THREE.Data3DTexture( volume.data, volume.xLength, volume.yLength, volume.zLength );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.type = THREE.FloatType;\n\t\t\t\ttexture.minFilter = texture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// Colormap textures\n\t\t\t\tcmtextures = {\n\t\t\t\t\tviridis: new THREE.TextureLoader().load( 'textures/cm_viridis.png', render ),\n\t\t\t\t\tgray: new THREE.TextureLoader().load( 'textures/cm_gray.png', render )\n\t\t\t\t};\n\n\t\t\t\t// Material\n\t\t\t\tconst shader = VolumeRenderShader1;\n\n\t\t\t\tconst uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\tuniforms[ 'u_data' ].value = texture;\n\t\t\t\tuniforms[ 'u_size' ].value.set( volume.xLength, volume.yLength, volume.zLength );\n\t\t\t\tuniforms[ 'u_clim' ].value.set( volconfig.clim1, volconfig.clim2 );\n\t\t\t\tuniforms[ 'u_renderstyle' ].value = volconfig.renderstyle == 'mip' ? 0 : 1; // 0: MIP, 1: ISO\n\t\t\t\tuniforms[ 'u_renderthreshold' ].value = volconfig.isothreshold; // For ISO renderstyle\n\t\t\t\tuniforms[ 'u_cmdata' ].value = cmtextures[ volconfig.colormap ];\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( {\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\t\tside: THREE.BackSide // The volume shader uses the backface as its \"reference point\"\n\t\t\t\t} );\n\n\t\t\t\t// THREE.Mesh\n\t\t\t\tconst geometry = new THREE.BoxGeometry( volume.xLength, volume.yLength, volume.zLength );\n\t\t\t\tgeometry.translate( volume.xLength / 2 - 0.5, volume.yLength / 2 - 0.5, volume.zLength / 2 - 0.5 );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trender();\n\n\t\t\t} );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction updateUniforms() {\n\n\t\t\tmaterial.uniforms[ 'u_clim' ].value.set( volconfig.clim1, volconfig.clim2 );\n\t\t\tmaterial.uniforms[ 'u_renderstyle' ].value = volconfig.renderstyle == 'mip' ? 0 : 1; // 0: MIP, 1: ISO\n\t\t\tmaterial.uniforms[ 'u_renderthreshold' ].value = volconfig.isothreshold; // For ISO renderstyle\n\t\t\tmaterial.uniforms[ 'u_cmdata' ].value = cmtextures[ volconfig.colormap ];\n\n\t\t\trender();\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trender();\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js - Float volume render test (mip / isosurface)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl2 - volume - cloud"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl2 - volume - cloud:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst INITIAL_CLOUD_SIZE = 128;\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet mesh;\n\t\t\tlet prevTime = performance.now();\n\t\t\tlet cloudTexture = null;\n\n\t\t\tinit();\n\n\t\t\tfunction generateCloudTexture( size, scaleFactor = 1.0 ) {\n\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\t\t\t\tconst scale = scaleFactor * 10.0 / size;\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tconst dist = vector.set( x, y, z ).subScalar( size / 2 ).divideScalar( size ).length();\n\t\t\t\t\t\t\tconst fadingFactor = ( 1.0 - dist ) * ( 1.0 - dist );\n\t\t\t\t\t\t\tdata[ i ] = ( 128 + 128 * perlin.noise( x * scale / 1.5, y * scale, z * scale / 1.5 ) ) * fadingFactor;\n\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.Data3DTexture( data, size, size, size );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 1.5 );\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t// Sky\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 1;\n\t\t\t\tcanvas.height = 32;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tconst gradient = context.createLinearGradient( 0, 0, 0, 32 );\n\t\t\t\tgradient.addColorStop( 0.0, '#014a84' );\n\t\t\t\tgradient.addColorStop( 0.5, '#0561a0' );\n\t\t\t\tgradient.addColorStop( 1.0, '#437ab6' );\n\t\t\t\tcontext.fillStyle = gradient;\n\t\t\t\tcontext.fillRect( 0, 0, 1, 32 );\n\n\t\t\t\tconst skyMap = new THREE.CanvasTexture( canvas );\n\t\t\t\tskyMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst sky = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 10 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { map: skyMap, side: THREE.BackSide } )\n\t\t\t\t);\n\t\t\t\tscene.add( sky );\n\n\t\t\t\t// Texture\n\n\t\t\t\tconst texture = new THREE.Data3DTexture(\n\t\t\t\t\tnew Uint8Array( INITIAL_CLOUD_SIZE * INITIAL_CLOUD_SIZE * INITIAL_CLOUD_SIZE ).fill( 0 ),\n\t\t\t\t\tINITIAL_CLOUD_SIZE,\n\t\t\t\t\tINITIAL_CLOUD_SIZE,\n\t\t\t\t\tINITIAL_CLOUD_SIZE\n\t\t\t\t);\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tcloudTexture = texture;\n\n\t\t\t\t// Material\n\n\t\t\t\tconst vertexShader = /* glsl */`\n\t\t\t\t\tin vec3 position;\n\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\t\t\t\t\tuniform vec3 cameraPos;\n\n\t\t\t\t\tout vec3 vOrigin;\n\t\t\t\t\tout vec3 vDirection;\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\tvOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;\n\t\t\t\t\t\tvDirection = position - vOrigin;\n\n\t\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst fragmentShader = /* glsl */`\n\t\t\t\t\tprecision highp float;\n\t\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t\t\tin vec3 vOrigin;\n\t\t\t\t\tin vec3 vDirection;\n\n\t\t\t\t\tout vec4 color;\n\n\t\t\t\t\tuniform vec3 base;\n\t\t\t\t\tuniform sampler3D map;\n\n\t\t\t\t\tuniform float threshold;\n\t\t\t\t\tuniform float range;\n\t\t\t\t\tuniform float opacity;\n\t\t\t\t\tuniform float steps;\n\t\t\t\t\tuniform float frame;\n\n\t\t\t\t\tuint wang_hash(uint seed)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tseed = (seed ^ 61u) ^ (seed >> 16u);\n\t\t\t\t\t\t\tseed *= 9u;\n\t\t\t\t\t\t\tseed = seed ^ (seed >> 4u);\n\t\t\t\t\t\t\tseed *= 0x27d4eb2du;\n\t\t\t\t\t\t\tseed = seed ^ (seed >> 15u);\n\t\t\t\t\t\t\treturn seed;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat randomFloat(inout uint seed)\n\t\t\t\t\t{\n\t\t\t\t\t\t\treturn float(wang_hash(seed)) / 4294967296.;\n\t\t\t\t\t}\n\n\t\t\t\t\tvec2 hitBox( vec3 orig, vec3 dir ) {\n\t\t\t\t\t\tconst vec3 box_min = vec3( - 0.5 );\n\t\t\t\t\t\tconst vec3 box_max = vec3( 0.5 );\n\t\t\t\t\t\tvec3 inv_dir = 1.0 / dir;\n\t\t\t\t\t\tvec3 tmin_tmp = ( box_min - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmax_tmp = ( box_max - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmin = min( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tvec3 tmax = max( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\t\t\t\t\t\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\t\t\t\t\t\treturn vec2( t0, t1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat sample1( vec3 p ) {\n\t\t\t\t\t\treturn texture( map, p ).r;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat shading( vec3 coord ) {\n\t\t\t\t\t\tfloat step = 0.01;\n\t\t\t\t\t\treturn sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tvec4 linearToSRGB( in vec4 value ) {\n\t\t\t\t\t\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid main(){\n\t\t\t\t\t\tvec3 rayDir = normalize( vDirection );\n\t\t\t\t\t\tvec2 bounds = hitBox( vOrigin, rayDir );\n\n\t\t\t\t\t\tif ( bounds.x > bounds.y ) discard;\n\n\t\t\t\t\t\tbounds.x = max( bounds.x, 0.0 );\n\n\t\t\t\t\t\tvec3 p = vOrigin + bounds.x * rayDir;\n\t\t\t\t\t\tvec3 inc = 1.0 / abs( rayDir );\n\t\t\t\t\t\tfloat delta = min( inc.x, min( inc.y, inc.z ) );\n\t\t\t\t\t\tdelta /= steps;\n\n\t\t\t\t\t\t// Jitter\n\n\t\t\t\t\t\t// Nice little seed from\n\t\t\t\t\t\t// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n\t\t\t\t\t\tuint seed = uint( gl_FragCoord.x ) * uint( 1973 ) + uint( gl_FragCoord.y ) * uint( 9277 ) + uint( frame ) * uint( 26699 );\n\t\t\t\t\t\tvec3 size = vec3( textureSize( map, 0 ) );\n\t\t\t\t\t\tfloat randNum = randomFloat( seed ) * 2.0 - 1.0;\n\t\t\t\t\t\tp += rayDir * randNum * ( 1.0 / size );\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tvec4 ac = vec4( base, 0.0 );\n\n\t\t\t\t\t\tfor ( float t = bounds.x; t < bounds.y; t += delta ) {\n\n\t\t\t\t\t\t\tfloat d = sample1( p + 0.5 );\n\n\t\t\t\t\t\t\td = smoothstep( threshold - range, threshold + range, d ) * opacity;\n\n\t\t\t\t\t\t\tfloat col = shading( p + 0.5 ) * 3.0 + ( ( p.x + p.y ) * 0.25 ) + 0.2;\n\n\t\t\t\t\t\t\tac.rgb += ( 1.0 - ac.a ) * d * col;\n\n\t\t\t\t\t\t\tac.a += ( 1.0 - ac.a ) * d;\n\n\t\t\t\t\t\t\tif ( ac.a >= 0.95 ) break;\n\n\t\t\t\t\t\t\tp += rayDir * delta;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolor = linearToSRGB( ac );\n\n\t\t\t\t\t\tif ( color.a == 0.0 ) discard;\n\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\t\t\t\t\tglslVersion: THREE.GLSL3,\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tbase: { value: new THREE.Color( 0x798aa0 ) },\n\t\t\t\t\t\tmap: { value: texture },\n\t\t\t\t\t\tcameraPos: { value: new THREE.Vector3() },\n\t\t\t\t\t\tthreshold: { value: 0.25 },\n\t\t\t\t\t\topacity: { value: 0.25 },\n\t\t\t\t\t\trange: { value: 0.1 },\n\t\t\t\t\t\tsteps: { value: 100 },\n\t\t\t\t\t\tframe: { value: 0 }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader,\n\t\t\t\t\tfragmentShader,\n\t\t\t\t\tside: THREE.BackSide,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst parameters = {\n\t\t\t\t\tthreshold: 0.25,\n\t\t\t\t\topacity: 0.25,\n\t\t\t\t\trange: 0.1,\n\t\t\t\t\tsteps: 100\n\t\t\t\t};\n\n\t\t\t\tfunction update() {\n\n\t\t\t\t\tmaterial.uniforms.threshold.value = parameters.threshold;\n\t\t\t\t\tmaterial.uniforms.opacity.value = parameters.opacity;\n\t\t\t\t\tmaterial.uniforms.range.value = parameters.range;\n\t\t\t\t\tmaterial.uniforms.steps.value = parameters.steps;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( parameters, 'threshold', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'opacity', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'range', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'steps', 0, 200, 1 ).onChange( update );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tlet curr = 0;\n\t\t\tconst countPerRow = 4;\n\t\t\tconst countPerSlice = countPerRow * countPerRow;\n\t\t\tconst sliceCount = 4;\n\t\t\tconst totalCount = sliceCount * countPerSlice;\n\t\t\tconst margins = 8;\n\n\t\t\tconst perElementPaddedSize = ( INITIAL_CLOUD_SIZE - margins ) / countPerRow;\n\t\t\tconst perElementSize = Math.floor( ( INITIAL_CLOUD_SIZE - 1 ) / countPerRow );\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now();\n\t\t\t\tif ( time - prevTime > 1500.0 && curr < totalCount ) {\n\n\t\t\t\t\tconst position = new THREE.Vector3(\n\t\t\t\t\t\tMath.floor( curr % countPerRow ) * perElementSize + margins * 0.5,\n\t\t\t\t\t\t( Math.floor( ( ( curr % countPerSlice ) / countPerRow ) ) ) * perElementSize + margins * 0.5,\n\t\t\t\t\t\tMath.floor( curr / countPerSlice ) * perElementSize + margins * 0.5\n\t\t\t\t\t).floor();\n\n\t\t\t\t\tconst maxDimension = perElementPaddedSize - 1;\n\t\t\t\t\tconst box = new THREE.Box3( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( maxDimension, maxDimension, maxDimension ) );\n\t\t\t\t\tconst scaleFactor = ( Math.random() + 0.5 ) * 0.5;\n\t\t\t\t\tconst source = generateCloudTexture( perElementPaddedSize, scaleFactor );\n\n\t\t\t\t\trenderer.copyTextureToTexture( source, cloudTexture, box, position );\n\n\t\t\t\t\tprevTime = time;\n\n\t\t\t\t\tcurr ++;\n\n\t\t\t\t}\n\n\t\t\t\tmesh.material.uniforms.cameraPos.value.copy( camera.position );\n\t\t\t\t// mesh.rotation.y = - performance.now() / 7500;\n\n\t\t\t\tmesh.material.uniforms.frame.value ++;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl2 - volume - cloud"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates WebGL 2 - Uniform Buffer Objects"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL 2 - Uniform Buffer Objects:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 25 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst geometry1 = new THREE.TetrahedronGeometry();\n\t\t\t\tconst geometry2 = new THREE.BoxGeometry();\n\n\t\t\t\t// texture\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/crate.gif' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// uniforms groups\n\n\t\t\t\t// Camera and lighting related data are perfect examples of using UBOs since you have to store these\n\t\t\t\t// data just once. They can be shared across all shader programs.\n\n\t\t\t\tconst cameraUniformsGroup = new THREE.UniformsGroup();\n\t\t\t\tcameraUniformsGroup.setName( 'ViewData' );\n\t\t\t\tcameraUniformsGroup.add( new THREE.Uniform( camera.projectionMatrix ) ); // projection matrix\n\t\t\t\tcameraUniformsGroup.add( new THREE.Uniform( camera.matrixWorldInverse ) ); // view matrix\n\n\t\t\t\tconst lightingUniformsGroup = new THREE.UniformsGroup();\n\t\t\t\tlightingUniformsGroup.setName( 'LightingData' );\n\t\t\t\tlightingUniformsGroup.add( new THREE.Uniform( new THREE.Vector3( 0, 0, 10 ) ) ); // light position\n\t\t\t\tlightingUniformsGroup.add( new THREE.Uniform( new THREE.Color( 0x7c7c7c ) ) ); // ambient color\n\t\t\t\tlightingUniformsGroup.add( new THREE.Uniform( new THREE.Color( 0xd5d5d5 ) ) ); // diffuse color\n\t\t\t\tlightingUniformsGroup.add( new THREE.Uniform( new THREE.Color( 0xe7e7e7 ) ) ); // specular color\n\t\t\t\tlightingUniformsGroup.add( new THREE.Uniform( 64 ) ); // shininess\n\n\t\t\t\t// materials\n\n\t\t\t\tconst material1 = new THREE.RawShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tmodelMatrix: { value: null },\n\t\t\t\t\t\tnormalMatrix: { value: null },\n\t\t\t\t\t\tcolor: { value: null }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader1' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader1' ).textContent,\n\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t} );\n\n\t\t\t\tconst material2 = new THREE.RawShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tmodelMatrix: { value: null },\n\t\t\t\t\t\tdiffuseMap: { value: null },\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader2' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader2' ).textContent,\n\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t} );\n\n\t\t\t\t// meshes\n\n\t\t\t\tfor ( let i = 0; i < 200; i ++ ) {\n\n\t\t\t\t\tlet mesh;\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry1, material1.clone() );\n\n\t\t\t\t\t\tmesh.material.uniformsGroups = [ cameraUniformsGroup, lightingUniformsGroup ];\n\t\t\t\t\t\tmesh.material.uniforms.modelMatrix.value = mesh.matrixWorld;\n\t\t\t\t\t\tmesh.material.uniforms.normalMatrix.value = mesh.normalMatrix;\n\t\t\t\t\t\tmesh.material.uniforms.color.value = new THREE.Color( 0xffffff * Math.random() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry2, material2.clone() );\n\n\t\t\t\t\t\tmesh.material.uniformsGroups = [ cameraUniformsGroup, lightingUniformsGroup ];\n\t\t\t\t\t\tmesh.material.uniforms.modelMatrix.value = mesh.matrixWorld;\n\t\t\t\t\t\tmesh.material.uniforms.diffuseMap.value = texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tconst s = 1 + Math.random() * 0.5;\n\n\t\t\t\t\tmesh.scale.x = s;\n\t\t\t\t\tmesh.scale.y = s;\n\t\t\t\t\tmesh.scale.z = s;\n\n\t\t\t\t\tmesh.rotation.x = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.y = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.z = Math.random() * Math.PI;\n\n\t\t\t\t\tmesh.position.x = Math.random() * 40 - 20;\n\t\t\t\t\tmesh.position.y = Math.random() * 40 - 20;\n\t\t\t\t\tmesh.position.z = Math.random() * 20 - 10;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tchild.rotation.x += delta * 0.5;\n\t\t\t\t\t\tchild.rotation.y += delta * 0.3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Uniform Buffer Objects"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates WebGL 2 - Uniform Buffer Objects Arrays"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js WebGL 2 - Uniform Buffer Objects Arrays:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, clock, stats;\n\n\t\t\tlet lightingUniformsGroup, lightCenters;\n\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tconst pointLightsMax = 300;\n\n\t\t\tconst api = {\n\t\t\t\tcount: 200,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 50, 50 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry();\n\n\t\t\t\t// uniforms groups\n\n\t\t\t\tlightingUniformsGroup = new THREE.UniformsGroup();\n\t\t\t\tlightingUniformsGroup.setName( 'LightingData' );\n\n\t\t\t\tconst data = [];\n\t\t\t\tconst dataColors = [];\n\t\t\t\tlightCenters = [];\n\n\t\t\t\tfor ( let i = 0; i < pointLightsMax; i ++ ) {\n\n\t\t\t\t\tconst col = new THREE.Color( 0xffffff * Math.random() ).toArray();\n\t\t\t\t\tconst x = Math.random() * 50 - 25;\n\t\t\t\t\tconst z = Math.random() * 50 - 25;\n\n\t\t\t\t\tdata.push( new THREE.Uniform( new THREE.Vector4( x, 1, z, 0 ) ) ); // light position\n\t\t\t\t\tdataColors.push( new THREE.Uniform( new THREE.Vector4( col[ 0 ], col[ 1 ], col[ 2 ], 0 ) ) ); // light color\n\n\t\t\t\t\t// Store the center positions\n\t\t\t\t\tlightCenters.push( { x, z } );\n\n\t\t\t\t}\n\n\t\t\t\tlightingUniformsGroup.add( data ); // light position\n\t\t\t\tlightingUniformsGroup.add( dataColors ); // light position\n\t\t\t\tlightingUniformsGroup.add( new THREE.Uniform( pointLightsMax ) ); // light position\n\n\t\t\t\tconst cameraUniformsGroup = new THREE.UniformsGroup();\n\t\t\t\tcameraUniformsGroup.setName( 'ViewData' );\n\t\t\t\tcameraUniformsGroup.add( new THREE.Uniform( camera.projectionMatrix ) ); // projection matrix\n\t\t\t\tcameraUniformsGroup.add( new THREE.Uniform( camera.matrixWorldInverse ) ); // view matrix\n\n\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tmodelMatrix: { value: null },\n\t\t\t\t\t\tnormalMatrix: { value: null }\n\t\t\t\t\t},\n\t\t\t\t\t// uniformsGroups: [ cameraUniformsGroup, lightingUniformsGroup ],\n\t\t\t\t\tname: 'Box',\n\t\t\t\t\tdefines: {\n\t\t\t\t\t\tPOINTLIGHTS_MAX: pointLightsMax\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent,\n\t\t\t\t\tglslVersion: THREE.GLSL3\n\t\t\t\t} );\n\n\t\t\t\tconst plane = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), material.clone() );\n\t\t\t\tplane.material.uniformsGroups = [ cameraUniformsGroup, lightingUniformsGroup ];\n\t\t\t\tplane.material.uniforms.modelMatrix.value = plane.matrixWorld;\n\t\t\t\tplane.material.uniforms.normalMatrix.value = plane.normalMatrix;\n\t\t\t\tplane.rotation.x = - Math.PI / 2;\n\t\t\t\tplane.position.y = - 1;\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// meshes\n\t\t\t\tconst gridSize = { x: 10, y: 1, z: 10 };\n\t\t\t\tconst spacing = 6;\n\n\t\t\t\tfor ( let i = 0; i < gridSize.x; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < gridSize.y; j ++ ) {\n\n\t\t\t\t\t\tfor ( let k = 0; k < gridSize.z; k ++ ) {\n\n\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material.clone() );\n\t\t\t\t\t\t\tmesh.name = 'Sphere';\n\t\t\t\t\t\t\tmesh.material.uniformsGroups = [ cameraUniformsGroup, lightingUniformsGroup ];\n\t\t\t\t\t\t\tmesh.material.uniforms.modelMatrix.value = mesh.matrixWorld;\n\t\t\t\t\t\t\tmesh.material.uniforms.normalMatrix.value = mesh.normalMatrix;\n\t\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\t\tmesh.position.x = i * spacing - ( gridSize.x * spacing ) / 2;\n\t\t\t\t\t\t\tmesh.position.y = 0;\n\t\t\t\t\t\t\tmesh.position.z = k * spacing - ( gridSize.z * spacing ) / 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t\t// controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// gui\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( api, 'count', 1, pointLightsMax ).step( 1 ).onChange( function () {\n\n\t\t\t\t\tlightingUniformsGroup.uniforms[ 2 ].value = api.count;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst elapsedTime = clock.getElapsedTime();\n\n\t\t\t\tconst lights = lightingUniformsGroup.uniforms[ 0 ];\n\t\t\t\n\t\t\t\t// Parameters for circular movement\n\t\t\t\tconst radius = 5; // Smaller radius for individual circular movements\n\t\t\t\tconst speed = 0.5; // Speed of rotation\n\n\t\t\t\t// Update each light's position\n\t\t\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\t\t\tconst light = lights[ i ];\n\t\t\t\t\tconst center = lightCenters[ i ];\n\n\t\t\t\t\t// Calculate circular movement around the light's center\n\t\t\t\t\tconst angle = speed * elapsedTime + i * 0.5; // Phase difference for each light\n\t\t\t\t\tconst x = center.x + Math.sin( angle ) * radius;\n\t\t\t\t\tconst z = center.z + Math.cos( angle ) * radius;\n\n\t\t\t\t\t// Update the light's position\n\t\t\t\t\tlight.value.set( x, 1, z, 0 );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Uniform Buffer Objects Arrays"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl2 - volume - cloud"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl2 - volume - cloud:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 1.5 );\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t// Sky\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 1;\n\t\t\t\tcanvas.height = 32;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tconst gradient = context.createLinearGradient( 0, 0, 0, 32 );\n\t\t\t\tgradient.addColorStop( 0.0, '#014a84' );\n\t\t\t\tgradient.addColorStop( 0.5, '#0561a0' );\n\t\t\t\tgradient.addColorStop( 1.0, '#437ab6' );\n\t\t\t\tcontext.fillStyle = gradient;\n\t\t\t\tcontext.fillRect( 0, 0, 1, 32 );\n\n\t\t\t\tconst skyMap = new THREE.CanvasTexture( canvas );\n\t\t\t\tskyMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst sky = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 10 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { map: skyMap, side: THREE.BackSide } )\n\t\t\t\t);\n\t\t\t\tscene.add( sky );\n\n\t\t\t\t// Texture\n\n\t\t\t\tconst size = 128;\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst scale = 0.05;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tconst d = 1.0 - vector.set( x, y, z ).subScalar( size / 2 ).divideScalar( size ).length();\n\t\t\t\t\t\t\tdata[ i ] = ( 128 + 128 * perlin.noise( x * scale / 1.5, y * scale, z * scale / 1.5 ) ) * d * d;\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// Material\n\n\t\t\t\tconst vertexShader = /* glsl */`\n\t\t\t\t\tin vec3 position;\n\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\t\t\t\t\tuniform vec3 cameraPos;\n\n\t\t\t\t\tout vec3 vOrigin;\n\t\t\t\t\tout vec3 vDirection;\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\tvOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;\n\t\t\t\t\t\tvDirection = position - vOrigin;\n\n\t\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst fragmentShader = /* glsl */`\n\t\t\t\t\tprecision highp float;\n\t\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t\t\tin vec3 vOrigin;\n\t\t\t\t\tin vec3 vDirection;\n\n\t\t\t\t\tout vec4 color;\n\n\t\t\t\t\tuniform vec3 base;\n\t\t\t\t\tuniform sampler3D map;\n\n\t\t\t\t\tuniform float threshold;\n\t\t\t\t\tuniform float range;\n\t\t\t\t\tuniform float opacity;\n\t\t\t\t\tuniform float steps;\n\t\t\t\t\tuniform float frame;\n\n\t\t\t\t\tuint wang_hash(uint seed)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tseed = (seed ^ 61u) ^ (seed >> 16u);\n\t\t\t\t\t\t\tseed *= 9u;\n\t\t\t\t\t\t\tseed = seed ^ (seed >> 4u);\n\t\t\t\t\t\t\tseed *= 0x27d4eb2du;\n\t\t\t\t\t\t\tseed = seed ^ (seed >> 15u);\n\t\t\t\t\t\t\treturn seed;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat randomFloat(inout uint seed)\n\t\t\t\t\t{\n\t\t\t\t\t\t\treturn float(wang_hash(seed)) / 4294967296.;\n\t\t\t\t\t}\n\n\t\t\t\t\tvec2 hitBox( vec3 orig, vec3 dir ) {\n\t\t\t\t\t\tconst vec3 box_min = vec3( - 0.5 );\n\t\t\t\t\t\tconst vec3 box_max = vec3( 0.5 );\n\t\t\t\t\t\tvec3 inv_dir = 1.0 / dir;\n\t\t\t\t\t\tvec3 tmin_tmp = ( box_min - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmax_tmp = ( box_max - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmin = min( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tvec3 tmax = max( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\t\t\t\t\t\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\t\t\t\t\t\treturn vec2( t0, t1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat sample1( vec3 p ) {\n\t\t\t\t\t\treturn texture( map, p ).r;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat shading( vec3 coord ) {\n\t\t\t\t\t\tfloat step = 0.01;\n\t\t\t\t\t\treturn sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tvec4 linearToSRGB( in vec4 value ) {\n\t\t\t\t\t\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid main(){\n\t\t\t\t\t\tvec3 rayDir = normalize( vDirection );\n\t\t\t\t\t\tvec2 bounds = hitBox( vOrigin, rayDir );\n\n\t\t\t\t\t\tif ( bounds.x > bounds.y ) discard;\n\n\t\t\t\t\t\tbounds.x = max( bounds.x, 0.0 );\n\n\t\t\t\t\t\tvec3 p = vOrigin + bounds.x * rayDir;\n\t\t\t\t\t\tvec3 inc = 1.0 / abs( rayDir );\n\t\t\t\t\t\tfloat delta = min( inc.x, min( inc.y, inc.z ) );\n\t\t\t\t\t\tdelta /= steps;\n\n\t\t\t\t\t\t// Jitter\n\n\t\t\t\t\t\t// Nice little seed from\n\t\t\t\t\t\t// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n\t\t\t\t\t\tuint seed = uint( gl_FragCoord.x ) * uint( 1973 ) + uint( gl_FragCoord.y ) * uint( 9277 ) + uint( frame ) * uint( 26699 );\n\t\t\t\t\t\tvec3 size = vec3( textureSize( map, 0 ) );\n\t\t\t\t\t\tfloat randNum = randomFloat( seed ) * 2.0 - 1.0;\n\t\t\t\t\t\tp += rayDir * randNum * ( 1.0 / size );\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tvec4 ac = vec4( base, 0.0 );\n\n\t\t\t\t\t\tfor ( float t = bounds.x; t < bounds.y; t += delta ) {\n\n\t\t\t\t\t\t\tfloat d = sample1( p + 0.5 );\n\n\t\t\t\t\t\t\td = smoothstep( threshold - range, threshold + range, d ) * opacity;\n\n\t\t\t\t\t\t\tfloat col = shading( p + 0.5 ) * 3.0 + ( ( p.x + p.y ) * 0.25 ) + 0.2;\n\n\t\t\t\t\t\t\tac.rgb += ( 1.0 - ac.a ) * d * col;\n\n\t\t\t\t\t\t\tac.a += ( 1.0 - ac.a ) * d;\n\n\t\t\t\t\t\t\tif ( ac.a >= 0.95 ) break;\n\n\t\t\t\t\t\t\tp += rayDir * delta;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolor = linearToSRGB( ac );\n\n\t\t\t\t\t\tif ( color.a == 0.0 ) discard;\n\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\t\t\t\t\tglslVersion: THREE.GLSL3,\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tbase: { value: new THREE.Color( 0x798aa0 ) },\n\t\t\t\t\t\tmap: { value: texture },\n\t\t\t\t\t\tcameraPos: { value: new THREE.Vector3() },\n\t\t\t\t\t\tthreshold: { value: 0.25 },\n\t\t\t\t\t\topacity: { value: 0.25 },\n\t\t\t\t\t\trange: { value: 0.1 },\n\t\t\t\t\t\tsteps: { value: 100 },\n\t\t\t\t\t\tframe: { value: 0 }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader,\n\t\t\t\t\tfragmentShader,\n\t\t\t\t\tside: THREE.BackSide,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst parameters = {\n\t\t\t\t\tthreshold: 0.25,\n\t\t\t\t\topacity: 0.25,\n\t\t\t\t\trange: 0.1,\n\t\t\t\t\tsteps: 100\n\t\t\t\t};\n\n\t\t\t\tfunction update() {\n\n\t\t\t\t\tmaterial.uniforms.threshold.value = parameters.threshold;\n\t\t\t\t\tmaterial.uniforms.opacity.value = parameters.opacity;\n\t\t\t\t\tmaterial.uniforms.range.value = parameters.range;\n\t\t\t\t\tmaterial.uniforms.steps.value = parameters.steps;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( parameters, 'threshold', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'opacity', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'range', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'steps', 0, 200, 1 ).onChange( update );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.material.uniforms.cameraPos.value.copy( camera.position );\n\t\t\t\tmesh.rotation.y = - performance.now() / 7500;\n\n\t\t\t\tmesh.material.uniforms.frame.value ++;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl2 - volume - cloud"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl2 - volume - instancing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl2 - volume - instancing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VOXLoader, VOXData3DTexture } from 'three/addons/loaders/VOXLoader.js';\n\n\t\t\tlet renderer, scene, camera, controls, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 4 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 1.0;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// Material\n\n\t\t\t\tconst vertexShader = /* glsl */`\n\t\t\t\t\tin vec3 position;\n\t\t\t\t\tin mat4 instanceMatrix;\n\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\t\t\t\t\tuniform vec3 cameraPos;\n\n\t\t\t\t\tout vec4 vScreenPosition;\n\t\t\t\t\tout mat4 vInstanceToViewMatrix;\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 mvPosition = modelViewMatrix * instanceMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t\t\t\tvScreenPosition = vec4( gl_Position.xy, 0.0, gl_Position.w );\n\t\t\t\t\t\tvInstanceToViewMatrix = modelViewMatrix * instanceMatrix;\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst fragmentShader = /* glsl */`\n\t\t\t\t\tprecision highp float;\n\t\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\t\tuniform mat4 viewMatrix;\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t\t\tin vec4 vScreenPosition;\n\t\t\t\t\tin mat4 vInstanceToViewMatrix;\n\n\t\t\t\t\tout vec4 color;\n\n\t\t\t\t\tuniform sampler3D map;\n\n\t\t\t\t\tuniform float threshold;\n\t\t\t\t\tuniform float steps;\n\n\t\t\t\t\tvec2 hitBox( vec3 orig, vec3 dir ) {\n\t\t\t\t\t\tconst vec3 box_min = vec3( - 0.5 );\n\t\t\t\t\t\tconst vec3 box_max = vec3( 0.5 );\n\t\t\t\t\t\tvec3 inv_dir = 1.0 / dir;\n\t\t\t\t\t\tvec3 tmin_tmp = ( box_min - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmax_tmp = ( box_max - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmin = min( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tvec3 tmax = max( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\t\t\t\t\t\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\t\t\t\t\t\treturn vec2( t0, t1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat sample1( vec3 p ) {\n\t\t\t\t\t\treturn texture( map, p ).r;\n\t\t\t\t\t}\n\n\t\t\t\t\t#define epsilon .0001\n\n\t\t\t\t\tvec3 normal( vec3 coord ) {\n\t\t\t\t\t\tif ( coord.x < epsilon ) return vec3( 1.0, 0.0, 0.0 );\n\t\t\t\t\t\tif ( coord.y < epsilon ) return vec3( 0.0, 1.0, 0.0 );\n\t\t\t\t\t\tif ( coord.z < epsilon ) return vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\t\tif ( coord.x > 1.0 - epsilon ) return vec3( - 1.0, 0.0, 0.0 );\n\t\t\t\t\t\tif ( coord.y > 1.0 - epsilon ) return vec3( 0.0, - 1.0, 0.0 );\n\t\t\t\t\t\tif ( coord.z > 1.0 - epsilon ) return vec3( 0.0, 0.0, - 1.0 );\n\n\t\t\t\t\t\tfloat step = 0.01;\n\t\t\t\t\t\tfloat x = sample1( coord + vec3( - step, 0.0, 0.0 ) ) - sample1( coord + vec3( step, 0.0, 0.0 ) );\n\t\t\t\t\t\tfloat y = sample1( coord + vec3( 0.0, - step, 0.0 ) ) - sample1( coord + vec3( 0.0, step, 0.0 ) );\n\t\t\t\t\t\tfloat z = sample1( coord + vec3( 0.0, 0.0, - step ) ) - sample1( coord + vec3( 0.0, 0.0, step ) );\n\n\t\t\t\t\t\treturn normalize( vec3( x, y, z ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid main() {\n\n\t\t\t\t\t\t// perform w divide in the fragment shader to avoid interpolation artifacts\n\t\t\t\t\t\tvec2 screenUv = vScreenPosition.xy / vScreenPosition.w;\n\t\t\t\t\t\tmat4 invProjectionMatrix = inverse( projectionMatrix );\n\t\t\t\t\t\tmat4 invInstanceToViewMatrix = inverse( vInstanceToViewMatrix );\n\t\t\t\t\t\t\n\t\t\t\t\t\t// get camera ray\n\t\t\t\t\t\tvec4 temp;\n\t\t\t\t\t\tvec3 camRayOrigin, camRayEnd;\n\t\t\t\t\t\ttemp = invProjectionMatrix * vec4( screenUv, - 1.0, 1.0 );\n\t\t\t\t\t\tcamRayOrigin = temp.xyz / temp.w;\n\n\t\t\t\t\t\ttemp = invProjectionMatrix * vec4( screenUv, 1.0, 1.0 );\n\t\t\t\t\t\tcamRayEnd = temp.xyz / temp.w;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// get local ray\n\t\t\t\t\t\tvec3 instRayOrigin, instRayDirection, instRayEnd;\n\t\t\t\t\t\tinstRayOrigin = ( invInstanceToViewMatrix * vec4( camRayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\t\tinstRayEnd = ( invInstanceToViewMatrix * vec4( camRayEnd, 1.0 ) ).xyz;\n\t\t\t\t\t\tinstRayDirection = normalize( instRayEnd - instRayOrigin );\n\n\t\t\t\t\t\t// calculate the start of the ray at the box edge\n\t\t\t\t\t\tvec2 bounds = hitBox( instRayOrigin, instRayDirection );\n\n\t\t\t\t\t\tif ( bounds.x > bounds.y ) discard;\n\n\t\t\t\t\t\tbounds.x = max( bounds.x, 0.0 );\n\n\t\t\t\t\t\tvec3 p = instRayOrigin + bounds.x * instRayDirection;\n\t\t\t\t\t\tvec3 inc = 1.0 / abs( instRayDirection );\n\t\t\t\t\t\tfloat delta = min( inc.x, min( inc.y, inc.z ) );\n\t\t\t\t\t\tdelta /= 50.0;\n\n\t\t\t\t\t\t// march through the volume\n\t\t\t\t\t\tfor ( float t = bounds.x; t < bounds.y; t += delta ) {\n\n\t\t\t\t\t\t\tfloat d = sample1( p + 0.5 );\n\n\t\t\t\t\t\t\tif ( d > 0.5 ) {\n\n\t\t\t\t\t\t\t\tcolor.rgb = p * 2.0; // normal( p + 0.5 ); // * 0.5 + ( p * 1.5 + 0.25 );\n\t\t\t\t\t\t\t\tcolor.a = 1.;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tp += instRayDirection * delta;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color.a == 0.0 ) discard;\n\n\t\t\t\t\t\t// calculate the final point in the ndc coords\n\t\t\t\t\t\tvec4 ndc = projectionMatrix * vInstanceToViewMatrix * vec4( p, 1.0 );\n\t\t\t\t\t\tndc /= ndc.w;\n\n\t\t\t\t\t\t// map the ndc coordinate to depth\n\t\t\t\t\t\t// https://stackoverflow.com/questions/10264949/glsl-gl-fragcoord-z-calculation-and-setting-gl-fragdepth\n\t\t\t\t\t\tfloat far = gl_DepthRange.far;\n\t\t\t\t\t\tfloat near = gl_DepthRange.near;\n\t\t\t\t\t\tgl_FragDepth = ( ( ( far - near ) * ndc.z ) + near + far ) / 2.0;\n\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst loader = new VOXLoader();\n\t\t\t\tloader.load( 'models/vox/menger.vox', function ( chunks ) {\n\n\t\t\t\t\tfor ( let i = 0; i < chunks.length; i ++ ) {\n\n\t\t\t\t\t\tconst chunk = chunks[ i ];\n\n\t\t\t\t\t\tconst geometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\t\t\t\t\t\t\tglslVersion: THREE.GLSL3,\n\t\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\t\tmap: { value: new VOXData3DTexture( chunk ) },\n\t\t\t\t\t\t\t\tcameraPos: { value: new THREE.Vector3() }\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvertexShader,\n\t\t\t\t\t\t\tfragmentShader,\n\t\t\t\t\t\t\tside: THREE.BackSide\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst mesh = new THREE.InstancedMesh( geometry, material, 50000 );\n\t\t\t\t\t\tmesh.onBeforeRender = function () {\n\n\t\t\t\t\t\t\tthis.material.uniforms.cameraPos.value.copy( camera.position );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst transform = new THREE.Object3D();\n\n\t\t\t\t\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\t\t\t\t\ttransform.position.random().subScalar( 0.5 ).multiplyScalar( 150 );\n\t\t\t\t\t\t\ttransform.rotation.x = Math.random() * Math.PI;\n\t\t\t\t\t\t\ttransform.rotation.y = Math.random() * Math.PI;\n\t\t\t\t\t\t\ttransform.rotation.z = Math.random() * Math.PI;\n\t\t\t\t\t\t\ttransform.updateMatrix();\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, transform.matrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\t\t\t\tcontrols.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl2 - volume - instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl2 - volume"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl2 - volume:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 2 );\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t// Texture\n\n\t\t\t\tconst size = 128;\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tvector.set( x, y, z ).divideScalar( size );\n\n\t\t\t\t\t\t\tconst d = perlin.noise( vector.x * 6.5, vector.y * 6.5, vector.z * 6.5 );\n\n\t\t\t\t\t\t\tdata[ i ++ ] = d * 128 + 128;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// Material\n\n\t\t\t\tconst vertexShader = /* glsl */`\n\t\t\t\t\tin vec3 position;\n\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\t\t\t\t\tuniform vec3 cameraPos;\n\n\t\t\t\t\tout vec3 vOrigin;\n\t\t\t\t\tout vec3 vDirection;\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\tvOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;\n\t\t\t\t\t\tvDirection = position - vOrigin;\n\n\t\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst fragmentShader = /* glsl */`\n\t\t\t\t\tprecision highp float;\n\t\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t\t\tin vec3 vOrigin;\n\t\t\t\t\tin vec3 vDirection;\n\n\t\t\t\t\tout vec4 color;\n\n\t\t\t\t\tuniform sampler3D map;\n\n\t\t\t\t\tuniform float threshold;\n\t\t\t\t\tuniform float steps;\n\n\t\t\t\t\tvec2 hitBox( vec3 orig, vec3 dir ) {\n\t\t\t\t\t\tconst vec3 box_min = vec3( - 0.5 );\n\t\t\t\t\t\tconst vec3 box_max = vec3( 0.5 );\n\t\t\t\t\t\tvec3 inv_dir = 1.0 / dir;\n\t\t\t\t\t\tvec3 tmin_tmp = ( box_min - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmax_tmp = ( box_max - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmin = min( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tvec3 tmax = max( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\t\t\t\t\t\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\t\t\t\t\t\treturn vec2( t0, t1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat sample1( vec3 p ) {\n\t\t\t\t\t\treturn texture( map, p ).r;\n\t\t\t\t\t}\n\n\t\t\t\t\t#define epsilon .0001\n\n\t\t\t\t\tvec3 normal( vec3 coord ) {\n\t\t\t\t\t\tif ( coord.x < epsilon ) return vec3( 1.0, 0.0, 0.0 );\n\t\t\t\t\t\tif ( coord.y < epsilon ) return vec3( 0.0, 1.0, 0.0 );\n\t\t\t\t\t\tif ( coord.z < epsilon ) return vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\t\tif ( coord.x > 1.0 - epsilon ) return vec3( - 1.0, 0.0, 0.0 );\n\t\t\t\t\t\tif ( coord.y > 1.0 - epsilon ) return vec3( 0.0, - 1.0, 0.0 );\n\t\t\t\t\t\tif ( coord.z > 1.0 - epsilon ) return vec3( 0.0, 0.0, - 1.0 );\n\n\t\t\t\t\t\tfloat step = 0.01;\n\t\t\t\t\t\tfloat x = sample1( coord + vec3( - step, 0.0, 0.0 ) ) - sample1( coord + vec3( step, 0.0, 0.0 ) );\n\t\t\t\t\t\tfloat y = sample1( coord + vec3( 0.0, - step, 0.0 ) ) - sample1( coord + vec3( 0.0, step, 0.0 ) );\n\t\t\t\t\t\tfloat z = sample1( coord + vec3( 0.0, 0.0, - step ) ) - sample1( coord + vec3( 0.0, 0.0, step ) );\n\n\t\t\t\t\t\treturn normalize( vec3( x, y, z ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid main(){\n\n\t\t\t\t\t\tvec3 rayDir = normalize( vDirection );\n\t\t\t\t\t\tvec2 bounds = hitBox( vOrigin, rayDir );\n\n\t\t\t\t\t\tif ( bounds.x > bounds.y ) discard;\n\n\t\t\t\t\t\tbounds.x = max( bounds.x, 0.0 );\n\n\t\t\t\t\t\tvec3 p = vOrigin + bounds.x * rayDir;\n\t\t\t\t\t\tvec3 inc = 1.0 / abs( rayDir );\n\t\t\t\t\t\tfloat delta = min( inc.x, min( inc.y, inc.z ) );\n\t\t\t\t\t\tdelta /= steps;\n\n\t\t\t\t\t\tfor ( float t = bounds.x; t < bounds.y; t += delta ) {\n\n\t\t\t\t\t\t\tfloat d = sample1( p + 0.5 );\n\n\t\t\t\t\t\t\tif ( d > threshold ) {\n\n\t\t\t\t\t\t\t\tcolor.rgb = normal( p + 0.5 ) * 0.5 + ( p * 1.5 + 0.25 );\n\t\t\t\t\t\t\t\tcolor.a = 1.;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tp += rayDir * delta;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color.a == 0.0 ) discard;\n\n\t\t\t\t\t}\n\t\t\t\t`;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\tconst material = new THREE.RawShaderMaterial( {\n\t\t\t\t\tglslVersion: THREE.GLSL3,\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tmap: { value: texture },\n\t\t\t\t\t\tcameraPos: { value: new THREE.Vector3() },\n\t\t\t\t\t\tthreshold: { value: 0.6 },\n\t\t\t\t\t\tsteps: { value: 200 }\n\t\t\t\t\t},\n\t\t\t\t\tvertexShader,\n\t\t\t\t\tfragmentShader,\n\t\t\t\t\tside: THREE.BackSide,\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst parameters = { threshold: 0.6, steps: 200 };\n\n\t\t\t\tfunction update() {\n\n\t\t\t\t\tmaterial.uniforms.threshold.value = parameters.threshold;\n\t\t\t\t\tmaterial.uniforms.steps.value = parameters.steps;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( parameters, 'threshold', 0, 1, 0.01 ).onChange( update );\n\t\t\t\tgui.add( parameters, 'steps', 0, 300, 1 ).onChange( update );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.material.uniforms.cameraPos.value.copy( camera.position );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl2 - volume"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - worker - offscreen canvas"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - worker - offscreen canvas:\n\n```javascript\nimport initJank from 'three/addons/offscreen/jank.js';\n\t\t\timport init from 'three/addons/offscreen/scene.js';\n\t\t\t\n\t\t\t// onscreen\n\n\t\t\tconst canvas1 = document.getElementById( 'canvas1' );\n\t\t\tconst canvas2 = document.getElementById( 'canvas2' );\n\n\t\t\tconst width = canvas1.clientWidth;\n\t\t\tconst height = canvas1.clientHeight;\n\t\t\tconst pixelRatio = window.devicePixelRatio;\n\n\t\t\tinit( canvas1, width, height, pixelRatio, './' );\n\t\t\tinitJank();\n\n\t\t\t// offscreen\n\n\t\t\tconst isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent );\n\t\t\tlet supportOffScreenWebGL = 'transferControlToOffscreen' in canvas2;\n\n\t\t\t// If it's Safari, then check the version because Safari < 17 doesn't support OffscreenCanvas with a WebGL context.\n\t\t\tif ( isSafari ) {\n\n\t\t\t\tvar versionMatch = navigator.userAgent.match( /version\\/(\\d+)/i );\n\t\t\t\tvar safariVersion = versionMatch ? parseInt( versionMatch[ 1 ] ) : 0;\n\n\t\t\t\tsupportOffScreenWebGL = safariVersion >= 17;\n\n\t\t\t}\n\n\t\t\tif ( supportOffScreenWebGL ) {\n\n\t\t\t\tconst offscreen = canvas2.transferControlToOffscreen();\n\t\t\t\tconst worker = new Worker( 'jsm/offscreen/offscreen.js', { type: 'module' } );\n\t\t\t\tworker.postMessage( {\n\t\t\t\t\tdrawingSurface: offscreen,\n\t\t\t\t\twidth: canvas2.clientWidth,\n\t\t\t\t\theight: canvas2.clientHeight,\n\t\t\t\t\tpixelRatio: window.devicePixelRatio,\n\t\t\t\t\tpath: '../../'\n\t\t\t\t}, [ offscreen ] );\n\n\t\t\t} else {\n\n\t\t\t\tdocument.getElementById( 'message' ).style.display = 'block';\n\n\t\t\t}\n```\n\nThis example three.js - offscreen canvas ( about ) Your browser does not support OffscreenCanvas with a WebGL Context. Check the browser support here"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates webgl - GLTFloader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - GLTFloader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 60, 60, 60 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\t\t\tloader.load( 'dungeon_warkarma.glb', async function ( gltf ) {\n\n\t\t\t\t\t\t\tconst model = gltf.scene;\n\n\t\t\t\t\t\t\t// wait until the model can be added to the scene without blocking due to shader compilation\n\n\t\t\t\t\t\t\tawait renderer.compileAsync( model, camera, scene );\n\n\t\t\t\t\t\t\tscene.add( model );\n\t\t\t\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 60;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Performance Dungeon - Low Poly Game Level Challenge by Warkarma Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - animation retargeting"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - animation retargeting:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, screenUV, hue, reflector, time, Fn, vec2, length, atan, float, sin, cos, vec3, sub, mul, pow, blendDodge, normalWorldGeometry } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n\n\t\t\tconst [ sourceModel, targetModel ] = await Promise.all( [\n\n\t\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tnew GLTFLoader().load( './models/gltf/Michelle.glb', resolve, undefined, reject );\n\n\t\t\t\t} ),\n\n\t\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tnew GLTFLoader().load( './models/gltf/Soldier.glb', resolve, undefined, reject );\n\n\t\t\t\t} )\n\n\t\t\t] );\n\n\t\t\t//\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst stats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\texport const lightSpeed = /*#__PURE__*/ Fn( ( [ suv_immutable ] ) => {\n\n\t\t\t\t// forked from https://www.shadertoy.com/view/7ly3D1\n\n\t\t\t\tconst suv = vec2( suv_immutable );\n\t\t\t\tconst uv = vec2( length( suv ), atan( suv.y, suv.x ) );\n\t\t\t\tconst offset = float( float( .1 ).mul( sin( uv.y.mul( 10. ).sub( time.mul( .6 ) ) ) ).mul( cos( uv.y.mul( 48. ).add( time.mul( .3 ) ) ) ).mul( cos( uv.y.mul( 3.7 ).add( time ) ) ) );\n\t\t\t\tconst rays = vec3( vec3( sin( uv.y.mul( 150. ).add( time ) ).mul( .5 ).add( .5 ) ).mul( vec3( sin( uv.y.mul( 80. ).sub( time.mul( 0.6 ) ) ).mul( .5 ).add( .5 ) ) ).mul( vec3( sin( uv.y.mul( 45. ).add( time.mul( 0.8 ) ) ).mul( .5 ).add( .5 ) ) ).mul( vec3( sub( 1., cos( uv.y.add( mul( 22., time ).sub( pow( uv.x.add( offset ), .3 ).mul( 60. ) ) ) ) ) ) ).mul( vec3( uv.x.mul( 2. ) ) ) );\n\n\t\t\t\treturn rays;\n\n\t\t\t} ).setLayout( {\n\t\t\t\tname: 'lightSpeed',\n\t\t\t\ttype: 'vec3',\n\t\t\t\tinputs: [\n\t\t\t\t\t{ name: 'suv', type: 'vec2' }\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\t// scene\n\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t// background\n\n\t\t\tconst coloredVignette = screenUV.distance( .5 ).mix( hue( color( 0x0175ad ), time.mul( .1 ) ), hue( color( 0x02274f ), time.mul( .5 ) ) );\n\t\t\tconst lightSpeedEffect = lightSpeed( normalWorldGeometry ).clamp();\n\t\t\tconst lightSpeedSky = normalWorldGeometry.y.remapClamp( - .1, 1 ).mix( 0, lightSpeedEffect );\n\t\t\tconst composedBackground = blendDodge( coloredVignette, lightSpeedSky );\n\n\t\t\tscene.backgroundNode = composedBackground;\n\n\t\t\t//\n\n\t\t\tconst helpers = new THREE.Group();\n\t\t\thelpers.visible = false;\n\t\t\tscene.add( helpers );\n\n\t\t\tconst light = new THREE.HemisphereLight( 0xe9c0a5, 0x0175ad, 5 );\n\t\t\tscene.add( light );\n\n\t\t\tconst dirLight = new THREE.DirectionalLight( 0xfff9ea, 4 );\n\t\t\tdirLight.position.set( 2, 5, 2 );\n\t\t\tscene.add( dirLight );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .25, 50 );\n\t\t\tcamera.position.set( 0, 1, 4 );\n\n\t\t\t// add models to scene\n\t\t\tscene.add( sourceModel.scene );\n\t\t\tscene.add( targetModel.scene );\n\n\t\t\t// reposition models\n\t\t\tsourceModel.scene.position.x -= .8;\n\t\t\ttargetModel.scene.position.x += .7;\n\n\t\t\ttargetModel.scene.position.z -= .1;\n\n\t\t\t// reajust model\n\t\t\ttargetModel.scene.scale.setScalar( .01 );\n\n\t\t\t// flip model\n\t\t\tsourceModel.scene.rotation.y = Math.PI / 2;\n\t\t\ttargetModel.scene.rotation.y = - Math.PI / 2;\n\n\t\t\t// retarget\n\t\t\tconst source = getSource( sourceModel );\n\t\t\tconst mixer = retargetModel( source, targetModel );\n\n\t\t\t// floor\n\t\t\tconst reflection = reflector();\n\t\t\treflection.target.rotateX( - Math.PI / 2 );\n\t\t\tscene.add( reflection.target );\n\n\t\t\tconst floorMaterial = new THREE.NodeMaterial();\n\t\t\tfloorMaterial.colorNode = reflection;\n\t\t\tfloorMaterial.opacity = .2;\n\t\t\tfloorMaterial.transparent = true;\n\n\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );\n\t\t\tfloor.receiveShadow = true;\n\n\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\tscene.add( floor );\n\n\t\t\t// renderer\n\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.minDistance = 3;\n\t\t\tcontrols.maxDistance = 12;\n\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\tconst gui = new GUI();\n\t\t\tgui.add( helpers, 'visible' ).name( 'helpers' );\n\n\t\t\t//\n\n\t\t\tfunction getSource( sourceModel ) {\n\n\t\t\t\tconst clip = sourceModel.animations[ 0 ];\n\n\t\t\t\tconst helper = new THREE.SkeletonHelper( sourceModel.scene );\n\t\t\t\thelpers.add( helper );\n\n\t\t\t\tconst skeleton = new THREE.Skeleton( helper.bones );\n\n\t\t\t\tconst mixer = new THREE.AnimationMixer( sourceModel.scene );\n\t\t\t\tmixer.clipAction( sourceModel.animations[ 0 ] ).play();\n\n\t\t\t\treturn { clip, skeleton, mixer };\n\n\t\t\t}\n\n\t\t\tfunction retargetModel( sourceModel, targetModel ) {\n\n\t\t\t\tconst targetSkin = targetModel.scene.children[ 0 ].children[ 0 ];\n\n\t\t\t\tconst targetSkelHelper = new THREE.SkeletonHelper( targetModel.scene );\n\t\t\t\thelpers.add( targetSkelHelper );\n\n\t\t\t\tconst rotateCW45 = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( 45 ) );\n\t\t\t\tconst rotateCCW180 = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( - 180 ) );\n\t\t\t\tconst rotateCW180 = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( 180 ) );\n\t\t\t\tconst rotateFoot = new THREE.Matrix4().makeRotationFromEuler( new THREE.Euler( THREE.MathUtils.degToRad( 45 ), THREE.MathUtils.degToRad( 180 ), THREE.MathUtils.degToRad( 0 ) ) );\n\n\t\t\t\tconst retargetOptions = {\n\n\t\t\t\t\t// specify the name of the source's hip bone.\n\t\t\t\t\thip: 'mixamorigHips',\n\n\t\t\t\t\t// specify the influence of the source's hip bone.\n\t\t\t\t\t// use ( 0, 1, 0 ) to ignore xz hip movement.\n\t\t\t\t\t//hipInfluence: new THREE.Vector3( 0, 1, 0 ),\n\n\t\t\t\t\t// specify an animation range in seconds.\n\t\t\t\t\t//trim: [ 3.0, 4.0 ],\n\n\t\t\t\t\t// preserve the scale of the target model\n\t\t\t\t\tscale: 1 / targetModel.scene.scale.y,\n\n\t\t\t\t\t// offset target bones -> { targetBoneName: offsetMatrix }\n\t\t\t\t\tlocalOffsets: {\n\n\t\t\t\t\t\tmixamorigLeftShoulder: rotateCW45,\n\t\t\t\t\t\tmixamorigRightShoulder: rotateCCW180,\n\t\t\t\t\t\tmixamorigLeftArm: rotateCW45,\n\t\t\t\t\t\tmixamorigRightArm: rotateCCW180,\n\t\t\t\t\t\tmixamorigLeftForeArm: rotateCW45,\n\t\t\t\t\t\tmixamorigRightForeArm: rotateCCW180,\n\t\t\t\t\t\tmixamorigLeftHand: rotateCW45,\n\t\t\t\t\t\tmixamorigRightHand: rotateCCW180,\n\n\t\t\t\t\t\tmixamorigLeftUpLeg: rotateCW180,\n\t\t\t\t\t\tmixamorigRightUpLeg: rotateCW180,\n\t\t\t\t\t\tmixamorigLeftLeg: rotateCW180,\n\t\t\t\t\t\tmixamorigRightLeg: rotateCW180,\n\t\t\t\t\t\tmixamorigLeftFoot: rotateFoot,\n\t\t\t\t\t\tmixamorigRightFoot: rotateFoot,\n\t\t\t\t\t\tmixamorigLeftToeBase: rotateCW180,\n\t\t\t\t\t\tmixamorigRightToeBase: rotateCW180\n\n\t\t\t\t\t},\n\n\t\t\t\t\t// Map of target's bone names to source's bone names -> { targetBoneName: sourceBoneName }\n\t\t\t\t\tnames: {\n\n\t\t\t\t\t\tmixamorigHips: 'mixamorigHips',\n\n\t\t\t\t\t\tmixamorigSpine: 'mixamorigSpine',\n\t\t\t\t\t\tmixamorigSpine2: 'mixamorigSpine2',\n\t\t\t\t\t\tmixamorigHead: 'mixamorigHead',\n\n\t\t\t\t\t\tmixamorigLeftShoulder: 'mixamorigLeftShoulder',\n\t\t\t\t\t\tmixamorigRightShoulder: 'mixamorigRightShoulder',\n\t\t\t\t\t\tmixamorigLeftArm: 'mixamorigLeftArm',\n\t\t\t\t\t\tmixamorigRightArm: 'mixamorigRightArm',\n\t\t\t\t\t\tmixamorigLeftForeArm: 'mixamorigLeftForeArm',\n\t\t\t\t\t\tmixamorigRightForeArm: 'mixamorigRightForeArm',\n\t\t\t\t\t\tmixamorigLeftHand: 'mixamorigLeftHand',\n\t\t\t\t\t\tmixamorigRightHand: 'mixamorigRightHand',\n\n\t\t\t\t\t\tmixamorigLeftUpLeg: 'mixamorigLeftUpLeg',\n\t\t\t\t\t\tmixamorigRightUpLeg: 'mixamorigRightUpLeg',\n\t\t\t\t\t\tmixamorigLeftLeg: 'mixamorigLeftLeg',\n\t\t\t\t\t\tmixamorigRightLeg: 'mixamorigRightLeg',\n\t\t\t\t\t\tmixamorigLeftFoot: 'mixamorigLeftFoot',\n\t\t\t\t\t\tmixamorigRightFoot: 'mixamorigRightFoot',\n\t\t\t\t\t\tmixamorigLeftToeBase: 'mixamorigLeftToeBase',\n\t\t\t\t\t\tmixamorigRightToeBase: 'mixamorigRightToeBase'\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tconst retargetedClip = SkeletonUtils.retargetClip( targetSkin, sourceModel.skeleton, sourceModel.clip, retargetOptions );\n\n\t\t\t\t// Apply the mixer directly to the SkinnedMesh, not any\n\t\t\t\t// ancestor node, because that's what\n\t\t\t\t// SkeletonUtils.retargetClip outputs the clip to be\n\t\t\t\t// compatible with.\n\t\t\t\tconst mixer = new THREE.AnimationMixer( targetSkin );\n\t\t\t\tmixer.clipAction( retargetedClip ).play();\n\n\t\t\t\treturn mixer;\n\n\t\t\t}\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t};\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tsource.mixer.update( delta );\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - animation retargeting"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - animation retargeting"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - animation retargeting:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { screenUV, color, vec2, vec4, reflector, positionWorld } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { FBXLoader } from 'three/addons/loaders/FBXLoader.js';\n\n\t\t\timport * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n\n\t\t\tconst [ sourceModel, targetModel ] = await Promise.all( [\n\n\t\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tnew FBXLoader().load( './models/fbx/mixamo.fbx', resolve, undefined, reject );\n\n\t\t\t\t} ),\n\n\t\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tnew GLTFLoader().load( './models/gltf/readyplayer.me.glb', resolve, undefined, reject );\n\n\t\t\t\t} )\n\n\t\t\t] );\n\n\t\t\t//\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst stats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t// scene\n\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t// background\n\n\t\t\tconst horizontalEffect = screenUV.x.mix( color( 0x13172b ), color( 0x311649 ) );\n\t\t\tconst lightEffect = screenUV.distance( vec2( 0.5, 1.0 ) ).oneMinus().mul( color( 0x0c5d68 ) );\n\n\t\t\tscene.backgroundNode = horizontalEffect.add( lightEffect );\n\n\t\t\t//\n\n\t\t\tconst light = new THREE.HemisphereLight( 0x311649, 0x0c5d68, 10 );\n\t\t\tscene.add( light );\n\n\t\t\tconst backLight = new THREE.DirectionalLight( 0xffffff, 10 );\n\t\t\tbackLight.position.set( 0, 5, - 5 );\n\t\t\tscene.add( backLight );\n\n\t\t\tconst keyLight = new THREE.DirectionalLight( 0xfff9ea, 4 );\n\t\t\tkeyLight.position.set( 3, 5, 3 );\n\t\t\tscene.add( keyLight );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .25, 50 );\n\t\t\tcamera.position.set( 0, 3, 5 );\n\n\t\t\t// add models to scene\n\t\t\tscene.add( sourceModel );\n\t\t\tscene.add( targetModel.scene );\n\n\t\t\t// reposition models\n\t\t\tsourceModel.position.x -= .9;\n\t\t\ttargetModel.scene.position.x += .9;\n\n\t\t\t// reajust model - mixamo use centimeters, readyplayer.me use meters (three.js scale is meters)\n\t\t\tsourceModel.scale.setScalar( .01 );\n\n\t\t\t// retarget\n\t\t\tconst source = getSource( sourceModel );\n\t\t\tconst mixer = retargetModel( source, targetModel );\n\n\t\t\t// renderer\n\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.minDistance = 3;\n\t\t\tcontrols.maxDistance = 12;\n\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t// floor\n\t\t\tconst reflection = reflector();\n\t\t\treflection.target.rotateX( - Math.PI / 2 );\n\t\t\tscene.add( reflection.target );\n\n\t\t\tconst reflectionMask = positionWorld.xz.distance( 0 ).mul( .1 ).clamp().oneMinus();\n\n\t\t\tconst floorMaterial = new THREE.NodeMaterial();\n\t\t\tfloorMaterial.colorNode = vec4( reflection.rgb, reflectionMask );\n\t\t\tfloorMaterial.opacity = .2;\n\t\t\tfloorMaterial.transparent = true;\n\n\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );\n\t\t\tfloor.receiveShadow = true;\n\n\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\tscene.add( floor );\n\n\t\t\t//\n\n\t\t\tfunction getSource( sourceModel ) {\n\n\t\t\t\tconst clip = sourceModel.animations[ 0 ];\n\n\t\t\t\tconst helper = new THREE.SkeletonHelper( sourceModel );\n\t\t\t\tconst skeleton = new THREE.Skeleton( helper.bones );\n\n\t\t\t\tconst mixer = new THREE.AnimationMixer( sourceModel );\n\t\t\t\tmixer.clipAction( sourceModel.animations[ 0 ] ).play();\n\n\t\t\t\treturn { clip, skeleton, mixer };\n\n\t\t\t}\n\n\t\t\tfunction retargetModel( sourceModel, targetModel ) {\n\n\t\t\t\tconst targetSkin = targetModel.scene.children[ 0 ].children[ 1 ];\n\n\t\t\t\tconst retargetOptions = {\n\n\t\t\t\t\t// specify the name of the source's hip bone.\n\t\t\t\t\thip: 'mixamorigHips',\n\n\t\t\t\t\t// preserve the scale of the target model\n\t\t\t\t\tscale: .01,\n\n\t\t\t\t\t// use ( 0, 1, 0 ) to ignore xz hip movement.\n\t\t\t\t\t//hipInfluence: new THREE.Vector3( 0, 1, 0 ),\n\n\t\t\t\t\t// Map of target's bone names to source's bone names -> { targetBoneName: sourceBoneName }\n\t\t\t\t\tgetBoneName: function ( bone ) {\n\n\t\t\t\t\t\treturn 'mixamorig' + bone.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tconst retargetedClip = SkeletonUtils.retargetClip( targetSkin, sourceModel.skeleton, sourceModel.clip, retargetOptions );\n\n\t\t\t\tconst mixer = new THREE.AnimationMixer( targetSkin );\n\t\t\t\tmixer.clipAction( retargetedClip ).play();\n\n\t\t\t\treturn mixer;\n\n\t\t\t}\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t};\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tsource.mixer.update( delta );\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - animation retargeting mixamo to readyplayer.me"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Backdrop"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Backdrop:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { float, vec3, color, viewportSharedTexture, hue, blendOverlay, posterize, grayscale, saturation, viewportSafeUV, screenUV, checker, uv, time, oscSine, output } from 'three/tsl';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet portals, rotate = true;\n\t\t\tlet mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.set( 1, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst light = new THREE.SpotLight( 0xffffff, 1 );\n\t\t\t\tlight.power = 2000;\n\t\t\t\tcamera.add( light );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tconst object = gltf.scene;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\tconst material = object.children[ 0 ].children[ 0 ].material;\n\t\t\t\t\tmaterial.outputNode = oscSine( time.mul( .1 ) ).mix( output, posterize( output.add( .1 ), 4 ).mul( 2 ) );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t// portals\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( .3, 32, 16 );\n\n\t\t\t\tportals = new THREE.Group();\n\t\t\t\tscene.add( portals );\n\n\t\t\t\tfunction addBackdropSphere( backdropNode, backdropAlphaNode = null ) {\n\n\t\t\t\t\tconst distance = 1;\n\t\t\t\t\tconst id = portals.children.length;\n\t\t\t\t\tconst rotation = THREE.MathUtils.degToRad( id * 45 );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( { color: 0x0066ff } );\n\t\t\t\t\tmaterial.roughnessNode = float( .2 );\n\t\t\t\t\tmaterial.metalnessNode = float( 0 );\n\t\t\t\t\tmaterial.backdropNode = backdropNode;\n\t\t\t\t\tmaterial.backdropAlphaNode = backdropAlphaNode;\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set(\n\t\t\t\t\t\tMath.cos( rotation ) * distance,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tMath.sin( rotation ) * distance\n\t\t\t\t\t);\n\n\t\t\t\t\tportals.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\taddBackdropSphere( hue( viewportSharedTexture().bgr, oscSine().mul( Math.PI ) ) );\n\t\t\t\taddBackdropSphere( viewportSharedTexture().rgb.oneMinus() );\n\t\t\t\taddBackdropSphere( grayscale( viewportSharedTexture().rgb ) );\n\t\t\t\taddBackdropSphere( saturation( viewportSharedTexture().rgb, 10 ), oscSine() );\n\t\t\t\taddBackdropSphere( blendOverlay( viewportSharedTexture().rgb, checker( uv().mul( 10 ) ) ) );\n\t\t\t\taddBackdropSphere( viewportSharedTexture( viewportSafeUV( screenUV.mul( 40 ).floor().div( 40 ) ) ) );\n\t\t\t\taddBackdropSphere( viewportSharedTexture( viewportSafeUV( screenUV.mul( 80 ).floor().div( 80 ) ) ).add( color( 0x0033ff ) ) );\n\t\t\t\taddBackdropSphere( vec3( 0, 0, viewportSharedTexture().b ) );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.3;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.addEventListener( 'start', () => rotate = false );\n\t\t\t\tcontrols.addEventListener( 'end', () => rotate = true );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\tif ( rotate ) portals.rotation.y += delta * 0.5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Backdrop"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Backdrop Area"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Backdrop Area:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, positionWorld, linearDepth, viewportLinearDepth, viewportSharedTexture, screenUV, hue, time, checker, uv, modelScale } from 'three/tsl';\n\t\t\timport { hashBlur } from 'three/addons/tsl/display/hashBlur.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 25 );\n\t\t\t\tcamera.position.set( 3, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = hue( screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) ), time.mul( 0.1 ) );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0xffffff, 2.5 );\n\t\t\t\tscene.add( ambient );\n\t\t\t\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tconst object = gltf.scene;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t// volume\n\n\t\t\t\t// compare depth from viewportLinearDepth with linearDepth() to create a distance field\n\t\t\t\t// viewportLinearDepth return the linear depth of the scene\n\t\t\t\t// linearDepth() returns the linear depth of the mesh\n\t\t\t\tconst depthDistance = viewportLinearDepth.distance( linearDepth() );\n\n\t\t\t\tconst depthAlphaNode = depthDistance.oneMinus().smoothstep( .90, 2 ).mul( 10 ).saturate();\n\t\t\t\tconst depthBlurred = hashBlur( viewportSharedTexture(), depthDistance.smoothstep( 0, .6 ).mul( 40 ).clamp().mul( .1 ) );\n\n\t\t\t\tconst blurredBlur = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tblurredBlur.backdropNode = depthBlurred.add( depthAlphaNode.mix( color( 0x003399 ).mul( .3 ), 0 ) );\n\t\t\t\tblurredBlur.transparent = true;\n\t\t\t\tblurredBlur.side = THREE.DoubleSide;\n\n\t\t\t\tconst depthMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tdepthMaterial.backdropNode = depthAlphaNode;\n\t\t\t\tdepthMaterial.transparent = true;\n\t\t\t\tdepthMaterial.side = THREE.DoubleSide;\n\n\t\t\t\tconst checkerMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tcheckerMaterial.backdropNode = hashBlur( viewportSharedTexture(), .05 );\n\t\t\t\tcheckerMaterial.backdropAlphaNode = checker( uv().mul( 3 ).mul( modelScale.xy ) );\n\t\t\t\tcheckerMaterial.opacityNode = checkerMaterial.backdropAlphaNode;\n\t\t\t\tcheckerMaterial.transparent = true;\n\t\t\t\tcheckerMaterial.side = THREE.DoubleSide;\n\n\t\t\t\tconst pixelMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tpixelMaterial.backdropNode = viewportSharedTexture( screenUV.mul( 100 ).floor().div( 100 ) );\n\t\t\t\tpixelMaterial.transparent = true;\n\n\t\t\t\t// box / floor\n\n\t\t\t\tconst box = new THREE.Mesh( new THREE.BoxGeometry( 2, 2, 2 ), blurredBlur );\n\t\t\t\tbox.position.set( 0, 1, 0 );\n\t\t\t\tbox.renderOrder = 1;\n\t\t\t\tscene.add( box );\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 5, .01, 5 ), new THREE.MeshBasicNodeMaterial( {\n\t\t\t\t\tcolor: 0xff6600,\n\t\t\t\t\topacityNode: positionWorld.xz.distance( 0 ).oneMinus().clamp(),\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\tdepthWrite: false\n\t\t\t\t} ) );\n\t\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( /*{ antialias: true }*/ );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = .9;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst materials = {\n\t\t\t\t\t'blurred': blurredBlur,\n\t\t\t\t\t'depth': depthMaterial,\n\t\t\t\t\t'checker': checkerMaterial,\n\t\t\t\t\t'pixel': pixelMaterial\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tconst options = { material: 'blurred' };\n\n\t\t\t\tbox.material = materials[ options.material ];\n\n\t\t\t\tgui.add( box.scale, 'x', 0.1, 2, 0.01 );\n\t\t\t\tgui.add( box.scale, 'z', 0.1, 2, 0.01 );\n\t\t\t\tgui.add( options, 'material', Object.keys( materials ) ).onChange( name => {\n\n\t\t\t\t\tbox.material = materials[ name ];\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Backdrop Area"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Backdrop Water"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Backdrop Water:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, vec2, pass, linearDepth, normalWorld, triplanarTexture, texture, objectPosition, screenUV, viewportLinearDepth, viewportDepthTexture, viewportSharedTexture, mx_worley_noise_float, positionWorld, time } from 'three/tsl';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mixer, objects, clock;\n\t\t\tlet model, floor, floorPosition;\n\t\t\tlet postProcessing;\n\t\t\tlet controls;\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );\n\t\t\t\tcamera.position.set( 3, 2, 4 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x0487e2, 7, 25 );\n\t\t\t\tscene.backgroundNode = normalWorld.y.mix( color( 0x0487e2 ), color( 0x0066ff ) );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tconst sunLight = new THREE.DirectionalLight( 0xFFE499, 5 );\n\t\t\t\tsunLight.castShadow = true;\n\t\t\t\tsunLight.shadow.camera.near = .1;\n\t\t\t\tsunLight.shadow.camera.far = 5;\n\t\t\t\tsunLight.shadow.camera.right = 2;\n\t\t\t\tsunLight.shadow.camera.left = - 2;\n\t\t\t\tsunLight.shadow.camera.top = 1;\n\t\t\t\tsunLight.shadow.camera.bottom = - 2;\n\t\t\t\tsunLight.shadow.mapSize.width = 2048;\n\t\t\t\tsunLight.shadow.mapSize.height = 2048;\n\t\t\t\tsunLight.shadow.bias = - 0.001;\n\t\t\t\tsunLight.position.set( .5, 3, .5 );\n\n\t\t\t\tconst waterAmbientLight = new THREE.HemisphereLight( 0x333366, 0x74ccf4, 5 );\n\t\t\t\tconst skyAmbientLight = new THREE.HemisphereLight( 0x74ccf4, 0, 1 );\n\n\t\t\t\tscene.add( sunLight );\n\t\t\t\tscene.add( skyAmbientLight );\n\t\t\t\tscene.add( waterAmbientLight );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// animated model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tmodel.children[ 0 ].children[ 0 ].castShadow = true;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\t// objects\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst iceDiffuse = textureLoader.load( './textures/water.jpg' );\n\t\t\t\ticeDiffuse.wrapS = THREE.RepeatWrapping;\n\t\t\t\ticeDiffuse.wrapT = THREE.RepeatWrapping;\n\t\t\t\ticeDiffuse.colorSpace = THREE.NoColorSpace;\n\n\t\t\t\tconst iceColorNode = triplanarTexture( texture( iceDiffuse ) ).add( color( 0x0066ff ) ).mul( .8 );\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 3 );\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( { colorNode: iceColorNode } );\n\n\t\t\t\tconst count = 100;\n\t\t\t\tconst scale = 3.5;\n\t\t\t\tconst column = 10;\n\n\t\t\t\tobjects = new THREE.Group();\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst x = i % column;\n\t\t\t\t\tconst y = i / column;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( x * scale, 0, y * scale );\n\t\t\t\t\tmesh.rotation.set( Math.random(), Math.random(), Math.random() );\n\t\t\t\t\tobjects.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tobjects.position.set(\n\t\t\t\t\t( ( column - 1 ) * scale ) * - .5,\n\t\t\t\t\t- 1,\n\t\t\t\t\t( ( count / column ) * scale ) * - .5\n\t\t\t\t);\n\n\t\t\t\tscene.add( objects );\n\n\t\t\t\t// water\n\n\t\t\t\tconst timer = time.mul( .8 );\n\t\t\t\tconst floorUV = positionWorld.xzy;\n\n\t\t\t\tconst waterLayer0 = mx_worley_noise_float( floorUV.mul( 4 ).add( timer ) );\n\t\t\t\tconst waterLayer1 = mx_worley_noise_float( floorUV.mul( 2 ).add( timer ) );\n\n\t\t\t\tconst waterIntensity = waterLayer0.mul( waterLayer1 );\n\t\t\t\tconst waterColor = waterIntensity.mul( 1.4 ).mix( color( 0x0487e2 ), color( 0x74ccf4 ) );\n\n\t\t\t\t// linearDepth() returns the linear depth of the mesh\n\t\t\t\tconst depth = linearDepth();\n\t\t\t\tconst depthWater = viewportLinearDepth.sub( depth );\n\t\t\t\tconst depthEffect = depthWater.remapClamp( - .002, .04 );\n\n\t\t\t\tconst refractionUV = screenUV.add( vec2( 0, waterIntensity.mul( .1 ) ) );\n\n\t\t\t\t// linearDepth( viewportDepthTexture( uv ) ) return the linear depth of the scene\n\t\t\t\tconst depthTestForRefraction = linearDepth( viewportDepthTexture( refractionUV ) ).sub( depth );\n\n\t\t\t\tconst depthRefraction = depthTestForRefraction.remapClamp( 0, .1 );\n\n\t\t\t\tconst finalUV = depthTestForRefraction.lessThan( 0 ).select( screenUV, refractionUV );\n\n\t\t\t\tconst viewportTexture = viewportSharedTexture( finalUV );\n\n\t\t\t\tconst waterMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\twaterMaterial.colorNode = waterColor;\n\t\t\t\twaterMaterial.backdropNode = depthEffect.mix( viewportSharedTexture(), viewportTexture.mul( depthRefraction.mix( 1, waterColor ) ) );\n\t\t\t\twaterMaterial.backdropAlphaNode = depthRefraction.oneMinus();\n\t\t\t\twaterMaterial.transparent = true;\n\n\t\t\t\tconst water = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), waterMaterial );\n\t\t\t\twater.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( water );\n\n\t\t\t\t// floor\n\n\t\t\t\tfloor = new THREE.Mesh( new THREE.CylinderGeometry( 1.1, 1.1, 10 ), new THREE.MeshStandardNodeMaterial( { colorNode: iceColorNode } ) );\n\t\t\t\tfloor.position.set( 0, - 5, 0 );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// caustics\n\n\t\t\t\tconst waterPosY = positionWorld.y.sub( water.position.y );\n\n\t\t\t\tlet transition = waterPosY.add( .1 ).saturate().oneMinus();\n\t\t\t\ttransition = waterPosY.lessThan( 0 ).select( transition, normalWorld.y.mix( transition, 0 ) ).toVar();\n\n\t\t\t\tconst colorNode = transition.mix( material.colorNode, material.colorNode.add( waterLayer0 ) );\n\n\t\t\t\t//material.colorNode = colorNode;\n\t\t\t\tfloor.material.colorNode = colorNode;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.9;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = 1;\n\t\t\t\tcontrols.target.set( 0, .2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tfloorPosition = new THREE.Vector3( 0, .2, 0 );\n\n\t\t\t\tgui.add( floorPosition, 'y', - 1, 1, .001 ).name( 'position' );\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\t\t\t\tconst scenePassDepth = scenePass.getLinearDepthNode().remapClamp( .3, .5 );\n\n\t\t\t\tconst waterMask = objectPosition( camera ).y.greaterThan( screenUV.y.sub( .5 ).mul( camera.near ) );\n\n\t\t\t\tconst scenePassColorBlurred = gaussianBlur( scenePassColor );\n\t\t\t\tscenePassColorBlurred.directionNode = waterMask.select( scenePassDepth, scenePass.getLinearDepthNode().mul( 5 ) );\n\n\t\t\t\tconst vignette = screenUV.distance( .5 ).mul( 1.35 ).clamp().oneMinus();\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = waterMask.select( scenePassColorBlurred, scenePassColorBlurred.mul( color( 0x74ccf4 ) ).mul( vignette ) );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfloor.position.y = floorPosition.y - 5;\n\n\t\t\t\tif ( model ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t\tmodel.position.y = floorPosition.y;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const object of objects.children ) {\n\n\t\t\t\t\tobject.position.y = Math.sin( clock.elapsedTime + object.id ) * .3;\n\t\t\t\t\tobject.rotation.y += delta * .3;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Backdrop Water"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - cameras"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - cameras:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color } from 'three/tsl';\n\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tlet aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer, mesh;\n\t\t\tlet cameraRig, activeCamera, activeHelper;\n\t\t\tlet cameraPerspective, cameraOrtho;\n\t\t\tlet cameraPerspectiveHelper, cameraOrthoHelper;\n\t\t\tlet backgroundNode;\n\t\t\tconst frustumSize = 600;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );\n\t\t\t\tcamera.position.z = 2500;\n\n\t\t\t\tcameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 1000 );\n\n\t\t\t\tcameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );\n\t\t\t\tscene.add( cameraPerspectiveHelper );\n\n\t\t\t\t//\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );\n\n\t\t\t\tcameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );\n\t\t\t\tscene.add( cameraOrthoHelper );\n\n\t\t\t\t//\n\n\t\t\t\tactiveCamera = cameraPerspective;\n\t\t\t\tactiveHelper = cameraPerspectiveHelper;\n\n\n\t\t\t\t// counteract different front orientation of cameras vs rig\n\n\t\t\t\tcameraOrtho.rotation.y = Math.PI;\n\t\t\t\tcameraPerspective.rotation.y = Math.PI;\n\n\t\t\t\tcameraRig = new THREE.Group();\n\n\t\t\t\tcameraRig.add( cameraPerspective );\n\t\t\t\tcameraRig.add( cameraOrtho );\n\n\t\t\t\tscene.add( cameraRig );\n\n\t\t\t\t//\n\n\t\t\t\tmesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 100, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 50, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tmesh2.position.y = 150;\n\t\t\t\tmesh.add( mesh2 );\n\n\t\t\t\tconst mesh3 = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 5, 16, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )\n\t\t\t\t);\n\t\t\t\tmesh3.position.z = 150;\n\t\t\t\tcameraRig.add( mesh3 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < 10000; i ++ ) {\n\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // x\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // y\n\t\t\t\t\tvertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // z\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\tconst particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.setScissorTest( true );\n\t\t\t\tbackgroundNode = color( 0x111111 );\n\t\t\t\trenderer.setClearColor( 0x000000, 1 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\tcase 79: /*O*/\n\n\t\t\t\t\t\tactiveCamera = cameraOrtho;\n\t\t\t\t\t\tactiveHelper = cameraOrthoHelper;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 80: /*P*/\n\n\t\t\t\t\t\tactiveCamera = cameraPerspective;\n\t\t\t\t\t\tactiveHelper = cameraPerspectiveHelper;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\t\t\t\taspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = 0.5 * aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tcameraPerspective.aspect = 0.5 * aspect;\n\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = - 0.5 * frustumSize * aspect / 2;\n\t\t\t\tcameraOrtho.right = 0.5 * frustumSize * aspect / 2;\n\t\t\t\tcameraOrtho.top = frustumSize / 2;\n\t\t\t\tcameraOrtho.bottom = - frustumSize / 2;\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst r = Date.now() * 0.0005;\n\n\t\t\t\tmesh.position.x = 700 * Math.cos( r );\n\t\t\t\tmesh.position.z = 700 * Math.sin( r );\n\t\t\t\tmesh.position.y = 700 * Math.sin( r );\n\n\t\t\t\tmesh.children[ 0 ].position.x = 70 * Math.cos( 2 * r );\n\t\t\t\tmesh.children[ 0 ].position.z = 70 * Math.sin( r );\n\n\t\t\t\tif ( activeCamera === cameraPerspective ) {\n\n\t\t\t\t\tcameraPerspective.fov = 35 + 30 * Math.sin( 0.5 * r );\n\t\t\t\t\tcameraPerspective.far = mesh.position.length();\n\t\t\t\t\tcameraPerspective.updateProjectionMatrix();\n\n\t\t\t\t\tcameraPerspectiveHelper.update();\n\t\t\t\t\tcameraPerspectiveHelper.visible = true;\n\n\t\t\t\t\tcameraOrthoHelper.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcameraOrtho.far = mesh.position.length();\n\t\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\t\tcameraOrthoHelper.update();\n\t\t\t\t\tcameraOrthoHelper.visible = true;\n\n\t\t\t\t\tcameraPerspectiveHelper.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\tcameraRig.lookAt( mesh.position );\n\n\t\t\t\t//\n\n\t\t\t\tactiveHelper.visible = false;\n\n\t\t\t\trenderer.autoClear = true;\n\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.setViewport( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\tscene.backgroundNode = null;\n\t\t\t\trenderer.render( scene, activeCamera );\n\n\t\t\t\t//\n\n\t\t\t\tactiveHelper.visible = true;\n\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.setViewport( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\tscene.backgroundNode = backgroundNode;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - cameras O orthographic P perspective"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - arraycamera"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - arraycamera:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mesh;\n\t\t\tlet stats;\n\n\t\t\tconst AMOUNT = 6;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst subCameras = [];\n\n\t\t\t\tfor ( let i = 0; i < AMOUNT * AMOUNT; i ++ ) {\n\n\t\t\t\t\tconst subCamera = new THREE.PerspectiveCamera( 40, 1, 0.1, 10 );\n\t\t\t\t\tsubCamera.viewport = new THREE.Vector4();\n\n\t\t\t\t\tsubCameras.push( subCamera );\n\n\t\t\t\t}\n\n\t\t\t\tcamera = new THREE.ArrayCamera( subCameras );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tupdateCameras();\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x999999 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0.5, 0.5, 1 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.bias = - 0.001;\n\t\t\t\tlight.shadow.camera.zoom = 4; // tighter shadow map\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometryBackground = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tconst materialBackground = new THREE.MeshPhongMaterial( { color: 0x000066 } );\n\n\t\t\t\tconst background = new THREE.Mesh( geometryBackground, materialBackground );\n\t\t\t\tbackground.receiveShadow = true;\n\t\t\t\tbackground.position.set( 0, 0, - 1 );\n\t\t\t\tscene.add( background );\n\n\t\t\t\tconst geometryCylinder = new THREE.CylinderGeometry( 0.5, 0.5, 1, 32 );\n\t\t\t\tconst materialCylinder = new THREE.MeshPhongMaterial( { color: 0xff0000 } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometryCylinder, materialCylinder );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( /*{ forceWebGL: true }*/ );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction updateCameras() {\n\n\t\t\t\tconst ASPECT_RATIO = window.innerWidth / window.innerHeight;\n\t\t\t\tconst WIDTH = window.innerWidth / AMOUNT;\n\t\t\t\tconst HEIGHT = window.innerHeight / AMOUNT;\n\n\t\t\t\tcamera.aspect = ASPECT_RATIO;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\tfor ( let y = 0; y < AMOUNT; y ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < AMOUNT; x ++ ) {\n\n\t\t\t\t\t\tconst subcamera = camera.cameras[ AMOUNT * y + x ];\n\t\t\t\t\t\tsubcamera.copy( camera ); // copy fov, aspect ratio, near, far from the root camera\n\n\t\t\t\t\t\tsubcamera.viewport.set( Math.floor( x * WIDTH ), Math.floor( y * HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );\n\t\t\t\t\t\tsubcamera.updateProjectionMatrix();\n\n\t\t\t\t\t\tsubcamera.position.x = ( x / AMOUNT ) - 0.5;\n\t\t\t\t\t\tsubcamera.position.y = 0.5 - ( y / AMOUNT );\n\t\t\t\t\t\tsubcamera.position.z = 1.5 + ( ( x + y ) * .5 );\n\t\t\t\t\t\tsubcamera.position.multiplyScalar( 2 );\n\n\t\t\t\t\t\tsubcamera.lookAt( 0, 0, 0 );\n\t\t\t\t\t\tsubcamera.updateMatrixWorld();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tupdateCameras();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.x += 0.005;\n\t\t\t\tmesh.rotation.z += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - cameras - logarithmic depth buffer"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - cameras - logarithmic depth buffer:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\t// 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...\n\t\t\tconst NEAR = 1e-6, FAR = 1e27;\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight;\n\t\t\tlet screensplit = .25, screensplit_right = 0;\n\t\t\tconst mouse = [ .5, .5 ];\n\t\t\tlet zoompos = - 100, minzoomspeed = .015;\n\t\t\tlet zoomspeed = minzoomspeed;\n\n\t\t\tlet container, border, stats;\n\t\t\tconst objects = {};\n\n\t\t\t// Generate a number of text labels, from 1\u00b5m in size up to 100,000,000 light years\n\t\t\t// Try to use some descriptive real-world examples of objects at each scale\n\n\t\t\tconst labeldata = [\n\t\t\t\t{ size: .01, scale: 0.0001, label: 'microscopic (1\u00b5m)' }, // FIXME - triangulating text fails at this size, so we scale instead\n\t\t\t\t{ size: .01, scale: 0.1, label: 'minuscule (1mm)' },\n\t\t\t\t{ size: .01, scale: 1.0, label: 'tiny (1cm)' },\n\t\t\t\t{ size: 1, scale: 1.0, label: 'child-sized (1m)' },\n\t\t\t\t{ size: 10, scale: 1.0, label: 'tree-sized (10m)' },\n\t\t\t\t{ size: 100, scale: 1.0, label: 'building-sized (100m)' },\n\t\t\t\t{ size: 1000, scale: 1.0, label: 'medium (1km)' },\n\t\t\t\t{ size: 10000, scale: 1.0, label: 'city-sized (10km)' },\n\t\t\t\t{ size: 3400000, scale: 1.0, label: 'moon-sized (3,400 Km)' },\n\t\t\t\t{ size: 12000000, scale: 1.0, label: 'planet-sized (12,000 km)' },\n\t\t\t\t{ size: 1400000000, scale: 1.0, label: 'sun-sized (1,400,000 km)' },\n\t\t\t\t{ size: 7.47e12, scale: 1.0, label: 'solar system-sized (50Au)' },\n\t\t\t\t{ size: 9.4605284e15, scale: 1.0, label: 'gargantuan (1 light year)' },\n\t\t\t\t{ size: 3.08567758e16, scale: 1.0, label: 'ludicrous (1 parsec)' },\n\t\t\t\t{ size: 1e19, scale: 1.0, label: 'mind boggling (1000 light years)' }\n\t\t\t];\n\n\t\t\tinit().then( animate );\n\n\t\t\tasync function init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tconst font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );\n\n\t\t\t\tconst scene = initScene( font );\n\n\t\t\t\t// Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer\n\t\t\t\tobjects.normal = await initView( scene, 'normal', false );\n\t\t\t\tobjects.logzbuf = await initView( scene, 'logzbuf', true );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene\n\t\t\t\tborder = document.getElementById( 'renderer_border' );\n\t\t\t\tborder.addEventListener( 'pointerdown', onBorderPointerDown );\n\n\t\t\t\twindow.addEventListener( 'mousemove', onMouseMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.addEventListener( 'wheel', onMouseWheel );\n\n\t\t\t}\n\n\t\t\tasync function initView( scene, name, logDepthBuf ) {\n\n\t\t\t\tconst framecontainer = document.getElementById( 'container_' + name );\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, screensplit * SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true, logarithmicDepthBuffer: logDepthBuf } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH / 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\trenderer.domElement.id = 'renderer_' + name;\n\t\t\t\tframecontainer.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\treturn { container: framecontainer, renderer: renderer, scene: scene, camera: camera };\n\n\t\t\t}\n\n\t\t\tfunction initScene( font ) {\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x777777 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 100, 100, 100 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst materialargs = {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tspecular: 0x050505,\n\t\t\t\t\tshininess: 50,\n\t\t\t\t\temissive: 0x000000\n\t\t\t\t};\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.5, 24, 12 );\n\n\t\t\t\tfor ( let i = 0; i < labeldata.length; i ++ ) {\n\n\t\t\t\t\tconst scale = labeldata[ i ].scale || 1;\n\n\t\t\t\t\tconst labelgeo = new TextGeometry( labeldata[ i ].label, {\n\t\t\t\t\t\tfont: font,\n\t\t\t\t\t\tsize: labeldata[ i ].size,\n\t\t\t\t\t\tdepth: labeldata[ i ].size / 2\n\t\t\t\t\t} );\n\n\t\t\t\t\tlabelgeo.computeBoundingSphere();\n\n\t\t\t\t\t// center text\n\t\t\t\t\tlabelgeo.translate( - labelgeo.boundingSphere.radius, 0, 0 );\n\n\t\t\t\t\tmaterialargs.color = new THREE.Color().setHSL( Math.random(), 0.5, 0.5 );\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( materialargs );\n\n\t\t\t\t\tconst group = new THREE.Group();\n\t\t\t\t\tgroup.position.z = - labeldata[ i ].size * scale;\n\t\t\t\t\tscene.add( group );\n\n\t\t\t\t\tconst textmesh = new THREE.Mesh( labelgeo, material );\n\t\t\t\t\ttextmesh.scale.set( scale, scale, scale );\n\t\t\t\t\ttextmesh.position.z = - labeldata[ i ].size * scale;\n\t\t\t\t\ttextmesh.position.y = labeldata[ i ].size / 4 * scale;\n\t\t\t\t\tgroup.add( textmesh );\n\n\t\t\t\t\tconst dotmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tdotmesh.position.y = - labeldata[ i ].size / 4 * scale;\n\t\t\t\t\tdotmesh.scale.multiplyScalar( labeldata[ i ].size * scale );\n\t\t\t\t\tgroup.add( dotmesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t\tfunction updateRendererSizes() {\n\n\t\t\t\t// Recalculate size for both renderers when screen size or split location changes\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tscreensplit_right = 1 - screensplit;\n\n\t\t\t\tobjects.normal.renderer.setSize( screensplit * SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tobjects.normal.camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tobjects.normal.camera.updateProjectionMatrix();\n\t\t\t\tobjects.normal.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT );\n\t\t\t\tobjects.normal.container.style.width = ( screensplit * 100 ) + '%';\n\n\t\t\t\tobjects.logzbuf.renderer.setSize( screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tobjects.logzbuf.camera.aspect = screensplit_right * SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tobjects.logzbuf.camera.updateProjectionMatrix();\n\t\t\t\tobjects.logzbuf.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_WIDTH * screensplit, 0, SCREEN_WIDTH * screensplit_right, SCREEN_HEIGHT );\n\t\t\t\tobjects.logzbuf.container.style.width = ( screensplit_right * 100 ) + '%';\n\n\t\t\t\tborder.style.left = ( screensplit * 100 ) + '%';\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\t// Put some limits on zooming\n\t\t\t\tconst minzoom = labeldata[ 0 ].size * labeldata[ 0 ].scale * 1;\n\t\t\t\tconst maxzoom = labeldata[ labeldata.length - 1 ].size * labeldata[ labeldata.length - 1 ].scale * 100;\n\t\t\t\tlet damping = ( Math.abs( zoomspeed ) > minzoomspeed ? .95 : 1.0 );\n\n\t\t\t\t// Zoom out faster the further out you go\n\t\t\t\tconst zoom = THREE.MathUtils.clamp( Math.pow( Math.E, zoompos ), minzoom, maxzoom );\n\t\t\t\tzoompos = Math.log( zoom );\n\n\t\t\t\t// Slow down quickly at the zoom limits\n\t\t\t\tif ( ( zoom == minzoom && zoomspeed < 0 ) || ( zoom == maxzoom && zoomspeed > 0 ) ) {\n\n\t\t\t\t\tdamping = .85;\n\n\t\t\t\t}\n\n\t\t\t\tzoompos += zoomspeed;\n\t\t\t\tzoomspeed *= damping;\n\n\t\t\t\tobjects.normal.camera.position.x = Math.sin( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.position.y = Math.sin( .25 * Math.PI * ( mouse[ 1 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.position.z = Math.cos( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;\n\t\t\t\tobjects.normal.camera.lookAt( objects.normal.scene.position );\n\n\t\t\t\t// Clone camera settings across both scenes\n\t\t\t\tobjects.logzbuf.camera.position.copy( objects.normal.camera.position );\n\t\t\t\tobjects.logzbuf.camera.quaternion.copy( objects.normal.camera.quaternion );\n\n\t\t\t\t// Update renderer sizes if the split has changed\n\t\t\t\tif ( screensplit_right != 1 - screensplit ) {\n\n\t\t\t\t\tupdateRendererSizes();\n\n\t\t\t\t}\n\n\t\t\t\tobjects.normal.renderer.render( objects.normal.scene, objects.normal.camera );\n\t\t\t\tobjects.logzbuf.renderer.render( objects.logzbuf.scene, objects.logzbuf.camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tupdateRendererSizes();\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerDown() {\n\n\t\t\t\t// activate draggable window resizing bar\n\t\t\t\twindow.addEventListener( 'pointermove', onBorderPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', onBorderPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerMove( ev ) {\n\n\t\t\t\tscreensplit = Math.max( 0, Math.min( 1, ev.clientX / window.innerWidth ) );\n\n\t\t\t}\n\n\t\t\tfunction onBorderPointerUp() {\n\n\t\t\t\twindow.removeEventListener( 'pointermove', onBorderPointerMove );\n\t\t\t\twindow.removeEventListener( 'pointerup', onBorderPointerUp );\n\n\t\t\t}\n\n\t\t\tfunction onMouseMove( ev ) {\n\n\t\t\t\tmouse[ 0 ] = ev.clientX / window.innerWidth;\n\t\t\t\tmouse[ 1 ] = ev.clientY / window.innerHeight;\n\n\t\t\t}\n\n\t\t\tfunction onMouseWheel( ev ) {\n\n\t\t\t\tconst amount = ev.deltaY;\n\t\t\t\tif ( amount === 0 ) return;\n\t\t\t\tconst dir = amount / Math.abs( amount );\n\t\t\t\tzoomspeed = dir / 10;\n\n\t\t\t\t// Slow down default zoom speed after user starts zooming, to give them more control\n\t\t\t\tminzoomspeed = 0.001;\n\n\t\t\t}\n```\n\nThis example three.js - cameras - logarithmic depth buffer mousewheel to dolly out"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - caustics"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - caustics:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { uniform, refract, div, positionViewDirection, positionLocal, normalView, texture, Fn, vec2, vec3, vec4 } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet stats;\n\t\t\tlet gltf;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.025, 5 );\n\t\t\t\tcamera.position.set( - 0.5, 0.35, 0.2 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// light\n\n\t\t\t\tconst spotLight = new THREE.SpotLight( 0xffffff, 1 );\n\t\t\t\tspotLight.position.set( .2, .3, .2 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.angle = Math.PI / 6;\n\t\t\t\tspotLight.penumbra = 1;\n\t\t\t\tspotLight.decay = 2;\n\t\t\t\tspotLight.distance = 0;\n\t\t\t\tspotLight.shadow.mapType = THREE.HalfFloatType; // For HDR Caustics\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tspotLight.shadow.camera.near = .1;\n\t\t\t\tspotLight.shadow.camera.far = 1;\n\t\t\t\tspotLight.shadow.bias = - .003;\n\t\t\t\tspotLight.shadow.intensity = .95;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\t// model / textures\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\n\t\t\t\tgltf = ( await new GLTFLoader().setDRACOLoader( dracoLoader ).loadAsync( './models/gltf/duck.glb' ) ).scene;\n\t\t\t\tgltf.scale.setScalar( .5 );\n\t\t\t\tscene.add( gltf );\n\n\t\t\t\tconst causticMap = new THREE.TextureLoader().load( './textures/opengameart/Caustic_Free.jpg' );\n\t\t\t\tcausticMap.wrapS = causticMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\tcausticMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// objects / material\n\n\t\t\t\tconst duck = gltf.children[ 0 ];\n\t\t\t\tduck.material = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\tduck.material.side = THREE.DoubleSide;\n\t\t\t\tduck.material.transparent = true;\n\t\t\t\tduck.material.color = new THREE.Color( 0xFFD700 );\n\t\t\t\tduck.material.transmission = 1;\n\t\t\t\tduck.material.thickness = .25;\n\t\t\t\tduck.material.ior = 1.5;\n\t\t\t\tduck.material.metalness = 0;\n\t\t\t\tduck.material.roughness = .1;\n\t\t\t\tduck.castShadow = true;\n\n\t\t\t\t// tsl shader\n\n\t\t\t\tconst causticOcclusion = uniform( 20 );\n\n\t\t\t\tduck.material.castShadowPositionNode = Fn( () => {\n\n\t\t\t\t\t// optional: add some distortion to the geometry shadow position if needed\n\n\t\t\t\t\treturn positionLocal;\n\n\t\t\t\t} )();\n\n\t\t\t\tduck.material.castShadowNode = Fn( () => {\n\n\t\t\t\t\tconst refractionVector = refract( positionViewDirection.negate(), normalView, div( 1.0, duck.material.ior ) ).normalize();\n\t\t\t\t\tconst viewZ = normalView.z.pow( causticOcclusion );\n\n\t\t\t\t\tconst textureUV = refractionVector.xy.mul( .6 );\n\n\t\t\t\t\tconst causticColor = uniform( duck.material.color );\n\t\t\t\t\tconst chromaticAberrationOffset = normalView.z.pow( - .9 ).mul( .004 );\n\n\t\t\t\t\tconst causticProjection = vec3(\n\t\t\t\t\t\ttexture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x.negate(), 0 ) ) ).r,\n\t\t\t\t\t\ttexture( causticMap, textureUV.add( vec2( 0, chromaticAberrationOffset.y.negate() ) ) ).g,\n\t\t\t\t\t\ttexture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x, chromaticAberrationOffset.y ) ) ).b\n\t\t\t\t\t);\n\n\t\t\t\t\treturn causticProjection.mul( viewZ.mul( 25 ) ).add( viewZ ).mul( causticColor );\n\n\t\t\t\t} )();\n\n\t\t\t\t//\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\t// glass\n\n\t\t\t\tconst colorMap = textureLoader.load( 'textures/colors.png' );\n\t\t\t\tcolorMap.wrapS = colorMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\tcolorMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst glassMaterial = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\tglassMaterial.map = colorMap;\n\t\t\t\tglassMaterial.side = THREE.DoubleSide;\n\t\t\t\tglassMaterial.transparent = true;\n\t\t\t\tglassMaterial.color = new THREE.Color( 0xffffff );\n\t\t\t\tglassMaterial.transmission = 1;\n\t\t\t\tglassMaterial.ior = 1.5;\n\t\t\t\tglassMaterial.metalness = 0;\n\t\t\t\tglassMaterial.roughness = .1;\n\t\t\t\tglassMaterial.castShadowNode = vec4( texture( colorMap ).rgb, .8 );\n\n\t\t\t\tconst glass = new THREE.Mesh( new THREE.PlaneGeometry( .2, .2 ), glassMaterial );\n\t\t\t\tglass.position.y = .1;\n\t\t\t\tglass.castShadow = true;\n\t\t\t\tglass.visible = false;\n\t\t\t\tscene.add( glass );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( causticOcclusion, 'value', 0, 20 ).name( 'caustic occlusion' );\n\t\t\t\tgui.addColor( duck.material, 'color' ).name( 'material color' );\n\t\t\t\tgui.add( { model: 'duck' }, 'model', [\n\t\t\t\t\t'duck',\n\t\t\t\t\t'glass'\n\t\t\t\t] ).onChange( model => {\n\n\t\t\t\t\tduck.visible = glass.visible = false;\n\n\t\t\t\t\tif ( model === 'duck' ) {\n\n\t\t\t\t\t\tduck.visible = true;\n\n\t\t\t\t\t} else if ( model === 'glass' ) {\n\n\t\t\t\t\t\tglass.visible = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst map = textureLoader.load( 'textures/hardwood2_diffuse.jpg' );\n\t\t\t\tmap.wrapS = map.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmap.repeat.set( 10, 10 );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0x999999, map } );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, material );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxDistance = 3;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tfor ( const mesh of gltf.children ) {\n\n\t\t\t\t\tmesh.rotation.y -= .01;\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - realtime caustics"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - centroid sampling"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - centroid sampling:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { varying, uv, texture, Fn } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet rendererAntialiasingEnabled;\n\t\t\tlet rendererAntialiasingDisabled;\n\t\t\tlet camera;\n\t\t\tlet scene;\n\t\t\tlet gui;\n\n\t\t\tconst effectController = {\n\t\t\t\tsampling: 'normal'\n\t\t\t};\n\n\t\t\tconst atlasCanvas = document.createElement( 'canvas' );\n\t\t\tatlasCanvas.width = 16;\n\t\t\tatlasCanvas.height = 16;\n\n\t\t\tconst ctx = atlasCanvas.getContext( '2d' );\n\t\t\tctx.fillStyle = 'red';\n\t\t\tctx.fillRect( 0, 0, 8, 8 );\n\n\t\t\tconst redUVs = [ 0, 1, 0.5, 1, 0.5, 0.5, 0, 0.5 ];\n\t\t\tctx.fillStyle = 'green';\n\t\t\tctx.fillRect( 8, 0, 8, 8 );\n\n\t\t\tconst greenUVs = [ 1, 1, 0.5, 1, 0.5, 0.5, 1, 0.5 ];\n\n\t\t\tctx.fillStyle = 'blue';\n\t\t\tctx.fillRect( 0, 8, 8, 8 );\n\n\t\t\tconst blueUVs = [ 0, 0, 0.5, 0, 0.5, 0.5, 0, 0.5 ];\n\n\t\t\tctx.fillStyle = 'yellow';\n\t\t\tctx.fillRect( 8, 8, 8, 8 );\n\n\t\t\tconst yellowUVs = [ 1, 0, 0.5, 0, 0.5, 0.5, 1, 0.5 ];\n\n\t\t\tconst faces = [ redUVs, greenUVs, blueUVs, yellowUVs ];\n\n\t\t\tconst canvasTexture = new THREE.CanvasTexture( atlasCanvas );\n\t\t\tcanvasTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\tcanvasTexture.mapping = THREE.UVMapping;\n\t\t\tcanvasTexture.wrapS = THREE.RepeatWrapping;\n\t\t\tcanvasTexture.wrapT = THREE.RepeatWrapping;\n\t\t\tcanvasTexture.magFilter = THREE.NearestFilter;\n\t\t\tcanvasTexture.minFilter = THREE.NearestFilter;\n\t\t\tcanvasTexture.format = THREE.RGBAFormat;\n\t\t\tcanvasTexture.type = THREE.UnsignedByteType;\n\n\t\t\tconst forceWebGL = false;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera();\n\t\t\t\tcamera.fov = 60;\n\t\t\t\tcamera.near = 1;\n\t\t\t\tcamera.far = 2100;\n\t\t\t\tcamera.position.z = 50;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst makeFaceGeometry = ( uvs ) => {\n\n\t\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\t\tconst positions = [ - 1, - 1, 0, 1, - 1, 0, 1, 1, 0, - 1, 1, 0 ];\n\t\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t\t'position',\n\t\t\t\t\t\tnew THREE.BufferAttribute( new Float32Array( positions ), 3 )\n\t\t\t\t\t);\n\n\t\t\t\t\tconst indices = [ 0, 1, 2, 2, 3, 0 ];\n\t\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t\t'uv',\n\t\t\t\t\t\tnew THREE.BufferAttribute( new Float32Array( uvs ), 2 )\n\t\t\t\t\t);\n\n\t\t\t\t\treturn geometry;\n\t\t\t\n\t\t\t\t};\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tconst testUV = varying( uv(), 'testUV' );\n\n\t\t\t\tconst createShader = ( type, sampling ) => {\n\n\t\t\t\t\treturn Fn( () => {\n\n\t\t\t\t\t\ttestUV.setInterpolation( type, sampling );\n\n\t\t\t\t\t\treturn texture( canvasTexture, testUV ).rgb;\n\n\t\t\t\t\t} );\n\n\t\t\t\t};\n\n\t\t\t\tconst withFlatFirstShader = createShader( THREE.InterpolationSamplingType.FLAT, THREE.InterpolationSamplingMode.FIRST );\n\t\t\t\tconst withFlatEitherShader = createShader( THREE.InterpolationSamplingType.FLAT, THREE.InterpolationSamplingMode.EITHER );\n\n\t\t\t\tconst withSampleShader = Fn( () => {\n\n\t\t\t\t\ttestUV.setInterpolation( THREE.InterpolationSamplingType.PERSPECTIVE, THREE.InterpolationSamplingMode.SAMPLE );\n\n\t\t\t\t\treturn texture( canvasTexture, testUV ).rgb;\n\n\t\t\t\t} );\n\n\t\t\t\tconst withInterpolationShader = Fn( () => {\n\n\t\t\t\t\ttestUV.setInterpolation( THREE.InterpolationSamplingType.PERSPECTIVE, THREE.InterpolationSamplingMode.CENTROID );\n\n\t\t\t\t\treturn texture( canvasTexture, testUV ).rgb;\n\n\t\t\t\t} );\n\n\t\t\t\tconst withoutInterpolationShader = Fn( () => {\n\n\t\t\t\t\treturn texture( canvasTexture, uv() ).rgb;\n\n\t\t\t\t} );\n\n\t\t\t\tmaterial.colorNode = withoutInterpolationShader();\n\n\t\t\t\tconst faceMeshes = [];\n\n\t\t\t\tfor ( let x = - 5; x < 5; x ++ ) {\n\n\t\t\t\t\tfor ( let y = - 5; y < 5; y ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ Math.floor( Math.random() * faces.length ) ];\n\t\t\t\t\t\tconst geometry = makeFaceGeometry( face );\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\tmesh.position.set( x * 2, y * 2, 0 );\n\t\t\t\t\t\tfaceMeshes.push( mesh );\n\t\t\t\t\t\tscene.add( mesh );\n\t\t\t\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// Create Standard Renderer\n\t\t\t\trendererAntialiasingDisabled = new THREE.WebGPURenderer( {\n\t\t\t\t\tantialias: false,\n\t\t\t\t\tforceWebGL: forceWebGL\n\t\t\t\t} );\n\n\t\t\t\trendererAntialiasingDisabled.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trendererAntialiasingDisabled.setSize( window.innerWidth / 2, window.innerHeight );\n\t\t\t\trendererAntialiasingDisabled.setAnimationLoop( animateStandard );\n\n\t\t\t\t// Create antialiased renderer\n\t\t\t\trendererAntialiasingEnabled = new THREE.WebGPURenderer( {\n\t\t\t\t\tantialias: true,\n\t\t\t\t\tforceWebGL: forceWebGL\n\t\t\t\t} );\n\n\t\t\t\tdocument.body.querySelector( '#antialising-enabled' ).appendChild( rendererAntialiasingEnabled.domElement );\n\t\t\t\trendererAntialiasingEnabled.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trendererAntialiasingEnabled.setSize( window.innerWidth / 2, window.innerHeight );\n\t\t\t\trendererAntialiasingEnabled.setAnimationLoop( animateAliased );\n\t\t\t\n\t\t\t\tdocument.body.querySelector( '#antialising-disabled' ).appendChild( rendererAntialiasingDisabled.domElement );\n\t\t\t\tdocument.body.querySelector( '#antialising-disabled' ).appendChild( rendererAntialiasingDisabled.domElement );\n\n\t\t\t\tonWindowResize();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tgui.add( effectController, 'sampling', [\n\t\t\t\t\tTHREE.InterpolationSamplingMode.NORMAL,\n\t\t\t\t\tTHREE.InterpolationSamplingMode.CENTROID,\n\t\t\t\t\tTHREE.InterpolationSamplingMode.SAMPLE,\n\t\t\t\t\t'flat first',\n\t\t\t\t\t'flat either'\n\t\t\t\t] ).onChange( () => {\n\n\t\t\t\t\tconst interpolationShaderLib = {\n\t\t\t\t\t\t[ THREE.InterpolationSamplingMode.NORMAL ]: withoutInterpolationShader,\n\t\t\t\t\t\t[ THREE.InterpolationSamplingMode.CENTROID ]: withInterpolationShader,\n\t\t\t\t\t\t[ THREE.InterpolationSamplingMode.SAMPLE ]: withSampleShader,\n\t\t\t\t\t\t[ 'flat first' ]: withFlatFirstShader,\n\t\t\t\t\t\t[ 'flat either' ]: withFlatEitherShader\n\t\t\t\t\t};\n\n\t\t\t\t\tconst shader = interpolationShaderLib[ effectController.sampling ];\n\n\t\t\t\t\tfor ( let i = 0; i < faceMeshes.length; i ++ ) {\n\n\t\t\t\t\t\tfaceMeshes[ i ].material.colorNode = shader();\n\t\t\t\t\t\tfaceMeshes[ i ].material.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst halfWidth = window.innerWidth / 2;\n\t\t\t\trendererAntialiasingDisabled.setSize( halfWidth, window.innerHeight );\n\t\t\t\trendererAntialiasingEnabled.setSize( halfWidth, window.innerHeight );\n\t\t\t\tconst aspect = ( halfWidth ) / window.innerHeight;\n\t\t\t\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animateStandard() {\n\n\t\t\t\trendererAntialiasingDisabled.render( scene, camera );\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction animateAliased() {\n\n\t\t\t\trendererAntialiasingEnabled.render( scene, camera );\n\t\t\t\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materials - clearcoat"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materials - clearcoat:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';\n\n\t\t\timport { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet particleLight;\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.25, 50 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tnew HDRCubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/pisaHDR/' )\n\t\t\t\t\t.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],\n\t\t\t\t\t\tfunction ( texture ) {\n\n\t\t\t\t\t\t\tconst geometry = new THREE.SphereGeometry( .8, 64, 32 );\n\n\t\t\t\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\t\t\t\tconst diffuse = textureLoader.load( 'textures/carbon/Carbon.png' );\n\t\t\t\t\t\t\tdiffuse.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\t\tdiffuse.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tdiffuse.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tdiffuse.repeat.x = 10;\n\t\t\t\t\t\t\tdiffuse.repeat.y = 10;\n\n\t\t\t\t\t\t\tconst normalMap = textureLoader.load( 'textures/carbon/Carbon_Normal.png' );\n\t\t\t\t\t\t\tnormalMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap.repeat.x = 10;\n\t\t\t\t\t\t\tnormalMap.repeat.y = 10;\n\n\t\t\t\t\t\t\tconst normalMap2 = textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\n\n\t\t\t\t\t\t\tconst normalMap3 = new THREE.CanvasTexture( new FlakesTexture() );\n\t\t\t\t\t\t\tnormalMap3.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap3.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tnormalMap3.repeat.x = 10;\n\t\t\t\t\t\t\tnormalMap3.repeat.y = 6;\n\t\t\t\t\t\t\tnormalMap3.anisotropy = 16;\n\n\t\t\t\t\t\t\tconst normalMap4 = textureLoader.load( 'textures/golfball.jpg' );\n\n\t\t\t\t\t\t\tconst clearcoatNormalMap = textureLoader.load( 'textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png' );\n\n\t\t\t\t\t\t\t// car paint\n\n\t\t\t\t\t\t\tlet material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tclearcoatRoughness: 0.1,\n\t\t\t\t\t\t\t\tmetalness: 0.9,\n\t\t\t\t\t\t\t\troughness: 0.5,\n\t\t\t\t\t\t\t\tcolor: 0x0000ff,\n\t\t\t\t\t\t\t\tnormalMap: normalMap3,\n\t\t\t\t\t\t\t\tnormalScale: new THREE.Vector2( 0.15, 0.15 )\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tlet mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = - 1;\n\t\t\t\t\t\t\tmesh.position.y = 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// fibers\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\troughness: 0.5,\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tclearcoatRoughness: 0.1,\n\t\t\t\t\t\t\t\tmap: diffuse,\n\t\t\t\t\t\t\t\tnormalMap: normalMap\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = 1;\n\t\t\t\t\t\t\tmesh.position.y = 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// golf\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tmetalness: 0.0,\n\t\t\t\t\t\t\t\troughness: 0.1,\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tnormalMap: normalMap4,\n\t\t\t\t\t\t\t\tclearcoatNormalMap: clearcoatNormalMap,\n\n\t\t\t\t\t\t\t\t// y scale is negated to compensate for normal map handedness.\n\t\t\t\t\t\t\t\tclearcoatNormalScale: new THREE.Vector2( 2.0, - 2.0 )\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = - 1;\n\t\t\t\t\t\t\tmesh.position.y = - 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// clearcoat + normalmap\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\tclearcoat: 1.0,\n\t\t\t\t\t\t\t\tmetalness: 1.0,\n\t\t\t\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\t\t\t\tnormalMap: normalMap2,\n\t\t\t\t\t\t\t\tnormalScale: new THREE.Vector2( 0.15, 0.15 ),\n\t\t\t\t\t\t\t\tclearcoatNormalMap: clearcoatNormalMap,\n\n\t\t\t\t\t\t\t\t// y scale is negated to compensate for normal map handedness.\n\t\t\t\t\t\t\t\tclearcoatNormalScale: new THREE.Vector2( 2.0, - 2.0 )\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = 1;\n\t\t\t\t\t\t\tmesh.position.y = - 1;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t);\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tparticleLight = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( .05, 8, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff } )\n\t\t\t\t);\n\t\t\t\tscene.add( particleLight );\n\n\t\t\t\tparticleLight.add( new THREE.PointLight( 0xffffff, 30 ) );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.25;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 30;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.00025;\n\n\t\t\t\tparticleLight.position.x = Math.sin( timer * 7 ) * 3;\n\t\t\t\tparticleLight.position.y = Math.cos( timer * 5 ) * 4;\n\t\t\t\tparticleLight.position.z = Math.cos( timer * 3 ) * 3;\n\n\t\t\t\tfor ( let i = 0; i < group.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = group.children[ i ];\n\t\t\t\t\tchild.rotation.y += 0.005;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - clearcoat"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - clipping planes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - clipping planes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, startTime, object, stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 16 );\n\n\t\t\t\tcamera.position.set( 0, 1.3, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst spotLight = new THREE.SpotLight( 0xffffff, 60 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.2;\n\t\t\t\tspotLight.position.set( 2, 3, 3 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 3;\n\t\t\t\tspotLight.shadow.camera.far = 10;\n\t\t\t\tspotLight.shadow.mapSize.width = 2048;\n\t\t\t\tspotLight.shadow.mapSize.height = 2048;\n\t\t\t\tspotLight.shadow.bias = - 0.002;\n\t\t\t\tspotLight.shadow.radius = 4;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0x55505a, 3 );\n\t\t\t\tdirLight.position.set( 0, 3, 0 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 10;\n\n\t\t\t\tdirLight.shadow.camera.right = 1;\n\t\t\t\tdirLight.shadow.camera.left = - 1;\n\t\t\t\tdirLight.shadow.camera.top\t= 1;\n\t\t\t\tdirLight.shadow.camera.bottom = - 1;\n\n\t\t\t\tdirLight.shadow.mapSize.width = 1024;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// Clipping planes\n\n\t\t\t\tconst globalPlane = new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 0.1 );\n\t\t\t\tconst localPlane1 = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );\n\t\t\t\tconst localPlane2 = new THREE.Plane( new THREE.Vector3( 0, 0, - 1 ), 0.1 );\n\n\t\t\t\t// Clipping Groups\n\n\t\t\t\tconst globalClippingGroup = new THREE.ClippingGroup();\n\t\t\t\tglobalClippingGroup.clippingPlanes = [ globalPlane ];\n\n\t\t\t\tconst knotClippingGroup = new THREE.ClippingGroup();\n\t\t\t\tknotClippingGroup.clippingPlanes = [ localPlane1, localPlane2 ];\n\t\t\t\tknotClippingGroup.clipIntersection = true;\n\n\t\t\t\tscene.add( globalClippingGroup );\n\t\t\t\tglobalClippingGroup.add( knotClippingGroup );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tconst material = new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolor: 0x80ee10,\n\t\t\t\t\tshininess: 0,\n\t\t\t\t\tside: THREE.DoubleSide,\n\n\t\t\t\t\t// ***** Clipping setup (material): *****\n\t\t\t\t\talphaToCoverage: true\n\t\t\t\t} );\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 0.4, 0.08, 95, 20 );\n\n\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\t\t\tobject.castShadow = true;\n\t\t\t\tknotClippingGroup.add( object );\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 9, 9, 1, 1 ),\n\t\t\t\t\tnew THREE.MeshPhongNodeMaterial( { color: 0xa0adaf, shininess: 150, alphaToCoverage: true } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tglobalClippingGroup.add( ground );\n\n\t\t\t\t// Stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// Renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI(),\n\t\t\t\t\tprops = {\n\t\t\t\t\t\talphaToCoverage: true,\n\t\t\t\t\t},\n\t\t\t\t\tfolderKnot = gui.addFolder( 'Knot Clipping Group' ),\n\t\t\t\t\tpropsKnot = {\n\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn knotClippingGroup.enabled;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\tknotClippingGroup.enabled = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Shadows'() {\n\n\t\t\t\t\t\t\treturn knotClippingGroup.clipShadows;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Shadows'( v ) {\n\n\t\t\t\t\t\t\tknotClippingGroup.clipShadows = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Intersection'() {\n\n\t\t\t\t\t\t\treturn knotClippingGroup.clipIntersection;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tset 'Intersection'( v ) {\n\n\t\t\t\t\t\t\tknotClippingGroup.clipIntersection = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Plane'() {\n\n\t\t\t\t\t\t\treturn localPlane1.constant;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Plane'( v ) {\n\n\t\t\t\t\t\t\tlocalPlane1.constant = v;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfolderGlobal = gui.addFolder( 'Global Clipping Group' ),\n\t\t\t\t\tpropsGlobal = {\n\n\t\t\t\t\t\tget 'Enabled'() {\n\n\t\t\t\t\t\t\treturn globalClippingGroup.enabled;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Enabled'( v ) {\n\n\t\t\t\t\t\t\tglobalClippingGroup.enabled = v;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tget 'Plane'() {\n\n\t\t\t\t\t\t\treturn globalPlane.constant;\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset 'Plane'( v ) {\n\n\t\t\t\t\t\t\tglobalPlane.constant = v;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\tgui.add( props, 'alphaToCoverage' ).onChange( function ( value ) {\n\n\t\t\t\t\tground.material.alphaToCoverage = value;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t\t\tmaterial.alphaToCoverage = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tfolderKnot.add( propsKnot, 'Enabled' );\n\t\t\t\tfolderKnot.add( propsKnot, 'Shadows' );\n\t\t\t\tfolderKnot.add( propsKnot, 'Intersection' );\n\t\t\t\tfolderKnot.add( propsKnot, 'Plane', 0.3, 1.25 );\n\n\t\t\t\tfolderGlobal.add( propsGlobal, 'Enabled' );\n\t\t\t\tfolderGlobal.add( propsGlobal, 'Plane', - 0.4, 3 );\n\n\t\t\t\t// Start\n\n\t\t\t\tstartTime = Date.now();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate( currentTime ) {\n\n\t\t\t\tconst time = ( currentTime - startTime ) / 1000;\n\n\t\t\t\tobject.position.y = 0.8;\n\t\t\t\tobject.rotation.x = time * 0.5;\n\t\t\t\tobject.rotation.y = time * 0.2;\n\t\t\t\tobject.scale.setScalar( Math.cos( time ) * 0.125 + 0.875 );\n\n\t\t\t\tstats.begin();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - clipping"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Audio Processing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Audio Processing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, uniform, instanceIndex, instancedArray, float, texture, screenUV, color } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet computeNode;\n\t\t\tlet waveBuffer, sampleRate;\n\t\t\tlet waveArray;\n\t\t\tlet currentAudio, currentAnalyser;\n\t\t\tconst analyserBuffer = new Uint8Array( 1024 );\n\t\t\tlet analyserTexture;\n\n\t\t\tconst startButton = document.getElementById( 'startButton' );\n\t\t\tstartButton.addEventListener( 'click', init );\n\n\t\t\tasync function playAudioBuffer() {\n\n\t\t\t\tif ( currentAudio ) currentAudio.stop();\n\n\t\t\t\t// compute audio\n\n\t\t\t\tawait renderer.computeAsync( computeNode );\n\n\t\t\t\tconst wave = new Float32Array( await renderer.getArrayBufferAsync( waveArray.value ) );\n\n\t\t\t\t// play result\n\n\t\t\t\tconst audioOutputContext = new AudioContext( { sampleRate } );\n\t\t\t\tconst audioOutputBuffer = audioOutputContext.createBuffer( 1, wave.length, sampleRate );\n\n\t\t\t\taudioOutputBuffer.copyToChannel( wave, 0 );\n\n\t\t\t\tconst source = audioOutputContext.createBufferSource();\n\t\t\t\tsource.connect( audioOutputContext.destination );\n\t\t\t\tsource.buffer = audioOutputBuffer;\n\t\t\t\tsource.start();\n\n\t\t\t\tcurrentAudio = source;\n\n\t\t\t\t// visual feedback\n\n\t\t\t\tcurrentAnalyser = audioOutputContext.createAnalyser();\n\t\t\t\tcurrentAnalyser.fftSize = 2048;\n\n\t\t\t\tsource.connect( currentAnalyser );\n\n\t\t\t}\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\t\toverlay.remove();\n\n\t\t\t\t// audio buffer\n\n\t\t\t\tconst soundBuffer = await fetch( 'sounds/webgpu-audio-processing.mp3' ).then( res => res.arrayBuffer() );\n\t\t\t\tconst audioContext = new AudioContext();\n\n\t\t\t\tconst audioBuffer = await audioContext.decodeAudioData( soundBuffer );\n\n\t\t\t\twaveBuffer = audioBuffer.getChannelData( 0 );\n\n\t\t\t\t// adding extra silence to delay and pitch\n\t\t\t\twaveBuffer = new Float32Array( [ ...waveBuffer, ...new Float32Array( 200000 ) ] );\n\n\t\t\t\tsampleRate = audioBuffer.sampleRate / audioBuffer.numberOfChannels;\n\n\t\t\t\t// create webgpu buffers\n\n\t\t\t\twaveArray = instancedArray( waveBuffer );\n\n\t\t\t\t// read-only buffer\n\n\t\t\t\tconst originalWave = instancedArray( waveBuffer ).toReadOnly();\n\n\t\t\t\t// The Pixel Buffer Object (PBO) is required to get the GPU computed data to the CPU in the WebGL2 fallback.\n\t\t\t\t// As used in `renderer.getArrayBufferAsync( waveArray.value )`.\n\n\t\t\t\toriginalWave.setPBO( true );\n\t\t\t\twaveArray.setPBO( true );\n\n\t\t\t\t// params\n\n\t\t\t\tconst pitch = uniform( 1.5 );\n\t\t\t\tconst delayVolume = uniform( .2 );\n\t\t\t\tconst delayOffset = uniform( .55 );\n\n\n\t\t\t\t// compute (shader-node)\n\n\t\t\t\tconst computeShaderFn = Fn( () => {\n\n\t\t\t\t\tconst index = float( instanceIndex );\n\n\t\t\t\t\t// pitch\n\n\t\t\t\t\tconst time = index.mul( pitch );\n\n\t\t\t\t\tlet wave = originalWave.element( time );\n\n\n\t\t\t\t\t// delay\n\n\t\t\t\t\tfor ( let i = 1; i < 7; i ++ ) {\n\n\t\t\t\t\t\tconst waveOffset = originalWave.element( index.sub( delayOffset.mul( sampleRate ).mul( i ) ).mul( pitch ) );\n\t\t\t\t\t\tconst waveOffsetVolume = waveOffset.mul( delayVolume.div( i * i ) );\n\n\t\t\t\t\t\twave = wave.add( waveOffsetVolume );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// store\n\n\t\t\t\t\tconst waveStorageElementNode = waveArray.element( instanceIndex );\n\n\t\t\t\t\twaveStorageElementNode.assign( wave );\n\n\t\t\t\t} );\n\n\n\t\t\t\t// compute\n\n\t\t\t\tcomputeNode = computeShaderFn().compute( waveBuffer.length );\n\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( pitch, 'value', .5, 2, 0.01 ).name( 'pitch' );\n\t\t\t\tgui.add( delayVolume, 'value', 0, 1, .01 ).name( 'delayVolume' );\n\t\t\t\tgui.add( delayOffset, 'value', .1, 1, .01 ).name( 'delayOffset' );\n\n\n\t\t\t\t// renderer\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 30 );\n\n\n\t\t\t\t// nodes\n\n\t\t\t\tanalyserTexture = new THREE.DataTexture( analyserBuffer, analyserBuffer.length, 1, THREE.RedFormat );\n\n\t\t\t\tconst spectrum = texture( analyserTexture, screenUV.x ).x.mul( screenUV.y );\n\t\t\t\tconst backgroundNode = color( 0x0000FF ).mul( spectrum );\n\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = backgroundNode;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tdocument.addEventListener( 'click', playAudioBuffer );\n\n\t\t\t\tplayAudioBuffer();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( currentAnalyser ) {\n\n\t\t\t\t\tcurrentAnalyser.getByteFrequencyData( analyserBuffer );\n\n\t\t\t\t\tanalyserTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Audio Processing Click on screen to process the audio using WebGPU."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - compute - flocking"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - compute - flocking:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { uniform, varying, vec4, add, sub, max, dot, sin, mat3, uint, negate, instancedArray, cameraProjectionMatrix, cameraViewMatrix, positionLocal, modelWorldMatrix, sqrt, attribute, property, float, Fn, If, cos, Loop, Continue, normalize, instanceIndex, length } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'stats-gl';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet last = performance.now();\n\n\t\t\tlet pointer, raycaster;\n\t\t\tlet computeVelocity, computePosition, effectController;\n\n\t\t\tconst BIRDS = 16384;\n\t\t\tconst SPEED_LIMIT = 9.0;\n\t\t\tconst BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;\n\n\t\t\t// Custom Geometry - using 3 triangles each. No normals currently.\n\t\t\tclass BirdGeometry extends THREE.BufferGeometry {\n\n\t\t\t\tconstructor() {\n\n\t\t\t\t\tsuper();\n\n\t\t\t\t\tconst trianglesPerBird = 3;\n\t\t\t\t\tconst triangles = BIRDS * trianglesPerBird;\n\t\t\t\t\tconst points = triangles * 3;\n\n\t\t\t\t\tconst vertices = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );\n\t\t\t\t\tconst references = new THREE.BufferAttribute( new Uint32Array( points ), 1 );\n\t\t\t\t\tconst birdVertex = new THREE.BufferAttribute( new Uint32Array( points ), 1 );\n\n\t\t\t\t\tthis.setAttribute( 'position', vertices );\n\t\t\t\t\tthis.setAttribute( 'reference', references );\n\t\t\t\t\tthis.setAttribute( 'birdVertex', birdVertex );\n\n\t\t\t\t\tlet v = 0;\n\n\t\t\t\t\tfunction verts_push() {\n\n\t\t\t\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\t\t\tvertices.array[ v ++ ] = arguments[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wingsSpan = 20;\n\n\t\t\t\t\tfor ( let f = 0; f < BIRDS; f ++ ) {\n\n\t\t\t\t\t\t// Body\n\t\t\t\t\t\tverts_push(\n\t\t\t\t\t\t\t0, 0, - 20,\n\t\t\t\t\t\t\t0, - 8, 10,\n\t\t\t\t\t\t\t0, 0, 30\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Wings\n\t\t\t\t\t\tverts_push(\n\t\t\t\t\t\t\t0, 0, - 15,\n\t\t\t\t\t\t\t- wingsSpan, 0, 5,\n\t\t\t\t\t\t\t0, 0, 15\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tverts_push(\n\t\t\t\t\t\t\t0, 0, 15,\n\t\t\t\t\t\t\twingsSpan, 0, 5,\n\t\t\t\t\t\t\t0, 0, - 15\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let v = 0; v < triangles * 3; v ++ ) {\n\n\t\t\t\t\t\tconst triangleIndex = ~ ~ ( v / 3 );\n\t\t\t\t\t\tconst birdIndex = ~ ~ ( triangleIndex / trianglesPerBird );\n\n\t\t\t\t\t\treferences.array[ v ] = birdIndex;\n\n\t\t\t\t\t\tbirdVertex.array[ v ] = v % 9;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.scale( 0.2, 0.2, 0.2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0xffffff, 700, 3000 );\n\n\t\t\t\t// Pointer\n\n\t\t\t\tpointer = new THREE.Vector2();\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\t// Sky\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 6 );\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( {\n\t\t\t\t\t// Use vertex positions to create atmosphere colors\n\t\t\t\t\tcolorNode: varying(\n\t\t\t\t\t\tvec4(\n\t\t\t\t\t\t\tsub( 0.25, positionLocal.y ),\n\t\t\t\t\t\t\tsub( - 0.25, positionLocal.y ),\n\t\t\t\t\t\t\tadd( 1.5, positionLocal.y ),\n\t\t\t\t\t\t\t1.0\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\tside: THREE.BackSide\n\t\t\t\t} );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.rotation.z = 0.75;\n\t\t\t\tmesh.scale.setScalar( 1200 );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera );\n\t\t\t\tcontrols.connect( renderer.domElement );\n\n\t\t\t\t// Initialize position, velocity, and phase values\n\n\t\t\t\tconst positionArray = new Float32Array( BIRDS * 3 );\n\t\t\t\tconst velocityArray = new Float32Array( BIRDS * 3 );\n\t\t\t\tconst phaseArray = new Float32Array( BIRDS );\n\n\t\t\t\tfor ( let i = 0; i < BIRDS; i ++ ) {\n\n\t\t\t\t\tconst posX = Math.random() * BOUNDS - BOUNDS_HALF;\n\t\t\t\t\tconst posY = Math.random() * BOUNDS - BOUNDS_HALF;\n\t\t\t\t\tconst posZ = Math.random() * BOUNDS - BOUNDS_HALF;\n\n\t\t\t\t\tpositionArray[ i * 3 + 0 ] = posX;\n\t\t\t\t\tpositionArray[ i * 3 + 1 ] = posY;\n\t\t\t\t\tpositionArray[ i * 3 + 2 ] = posZ;\n\n\t\t\t\t\tconst velX = Math.random() - 0.5;\n\t\t\t\t\tconst velY = Math.random() - 0.5;\n\t\t\t\t\tconst velZ = Math.random() - 0.5;\n\n\t\t\t\t\tvelocityArray[ i * 3 + 0 ] = velX * 10;\n\t\t\t\t\tvelocityArray[ i * 3 + 1 ] = velY * 10;\n\t\t\t\t\tvelocityArray[ i * 3 + 2 ] = velZ * 10;\n\n\t\t\t\t\tphaseArray[ i ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\t// Labels applied to storage nodes and uniform nodes are reflected within the shader output,\n\t\t\t\t// and are useful for debugging purposes.\n\n\t\t\t\tconst positionStorage = instancedArray( positionArray, 'vec3' ).label( 'positionStorage' );\n\t\t\t\tconst velocityStorage = instancedArray( velocityArray, 'vec3' ).label( 'velocityStorage' );\n\t\t\t\tconst phaseStorage = instancedArray( phaseArray, 'float' ).label( 'phaseStorage' );\n\n\t\t\t\t// The Pixel Buffer Object (PBO) is required to get the GPU computed data in the WebGL2 fallback.\n\n\t\t\t\tpositionStorage.setPBO( true );\n\t\t\t\tvelocityStorage.setPBO( true );\n\t\t\t\tphaseStorage.setPBO( true );\n\n\t\t\t\t// Define Uniforms. Uniforms only need to be defined once rather than per shader.\n\n\t\t\t\teffectController = {\n\t\t\t\t\tseparation: uniform( 15.0 ).label( 'separation' ),\n\t\t\t\t\talignment: uniform( 20.0 ).label( 'alignment' ),\n\t\t\t\t\tcohesion: uniform( 20.0 ).label( 'cohesion' ),\n\t\t\t\t\tfreedom: uniform( 0.75 ).label( 'freedom' ),\n\t\t\t\t\tnow: uniform( 0.0 ),\n\t\t\t\t\tdeltaTime: uniform( 0.0 ).label( 'deltaTime' ),\n\t\t\t\t\trayOrigin: uniform( new THREE.Vector3() ).label( 'rayOrigin' ),\n\t\t\t\t\trayDirection: uniform( new THREE.Vector3() ).label( 'rayDirection' )\n\t\t\t\t};\n\n\t\t\t\t// Create geometry\n\n\t\t\t\tconst birdGeometry = new BirdGeometry();\n\t\t\t\tconst birdMaterial = new THREE.NodeMaterial();\n\n\t\t\t\t// Animate bird mesh within vertex shader, then apply position offset to vertices.\n\n\t\t\t\tconst birdVertexTSL = Fn( () => {\n\n\t\t\t\t\tconst reference = attribute( 'reference' );\n\t\t\t\t\tconst birdVertex = attribute( 'birdVertex' );\n\n\t\t\t\t\tconst position = positionLocal.toVar();\n\t\t\t\t\tconst newPhase = phaseStorage.element( reference ).toVar();\n\t\t\t\t\tconst newVelocity = normalize( velocityStorage.element( reference ) ).toVar();\n\n\t\t\t\t\tIf( birdVertex.equal( 4 ).or( birdVertex.equal( 7 ) ), () => {\n\n\t\t\t\t\t\t// flap wings\n\t\t\t\t\t\tposition.y = sin( newPhase ).mul( 5.0 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst newPosition = modelWorldMatrix.mul( position );\n\n\t\t\t\t\tnewVelocity.z.mulAssign( - 1.0 );\n\t\t\t\t\tconst xz = length( newVelocity.xz );\n\t\t\t\t\tconst xyz = float( 1.0 );\n\t\t\t\t\tconst x = sqrt( ( newVelocity.y.mul( newVelocity.y ) ).oneMinus() );\n\n\t\t\t\t\tconst cosry = newVelocity.x.div( xz ).toVar();\n\t\t\t\t\tconst sinry = newVelocity.z.div( xz ).toVar();\n\n\t\t\t\t\tconst cosrz = x.div( xyz );\n\t\t\t\t\tconst sinrz = newVelocity.y.div( xyz ).toVar();\n\n\t\t\t\t\t// Nodes must be negated with negate(). Using '-', their values will resolve to NaN.\n\t\t\t\t\tconst maty = mat3(\n\t\t\t\t\t\tcosry, 0, negate( sinry ),\n\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\tsinry, 0, cosry\n\t\t\t\t\t);\n\n\t\t\t\t\tconst matz = mat3(\n\t\t\t\t\t\tcosrz, sinrz, 0,\n\t\t\t\t\t\tnegate( sinrz ), cosrz, 0,\n\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tconst finalVert = maty.mul( matz ).mul( newPosition );\n\t\t\t\t\tfinalVert.addAssign( positionStorage.element( reference ) );\n\n\t\t\t\t\treturn cameraProjectionMatrix.mul( cameraViewMatrix ).mul( finalVert );\n\n\t\t\t\t} );\n\n\t\t\t\tbirdMaterial.vertexNode = birdVertexTSL();\n\t\t\t\tbirdMaterial.side = THREE.DoubleSide;\n\n\t\t\t\tconst birdMesh = new THREE.Mesh( birdGeometry, birdMaterial );\n\t\t\t\tbirdMesh.rotation.y = Math.PI / 2;\n\t\t\t\tbirdMesh.matrixAutoUpdate = false;\n\t\t\t\tbirdMesh.frustumCulled = false;\n\t\t\t\tbirdMesh.updateMatrix();\n\n\t\t\t\t// Define GPU Compute shaders.\n\t\t\t\t// Shaders are computationally identical to their GLSL counterparts outside of texture destructuring.\n\n\t\t\t\tcomputeVelocity = Fn( () => {\n\n\t\t\t\t\t// Define consts\n\t\t\t\t\tconst PI = float( 3.141592653589793 );\n\t\t\t\t\tconst PI_2 = PI.mul( 2.0 );\n\t\t\t\t\tconst limit = property( 'float', 'limit' ).assign( SPEED_LIMIT );\n\n\t\t\t\t\t// Destructure uniforms\n\t\t\t\t\tconst { alignment, separation, cohesion, deltaTime, rayOrigin, rayDirection } = effectController;\n\n\t\t\t\t\tconst zoneRadius = separation.add( alignment ).add( cohesion ).toConst();\n\t\t\t\t\tconst separationThresh = separation.div( zoneRadius ).toConst();\n\t\t\t\t\tconst alignmentThresh = ( separation.add( alignment ) ).div( zoneRadius ).toConst();\n\t\t\t\t\tconst zoneRadiusSq = zoneRadius.mul( zoneRadius ).toConst();\n\n\t\t\t\t\t// Cache current bird's position and velocity outside the loop\n\t\t\t\t\tconst birdIndex = instanceIndex.toConst( 'birdIndex' );\n\t\t\t\t\tconst position = positionStorage.element( birdIndex ).toVar();\n\t\t\t\t\tconst velocity = velocityStorage.element( birdIndex ).toVar();\n\n\t\t\t\t\t// Add influence of pointer position to velocity using cached position\n\t\t\t\t\tconst directionToRay = rayOrigin.sub( position ).toConst();\n\t\t\t\t\tconst projectionLength = dot( directionToRay, rayDirection ).toConst();\n\t\t\t\t\tconst closestPoint = rayOrigin.sub( rayDirection.mul( projectionLength ) ).toConst();\n\t\t\t\t\tconst directionToClosestPoint = closestPoint.sub( position ).toConst();\n\t\t\t\t\tconst distanceToClosestPoint = length( directionToClosestPoint ).toConst();\n\t\t\t\t\tconst distanceToClosestPointSq = distanceToClosestPoint.mul( distanceToClosestPoint ).toConst();\n\n\t\t\t\t\tconst rayRadius = float( 150.0 ).toConst();\n\t\t\t\t\tconst rayRadiusSq = rayRadius.mul( rayRadius ).toConst();\n\n\t\t\t\t\tIf( distanceToClosestPointSq.lessThan( rayRadiusSq ), () => {\n\n\t\t\t\t\t\tconst velocityAdjust = ( distanceToClosestPointSq.div( rayRadiusSq ).sub( 1.0 ) ).mul( deltaTime ).mul( 100.0 );\n\t\t\t\t\t\tvelocity.addAssign( normalize( directionToClosestPoint ).mul( velocityAdjust ) );\n\t\t\t\t\t\tlimit.addAssign( 5.0 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Attract flocks to center\n\t\t\t\t\tconst dirToCenter = position.toVar();\n\t\t\t\t\tdirToCenter.y.mulAssign( 2.5 );\n\t\t\t\t\tvelocity.subAssign( normalize( dirToCenter ).mul( deltaTime ).mul( 5.0 ) );\n\n\t\t\t\t\tLoop( { start: uint( 0 ), end: uint( BIRDS ), type: 'uint', condition: '<' }, ( { i } ) => {\n\n\t\t\t\t\t\tIf( i.equal( birdIndex ), () => {\n\n\t\t\t\t\t\t\tContinue();\n\t\t\t\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Cache bird's position and velocity\n\n\t\t\t\t\t\tconst birdPosition = positionStorage.element( i );\n\t\t\t\t\t\tconst dirToBird = birdPosition.sub( position );\n\t\t\t\t\t\tconst distToBird = length( dirToBird );\n\n\t\t\t\t\t\tIf( distToBird.lessThan( 0.0001 ), () => {\n\n\t\t\t\t\t\t\tContinue();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst distToBirdSq = distToBird.mul( distToBird );\n\n\t\t\t\t\t\t// Don't apply any changes to velocity if changes if the bird is outsize the zone's radius.\n\t\t\t\t\t\tIf( distToBirdSq.greaterThan( zoneRadiusSq ), () => {\n\n\t\t\t\t\t\t\tContinue();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Determine which threshold the bird is flying within and adjust its velocity accordingly\n\n\t\t\t\t\t\tconst percent = distToBirdSq.div( zoneRadiusSq );\n\n\t\t\t\t\t\tIf( percent.lessThan( separationThresh ), () => {\n\n\t\t\t\t\t\t\t// Separation - Move apart for comfort\n\t\t\t\t\t\t\tconst velocityAdjust = ( separationThresh.div( percent ).sub( 1.0 ) ).mul( deltaTime );\n\t\t\t\t\t\t\tvelocity.subAssign( normalize( dirToBird ).mul( velocityAdjust ) );\n\n\t\t\t\t\t\t} ).ElseIf( percent.lessThan( alignmentThresh ), () => {\n\n\t\t\t\t\t\t\t// Alignment - fly the same direction\n\t\t\t\t\t\t\tconst threshDelta = alignmentThresh.sub( separationThresh );\n\t\t\t\t\t\t\tconst adjustedPercent = ( percent.sub( separationThresh ) ).div( threshDelta );\n\t\t\t\t\t\t\tconst birdVelocity = velocityStorage.element( i );\n\n\t\t\t\t\t\t\tconst cosRange = cos( adjustedPercent.mul( PI_2 ) );\n\t\t\t\t\t\t\tconst cosRangeAdjust = float( 0.5 ).sub( cosRange.mul( 0.5 ) ).add( 0.5 );\n\t\t\t\t\t\t\tconst velocityAdjust = cosRangeAdjust.mul( deltaTime );\n\t\t\t\t\t\t\tvelocity.addAssign( normalize( birdVelocity ).mul( velocityAdjust ) );\n\n\t\t\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\t\t\t// Attraction / Cohesion - move closer\n\t\t\t\t\t\t\tconst threshDelta = alignmentThresh.oneMinus();\n\t\t\t\t\t\t\tconst adjustedPercent = threshDelta.equal( 0.0 ).select( 1.0, ( percent.sub( alignmentThresh ) ).div( threshDelta ) );\n\n\t\t\t\t\t\t\tconst cosRange = cos( adjustedPercent.mul( PI_2 ) );\n\t\t\t\t\t\t\tconst adj1 = cosRange.mul( - 0.5 );\n\t\t\t\t\t\t\tconst adj2 = adj1.add( 0.5 );\n\t\t\t\t\t\t\tconst adj3 = float( 0.5 ).sub( adj2 );\n\n\t\t\t\t\t\t\tconst velocityAdjust = adj3.mul( deltaTime );\n\t\t\t\t\t\t\tvelocity.addAssign( normalize( dirToBird ).mul( velocityAdjust ) );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tIf( length( velocity ).greaterThan( limit ), () => {\n\n\t\t\t\t\t\tvelocity.assign( normalize( velocity ).mul( limit ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Write back the final velocity to storage\n\t\t\t\t\tvelocityStorage.element( birdIndex ).assign( velocity );\n\n\t\t\t\t} )().compute( BIRDS );\n\t\t\t\tcomputePosition = Fn( () => {\n\n\t\t\t\t\tconst { deltaTime } = effectController;\n\t\t\t\t\tpositionStorage.element( instanceIndex ).addAssign( velocityStorage.element( instanceIndex ).mul( deltaTime ).mul( 15.0 ) );\n\n\t\t\t\t\tconst velocity = velocityStorage.element( instanceIndex );\n\t\t\t\t\tconst phase = phaseStorage.element( instanceIndex );\n\n\t\t\t\t\tconst modValue = phase.add( deltaTime ).add( length( velocity.xz ).mul( deltaTime ).mul( 3.0 ) ).add( max( velocity.y, 0.0 ).mul( deltaTime ).mul( 6.0 ) );\n\t\t\t\t\tphaseStorage.element( instanceIndex ).assign( modValue.mod( 62.83 ) );\n\n\t\t\t\t} )().compute( BIRDS );\n\n\t\t\t\tscene.add( birdMesh );\n\n\t\t\t\tstats = new Stats( {\n\t\t\t\t\tprecision: 3,\n\t\t\t\t\thorizontal: false,\n\t\t\t\t\ttrackGPU: true,\n\t\t\t\t\ttrackCPT: true\n\t\t\t\t} );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( effectController.separation, 'value', 0.0, 100.0, 1.0 ).name( 'Separation' );\n\t\t\t\tgui.add( effectController.alignment, 'value', 0.0, 100, 0.001 ).name( 'Alignment ' );\n\t\t\t\tgui.add( effectController.cohesion, 'value', 0.0, 100, 0.025 ).name( 'Cohesion' );\n\t\t\t\tgui.close();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2.0 - 1.0;\n\t\t\t\tpointer.y = 1.0 - ( event.clientY / window.innerHeight ) * 2.0;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\trenderer.resolveTimestampsAsync();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst now = performance.now();\n\t\t\t\tlet deltaTime = ( now - last ) / 1000;\n\n\t\t\t\tif ( deltaTime > 1 ) deltaTime = 1; // safety cap on large deltas\n\t\t\t\tlast = now;\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\teffectController.now.value = now;\n\t\t\t\teffectController.deltaTime.value = deltaTime;\n\t\t\t\teffectController.rayOrigin.value.copy( raycaster.ray.origin );\n\t\t\t\teffectController.rayDirection.value.copy( raycaster.ray.direction );\n\n\t\t\t\trenderer.compute( computeVelocity );\n\t\t\t\trenderer.compute( computePosition );\n\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// Move pointer away so we only affect birds when moving the mouse\n\t\t\t\tpointer.y = 10;\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js - webgpu compute birds Move mouse to disturb birds."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - compute cloth"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - compute cloth:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { Fn, If, Return, instancedArray, instanceIndex, uniform, select, attribute, uint, Loop, float, transformNormalToView, cross, triNoise3D, time } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\n\t\t\tconst clothWidth = 1;\n\t\t\tconst clothHeight = 1;\n\t\t\tconst clothNumSegmentsX = 30;\n\t\t\tconst clothNumSegmentsY = 30;\n\t\t\tconst sphereRadius = 0.15;\n\n\t\t\tlet vertexPositionBuffer, vertexForceBuffer, vertexParamsBuffer;\n\t\t\tlet springVertexIdBuffer, springRestLengthBuffer, springForceBuffer;\n\t\t\tlet springListBuffer;\n\t\t\tlet computeSpringForces, computeVertexForces;\n\t\t\tlet dampeningUniform, spherePositionUniform, stiffnessUniform, sphereUniform, windUniform;\n\t\t\tlet vertexWireframeObject, springWireframeObject;\n\t\t\tlet clothMesh, clothMaterial, sphere;\n\t\t\tlet timeSinceLastStep = 0;\n\t\t\tlet timestamp = 0;\n\t\t\tconst verletVertices = [];\n\t\t\tconst verletSprings = [];\n\t\t\tconst verletVertexColumns = [];\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst params = {\n\t\t\t\twireframe: false,\n\t\t\t\tsphere: true,\n\t\t\t\twind: 1.0,\n\t\t\t};\n\n\t\t\tconst API = {\n\t\t\t\tcolor: 0x204080, // sRGB\n\t\t\t\tsheenColor: 0xffffff // sRGB\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( - 1.6, - 0.1, - 1.6 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 3;\n\t\t\t\tcontrols.target.set( 0, - 0.1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader().setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst hdrTexture = await rgbeLoader.loadAsync( 'royal_esplanade_1k.hdr' );\n\t\t\t\thdrTexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\tscene.background = hdrTexture;\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\tscene.environment = hdrTexture;\n\n\t\t\t\tsetupCloth();\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( stiffnessUniform, 'value', 0.1, 0.5, 0.01 ).name( 'stiffness' );\n\t\t\t\tgui.add( params, 'wireframe' );\n\t\t\t\tgui.add( params, 'sphere' );\n\t\t\t\tgui.add( params, 'wind', 0, 5, 0.1 );\n\n\t\t\t\tconst materialFolder = gui.addFolder( 'material' );\n\t\t\t\tmaterialFolder.addColor( API, 'color' ).onChange( function ( color ) { clothMaterial.color.setHex( color ); } );\n\t\t\t\tmaterialFolder.add( clothMaterial, 'roughness', 0.0, 1, 0.01 );\n\t\t\t\tmaterialFolder.add( clothMaterial, 'sheen', 0.0, 1, 0.01 );\n\t\t\t\tmaterialFolder.add( clothMaterial, 'sheenRoughness', 0.0, 1, 0.01 );\n\t\t\t\tmaterialFolder.addColor( API, 'sheenColor' ).onChange( function ( color ) { clothMaterial.sheenColor.setHex( color ); } );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\trenderer.setAnimationLoop( render );\n\n\t\t\t}\n\n\t\t\tfunction setupVerletGeometry() {\n\n\t\t\t\t// this function sets up the geometry of the verlet system, a grid of vertices connected by springs\n\n\t\t\t\tconst addVerletVertex = ( x, y, z, isFixed ) => {\n\n\t\t\t\t\tconst id = verletVertices.length;\n\t\t\t\t\tconst vertex = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tposition: new THREE.Vector3( x, y, z ),\n\t\t\t\t\t\tisFixed,\n\t\t\t\t\t\tspringIds: [],\n\t\t\t\t\t};\n\t\t\t\t\tverletVertices.push( vertex );\n\t\t\t\t\treturn vertex;\n\n\t\t\t\t};\n\n\t\t\t\tconst addVerletSpring = ( vertex0, vertex1 ) => {\n\n\t\t\t\t\tconst id = verletSprings.length;\n\t\t\t\t\tconst spring = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tvertex0,\n\t\t\t\t\t\tvertex1\n\t\t\t\t\t};\n\t\t\t\t\tvertex0.springIds.push( id );\n\t\t\t\t\tvertex1.springIds.push( id );\n\t\t\t\t\tverletSprings.push( spring );\n\t\t\t\t\treturn spring;\n\n\t\t\t\t};\n\n\t\t\t\t// create the cloth's verlet vertices\n\t\t\t\tfor ( let x = 0; x <= clothNumSegmentsX; x ++ ) {\n\n\t\t\t\t\tconst column = [];\n\t\t\t\t\tfor ( let y = 0; y <= clothNumSegmentsY; y ++ ) {\n\n\t\t\t\t\t\tconst posX = x * ( clothWidth / clothNumSegmentsX ) - clothWidth * 0.5;\n\t\t\t\t\t\tconst posZ = y * ( clothHeight / clothNumSegmentsY );\n\t\t\t\t\t\tconst isFixed = ( y === 0 ) && ( ( x % 5 ) === 0 ); // make some of the top vertices' positions fixed\n\t\t\t\t\t\tconst vertex = addVerletVertex( posX, clothHeight * 0.5, posZ, isFixed );\n\t\t\t\t\t\tcolumn.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tverletVertexColumns.push( column );\n\n\t\t\t\t}\n\n\t\t\t\t// create the cloth's verlet springs\n\t\t\t\tfor ( let x = 0; x <= clothNumSegmentsX; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y <= clothNumSegmentsY; y ++ ) {\n\n\t\t\t\t\t\tconst vertex0 = verletVertexColumns[ x ][ y ];\n\t\t\t\t\t\tif ( x > 0 ) addVerletSpring( vertex0, verletVertexColumns[ x - 1 ][ y ] );\n\t\t\t\t\t\tif ( y > 0 ) addVerletSpring( vertex0, verletVertexColumns[ x ][ y - 1 ] );\n\t\t\t\t\t\tif ( x > 0 && y > 0 ) addVerletSpring( vertex0, verletVertexColumns[ x - 1 ][ y - 1 ] );\n\t\t\t\t\t\tif ( x > 0 && y < clothNumSegmentsY ) addVerletSpring( vertex0, verletVertexColumns[ x - 1 ][ y + 1 ] );\n\n\t\t\t\t\t\t// You can make the cloth more rigid by adding more springs between further apart vertices\n\t\t\t\t\t\t//if (x > 1) addVerletSpring(vertex0, verletVertexColumns[x - 2][y]);\n\t\t\t\t\t\t//if (y > 1) addVerletSpring(vertex0, verletVertexColumns[x][y - 2]);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setupVerletVertexBuffers() {\n\n\t\t\t\t// setup the buffers holding the vertex data for the compute shaders\n\n\t\t\t\tconst vertexCount = verletVertices.length;\n\n\t\t\t\tconst springListArray = [];\n\t\t\t\t// this springListArray will hold a list of spring ids, ordered by the id of the vertex affected by that spring.\n\t\t\t\t// this is so the compute shader that accumulates the spring forces for each vertex can efficiently iterate over all springs affecting that vertex\n\n\t\t\t\tconst vertexPositionArray = new Float32Array( vertexCount * 3 );\n\t\t\t\tconst vertexParamsArray = new Uint32Array( vertexCount * 3 );\n\t\t\t\t// the params Array holds three values for each verlet vertex:\n\t\t\t\t// x: isFixed, y: springCount, z: springPointer\n\t\t\t\t// isFixed is 1 if the verlet is marked as immovable, 0 if not\n\t\t\t\t// springCount is the number of springs connected to that vertex\n\t\t\t\t// springPointer is the index of the first spring in the springListArray that is connected to that vertex\n\n\t\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\t\tconst vertex = verletVertices[ i ];\n\t\t\t\t\tvertexPositionArray[ i * 3 ] = vertex.position.x;\n\t\t\t\t\tvertexPositionArray[ i * 3 + 1 ] = vertex.position.y;\n\t\t\t\t\tvertexPositionArray[ i * 3 + 2 ] = vertex.position.z;\n\t\t\t\t\tvertexParamsArray[ i * 3 ] = vertex.isFixed ? 1 : 0;\n\t\t\t\t\tif ( ! vertex.isFixed ) {\n\n\t\t\t\t\t\tvertexParamsArray[ i * 3 + 1 ] = vertex.springIds.length;\n\t\t\t\t\t\tvertexParamsArray[ i * 3 + 2 ] = springListArray.length;\n\t\t\t\t\t\tspringListArray.push( ...vertex.springIds );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvertexPositionBuffer = instancedArray( vertexPositionArray, 'vec3' ).setPBO( true ); // setPBO(true) is only important for the WebGL Fallback\n\t\t\t\tvertexForceBuffer = instancedArray( vertexCount, 'vec3' );\n\t\t\t\tvertexParamsBuffer = instancedArray( vertexParamsArray, 'uvec3' );\n\n\t\t\t\tspringListBuffer = instancedArray( new Uint32Array( springListArray ), 'uint' ).setPBO( true );\n\n\t\t\t}\n\n\t\t\tfunction setupVerletSpringBuffers() {\n\n\t\t\t\t// setup the buffers holding the spring data for the compute shaders\n\n\t\t\t\tconst springCount = verletSprings.length;\n\n\t\t\t\tconst springVertexIdArray = new Uint32Array( springCount * 2 );\n\t\t\t\tconst springRestLengthArray = new Float32Array( springCount );\n\n\t\t\t\tfor ( let i = 0; i < springCount; i ++ ) {\n\n\t\t\t\t\tconst spring = verletSprings[ i ];\n\t\t\t\t\tspringVertexIdArray[ i * 2 ] = spring.vertex0.id;\n\t\t\t\t\tspringVertexIdArray[ i * 2 + 1 ] = spring.vertex1.id;\n\t\t\t\t\tspringRestLengthArray[ i ] = spring.vertex0.position.distanceTo( spring.vertex1.position );\n\n\t\t\t\t}\n\n\t\t\t\tspringVertexIdBuffer = instancedArray( springVertexIdArray, 'uvec2' ).setPBO( true );\n\t\t\t\tspringRestLengthBuffer = instancedArray( springRestLengthArray, 'float' );\n\t\t\t\tspringForceBuffer = instancedArray( springCount * 3, 'vec3' ).setPBO( true );\n\n\t\t\t}\n\n\t\t\tfunction setupUniforms() {\n\n\t\t\t\tdampeningUniform = uniform( 0.99 );\n\t\t\t\tspherePositionUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );\n\t\t\t\tsphereUniform = uniform( 1.0 );\n\t\t\t\twindUniform = uniform( 1.0 );\n\t\t\t\tstiffnessUniform = uniform( 0.2 );\n\n\t\t\t}\n\n\t\t\tfunction setupComputeShaders() {\n\n\t\t\t\t// This function sets up the compute shaders for the verlet simulation\n\t\t\t\t// There are two shaders that are executed for each simulation step\n\n\t\t\t\tconst vertexCount = verletVertices.length;\n\t\t\t\tconst springCount = verletSprings.length;\n\n\t\t\t\t// 1. computeSpringForces:\n\t\t\t\t// This shader computes a force for each spring, depending on the distance between the two vertices connected by that spring and the targeted rest length\n\t\t\t\tcomputeSpringForces = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( uint( springCount ) ), () => {\n\n\t\t\t\t\t\t// compute Shaders are executed in groups of 64, so instanceIndex might be bigger than the amount of springs.\n\t\t\t\t\t\t// in that case, return.\n\t\t\t\t\t\tReturn();\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst vertexIds = springVertexIdBuffer.element( instanceIndex );\n\t\t\t\t\tconst restLength = springRestLengthBuffer.element( instanceIndex );\n\n\t\t\t\t\tconst vertex0Position = vertexPositionBuffer.element( vertexIds.x );\n\t\t\t\t\tconst vertex1Position = vertexPositionBuffer.element( vertexIds.y );\n\n\t\t\t\t\tconst delta = vertex1Position.sub( vertex0Position ).toVar();\n\t\t\t\t\tconst dist = delta.length().max( 0.000001 ).toVar();\n\t\t\t\t\tconst force = dist.sub( restLength ).mul( stiffnessUniform ).mul( delta ).mul( 0.5 ).div( dist );\n\t\t\t\t\tspringForceBuffer.element( instanceIndex ).assign( force );\n\n\t\t\t\t} )().compute( springCount );\n\n\t\t\t\t// 2. computeVertexForces:\n\t\t\t\t// This shader accumulates the force for each vertex.\n\t\t\t\t// First it iterates over all springs connected to this vertex and accumulates their forces.\n\t\t\t\t// Then it adds a gravital force, wind force, and the collision with the sphere.\n\t\t\t\t// In the end it adds the force to the vertex' position.\n\t\t\t\tcomputeVertexForces = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( uint( vertexCount ) ), () => {\n\n\t\t\t\t\t\t// compute Shaders are executed in groups of 64, so instanceIndex might be bigger than the amount of vertices.\n\t\t\t\t\t\t// in that case, return.\n\t\t\t\t\t\tReturn();\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst params = vertexParamsBuffer.element( instanceIndex ).toVar();\n\t\t\t\t\tconst isFixed = params.x;\n\t\t\t\t\tconst springCount = params.y;\n\t\t\t\t\tconst springPointer = params.z;\n\n\t\t\t\t\tIf( isFixed, () => {\n\n\t\t\t\t\t\t// don't need to calculate vertex forces if the vertex is set as immovable\n\t\t\t\t\t\tReturn();\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst position = vertexPositionBuffer.element( instanceIndex ).toVar( 'vertexPosition' );\n\t\t\t\t\tconst force = vertexForceBuffer.element( instanceIndex ).toVar( 'vertexForce' );\n\n\t\t\t\t\tforce.mulAssign( dampeningUniform );\n\n\t\t\t\t\tconst ptrStart = springPointer.toVar( 'ptrStart' );\n\t\t\t\t\tconst ptrEnd = ptrStart.add( springCount ).toVar( 'ptrEnd' );\n\n\t\t\t\t\tLoop( { start: ptrStart, end: ptrEnd, type: 'uint', condition: '<' }, ( { i } ) => {\n\n\t\t\t\t\t\tconst springId = springListBuffer.element( i ).toVar( 'springId' );\n\t\t\t\t\t\tconst springForce = springForceBuffer.element( springId );\n\t\t\t\t\t\tconst springVertexIds = springVertexIdBuffer.element( springId );\n\t\t\t\t\t\tconst factor = select( springVertexIds.x.equal( instanceIndex ), 1.0, - 1.0 );\n\t\t\t\t\t\tforce.addAssign( springForce.mul( factor ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// gravity\n\t\t\t\t\tforce.y.subAssign( 0.00005 );\n\n\t\t\t\t\t// wind\n\t\t\t\t\tconst noise = triNoise3D( position, 1, time ).sub( 0.2 ).mul( 0.0001 );\n\t\t\t\t\tconst windForce = noise.mul( windUniform );\n\t\t\t\t\tforce.z.subAssign( windForce );\n\n\t\t\t\t\t// collision with sphere\n\t\t\t\t\tconst deltaSphere = position.add( force ).sub( spherePositionUniform );\n\t\t\t\t\tconst dist = deltaSphere.length();\n\t\t\t\t\tconst sphereForce = float( sphereRadius ).sub( dist ).max( 0 ).mul( deltaSphere ).div( dist ).mul( sphereUniform );\n\t\t\t\t\tforce.addAssign( sphereForce );\n\n\t\t\t\t\tvertexForceBuffer.element( instanceIndex ).assign( force );\n\t\t\t\t\tvertexPositionBuffer.element( instanceIndex ).addAssign( force );\n\n\t\t\t\t} )().compute( vertexCount );\n\n\t\t\t}\n\n\t\t\tfunction setupWireframe() {\n\n\t\t\t\t// adds helpers to visualize the verlet system\n\n\t\t\t\t// verlet vertex visualizer\n\t\t\t\tconst vertexWireframeMaterial = new THREE.SpriteNodeMaterial();\n\t\t\t\tvertexWireframeMaterial.positionNode = vertexPositionBuffer.element( instanceIndex );\n\t\t\t\tvertexWireframeObject = new THREE.Mesh( new THREE.PlaneGeometry( 0.01, 0.01 ), vertexWireframeMaterial );\n\t\t\t\tvertexWireframeObject.frustumCulled = false;\n\t\t\t\tvertexWireframeObject.count = verletVertices.length;\n\t\t\t\tscene.add( vertexWireframeObject );\n\n\n\t\t\t\t// verlet spring visualizer\n\t\t\t\tconst springWireframePositionBuffer = new THREE.BufferAttribute( new Float32Array( 6 ), 3, false );\n\t\t\t\tconst springWireframeIndexBuffer = new THREE.BufferAttribute( new Uint32Array( [ 0, 1 ] ), 1, false );\n\t\t\t\tconst springWireframeMaterial = new THREE.LineBasicNodeMaterial();\n\t\t\t\tspringWireframeMaterial.positionNode = Fn( () => {\n\n\t\t\t\t\tconst vertexIds = springVertexIdBuffer.element( instanceIndex );\n\t\t\t\t\tconst vertexId = select( attribute( 'vertexIndex' ).equal( 0 ), vertexIds.x, vertexIds.y );\n\t\t\t\t\treturn vertexPositionBuffer.element( vertexId );\n\n\t\t\t\t} )();\n\n\t\t\t\tconst springWireframeGeometry = new THREE.InstancedBufferGeometry();\n\t\t\t\tspringWireframeGeometry.setAttribute( 'position', springWireframePositionBuffer );\n\t\t\t\tspringWireframeGeometry.setAttribute( 'vertexIndex', springWireframeIndexBuffer );\n\t\t\t\tspringWireframeGeometry.instanceCount = verletSprings.length;\n\n\t\t\t\tspringWireframeObject = new THREE.Line( springWireframeGeometry, springWireframeMaterial );\n\t\t\t\tspringWireframeObject.frustumCulled = false;\n\t\t\t\tspringWireframeObject.count = verletSprings.length;\n\t\t\t\tscene.add( springWireframeObject );\n\n\t\t\t}\n\n\t\t\tfunction setupSphere() {\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( sphereRadius * 0.95, 4 );\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tsphere = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t}\n\n\t\t\tfunction setupClothMesh() {\n\n\t\t\t\t// This function generates a three Geometry and Mesh to render the cloth based on the verlet systems position data.\n\t\t\t\t// Therefore it creates a plane mesh, in which each vertex will be centered in the center of 4 verlet vertices.\n\n\t\t\t\tconst vertexCount = clothNumSegmentsX * clothNumSegmentsY;\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\n\t\t\t\t// verletVertexIdArray will hold the 4 verlet vertex ids that contribute to each geometry vertex's position\n\t\t\t\tconst verletVertexIdArray = new Uint32Array( vertexCount * 4 );\n\t\t\t\tconst indices = [];\n\n\t\t\t\tconst getIndex = ( x, y ) => {\n\n\t\t\t\t\treturn y * clothNumSegmentsX + x;\n\n\t\t\t\t};\n\n\t\t\t\tfor ( let x = 0; x < clothNumSegmentsX; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < clothNumSegmentsX; y ++ ) {\n\n\t\t\t\t\t\tconst index = getIndex( x, y );\n\t\t\t\t\t\tverletVertexIdArray[ index * 4 ] = verletVertexColumns[ x ][ y ].id;\n\t\t\t\t\t\tverletVertexIdArray[ index * 4 + 1 ] = verletVertexColumns[ x + 1 ][ y ].id;\n\t\t\t\t\t\tverletVertexIdArray[ index * 4 + 2 ] = verletVertexColumns[ x ][ y + 1 ].id;\n\t\t\t\t\t\tverletVertexIdArray[ index * 4 + 3 ] = verletVertexColumns[ x + 1 ][ y + 1 ].id;\n\n\t\t\t\t\t\tif ( x > 0 && y > 0 ) {\n\n\t\t\t\t\t\t\tindices.push( getIndex( x, y ), getIndex( x - 1, y ), getIndex( x - 1, y - 1 ) );\n\t\t\t\t\t\t\tindices.push( getIndex( x, y ), getIndex( x - 1, y - 1 ), getIndex( x, y - 1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst verletVertexIdBuffer = new THREE.BufferAttribute( verletVertexIdArray, 4, false );\n\t\t\t\tconst positionBuffer = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3, false );\n\t\t\t\tgeometry.setAttribute( 'position', positionBuffer );\n\t\t\t\tgeometry.setAttribute( 'vertexIds', verletVertexIdBuffer );\n\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\tclothMaterial = new THREE.MeshPhysicalNodeMaterial( {\n\t\t\t\t\tcolor: new THREE.Color().setHex( API.color ),\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 0.85,\n\t\t\t\t\tsheen: 1.0,\n\t\t\t\t\tsheenRoughness: 0.5,\n\t\t\t\t\tsheenColor: new THREE.Color().setHex( API.sheenColor ),\n\t\t\t\t} );\n\n\t\t\t\tclothMaterial.positionNode = Fn( ( { material } ) => {\n\n\t\t\t\t\t// gather the position of the 4 verlet vertices and calculate the center position and normal from that\n\t\t\t\t\tconst vertexIds = attribute( 'vertexIds' );\n\t\t\t\t\tconst v0 = vertexPositionBuffer.element( vertexIds.x ).toVar();\n\t\t\t\t\tconst v1 = vertexPositionBuffer.element( vertexIds.y ).toVar();\n\t\t\t\t\tconst v2 = vertexPositionBuffer.element( vertexIds.z ).toVar();\n\t\t\t\t\tconst v3 = vertexPositionBuffer.element( vertexIds.w ).toVar();\n\n\t\t\t\t\tconst top = v0.add( v1 );\n\t\t\t\t\tconst right = v1.add( v3 );\n\t\t\t\t\tconst bottom = v2.add( v3 );\n\t\t\t\t\tconst left = v0.add( v2 );\n\n\t\t\t\t\tconst tangent = right.sub( left ).normalize();\n\t\t\t\t\tconst bitangent = bottom.sub( top ).normalize();\n\n\t\t\t\t\tconst normal = cross( tangent, bitangent );\n\n\t\t\t\t\t// send the normalView from the vertex shader to the fragment shader\n\t\t\t\t\tmaterial.normalNode = transformNormalToView( normal ).toVarying();\n\n\t\t\t\t\treturn v0.add( v1 ).add( v2 ).add( v3 ).mul( 0.25 );\n\n\t\t\t\t} )();\n\n\t\t\t\tclothMesh = new THREE.Mesh( geometry, clothMaterial );\n\t\t\t\tclothMesh.frustumCulled = false;\n\t\t\t\tscene.add( clothMesh );\n\n\t\t\t}\n\n\t\t\tfunction setupCloth() {\n\n\t\t\t\tsetupVerletGeometry();\n\t\t\t\tsetupVerletVertexBuffers();\n\t\t\t\tsetupVerletSpringBuffers();\n\t\t\t\tsetupUniforms();\n\t\t\t\tsetupComputeShaders();\n\t\t\t\tsetupWireframe();\n\t\t\t\tsetupSphere();\n\t\t\t\tsetupClothMesh();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction updateSphere() {\n\n\t\t\t\tsphere.position.set( Math.sin( timestamp * 2.1 ) * 0.1, 0, Math.sin( timestamp * 0.8 ) );\n\t\t\t\tspherePositionUniform.value.copy( sphere.position );\n\n\t\t\t}\n\n\t\t\tasync function render() {\n\n\t\t\t\tsphere.visible = params.sphere;\n\t\t\t\tsphereUniform.value = params.sphere ? 1 : 0;\n\t\t\t\twindUniform.value = params.wind;\n\t\t\t\tclothMesh.visible = ! params.wireframe;\n\t\t\t\tvertexWireframeObject.visible = params.wireframe;\n\t\t\t\tspringWireframeObject.visible = params.wireframe;\n\n\t\t\t\tconst deltaTime = Math.min( clock.getDelta(), 1 / 60 ); // don't advance the time too far, for example when the window is out of focus\n\t\t\t\tconst stepsPerSecond = 360; // ensure the same amount of simulation steps per second on all systems, independent of refresh rate\n\t\t\t\tconst timePerStep = 1 / stepsPerSecond;\n\n\t\t\t\ttimeSinceLastStep += deltaTime;\n\n\t\t\t\twhile ( timeSinceLastStep >= timePerStep ) {\n\n\t\t\t\t\t// run a verlet system simulation step\n\t\t\t\t\ttimestamp += timePerStep;\n\t\t\t\t\ttimeSinceLastStep -= timePerStep;\n\t\t\t\t\tupdateSphere();\n\t\t\t\t\tawait renderer.computeAsync( computeSpringForces );\n\t\t\t\t\tawait renderer.computeAsync( computeVertexForces );\n\n\t\t\t\t}\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - compute cloth Simple cloth simulation with a verlet system running in compute shaders"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - compute geometry"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - compute geometry:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { vec4, storage, Fn, If, uniform, instanceIndex, objectWorldMatrix, color, screenUV, attribute } from 'three/tsl';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet raycaster, pointer;\n\t\t\tlet stats;\n\n\t\t\tlet mesh;\n\n\t\t\tconst pointerPosition = uniform( vec4( 0 ) );\n\t\t\tconst elasticity = uniform( .4 ); // elasticity ( how \"strong\" the spring is )\n\t\t\tconst damping = uniform( .94 ); // damping factor ( energy loss )\n\t\t\tconst brushSize = uniform( .25 );\n\t\t\tconst brushStrength = uniform( .22 );\n\n\t\t\tinit();\n\n\t\t\tconst jelly = Fn( ( { renderer, geometry, object } ) => {\n\n\t\t\t\tconst count = geometry.attributes.position.count;\n\n\t\t\t\t// Create storage buffer attribute for modified position.\n\n\t\t\t\tconst positionBaseAttribute = geometry.attributes.position;\n\t\t\t\tconst positionStorageBufferAttribute = new THREE.StorageBufferAttribute( count, 3 );\n\t\t\t\tconst speedBufferAttribute = new THREE.StorageBufferAttribute( count, 3 );\n\n\t\t\t\tgeometry.setAttribute( 'storagePosition', positionStorageBufferAttribute );\n\n\t\t\t\t// Attributes\n\n\t\t\t\tconst positionAttribute = storage( positionBaseAttribute, 'vec3', count );\n\t\t\t\tconst positionStorageAttribute = storage( positionStorageBufferAttribute, 'vec3', count );\n\n\t\t\t\tconst speedAttribute = storage( speedBufferAttribute, 'vec3', count );\n\n\t\t\t\t// Vectors\n\n\t\t\t\t// Base vec3 position of the mesh vertices.\n\t\t\t\tconst basePosition = positionAttribute.element( instanceIndex );\n\t\t\t\t// Mesh vertices after compute modification.\n\t\t\t\tconst currentPosition = positionStorageAttribute.element( instanceIndex );\n\t\t\t\t// Speed of each mesh vertex.\n\t\t\t\tconst currentSpeed = speedAttribute.element( instanceIndex );\n\n\t\t\t\t//\n\n\t\t\t\tconst computeInit = Fn( () => {\n\n\t\t\t\t\t// Modified storage position starts out the same as the base position.\n\n\t\t\t\t\tcurrentPosition.assign( basePosition );\n\n\t\t\t\t} )().compute( count );\n\n\t\t\t\t//\n\n\t\t\t\tconst computeUpdate = Fn( () => {\n\n\t\t\t\t\t// pinch\n\n\t\t\t\t\tIf( pointerPosition.w.equal( 1 ), () => {\n\n\t\t\t\t\t\tconst worldPosition = objectWorldMatrix( object ).mul( currentPosition );\n\n\t\t\t\t\t\tconst dist = worldPosition.distance( pointerPosition.xyz );\n\t\t\t\t\t\tconst direction = pointerPosition.xyz.sub( worldPosition ).normalize();\n\n\t\t\t\t\t\tconst power = brushSize.sub( dist ).max( 0 ).mul( brushStrength );\n\n\t\t\t\t\t\tcurrentPosition.addAssign( direction.mul( power ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// compute ( jelly )\n\n\t\t\t\t\tconst distance = basePosition.distance( currentPosition );\n\t\t\t\t\tconst force = elasticity.mul( distance ).mul( basePosition.sub( currentPosition ) );\n\n\t\t\t\t\tcurrentSpeed.addAssign( force );\n\t\t\t\t\tcurrentSpeed.mulAssign( damping );\n\n\t\t\t\t\tcurrentPosition.addAssign( currentSpeed );\n\n\t\t\t\t} )().compute( count );\n\n\t\t\t\t// initialize the storage buffer with the base position\n\n\t\t\t\tcomputeUpdate.onInit( () => renderer.compute( computeInit ) );\n\n\t\t\t\t//\n\n\t\t\t\treturn computeUpdate;\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 0, 1 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\t\t\t\tpointer = new THREE.Vector2();\n\n\t\t\t\t// background\n\n\t\t\t\tconst bgColor = screenUV.y.mix( color( 0x9f87f7 ), color( 0xf2cdcd ) );\n\t\t\t\tconst bgVignette = screenUV.distance( .5 ).remapClamp( 0.3, .8 ).oneMinus();\n\t\t\t\tconst bgIntensity = 4;\n\n\t\t\t\tscene.backgroundNode = bgColor.mul( bgVignette.mul( color( 0xa78ff6 ).mul( bgIntensity ) ) );\n\n\t\t\t\t// model\n\n\t\t\t\tnew GLTFLoader().load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\t// create jelly effect material\n\n\t\t\t\t\tconst material = new THREE.MeshNormalNodeMaterial();\n\t\t\t\t\tmaterial.geometryNode = jelly();\n\t\t\t\t\tmaterial.positionNode = attribute( 'storagePosition' );\n\n\t\t\t\t\t// apply the material to the mesh\n\n\t\t\t\t\tmesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.scale.setScalar( .1 );\n\t\t\t\t\tmesh.material = material;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = .7;\n\t\t\t\tcontrols.maxDistance = 2;\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( elasticity, 'value', 0, .5 ).name( 'elasticity' );\n\t\t\t\tgui.add( damping, 'value', .9, .98 ).name( 'damping' );\n\t\t\t\tgui.add( brushSize, 'value', .1, .5 ).name( 'brush size' );\n\t\t\t\tgui.add( brushStrength, 'value', .1, .3 ).name( 'brush strength' );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObject( scene );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst intersect = intersects[ 0 ];\n\n\t\t\t\t\tpointerPosition.value.copy( intersect.point );\n\t\t\t\t\tpointerPosition.value.w = 1; // enable\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpointerPosition.value.w = 0; // disable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - compute geometry"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Compute Particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Compute Particles:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, If, uniform, float, uv, vec2, vec3, hash, shapeCircle,\n\t\t\t\tinstancedArray, instanceIndex } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst particleCount = 200_000;\n\n\t\t\tconst gravity = uniform( - .00098 );\n\t\t\tconst bounce = uniform( .8 );\n\t\t\tconst friction = uniform( .99 );\n\t\t\tconst size = uniform( .12 );\n\n\t\t\tconst clickPosition = uniform( new THREE.Vector3() );\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, stats;\n\t\t\tlet computeParticles;\n\n\t\t\tlet isOrbitControlsActive;\n\n\t\t\tconst timestamps = document.getElementById( 'timestamps' );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, innerWidth / innerHeight, .1, 1000 );\n\t\t\t\tcamera.position.set( 0, 5, 20 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst positions = instancedArray( particleCount, 'vec3' );\n\t\t\t\tconst velocities = instancedArray( particleCount, 'vec3' );\n\t\t\t\tconst colors = instancedArray( particleCount, 'vec3' );\n\n\t\t\t\t// compute\n\t\t\t\t\n\t\t\t\tconst separation = 0.2;\n\t\t\t\tconst amount = Math.sqrt( particleCount );\n\t\t\t\tconst offset = float( amount / 2 );\n\n\t\t\t\tconst computeInit = Fn( () => {\n\n\t\t\t\t\tconst position = positions.element( instanceIndex );\n\t\t\t\t\tconst color = colors.element( instanceIndex );\n\t\t\t\t\t\n\t\t\t\t\tconst x = instanceIndex.mod( amount );\n\t\t\t\t\tconst z = instanceIndex.div( amount );\n\t\t\t\t\t\n\t\t\t\t\tposition.x = offset.sub( x ).mul( separation );\n\t\t\t\t\tposition.z = offset.sub( z ).mul( separation );\n\n\t\t\t\t\tcolor.x = hash( instanceIndex );\n\t\t\t\t\tcolor.y = hash( instanceIndex.add( 2 ) );\n\n\t\t\t\t} )().compute( particleCount );\n\n\t\t\t\t//\n\n\t\t\t\tconst computeUpdate = Fn( () => {\n\n\t\t\t\t\tconst position = positions.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocities.element( instanceIndex );\n\n\t\t\t\t\tvelocity.addAssign( vec3( 0.00, gravity, 0.00 ) );\n\t\t\t\t\tposition.addAssign( velocity );\n\n\t\t\t\t\tvelocity.mulAssign( friction );\n\n\t\t\t\t\t// floor\n\n\t\t\t\t\tIf( position.y.lessThan( 0 ), () => {\n\n\t\t\t\t\t\tposition.y = 0;\n\t\t\t\t\t\tvelocity.y = velocity.y.negate().mul( bounce );\n\n\t\t\t\t\t\t// floor friction\n\n\t\t\t\t\t\tvelocity.x = velocity.x.mul( .9 );\n\t\t\t\t\t\tvelocity.z = velocity.z.mul( .9 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tcomputeParticles = computeUpdate().compute( particleCount );\n\n\t\t\t\t// create particles\n\n\t\t\t\tconst material = new THREE.SpriteNodeMaterial();\n\t\t\t\tmaterial.colorNode = uv().mul( colors.element( instanceIndex ) );\n\t\t\t\tmaterial.positionNode = positions.toAttribute();\n\t\t\t\tmaterial.scaleNode = size;\n\t\t\t\tmaterial.opacityNode = shapeCircle();\n\t\t\t\tmaterial.alphaToCoverage = true;\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\tconst particles = new THREE.Sprite( material );\n\t\t\t\tparticles.count = particleCount;\n\t\t\t\tparticles.frustumCulled = false;\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\tconst helper = new THREE.GridHelper( 90, 45, 0x303030, 0x303030 );\n\t\t\t\tscene.add( helper );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\t\tconst pointer = new THREE.Vector2();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, trackTimestamp: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.computeAsync( computeInit );\n\n\t\t\t\t// Hit\n\n\t\t\t\tconst computeHit = Fn( () => {\n\n\t\t\t\t\tconst position = positions.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocities.element( instanceIndex );\n\n\t\t\t\t\tconst dist = position.distance( clickPosition );\n\t\t\t\t\tconst direction = position.sub( clickPosition ).normalize();\n\t\t\t\t\tconst distArea = float( 3 ).sub( dist ).max( 0 );\n\n\t\t\t\t\tconst power = distArea.mul( .01 );\n\t\t\t\t\tconst relativePower = power.mul( hash( instanceIndex ).mul( 1.5 ).add( .5 ) );\n\n\t\t\t\t\tvelocity.assign( velocity.add( direction.mul( relativePower ) ) );\n\n\t\t\t\t} )().compute( particleCount );\n\n\t\t\t\t//\n\n\t\t\t\tfunction onMove( event ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( isOrbitControlsActive ) return;\n\n\t\t\t\t\tpointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );\n\n\t\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObject( plane, false );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tconst { point } = intersects[ 0 ];\n\n\t\t\t\t\t\t// move to uniform\n\n\t\t\t\t\t\tclickPosition.value.copy( point );\n\t\t\t\t\t\tclickPosition.value.y = - 1;\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\trenderer.computeAsync( computeHit );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.domElement.addEventListener( 'pointermove', onMove );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 200;\n\t\t\t\tcontrols.target.set( 0, -8, 0 );\n\t\t\t\tcontrols.update();\n\t\t\t\t\n\t\t\t\tcontrols.addEventListener( 'start', () => { isOrbitControlsActive = true; } );\n\t\t\t\tcontrols.addEventListener( 'end', () => { isOrbitControlsActive = false; } );\n\n\t\t\t\tcontrols.touches = {\n\t\t\t\t\tONE: null,\n\t\t\t\t\tTWO: THREE.TOUCH.DOLLY_PAN\n\t\t\t\t};\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( gravity, 'value', - .0098, 0, 0.0001 ).name( 'gravity' );\n\t\t\t\tgui.add( bounce, 'value', .1, 1, 0.01 ).name( 'bounce' );\n\t\t\t\tgui.add( friction, 'value', .96, .99, 0.01 ).name( 'friction' );\n\t\t\t\tgui.add( size, 'value', .12, .5, 0.01 ).name( 'size' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera.aspect = innerWidth / innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( innerWidth, innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tawait renderer.computeAsync( computeParticles );\n\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );\n\n\t\t\t\t// throttle the logging\n\n\t\t\t\tif ( renderer.hasFeature( 'timestamp-query' ) ) {\n\n\t\t\t\t\tif ( renderer.info.render.calls % 5 === 0 ) {\n\n\t\t\t\t\t\ttimestamps.innerHTML = `\n\n\t\t\t\t\t\t\tCompute ${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>\n\t\t\t\t\t\t\tDraw ${renderer.info.render.drawCalls} pass in ${renderer.info.render.timestamp.toFixed( 6 )}ms`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttimestamps.innerHTML = 'Timestamp queries not supported';\n\n\t\t\t\t}\n\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Compute - 500k Particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - compute fluid particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - compute fluid particles:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { Fn, If, Return, instancedArray, instanceIndex, uniform, attribute, uint, float, clamp, struct, atomicStore, int, ivec3, array, vec3, atomicAdd, Loop, atomicLoad, max, pow, mat3, vec4, cross, step } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst maxParticles = 8192 * 16;\n\t\t\tconst gridSize1d = 64;\n\t\t\tconst gridSize = new THREE.Vector3( gridSize1d, gridSize1d, gridSize1d );\n\t\t\tconst fixedPointMultiplier = 1e7;\n\n\t\t\tlet particleCountUniform, stiffnessUniform, restDensityUniform, dynamicViscosityUniform, dtUniform, gravityUniform, gridSizeUniform;\n\t\t\tlet particleBuffer, cellBuffer, cellBufferFloat;\n\t\t\tlet clearGridKernel, p2g1Kernel, p2g2Kernel, updateGridKernel, g2pKernel;\n\t\t\tlet particleMesh;\n\t\t\tconst mouseCoord = new THREE.Vector3();\n\t\t\tconst prevMouseCoord = new THREE.Vector3();\n\t\t\tlet mouseRayOriginUniform, mouseRayDirectionUniform, mouseForceUniform;\n\n\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t}\n\n\t\t\tconst gui = new GUI();\n\n\t\t\tconst params = {\n\t\t\t\tparticleCount: 8192 * 4,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.35;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( - 1.3, 1.3, - 1.3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 3;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.35;\n\t\t\t\tcontrols.touches = { TWO: THREE.TOUCH.DOLLY_ROTATE };\n\n\t\t\t\tconst rgbeLoader = new RGBELoader().setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst hdrTexture = await rgbeLoader.loadAsync( 'royal_esplanade_1k.hdr' );\n\t\t\t\thdrTexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\tscene.background = hdrTexture;\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\tscene.environment = hdrTexture;\n\n\t\t\t\tsetupParticles();\n\n\t\t\t\tgui.add( params, 'particleCount', 4096, maxParticles, 4096 ).onChange( value => {\n\n\t\t\t\t\tp2g1Kernel.count = value;\n\t\t\t\t\tp2g2Kernel.count = value;\n\t\t\t\t\tg2pKernel.count = value;\n\t\t\t\t\tp2g1Kernel.updateDispatchCount();\n\t\t\t\t\tp2g2Kernel.updateDispatchCount();\n\t\t\t\t\tg2pKernel.updateDispatchCount();\n\t\t\t\t\tparticleMesh.count = value;\n\t\t\t\t\tparticleCountUniform.value = value;\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.setAnimationLoop( render );\n\n\t\t\t}\n\n\t\t\tfunction setupBuffers() {\n\n\t\t\t\tconst particleStruct = struct( {\n\t\t\t\t\tposition: { type: 'vec3' },\n\t\t\t\t\tvelocity: { type: 'vec3' },\n\t\t\t\t\tC: { type: 'mat3' },\n\t\t\t\t} );\n\t\t\t\tconst particleStructSize = 20; // each vec3 occupies 4 floats and mat3 occupies 12 floats in memory because of webgpu memory alignment\n\t\t\t\tconst particleArray = new Float32Array( maxParticles * particleStructSize );\n\n\t\t\t\tfor ( let i = 0; i < maxParticles; i ++ ) {\n\n\t\t\t\t\tparticleArray[ i * particleStructSize ] = ( Math.random() * 0.8 + 0.1 );\n\t\t\t\t\tparticleArray[ i * particleStructSize + 1 ] = ( Math.random() * 0.8 + 0.1 );\n\t\t\t\t\tparticleArray[ i * particleStructSize + 2 ] = ( Math.random() * 0.8 + 0.1 );\n\n\t\t\t\t}\n\n\t\t\t\tparticleBuffer = instancedArray( particleArray, particleStruct );\n\n\t\t\t\tconst cellCount = gridSize.x * gridSize.y * gridSize.z;\n\n\t\t\t\tconst cellStruct = struct( {\n\t\t\t\t\tx: { type: 'int', atomic: true },\n\t\t\t\t\ty: { type: 'int', atomic: true },\n\t\t\t\t\tz: { type: 'int', atomic: true },\n\t\t\t\t\tmass: { type: 'int', atomic: true },\n\t\t\t\t} );\n\n\t\t\t\tcellBuffer = instancedArray( cellCount, cellStruct );\n\t\t\t\tcellBufferFloat = instancedArray( cellCount, 'vec4' );\n\n\t\t\t}\n\n\t\t\tfunction setupUniforms() {\n\n\t\t\t\tgridSizeUniform = uniform( gridSize );\n\t\t\t\tparticleCountUniform = uniform( params.particleCount, 'uint' );\n\t\t\t\tstiffnessUniform = uniform( 50 );\n\t\t\t\trestDensityUniform = uniform( 1.5 );\n\t\t\t\tdynamicViscosityUniform = uniform( 0.1 );\n\t\t\t\tdtUniform = uniform( 1 / 60 );\n\t\t\t\tgravityUniform = uniform( new THREE.Vector3( 0, - ( 9.81 * 9.81 ), 0 ) );\n\t\t\t\tmouseRayOriginUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );\n\t\t\t\tmouseRayDirectionUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );\n\t\t\t\tmouseForceUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );\n\n\t\t\t\t// gui.add(restDensityUniform, \"value\", 1.0, 3, 0.1).name(\"restDensity\");\n\t\t\t\t// it's interesting to adjust the restDensity but it might cause the simulation to become unstable\n\n\t\t\t}\n\n\t\t\tfunction setupComputeShaders() {\n\n\t\t\t\t// the MLS-MPM system uses five compute shaders:\n\t\t\t\t// 1. clearGridKernel: this clears the grid before each pass\n\t\t\t\t// 2. p2g1Kernel & 3. p2g2Kernel: These particle2grid kernels transfer the particles' energy to the grid\n\t\t\t\t// 4. updateGridKernel: updates the grid\n\t\t\t\t// 5. g2pKernel: grid2particle kernel, transfers the grid energy back to the particles\n\t\t\t\t// the implementation closely follows https://github.com/matsuoka-601/WebGPU-Ocean\n\n\t\t\t\t// because webgpu only supports int atomics, we use fixed point floats by multiplying/dividing the float values with a high integer constant\n\t\t\t\tconst encodeFixedPoint = ( f32 ) => {\n\n\t\t\t\t\treturn int( f32.mul( fixedPointMultiplier ) );\n\t\t\t\n\t\t\t\t};\n\n\t\t\t\tconst decodeFixedPoint = ( i32 ) => {\n\n\t\t\t\t\treturn float( i32 ).div( fixedPointMultiplier );\n\t\t\t\n\t\t\t\t};\n\n\t\t\t\tconst cellCount = gridSize.x * gridSize.y * gridSize.z;\n\t\t\t\tclearGridKernel = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( uint( cellCount ) ), () => {\n\n\t\t\t\t\t\tReturn();\n\t\t\t\n\t\t\t\t\t} );\n\n\t\t\t\t\tatomicStore( cellBuffer.element( instanceIndex ).get( 'x' ), 0 );\n\t\t\t\t\tatomicStore( cellBuffer.element( instanceIndex ).get( 'y' ), 0 );\n\t\t\t\t\tatomicStore( cellBuffer.element( instanceIndex ).get( 'z' ), 0 );\n\t\t\t\t\tatomicStore( cellBuffer.element( instanceIndex ).get( 'mass' ), 0 );\n\t\t\t\n\t\t\t\t} )().compute( cellCount );\n\n\t\t\t\tp2g1Kernel = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( particleCountUniform ), () => {\n\n\t\t\t\t\t\tReturn();\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\t\tconst particlePosition = particleBuffer.element( instanceIndex ).get( 'position' ).toConst( 'particlePosition' );\n\t\t\t\t\tconst particleVelocity = particleBuffer.element( instanceIndex ).get( 'velocity' ).toConst( 'particleVelocity' );\n\t\t\t\t\tconst C = particleBuffer.element( instanceIndex ).get( 'C' ).toConst( 'C' );\n\n\t\t\t\t\tconst gridPosition = particlePosition.mul( gridSizeUniform ).toVar();\n\t\t\t\t\tconst cellIndex = ivec3( gridPosition ).sub( 1 ).toConst( 'cellIndex' );\n\t\t\t\t\tconst cellDiff = gridPosition.fract().sub( 0.5 ).toConst( 'cellDiff' );\n\t\t\t\t\tconst w0 = float( 0.5 ).mul( float( 0.5 ).sub( cellDiff ) ).mul( float( 0.5 ).sub( cellDiff ) );\n\t\t\t\t\tconst w1 = float( 0.75 ).sub( cellDiff.mul( cellDiff ) );\n\t\t\t\t\tconst w2 = float( 0.5 ).mul( float( 0.5 ).add( cellDiff ) ).mul( float( 0.5 ).add( cellDiff ) );\n\t\t\t\t\tconst weights = array( [ w0, w1, w2 ] ).toConst( 'weights' );\n\n\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {\n\n\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {\n\n\t\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {\n\n\t\t\t\t\t\t\t\tconst weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );\n\t\t\t\t\t\t\t\tconst cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();\n\t\t\t\t\t\t\t\tconst cellDist = vec3( cellX ).add( 0.5 ).sub( gridPosition ).toConst( 'cellDist' );\n\t\t\t\t\t\t\t\tconst Q = C.mul( cellDist );\n\n\t\t\t\t\t\t\t\tconst massContrib = weight; // assuming particle mass = 1.0\n\t\t\t\t\t\t\t\tconst velContrib = massContrib.mul( particleVelocity.add( Q ) ).toConst( 'velContrib' );\n\t\t\t\t\t\t\t\tconst cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();\n\t\t\t\t\t\t\t\tconst cell = cellBuffer.element( cellPtr );\n\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'x' ), encodeFixedPoint( velContrib.x ) );\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'y' ), encodeFixedPoint( velContrib.y ) );\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'z' ), encodeFixedPoint( velContrib.z ) );\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'mass' ), encodeFixedPoint( massContrib ) );\n\t\t\t\n\t\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t} )().compute( params.particleCount );\n\n\t\t\t\tp2g2Kernel = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( particleCountUniform ), () => {\n\n\t\t\t\t\t\tReturn();\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\t\tconst particlePosition = particleBuffer.element( instanceIndex ).get( 'position' ).toConst( 'particlePosition' );\n\t\t\t\t\tconst gridPosition = particlePosition.mul( gridSizeUniform ).toVar();\n\n\t\t\t\t\tconst cellIndex = ivec3( gridPosition ).sub( 1 ).toConst( 'cellIndex' );\n\t\t\t\t\tconst cellDiff = gridPosition.fract().sub( 0.5 ).toConst( 'cellDiff' );\n\t\t\t\t\tconst w0 = float( 0.5 ).mul( float( 0.5 ).sub( cellDiff ) ).mul( float( 0.5 ).sub( cellDiff ) );\n\t\t\t\t\tconst w1 = float( 0.75 ).sub( cellDiff.mul( cellDiff ) );\n\t\t\t\t\tconst w2 = float( 0.5 ).mul( float( 0.5 ).add( cellDiff ) ).mul( float( 0.5 ).add( cellDiff ) );\n\t\t\t\t\tconst weights = array( [ w0, w1, w2 ] ).toConst( 'weights' );\n\n\t\t\t\t\tconst density = float( 0 ).toVar( 'density' );\n\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {\n\n\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {\n\n\t\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {\n\n\t\t\t\t\t\t\t\tconst weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );\n\t\t\t\t\t\t\t\tconst cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();\n\t\t\t\t\t\t\t\tconst cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();\n\t\t\t\t\t\t\t\tconst cell = cellBuffer.element( cellPtr );\n\t\t\t\t\t\t\t\tconst mass = decodeFixedPoint( atomicLoad( cell.get( 'mass' ) ) );\n\t\t\t\t\t\t\t\tdensity.addAssign( mass.mul( weight ) );\n\t\t\t\n\t\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst volume = float( 1 ).div( density );\n\t\t\t\t\tconst pressure = max( 0.0, pow( density.div( restDensityUniform ), 5.0 ).sub( 1 ).mul( stiffnessUniform ) ).toConst( 'pressure' );\n\t\t\t\t\tconst stress = mat3( pressure.negate(), 0, 0, 0, pressure.negate(), 0, 0, 0, pressure.negate() ).toVar( 'stress' );\n\t\t\t\t\tconst dudv = particleBuffer.element( instanceIndex ).get( 'C' ).toConst( 'C' );\n\n\t\t\t\t\tconst strain = dudv.add( dudv.transpose() );\n\t\t\t\t\tstress.addAssign( strain.mul( dynamicViscosityUniform ) );\n\t\t\t\t\tconst eq16Term0 = volume.mul( - 4 ).mul( stress ).mul( dtUniform );\n\n\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {\n\n\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {\n\n\t\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {\n\n\t\t\t\t\t\t\t\tconst weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );\n\t\t\t\t\t\t\t\tconst cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();\n\t\t\t\t\t\t\t\tconst cellDist = vec3( cellX ).add( 0.5 ).sub( gridPosition ).toConst( 'cellDist' );\n\t\t\t\t\t\t\t\tconst momentum = eq16Term0.mul( weight ).mul( cellDist ).toConst( 'momentum' );\n\n\t\t\t\t\t\t\t\tconst cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();\n\t\t\t\t\t\t\t\tconst cell = cellBuffer.element( cellPtr );\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'x' ), encodeFixedPoint( momentum.x ) );\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'y' ), encodeFixedPoint( momentum.y ) );\n\t\t\t\t\t\t\t\tatomicAdd( cell.get( 'z' ), encodeFixedPoint( momentum.z ) );\n\t\t\t\n\t\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t} )().compute( params.particleCount );\n\n\t\t\t\tupdateGridKernel = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( uint( cellCount ) ), () => {\n\n\t\t\t\t\t\tReturn();\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\t\tconst cell = cellBuffer.element( instanceIndex );\n\t\t\t\t\tconst mass = decodeFixedPoint( atomicLoad( cell.get( 'mass' ) ) ).toConst();\n\t\t\t\t\tIf( mass.lessThanEqual( 0 ), () => {\n\n\t\t\t\t\t\tReturn();\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst vx = decodeFixedPoint( atomicLoad( cell.get( 'x' ) ) ).div( mass ).toVar();\n\t\t\t\t\tconst vy = decodeFixedPoint( atomicLoad( cell.get( 'y' ) ) ).div( mass ).toVar();\n\t\t\t\t\tconst vz = decodeFixedPoint( atomicLoad( cell.get( 'z' ) ) ).div( mass ).toVar();\n\n\t\t\t\t\tconst x = int( instanceIndex ).div( int( gridSize.z * gridSize.y ) );\n\t\t\t\t\tconst y = int( instanceIndex ).div( int( gridSize.z ) ).mod( int( gridSize.y ) );\n\t\t\t\t\tconst z = int( instanceIndex ).mod( int( gridSize.z ) );\n\t\t\t\t\tIf( x.lessThan( int( 1 ) ).or( x.greaterThan( int( gridSize.x ).sub( int( 2 ) ) ) ), () => {\n\n\t\t\t\t\t\tvx.assign( 0 );\n\n\t\t\t\t\t} );\n\t\t\t\t\tIf( y.lessThan( int( 1 ) ).or( y.greaterThan( int( gridSize.y ).sub( int( 2 ) ) ) ), () => {\n\n\t\t\t\t\t\tvy.assign( 0 );\n\n\t\t\t\t\t} );\n\t\t\t\t\tIf( z.lessThan( int( 1 ) ).or( z.greaterThan( int( gridSize.z ).sub( int( 2 ) ) ) ), () => {\n\n\t\t\t\t\t\tvz.assign( 0 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tcellBufferFloat.element( instanceIndex ).assign( vec4( vx, vy, vz, mass ) );\n\t\t\t\n\t\t\t\t} )().compute( cellCount );\n\n\n\t\t\t\tconst clampToRoundedBox = ( pos, box, radius ) => {\n\n\t\t\t\t\tconst result = pos.sub( 0.5 ).toVar();\n\t\t\t\t\tconst pp = step( box, result.abs() ).mul( result.add( box.negate().mul( result.sign() ) ) );\n\t\t\t\t\tconst ppLen = pp.length().toVar();\n\t\t\t\t\tconst dist = ppLen.sub( radius );\n\t\t\t\t\tIf( dist.greaterThan( 0.0 ), () => {\n\n\t\t\t\t\t\tresult.subAssign( pp.normalize().mul( dist ).mul( 1.3 ) );\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\t\tresult.addAssign( 0.5 );\n\t\t\t\t\treturn result;\n\t\t\t\n\t\t\t\t};\n\n\t\t\t\tg2pKernel = Fn( () => {\n\n\t\t\t\t\tIf( instanceIndex.greaterThanEqual( particleCountUniform ), () => {\n\n\t\t\t\t\t\tReturn();\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\t\tconst particlePosition = particleBuffer.element( instanceIndex ).get( 'position' ).toVar( 'particlePosition' );\n\t\t\t\t\tconst gridPosition = particlePosition.mul( gridSizeUniform ).toVar();\n\t\t\t\t\tconst particleVelocity = vec3( 0 ).toVar();\n\n\t\t\t\t\tconst cellIndex = ivec3( gridPosition ).sub( 1 ).toConst( 'cellIndex' );\n\t\t\t\t\tconst cellDiff = gridPosition.fract().sub( 0.5 ).toConst( 'cellDiff' );\n\n\t\t\t\t\tconst w0 = float( 0.5 ).mul( float( 0.5 ).sub( cellDiff ) ).mul( float( 0.5 ).sub( cellDiff ) );\n\t\t\t\t\tconst w1 = float( 0.75 ).sub( cellDiff.mul( cellDiff ) );\n\t\t\t\t\tconst w2 = float( 0.5 ).mul( float( 0.5 ).add( cellDiff ) ).mul( float( 0.5 ).add( cellDiff ) );\n\t\t\t\t\tconst weights = array( [ w0, w1, w2 ] ).toConst( 'weights' );\n\n\t\t\t\t\tconst B = mat3( 0 ).toVar( 'B' );\n\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {\n\n\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {\n\n\t\t\t\t\t\t\tLoop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {\n\n\t\t\t\t\t\t\t\tconst weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );\n\t\t\t\t\t\t\t\tconst cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();\n\t\t\t\t\t\t\t\tconst cellDist = vec3( cellX ).add( 0.5 ).sub( gridPosition ).toConst( 'cellDist' );\n\t\t\t\t\t\t\t\tconst cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();\n\n\t\t\t\t\t\t\t\tconst weightedVelocity = cellBufferFloat.element( cellPtr ).xyz.mul( weight ).toConst( 'weightedVelocity' );\n\t\t\t\t\t\t\t\tconst term = mat3(\n\t\t\t\t\t\t\t\t\tweightedVelocity.mul( cellDist.x ),\n\t\t\t\t\t\t\t\t\tweightedVelocity.mul( cellDist.y ),\n\t\t\t\t\t\t\t\t\tweightedVelocity.mul( cellDist.z )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tB.addAssign( term );\n\t\t\t\t\t\t\t\tparticleVelocity.addAssign( weightedVelocity );\n\t\t\t\n\t\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\t} );\n\n\t\t\t\t\tparticleBuffer.element( instanceIndex ).get( 'C' ).assign( B.mul( 4 ) );\n\n\t\t\t\t\t// gravity\n\t\t\t\t\tparticleVelocity.addAssign( gravityUniform.mul( dtUniform ) );\n\n\t\t\t\t\t// scale from (gridSize.x, gridSize.y, gridSize.z) to (1, 1, 1)\n\t\t\t\t\tparticleVelocity.divAssign( gridSizeUniform );\n\n\t\t\t\t\t// mouseInteraction\n\t\t\t\t\tconst dist = cross( mouseRayDirectionUniform, particlePosition.sub( mouseRayOriginUniform ) ).length();\n\t\t\t\t\tconst force = dist.mul( 3.00 ).oneMinus().max( 0.0 ).pow( 2 );\n\t\t\t\t\tparticleVelocity.addAssign( mouseForceUniform.mul( force ) );\n\n\t\t\t\t\t// add velocity to position\n\t\t\t\t\tparticlePosition.addAssign( particleVelocity.mul( dtUniform ) );\n\n\t\t\t\t\t// clamp position so outermost gridCells are not reached\n\t\t\t\t\tparticlePosition.assign( clamp( particlePosition, vec3( 1 ).div( gridSizeUniform ), vec3( gridSize ).sub( 1 ).div( gridSizeUniform ) ) );\n\n\t\t\t\t\t// add force for particles to stay within rounded box\n\t\t\t\t\tconst innerBox = gridSizeUniform.mul( 0.5 ).sub( 9.0 ).div( gridSizeUniform ).toVar();\n\t\t\t\t\tconst innerRadius = float( 6.0 ).div( gridSizeUniform.x );\n\t\t\t\t\tconst posNext = particlePosition.add( particleVelocity.mul( dtUniform ).mul( 2.0 ) ).toConst( 'posNext' );\n\t\t\t\t\tconst posNextClamped = clampToRoundedBox( posNext, innerBox, innerRadius );\n\t\t\t\t\tparticleVelocity.addAssign( posNextClamped.sub( posNext ) );\n\n\t\t\t\t\t/*\n\t\t\t\t\tconst wallStiffness = 1.0;\n\t\t\t\t\tconst xN = particlePosition.add( particleVelocity.mul( dtUniform ).mul( 2.0 ) ).toConst( 'xN' );\n\t\t\t\t\tconst wallMin = vec3( 3 ).div(gridSizeUniform).toConst( 'wallMin' );\n\t\t\t\t\tconst wallMax = vec3( gridSize ).sub( 3 ).div(gridSizeUniform).toConst( 'wallMax' );\n\t\t\t\t\tparticleVelocity.addAssign( wallMin.sub( xN ).max( 0.0 ).mul( wallStiffness ) );\n\t\t\t\t\tparticleVelocity.addAssign( wallMax.sub( xN ).min( 0.0 ).mul( wallStiffness ) );\n\t\t\t\t\t*/\n\n\t\t\t\t\t// scale from (1, 1, 1) back to (gridSize.x, gridSize.y, gridSize.z) to\n\t\t\t\t\tparticleVelocity.mulAssign( gridSizeUniform );\n\n\t\t\t\t\tparticleBuffer.element( instanceIndex ).get( 'position' ).assign( particlePosition );\n\t\t\t\t\tparticleBuffer.element( instanceIndex ).get( 'velocity' ).assign( particleVelocity );\n\t\t\t\n\t\t\t\t} )().compute( params.particleCount );\n\n\t\t\t}\n\n\t\t\tfunction setupMesh() {\n\n\t\t\t\t// mergeVertices to reduce the number of vertexShaderCalls\n\t\t\t\tconst geometry = BufferGeometryUtils.mergeVertices( new THREE.IcosahedronGeometry( 0.008, 1 ).deleteAttribute( 'uv' ) );\n\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tcolor: '#0066FF'\n\t\t\t\t} );\n\n\t\t\t\tmaterial.positionNode = Fn( () => {\n\n\t\t\t\t\tconst particlePosition = particleBuffer.element( instanceIndex ).get( 'position' );\n\t\t\t\t\treturn attribute( 'position' ).add( particlePosition );\n\t\t\t\n\t\t\t\t} )();\n\t\t\t\tparticleMesh = new THREE.Mesh( geometry, material );\n\t\t\t\tparticleMesh.count = params.particleCount;\n\t\t\t\tparticleMesh.position.set( - 0.5, 0, - 0.5 );\n\t\t\t\tparticleMesh.frustumCulled = false;\n\t\t\t\tscene.add( particleMesh );\n\n\t\t\t}\n\n\t\t\tfunction setupMouse() {\n\n\t\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\t\tconst raycastPlane = new THREE.Plane( new THREE.Vector3( 0, 1, 0 ) );\n\n\t\t\t\tconst onMove = ( event ) => {\n\n\t\t\t\t\tconst pointer = new THREE.Vector2( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );\n\t\t\t\t\traycaster.setFromCamera( pointer, camera );\n\t\t\t\t\traycaster.ray.origin.x += 0.5;\n\t\t\t\t\traycaster.ray.origin.z += 0.5;\n\t\t\t\t\tmouseRayOriginUniform.value.copy( raycaster.ray.origin );\n\t\t\t\t\tmouseRayDirectionUniform.value.copy( raycaster.ray.direction );\n\n\t\t\t\t\traycaster.ray.intersectPlane( raycastPlane, mouseCoord );\n\n\t\t\t\t};\n\n\t\t\t\trenderer.domElement.addEventListener( 'pointermove', onMove );\n\n\t\t\t}\n\n\t\t\tfunction setupParticles() {\n\n\t\t\t\tsetupBuffers();\n\t\t\t\tsetupUniforms();\n\t\t\t\tsetupComputeShaders();\n\t\t\t\tsetupMesh();\n\t\t\t\tsetupMouse();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function render() {\n\n\t\t\t\tconst deltaTime = THREE.MathUtils.clamp( clock.getDelta(), 0.00001, 1 / 60 ); // don't advance the time too far, for example when the window is out of focus\n\t\t\t\tdtUniform.value = deltaTime;\n\n\t\t\t\tmouseForceUniform.value.copy( mouseCoord ).sub( prevMouseCoord ).multiplyScalar( 2 );\n\t\t\t\tconst mouseForceLength = mouseForceUniform.value.length();\n\t\t\t\tif ( mouseForceLength > 0.3 ) {\n\n\t\t\t\t\tmouseForceUniform.value.multiplyScalar( 0.3 / mouseForceLength );\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\tprevMouseCoord.copy( mouseCoord );\n\n\t\t\t\tawait renderer.computeAsync( [ clearGridKernel, p2g1Kernel, p2g2Kernel, updateGridKernel, g2pKernel ] );\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - fluid particles MLS-MPM particle simulation running in compute shaders"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Compute Particles Rain"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Compute Particles Rain:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, texture, uv, uint, instancedArray, positionWorld, billboarding, time, hash, deltaTime, vec2, instanceIndex, positionGeometry, If } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\tconst maxParticleCount = 50000;\n\t\t\tconst instanceCount = maxParticleCount / 2;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, stats;\n\t\t\tlet computeParticles;\n\t\t\tlet monkey;\n\t\t\tlet clock;\n\n\t\t\tlet collisionBox, collisionCamera, collisionPosRT, collisionPosMaterial;\n\t\t\tlet collisionBoxPos, collisionBoxPosUI;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, .1, 110 );\n\t\t\t\tcamera.position.set( 40, 8, 0 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, .5 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.position.set( 3, 17, 17 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 50;\n\t\t\t\tdirLight.shadow.camera.right = 25;\n\t\t\t\tdirLight.shadow.camera.left = - 25;\n\t\t\t\tdirLight.shadow.camera.top = 25;\n\t\t\t\tdirLight.shadow.camera.bottom = - 25;\n\t\t\t\tdirLight.shadow.mapSize.width = 2048;\n\t\t\t\tdirLight.shadow.mapSize.height = 2048;\n\t\t\t\tdirLight.shadow.bias = - 0.01;\n\n\t\t\t\tscene.add( dirLight );\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x111111 ) );\n\n\t\t\t\t//\n\n\t\t\t\tcollisionCamera = new THREE.OrthographicCamera( - 50, 50, 50, - 50, .1, 50 );\n\t\t\t\tcollisionCamera.position.y = 50;\n\t\t\t\tcollisionCamera.lookAt( 0, 0, 0 );\n\t\t\t\tcollisionCamera.layers.disableAll();\n\t\t\t\tcollisionCamera.layers.enable( 1 );\n\n\t\t\t\tcollisionPosRT = new THREE.RenderTarget( 1024, 1024 );\n\t\t\t\tcollisionPosRT.texture.type = THREE.HalfFloatType;\n\t\t\t\tcollisionPosRT.texture.magFilter = THREE.NearestFilter;\n\t\t\t\tcollisionPosRT.texture.minFilter = THREE.NearestFilter;\n\t\t\t\tcollisionPosRT.texture.generateMipmaps = false;\n\n\t\t\t\tcollisionPosMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tcollisionPosMaterial.colorNode = positionWorld;\n\n\t\t\t\t//\n\n\t\t\t\tconst positionBuffer = instancedArray( maxParticleCount, 'vec3' );\n\t\t\t\tconst velocityBuffer = instancedArray( maxParticleCount, 'vec3' );\n\t\t\t\tconst ripplePositionBuffer = instancedArray( maxParticleCount, 'vec3' );\n\t\t\t\tconst rippleTimeBuffer = instancedArray( maxParticleCount, 'vec3' );\n\n\t\t\t\t// compute\n\n\t\t\t\tconst randUint = () => uint( Math.random() * 0xFFFFFF );\n\n\t\t\t\tconst computeInit = Fn( () => {\n\n\t\t\t\t\tconst position = positionBuffer.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocityBuffer.element( instanceIndex );\n\t\t\t\t\tconst rippleTime = rippleTimeBuffer.element( instanceIndex );\n\n\t\t\t\t\tconst randX = hash( instanceIndex );\n\t\t\t\t\tconst randY = hash( instanceIndex.add( randUint() ) );\n\t\t\t\t\tconst randZ = hash( instanceIndex.add( randUint() ) );\n\n\t\t\t\t\tposition.x = randX.mul( 100 ).add( - 50 );\n\t\t\t\t\tposition.y = randY.mul( 25 );\n\t\t\t\t\tposition.z = randZ.mul( 100 ).add( - 50 );\n\n\t\t\t\t\tvelocity.y = randX.mul( - .04 ).add( - .2 );\n\n\t\t\t\t\trippleTime.x = 1000;\n\n\t\t\t\t} )().compute( maxParticleCount );\n\n\t\t\t\t//\n\n\t\t\t\tconst computeUpdate = Fn( () => {\n\n\t\t\t\t\tconst getCoord = ( pos ) => pos.add( 50 ).div( 100 );\n\n\t\t\t\t\tconst position = positionBuffer.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocityBuffer.element( instanceIndex );\n\t\t\t\t\tconst ripplePosition = ripplePositionBuffer.element( instanceIndex );\n\t\t\t\t\tconst rippleTime = rippleTimeBuffer.element( instanceIndex );\n\n\t\t\t\t\tposition.addAssign( velocity );\n\n\t\t\t\t\trippleTime.x = rippleTime.x.add( deltaTime.mul( 4 ) );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst collisionArea = texture( collisionPosRT.texture, getCoord( position.xz ) );\n\n\t\t\t\t\tconst surfaceOffset = .05;\n\n\t\t\t\t\tconst floorPosition = collisionArea.y.add( surfaceOffset );\n\n\t\t\t\t\t// floor\n\n\t\t\t\t\tconst ripplePivotOffsetY = - .9;\n\n\t\t\t\t\tIf( position.y.add( ripplePivotOffsetY ).lessThan( floorPosition ), () => {\n\n\t\t\t\t\t\tposition.y = 25;\n\n\t\t\t\t\t\tripplePosition.xz = position.xz;\n\t\t\t\t\t\tripplePosition.y = floorPosition;\n\n\t\t\t\t\t\t// reset hit time: x = time\n\n\t\t\t\t\t\trippleTime.x = 1;\n\n\t\t\t\t\t\t// next drops will not fall in the same place\n\n\t\t\t\t\t\tposition.x = hash( instanceIndex.add( time ) ).mul( 100 ).add( - 50 );\n\t\t\t\t\t\tposition.z = hash( instanceIndex.add( time.add( randUint() ) ) ).mul( 100 ).add( - 50 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst rippleOnSurface = texture( collisionPosRT.texture, getCoord( ripplePosition.xz ) );\n\n\t\t\t\t\tconst rippleFloorArea = rippleOnSurface.y.add( surfaceOffset );\n\n\t\t\t\t\tIf( ripplePosition.y.greaterThan( rippleFloorArea ), () => {\n\n\t\t\t\t\t\trippleTime.x = 1000;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tcomputeParticles = computeUpdate().compute( maxParticleCount );\n\n\t\t\t\t// rain\n\n\t\t\t\tconst rainMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\trainMaterial.colorNode = uv().distance( vec2( .5, 0 ) ).oneMinus().mul( 3 ).exp().mul( .1 );\n\t\t\t\trainMaterial.vertexNode = billboarding( { position: positionBuffer.toAttribute() } );\n\t\t\t\trainMaterial.opacity = .2;\n\t\t\t\trainMaterial.side = THREE.DoubleSide;\n\t\t\t\trainMaterial.forceSinglePass = true;\n\t\t\t\trainMaterial.depthWrite = false;\n\t\t\t\trainMaterial.depthTest = true;\n\t\t\t\trainMaterial.transparent = true;\n\n\t\t\t\tconst rainParticles = new THREE.Mesh( new THREE.PlaneGeometry( .1, 2 ), rainMaterial );\n\t\t\t\trainParticles.count = instanceCount;\n\t\t\t\tscene.add( rainParticles );\n\n\t\t\t\t// ripple\n\n\t\t\t\tconst rippleTime = rippleTimeBuffer.element( instanceIndex ).x;\n\n\t\t\t\tconst rippleEffect = Fn( () => {\n\n\t\t\t\t\tconst center = uv().add( vec2( - .5 ) ).length().mul( 7 );\n\t\t\t\t\tconst distance = rippleTime.sub( center );\n\n\t\t\t\t\treturn distance.min( 1 ).sub( distance.max( 1 ).sub( 1 ) );\n\n\t\t\t\t} );\n\n\t\t\t\tconst rippleMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\trippleMaterial.colorNode = rippleEffect();\n\t\t\t\trippleMaterial.positionNode = positionGeometry.add( ripplePositionBuffer.toAttribute() );\n\t\t\t\trippleMaterial.opacityNode = rippleTime.mul( .3 ).oneMinus().max( 0 ).mul( .5 );\n\t\t\t\trippleMaterial.side = THREE.DoubleSide;\n\t\t\t\trippleMaterial.forceSinglePass = true;\n\t\t\t\trippleMaterial.depthWrite = false;\n\t\t\t\trippleMaterial.depthTest = true;\n\t\t\t\trippleMaterial.transparent = true;\n\n\t\t\t\t// ripple geometry\n\n\t\t\t\tconst surfaceRippleGeometry = new THREE.PlaneGeometry( 2.5, 2.5 );\n\t\t\t\tsurfaceRippleGeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst xRippleGeometry = new THREE.PlaneGeometry( 1, 2 );\n\t\t\t\txRippleGeometry.rotateY( - Math.PI / 2 );\n\n\t\t\t\tconst zRippleGeometry = new THREE.PlaneGeometry( 1, 2 );\n\n\t\t\t\tconst rippleGeometry = BufferGeometryUtils.mergeGeometries( [ surfaceRippleGeometry, xRippleGeometry, zRippleGeometry ] );\n\n\t\t\t\tconst rippleParticles = new THREE.Mesh( rippleGeometry, rippleMaterial );\n\t\t\t\trippleParticles.count = instanceCount;\n\t\t\t\tscene.add( rippleParticles );\n\n\t\t\t\t// floor geometry\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 1000, 1000 );\n\t\t\t\tfloorGeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst plane = new THREE.Mesh( floorGeometry, new THREE.MeshBasicMaterial( { color: 0x050505 } ) );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t//\n\n\t\t\t\tcollisionBox = new THREE.Mesh( new THREE.BoxGeometry( 30, 1, 15 ), new THREE.MeshStandardMaterial() );\n\t\t\t\tcollisionBox.material.color.set( 0x333333 );\n\t\t\t\tcollisionBox.position.y = 12;\n\t\t\t\tcollisionBox.scale.x = 3.5;\n\t\t\t\tcollisionBox.layers.enable( 1 );\n\t\t\t\tcollisionBox.castShadow = true;\n\t\t\t\tscene.add( collisionBox );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new THREE.BufferGeometryLoader();\n\t\t\t\tloader.load( 'models/json/suzanne_buffergeometry.json', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tmonkey = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial( { roughness: 1, metalness: 0 } ) );\n\t\t\t\t\tmonkey.receiveShadow = true;\n\t\t\t\t\tmonkey.scale.setScalar( 5 );\n\t\t\t\t\tmonkey.rotation.y = Math.PI / 2;\n\t\t\t\t\tmonkey.position.y = 4.5;\n\t\t\t\t\tmonkey.layers.enable( 1 ); // add to collision layer\n\n\t\t\t\t\tscene.add( monkey );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.computeAsync( computeInit );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t// use lerp to smooth the movement\n\t\t\t\tcollisionBoxPosUI = new THREE.Vector3().copy( collisionBox.position );\n\t\t\t\tcollisionBoxPos = new THREE.Vector3();\n\n\t\t\t\tgui.add( collisionBoxPosUI, 'z', - 50, 50, .001 ).name( 'position' );\n\t\t\t\tgui.add( collisionBox.scale, 'x', .1, 3.5, 0.01 ).name( 'scale' );\n\t\t\t\tgui.add( rainParticles, 'count', 200, maxParticleCount, 1 ).name( 'drop count' ).onChange( ( v ) => rippleParticles.count = v );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera.aspect = innerWidth / innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( innerWidth, innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( monkey ) {\n\n\t\t\t\t\tmonkey.rotation.y += delta;\n\n\t\t\t\t}\n\n\t\t\t\tcollisionBoxPos.set( collisionBoxPosUI.x, collisionBoxPosUI.y, - collisionBoxPosUI.z );\n\n\t\t\t\tcollisionBox.position.lerp( collisionBoxPos, 10 * delta );\n\n\t\t\t\t// position\n\n\t\t\t\tscene.overrideMaterial = collisionPosMaterial;\n\t\t\t\trenderer.setRenderTarget( collisionPosRT );\n\t\t\t\trenderer.render( scene, collisionCamera );\n\n\t\t\t\t// compute\n\n\t\t\t\trenderer.compute( computeParticles );\n\n\t\t\t\t// result\n\n\t\t\t\tscene.overrideMaterial = null;\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - GPU Compute Rain"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Compute Particles Snow"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Compute Particles Snow:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, texture, vec3, pass, color, uint, screenUV, instancedArray, positionWorld, positionLocal, time, vec2, hash, instanceIndex, If } from 'three/tsl';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'stats-gl';\n\n\t\t\tconst maxParticleCount = 100000;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, stats;\n\t\t\tlet computeParticles;\n\t\t\tlet postProcessing;\n\n\t\t\tlet collisionCamera, collisionPosRT, collisionPosMaterial;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, .1, 100 );\n\t\t\t\tcamera.position.set( 20, 2, 20 );\n\t\t\t\tcamera.layers.enable( 2 );\n\t\t\t\tcamera.lookAt( 0, 40, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x0f3c37, 5, 40 );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xf9ff9b, 9 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.position.set( 10, 10, 0 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 30;\n\t\t\t\tdirLight.shadow.camera.right = 30;\n\t\t\t\tdirLight.shadow.camera.left = - 30;\n\t\t\t\tdirLight.shadow.camera.top = 30;\n\t\t\t\tdirLight.shadow.camera.bottom = - 30;\n\t\t\t\tdirLight.shadow.mapSize.width = 2048;\n\t\t\t\tdirLight.shadow.mapSize.height = 2048;\n\t\t\t\tdirLight.shadow.bias = - 0.009;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x0f3c37, 0x080d10, 100 ) );\n\n\t\t\t\t//\n\n\t\t\t\tcollisionCamera = new THREE.OrthographicCamera( - 50, 50, 50, - 50, .1, 50 );\n\t\t\t\tcollisionCamera.position.y = 50;\n\t\t\t\tcollisionCamera.lookAt( 0, 0, 0 );\n\t\t\t\tcollisionCamera.layers.enable( 1 );\n\n\t\t\t\tcollisionPosRT = new THREE.RenderTarget( 1024, 1024 );\n\t\t\t\tcollisionPosRT.texture.type = THREE.HalfFloatType;\n\t\t\t\tcollisionPosRT.texture.magFilter = THREE.NearestFilter;\n\t\t\t\tcollisionPosRT.texture.minFilter = THREE.NearestFilter;\n\t\t\t\tcollisionPosRT.texture.generateMipmaps = false;\n\n\t\t\t\tcollisionPosMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tcollisionPosMaterial.fog = false;\n\t\t\t\tcollisionPosMaterial.toneMapped = false;\n\t\t\t\tcollisionPosMaterial.colorNode = positionWorld.y;\n\n\t\t\t\t//\n\n\t\t\t\tconst positionBuffer = instancedArray( maxParticleCount, 'vec3' );\n\t\t\t\tconst scaleBuffer = instancedArray( maxParticleCount, 'vec3' );\n\t\t\t\tconst staticPositionBuffer = instancedArray( maxParticleCount, 'vec3' );\n\t\t\t\tconst dataBuffer = instancedArray( maxParticleCount, 'vec4' );\n\n\t\t\t\t// compute\n\n\t\t\t\tconst randUint = () => uint( Math.random() * 0xFFFFFF );\n\n\t\t\t\tconst computeInit = Fn( () => {\n\n\t\t\t\t\tconst position = positionBuffer.element( instanceIndex );\n\t\t\t\t\tconst scale = scaleBuffer.element( instanceIndex );\n\t\t\t\t\tconst particleData = dataBuffer.element( instanceIndex );\n\n\t\t\t\t\tconst randX = hash( instanceIndex );\n\t\t\t\t\tconst randY = hash( instanceIndex.add( randUint() ) );\n\t\t\t\t\tconst randZ = hash( instanceIndex.add( randUint() ) );\n\n\t\t\t\t\tposition.x = randX.mul( 100 ).add( - 50 );\n\t\t\t\t\tposition.y = randY.mul( 500 ).add( 3 );\n\t\t\t\t\tposition.z = randZ.mul( 100 ).add( - 50 );\n\n\t\t\t\t\tscale.xyz = hash( instanceIndex.add( Math.random() ) ).mul( .8 ).add( .2 );\n\n\t\t\t\t\tstaticPositionBuffer.element( instanceIndex ).assign( vec3( 1000, 10000, 1000 ) );\n\n\t\t\t\t\tparticleData.y = randY.mul( - .1 ).add( - .02 );\n\n\t\t\t\t\tparticleData.x = position.x;\n\t\t\t\t\tparticleData.z = position.z;\n\t\t\t\t\tparticleData.w = randX;\n\n\t\t\t\t} )().compute( maxParticleCount );\n\n\t\t\t\t//\n\n\t\t\t\tconst surfaceOffset = .2;\n\t\t\t\tconst speed = .4;\n\n\t\t\t\tconst computeUpdate = Fn( () => {\n\n\t\t\t\t\tconst getCoord = ( pos ) => pos.add( 50 ).div( 100 );\n\n\t\t\t\t\tconst position = positionBuffer.element( instanceIndex );\n\t\t\t\t\tconst scale = scaleBuffer.element( instanceIndex );\n\t\t\t\t\tconst particleData = dataBuffer.element( instanceIndex );\n\n\t\t\t\t\tconst velocity = particleData.y;\n\t\t\t\t\tconst random = particleData.w;\n\n\t\t\t\t\tconst rippleOnSurface = texture( collisionPosRT.texture, getCoord( position.xz ) );\n\t\t\t\t\tconst rippleFloorArea = rippleOnSurface.y.add( scale.x.mul( surfaceOffset ) );\n\n\t\t\t\t\tIf( position.y.greaterThan( rippleFloorArea ), () => {\n\n\t\t\t\t\t\tposition.x = particleData.x.add( time.mul( random.mul( random ) ).mul( speed ).sin().mul( 3 ) );\n\t\t\t\t\t\tposition.z = particleData.z.add( time.mul( random ).mul( speed ).cos().mul( random.mul( 10 ) ) );\n\n\t\t\t\t\t\tposition.y = position.y.add( velocity );\n\n\t\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\t\tstaticPositionBuffer.element( instanceIndex ).assign( position );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tcomputeParticles = computeUpdate().compute( maxParticleCount );\n\n\t\t\t\t// rain\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( surfaceOffset, 5, 5 );\n\n\t\t\t\tfunction particle( staticParticles ) {\n\n\t\t\t\t\tconst posBuffer = staticParticles ? staticPositionBuffer : positionBuffer;\n\t\t\t\t\tconst layer = staticParticles ? 1 : 2;\n\n\t\t\t\t\tconst staticMaterial = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\t\tcolor: 0xeeeeee,\n\t\t\t\t\t\troughness: .9,\n\t\t\t\t\t\tmetalness: 0\n\t\t\t\t\t} );\n\n\t\t\t\t\tstaticMaterial.positionNode = positionLocal.mul( scaleBuffer.toAttribute() ).add( posBuffer.toAttribute() );\n\n\t\t\t\t\tconst rainParticles = new THREE.Mesh( geometry, staticMaterial );\n\t\t\t\t\trainParticles.count = maxParticleCount;\n\t\t\t\t\trainParticles.castShadow = true;\n\t\t\t\t\trainParticles.layers.disableAll();\n\t\t\t\t\trainParticles.layers.enable( layer );\n\n\t\t\t\t\treturn rainParticles;\n\n\t\t\t\t}\n\n\t\t\t\tconst dynamicParticles = particle();\n\t\t\t\tconst staticParticles = particle( true );\n\n\t\t\t\tscene.add( dynamicParticles );\n\t\t\t\tscene.add( staticParticles );\n\n\t\t\t\t// floor geometry\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\tfloorGeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst plane = new THREE.Mesh( floorGeometry, new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0x0c1e1e,\n\t\t\t\t\troughness: .5,\n\t\t\t\t\tmetalness: 0,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} ) );\n\n\t\t\t\tplane.material.opacityNode = positionLocal.xz.mul( .05 ).distance( 0 ).saturate().oneMinus();\n\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// tree\n\n\t\t\t\tfunction tree( count = 8 ) {\n\n\t\t\t\t\tconst coneMaterial = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\t\tcolor: 0x0d492c,\n\t\t\t\t\t\troughness: .6,\n\t\t\t\t\t\tmetalness: 0\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst object = new THREE.Group();\n\n\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tconst radius = 1 + i;\n\n\t\t\t\t\t\tconst coneGeometry = new THREE.ConeGeometry( radius * 0.95, radius * 1.25, 32 );\n\n\t\t\t\t\t\tconst cone = new THREE.Mesh( coneGeometry, coneMaterial );\n\t\t\t\t\t\tcone.castShadow = true;\n\t\t\t\t\t\tcone.position.y = ( ( count - i ) * 1.5 ) + ( count * .6 );\n\t\t\t\t\t\tobject.add( cone );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = new THREE.CylinderGeometry( 1, 1, count, 32 );\n\t\t\t\t\tconst cone = new THREE.Mesh( geometry, coneMaterial );\n\t\t\t\t\tcone.position.y = count / 2;\n\t\t\t\t\tobject.add( cone );\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tconst teapotTree = new THREE.Mesh( new TeapotGeometry( .5, 18 ), new THREE.MeshBasicNodeMaterial( {\n\t\t\t\t\tcolor: 0xfcfb9e\n\t\t\t\t} ) );\n\n\t\t\t\tteapotTree.position.y = 18;\n\n\t\t\t\tscene.add( tree() );\n\t\t\t\tscene.add( teapotTree );\n\n\t\t\t\t//\n\n\t\t\t\tscene.backgroundNode = screenUV.distance( .5 ).mul( 2 ).mix( color( 0x0f4140 ), color( 0x060a0d ) );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats( {\n\t\t\t\t\tprecision: 3,\n\t\t\t\t\thorizontal: false,\n\t\t\t\t\ttrackGPU: true,\n\t\t\t\t\ttrackCPT: true\n\t\t\t\t} );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 10, 0 );\n\t\t\t\tcontrols.minDistance = 25;\n\t\t\t\tcontrols.maxDistance = 35;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.7;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 0.7;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\t\t\t\tconst vignette = screenUV.distance( .5 ).mul( 1.35 ).clamp().oneMinus();\n\n\t\t\t\tconst teapotTreePass = pass( teapotTree, camera ).getTextureNode();\n\t\t\t\tconst teapotTreePassBlurred = gaussianBlur( teapotTreePass, vec2( 1 ), 3 );\n\t\t\t\tteapotTreePassBlurred.resolution = new THREE.Vector2( .2, .2 );\n\n\t\t\t\tconst scenePassColorBlurred = gaussianBlur( scenePassColor );\n\t\t\t\tscenePassColorBlurred.resolution = new THREE.Vector2( .5, .5 );\n\t\t\t\tscenePassColorBlurred.directionNode = vec2( 1 );\n\n\t\t\t\t// compose\n\n\t\t\t\tlet totalPass = scenePass;\n\t\t\t\ttotalPass = totalPass.add( scenePassColorBlurred.mul( .1 ) );\n\t\t\t\ttotalPass = totalPass.mul( vignette );\n\t\t\t\ttotalPass = totalPass.add( teapotTreePass.mul( 10 ).add( teapotTreePassBlurred ) );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = totalPass;\n\n\t\t\t\t//\n\n\t\t\t\tawait renderer.computeAsync( computeInit );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera.aspect = innerWidth / innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( innerWidth, innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// position\n\n\t\t\t\tscene.overrideMaterial = collisionPosMaterial;\n\t\t\t\trenderer.setRenderTarget( collisionPosRT );\n\t\t\t\trenderer.render( scene, collisionCamera );\n\n\t\t\t\t// compute\n\n\t\t\t\trenderer.compute( computeParticles );\n\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );\n\n\t\t\t\t// result\n\n\t\t\t\tscene.overrideMaterial = null;\n\t\t\t\trenderer.setRenderTarget( null );\n\n\t\t\t\tawait postProcessing.renderAsync();\n\n\t\t\t\trenderer.resolveTimestampsAsync();\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Compute Snow - 100K Particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Compute"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Compute:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'stats-gl';\n\n\n\t\t\timport { Fn, uniform, instancedArray, float, vec2, vec3, color, instanceIndex } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet computeNode;\n\n\t\t\tconst pointerVector = new THREE.Vector2( - 10.0, - 10.0 ); // Out of bounds first\n\t\t\tconst scaleVector = new THREE.Vector2( 1, 1 );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - 1.0, 1.0, 1.0, - 1.0, 0, 1 );\n\t\t\t\tcamera.position.z = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// initialize particles\n\n\t\t\t\tconst particlesCount = 300000;\n\n\t\t\t\tconst particleArray = instancedArray( particlesCount, 'vec2' );\n\t\t\t\tconst velocityArray = instancedArray( particlesCount, 'vec2' );\n\n\t\t\t\t// create function\n\n\t\t\t\tconst computeShaderFn = Fn( () => {\n\n\t\t\t\t\tconst particle = particleArray.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocityArray.element( instanceIndex );\n\n\t\t\t\t\tconst pointer = uniform( pointerVector );\n\t\t\t\t\tconst limit = uniform( scaleVector );\n\n\t\t\t\t\tconst position = particle.add( velocity ).toVar();\n\n\t\t\t\t\tvelocity.x = position.x.abs().greaterThanEqual( limit.x ).select( velocity.x.negate(), velocity.x );\n\t\t\t\t\tvelocity.y = position.y.abs().greaterThanEqual( limit.y ).select( velocity.y.negate(), velocity.y );\n\n\t\t\t\t\tposition.assign( position.min( limit ).max( limit.negate() ) );\n\n\t\t\t\t\tconst pointerSize = 0.1;\n\t\t\t\t\tconst distanceFromPointer = pointer.sub( position ).length();\n\n\t\t\t\t\tparticle.assign( distanceFromPointer.lessThanEqual( pointerSize ).select( vec3(), position ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// compute\n\n\t\t\t\tcomputeNode = computeShaderFn().compute( particlesCount );\n\t\t\t\tcomputeNode.onInit( ( { renderer } ) => {\n\n\t\t\t\t\tconst precomputeShaderNode = Fn( () => {\n\n\t\t\t\t\t\tconst particleIndex = float( instanceIndex );\n\n\t\t\t\t\t\tconst randomAngle = particleIndex.mul( .005 ).mul( Math.PI * 2 );\n\t\t\t\t\t\tconst randomSpeed = particleIndex.mul( 0.00000001 ).add( 0.0000001 );\n\n\t\t\t\t\t\tconst velX = randomAngle.sin().mul( randomSpeed );\n\t\t\t\t\t\tconst velY = randomAngle.cos().mul( randomSpeed );\n\n\t\t\t\t\t\tconst velocity = velocityArray.element( instanceIndex );\n\n\t\t\t\t\t\tvelocity.xy = vec2( velX, velY );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\trenderer.computeAsync( precomputeShaderNode().compute( particlesCount ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// use a compute shader to animate the point cloud's vertex data.\n\n\t\t\t\tconst pointsGeometry = new THREE.BufferGeometry();\n\t\t\t\tpointsGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 3 ), 3 ) ); // single vertex ( not triangle )\n\t\t\t\tpointsGeometry.drawRange.count = 1; // force render points as instances ( not triangle )\n\n\t\t\t\tconst pointsMaterial = new THREE.PointsNodeMaterial();\n\t\t\t\tpointsMaterial.colorNode = particleArray.element( instanceIndex ).add( color( 0xFFFFFF ) );\n\t\t\t\tpointsMaterial.positionNode = particleArray.element( instanceIndex );\n\n\t\t\t\tconst mesh = new THREE.Points( pointsGeometry, pointsMaterial );\n\t\t\t\tmesh.count = particlesCount;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats( {\n\t\t\t\t\tprecision: 4,\n\t\t\t\t\thorizontal: false,\n\t\t\t\t\ttrackGPU: true,\n\t\t\t\t\ttrackCPT: true,\n\t\t\t\t\tlogsPerSecond: 10,\n\t\t\t\t\tgraphsPerSecond: 60,\n\t\t\t\t\tsamplesGraph: 30,\n\t\t\t\t} );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\t\t\t\tstats.dom.style.position = 'absolute';\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\twindow.addEventListener( 'mousemove', onMouseMove );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( scaleVector, 'x', 0, 1, 0.01 );\n\t\t\t\tgui.add( scaleVector, 'y', 0, 1, 0.01 );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onMouseMove( event ) {\n\n\t\t\t\tconst x = event.clientX;\n\t\t\t\tconst y = event.clientY;\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tpointerVector.set(\n\t\t\t\t\t( x / width - 0.5 ) * 2.0,\n\t\t\t\t\t( - y / height + 0.5 ) * 2.0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.compute( computeNode );\n\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\n\t\t\t\trenderer.resolveTimestampsAsync().then( () => {\n\n\t\t\t\t\tstats.update();\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Compute - 300000 Points"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - storage pbo external element"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - storage pbo external element:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { storage, If, vec3, not, uniform, uv, uint, float, Fn, vec2, abs, int, invocationLocalIndex, workgroupArray, uvec2, floor, instanceIndex, workgroupBarrier, atomicAdd, atomicStore, workgroupId } from 'three/tsl';\n\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst StepType = {\n\n\t\t\t\tNONE: 0,\n\t\t\t\t// Swap values within workgroup local buffer.\n\t\t\t\tFLIP_LOCAL: 1,\n\t\t\t\tDISPERSE_LOCAL: 2,\n\t\t\t\t// Swap values within global data buffer.\n\t\t\t\tFLIP_GLOBAL: 3,\n\t\t\t\tDISPERSE_GLOBAL: 4,\n\n\t\t\t};\n\n\t\t\tconst timestamps = {\n\t\t\t\tlocal_swap: document.getElementById( 'local_swap' ),\n\t\t\t\tglobal_swap: document.getElementById( 'global_swap' )\n\t\t\t};\n\n\n\t\t\tconst localColors = [ 'rgb(203, 64, 203)', 'rgb(0, 215, 215)' ];\n\t\t\tconst globalColors = [ 'rgb(1, 150, 1)', 'red' ];\n\n\t\t\t// Total number of elements and the dimensions of the display grid.\n\t\t\tconst size = 16384;\n\t\t\tconst gridDim = Math.sqrt( size );\n\n\t\t\tconst getNumSteps = () => {\n\n\t\t\t\tconst n = Math.log2( size );\n\t\t\t\treturn ( n * ( n + 1 ) ) / 2;\n\n\t\t\t};\n\n\t\t\t// Total number of steps in a bitonic sort with 'size' elements.\n\t\t\tconst MAX_STEPS = getNumSteps();\n\t\t\tconst WORKGROUP_SIZE = [ 64 ];\n\n\t\t\tconst effectController = {\n\t\t\t\t// Sqr root of 16834\n\t\t\t\tgridWidth: uniform( gridDim ),\n\t\t\t\tgridHeight: uniform( gridDim ),\n\t\t\t\thighlight: uniform( 1 ),\n\t\t\t\t'Display Mode': 'Swap Zone Highlight'\n\t\t\t};\n\n\t\t\tconst gui = new GUI();\n\t\t\tgui.add( effectController, 'Display Mode', [ 'Elements', 'Swap Zone Highlight' ] ).onChange( () => {\n\n\t\t\t\tif ( effectController[ 'Display Mode' ] === 'Elements' ) {\n\n\t\t\t\t\teffectController.highlight.value = 0;\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\teffectController.highlight.value = 1;\n\n\t\t\t\t}\n\n\n\t\t\t} );\n\n\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t}\n\n\t\t\t// Allow Workgroup Array Swaps\n\t\t\tinit();\n\n\t\t\t// Global Swaps Only\n\t\t\tinit( true );\n\n\n\t\t\t// When forceGlobalSwap is true, force all valid local swaps to be global swaps.\n\t\t\tasync function init( forceGlobalSwap = false ) {\n\n\t\t\t\tlet currentStep = 0;\n\t\t\t\tlet nextStepGlobal = false;\n\n\t\t\t\tconst aspect = ( window.innerWidth / 2 ) / window.innerHeight;\n\t\t\t\tconst camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );\n\t\t\t\tcamera.position.z = 1;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tconst nextAlgoBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( forceGlobalSwap ? StepType.FLIP_GLOBAL : StepType.FLIP_LOCAL ), 1 );\n\n\t\t\t\tconst nextAlgoStorage = storage( nextAlgoBuffer, 'uint', nextAlgoBuffer.count ).setPBO( true ).label( 'NextAlgo' );\n\n\t\t\t\tconst nextBlockHeightBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( 2 ), 1 );\n\t\t\t\tconst nextBlockHeightStorage = storage( nextBlockHeightBuffer, 'uint', nextBlockHeightBuffer.count ).setPBO( true ).label( 'NextBlockHeight' );\n\t\t\t\tconst nextBlockHeightRead = storage( nextBlockHeightBuffer, 'uint', nextBlockHeightBuffer.count ).setPBO( true ).label( 'NextBlockHeight' ).toReadOnly();\n\n\t\t\t\tconst highestBlockHeightBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( 2 ), 1 );\n\t\t\t\tconst highestBlockHeightStorage = storage( highestBlockHeightBuffer, 'uint', highestBlockHeightBuffer.count ).setPBO( true ).label( 'HighestBlockHeight' );\n\n\t\t\t\tconst counterBuffer = new THREE.StorageBufferAttribute( 1, 1 );\n\t\t\t\tconst counterStorage = storage( counterBuffer, 'uint', counterBuffer.count ).setPBO( true ).toAtomic().label( 'Counter' );\n\n\t\t\t\tconst array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {\n\n\t\t\t\t\treturn i;\n\n\t\t\t\t} ) );\n\n\n\t\t\t\tconst randomizeDataArray = () => {\n\n\t\t\t\t\tlet currentIndex = array.length;\n\t\t\t\t\twhile ( currentIndex !== 0 ) {\n\n\t\t\t\t\t\tconst randomIndex = Math.floor( Math.random() * currentIndex );\n\t\t\t\t\t\tcurrentIndex -= 1;\n\t\t\t\t\t\t[ array[ currentIndex ], array[ randomIndex ] ] = [\n\t\t\t\t\t\t\tarray[ randomIndex ],\n\t\t\t\t\t\t\tarray[ currentIndex ],\n\t\t\t\t\t\t];\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\trandomizeDataArray();\n\n\t\t\t\tconst currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );\n\t\t\t\tconst currentElementsStorage = storage( currentElementsBuffer, 'uint', size ).setPBO( true ).label( 'Elements' );\n\t\t\t\tconst tempBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );\n\t\t\t\tconst tempStorage = storage( tempBuffer, 'uint', size ).setPBO( true ).label( 'Temp' );\n\t\t\t\tconst randomizedElementsBuffer = new THREE.StorageInstancedBufferAttribute( size, 1 );\n\t\t\t\tconst randomizedElementsStorage = storage( randomizedElementsBuffer, 'uint', size ).setPBO( true ).label( 'RandomizedElements' );\n\n\t\t\t\tconst getFlipIndices = ( index, blockHeight ) => {\n\n\t\t\t\t\tconst blockOffset = ( index.mul( 2 ).div( blockHeight ) ).mul( blockHeight );\n\t\t\t\t\tconst halfHeight = blockHeight.div( 2 );\n\t\t\t\t\tconst idx = uvec2(\n\t\t\t\t\t\tindex.mod( halfHeight ),\n\t\t\t\t\t\tblockHeight.sub( index.mod( halfHeight ) ).sub( 1 )\n\t\t\t\t\t);\n\t\t\t\t\tidx.x.addAssign( blockOffset );\n\t\t\t\t\tidx.y.addAssign( blockOffset );\n\n\t\t\t\t\treturn idx;\n\n\t\t\t\t};\n\n\t\t\t\tconst getDisperseIndices = ( index, blockHeight ) => {\n\n\t\t\t\t\tconst blockOffset = ( ( index.mul( 2 ) ).div( blockHeight ) ).mul( blockHeight );\n\t\t\t\t\tconst halfHeight = blockHeight.div( 2 );\n\t\t\t\t\tconst idx = uvec2(\n\t\t\t\t\t\tindex.mod( halfHeight ),\n\t\t\t\t\t\t( index.mod( halfHeight ) ).add( halfHeight )\n\t\t\t\t\t);\n\n\t\t\t\t\tidx.x.addAssign( blockOffset );\n\t\t\t\t\tidx.y.addAssign( blockOffset );\n\n\t\t\t\t\treturn idx;\n\n\t\t\t\t};\n\n\t\t\t\tconst localStorage = workgroupArray( 'uint', 64 * 2 );\n\n\t\t\t\t// Swap the elements in local storage\n\t\t\t\tconst localCompareAndSwap = ( idxBefore, idxAfter ) => {\n\n\t\t\t\t\tIf( localStorage.element( idxAfter ).lessThan( localStorage.element( idxBefore ) ), () => {\n\n\t\t\t\t\t\tatomicAdd( counterStorage.element( 0 ), 1 );\n\t\t\t\t\t\tconst temp = localStorage.element( idxBefore ).toVar();\n\t\t\t\t\t\tlocalStorage.element( idxBefore ).assign( localStorage.element( idxAfter ) );\n\t\t\t\t\t\tlocalStorage.element( idxAfter ).assign( temp );\n\n\t\t\t\t\t} );\n\n\t\t\t\t};\n\n\t\t\t\tconst globalCompareAndSwap = ( idxBefore, idxAfter ) => {\n\n\t\t\t\t\t// If the later element is less than the current element\n\t\t\t\t\tIf( currentElementsStorage.element( idxAfter ).lessThan( currentElementsStorage.element( idxBefore ) ), () => {\n\n\t\t\t\t\t\t// Apply the swapped values to temporary storage.\n\t\t\t\t\t\tatomicAdd( counterStorage.element( 0 ), 1 );\n\t\t\t\t\t\ttempStorage.element( idxBefore ).assign( currentElementsStorage.element( idxAfter ) );\n\t\t\t\t\t\ttempStorage.element( idxAfter ).assign( currentElementsStorage.element( idxBefore ) );\n\n\t\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\t\t// Otherwise apply the existing values to temporary storage.\n\t\t\t\t\t\ttempStorage.element( idxBefore ).assign( currentElementsStorage.element( idxBefore ) );\n\t\t\t\t\t\ttempStorage.element( idxAfter ).assign( currentElementsStorage.element( idxAfter ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t};\n\n\t\t\t\tconst computeInitFn = Fn( () => {\n\n\t\t\t\t\trandomizedElementsStorage.element( instanceIndex ).assign( currentElementsStorage.element( instanceIndex ) );\n\n\t\t\t\t} );\n\n\t\t\t\tconst computeBitonicStepFn = Fn( () => {\n\n\t\t\t\t\tconst nextBlockHeight = nextBlockHeightStorage.element( 0 ).toVar();\n\t\t\t\t\tconst nextAlgo = nextAlgoStorage.element( 0 ).toVar();\n\n\t\t\t\t\t// Get ids of indices needed to populate workgroup local buffer.\n\t\t\t\t\t// Use .toVar() to prevent these values from being recalculated multiple times.\n\t\t\t\t\tconst localOffset = uint( WORKGROUP_SIZE[ 0 ] ).mul( 2 ).mul( workgroupId.x ).toVar();\n\n\t\t\t\t\tconst localID1 = invocationLocalIndex.mul( 2 );\n\t\t\t\t\tconst localID2 = invocationLocalIndex.mul( 2 ).add( 1 );\n\n\t\t\t\t\t// If we will perform a local swap, then populate the local data\n\t\t\t\t\tIf( nextAlgo.lessThanEqual( uint( StepType.DISPERSE_LOCAL ) ), () => {\n\n\t\t\t\t\t\tlocalStorage.element( localID1 ).assign( currentElementsStorage.element( localOffset.add( localID1 ) ) );\n\t\t\t\t\t\tlocalStorage.element( localID2 ).assign( currentElementsStorage.element( localOffset.add( localID2 ) ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tworkgroupBarrier();\n\n\t\t\t\t\t// TODO: Convert to switch block.\n\t\t\t\t\tIf( nextAlgo.equal( uint( StepType.FLIP_LOCAL ) ), () => {\n\n\t\t\t\t\t\tconst idx = getFlipIndices( invocationLocalIndex, nextBlockHeight );\n\t\t\t\t\t\tlocalCompareAndSwap( idx.x, idx.y );\n\n\t\t\t\t\t} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_LOCAL ) ), () => {\n\n\t\t\t\t\t\tconst idx = getDisperseIndices( invocationLocalIndex, nextBlockHeight );\n\t\t\t\t\t\tlocalCompareAndSwap( idx.x, idx.y );\n\n\t\t\t\t\t} ).ElseIf( nextAlgo.equal( uint( StepType.FLIP_GLOBAL ) ), () => {\n\n\t\t\t\t\t\tconst idx = getFlipIndices( instanceIndex, nextBlockHeight );\n\t\t\t\t\t\tglobalCompareAndSwap( idx.x, idx.y );\n\n\t\t\t\t\t} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_GLOBAL ) ), () => {\n\n\t\t\t\t\t\tconst idx = getDisperseIndices( instanceIndex, nextBlockHeight );\n\t\t\t\t\t\tglobalCompareAndSwap( idx.x, idx.y );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Ensure that all invocations have swapped their own regions of data\n\t\t\t\t\tworkgroupBarrier();\n\n\t\t\t\t\t// Populate output data with the results from our swaps\n\t\t\t\t\tIf( nextAlgo.lessThanEqual( uint( StepType.DISPERSE_LOCAL ) ), () => {\n\n\t\t\t\t\t\tcurrentElementsStorage.element( localOffset.add( localID1 ) ).assign( localStorage.element( localID1 ) );\n\t\t\t\t\t\tcurrentElementsStorage.element( localOffset.add( localID2 ) ).assign( localStorage.element( localID2 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// If the previous algorithm was global, we execute an additional compute step to sync the current buffer with the output buffer.\n\n\t\t\t\t} );\n\n\t\t\t\tconst computeSetAlgoFn = Fn( () => {\n\n\t\t\t\t\tconst nextBlockHeight = nextBlockHeightStorage.element( 0 ).toVar();\n\t\t\t\t\tconst nextAlgo = nextAlgoStorage.element( 0 );\n\t\t\t\t\tconst highestBlockHeight = highestBlockHeightStorage.element( 0 ).toVar();\n\n\t\t\t\t\tnextBlockHeight.divAssign( 2 );\n\n\t\t\t\t\tIf( nextBlockHeight.equal( 1 ), () => {\n\n\t\t\t\t\t\thighestBlockHeight.mulAssign( 2 );\n\n\t\t\t\t\t\tif ( forceGlobalSwap ) {\n\n\t\t\t\t\t\t\tIf( highestBlockHeight.equal( size * 2 ), () => {\n\n\t\t\t\t\t\t\t\tnextAlgo.assign( StepType.NONE );\n\t\t\t\t\t\t\t\tnextBlockHeight.assign( 0 );\n\n\t\t\t\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\t\t\t\tnextAlgo.assign( StepType.FLIP_GLOBAL );\n\t\t\t\t\t\t\t\tnextBlockHeight.assign( highestBlockHeight );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tIf( highestBlockHeight.equal( size * 2 ), () => {\n\n\t\t\t\t\t\t\t\tnextAlgo.assign( StepType.NONE );\n\t\t\t\t\t\t\t\tnextBlockHeight.assign( 0 );\n\n\t\t\t\t\t\t\t} ).ElseIf( highestBlockHeight.greaterThan( WORKGROUP_SIZE[ 0 ] * 2 ), () => {\n\n\t\t\t\t\t\t\t\tnextAlgo.assign( StepType.FLIP_GLOBAL );\n\t\t\t\t\t\t\t\tnextBlockHeight.assign( highestBlockHeight );\n\n\t\t\t\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\t\t\t\tnextAlgo.assign( forceGlobalSwap ? StepType.FLIP_GLOBAL : StepType.FLIP_LOCAL );\n\t\t\t\t\t\t\t\tnextBlockHeight.assign( highestBlockHeight );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\t\tif ( forceGlobalSwap ) {\n\n\t\t\t\t\t\t\tnextAlgo.assign( StepType.DISPERSE_GLOBAL );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextAlgo.assign( nextBlockHeight.greaterThan( WORKGROUP_SIZE[ 0 ] * 2 ).select( StepType.DISPERSE_GLOBAL, StepType.DISPERSE_LOCAL ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tnextBlockHeightStorage.element( 0 ).assign( nextBlockHeight );\n\t\t\t\t\thighestBlockHeightStorage.element( 0 ).assign( highestBlockHeight );\n\n\t\t\t\t} );\n\n\t\t\t\tconst computeAlignCurrentFn = Fn( () => {\n\n\t\t\t\t\tcurrentElementsStorage.element( instanceIndex ).assign( tempStorage.element( instanceIndex ) );\n\n\t\t\t\t} );\n\n\t\t\t\tconst computeResetBuffersFn = Fn( () => {\n\n\t\t\t\t\tcurrentElementsStorage.element( instanceIndex ).assign( randomizedElementsStorage.element( instanceIndex ) );\n\n\t\t\t\t} );\n\n\t\t\t\tconst computeResetAlgoFn = Fn( () => {\n\n\t\t\t\t\tnextAlgoStorage.element( 0 ).assign( forceGlobalSwap ? StepType.FLIP_GLOBAL : StepType.FLIP_LOCAL );\n\t\t\t\t\tnextBlockHeightStorage.element( 0 ).assign( 2 );\n\t\t\t\t\thighestBlockHeightStorage.element( 0 ).assign( 2 );\n\t\t\t\t\tatomicStore( counterStorage.element( 0 ), 0 );\n\n\t\t\t\t} );\n\n\t\t\t\t// Initialize each value in the elements buffer.\n\t\t\t\tconst computeInit = computeInitFn().compute( size );\n\t\t\t\t// Swap a pair of elements in the elements buffer.\n\t\t\t\tconst computeBitonicStep = computeBitonicStepFn().compute( size / 2 );\n\t\t\t\t// Set the conditions for the next swap.\n\t\t\t\tconst computeSetAlgo = computeSetAlgoFn().compute( 1 );\n\t\t\t\t// Align the current buffer with the temp buffer if the previous sort was executed in a global scope.\n\t\t\t\tconst computeAlignCurrent = computeAlignCurrentFn().compute( size );\n\t\t\t\t// Reset the buffers and algorithm information after a full bitonic sort has been completed.\n\t\t\t\tconst computeResetBuffers = computeResetBuffersFn().compute( size );\n\t\t\t\tconst computeResetAlgo = computeResetAlgoFn().compute( 1 );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );\n\n\t\t\t\tconst display = Fn( () => {\n\n\t\t\t\t\tconst { gridWidth, gridHeight, highlight } = effectController;\n\n\t\t\t\t\tconst newUV = uv().mul( vec2( gridWidth, gridHeight ) );\n\n\t\t\t\t\tconst pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );\n\n\t\t\t\t\tconst elementIndex = uint( gridWidth ).mul( pixel.y ).add( pixel.x );\n\n\t\t\t\t\tconst colorChanger = currentElementsStorage.element( elementIndex );\n\n\t\t\t\t\tconst subtracter = float( colorChanger ).div( gridWidth.mul( gridHeight ) );\n\n\t\t\t\t\tconst color = vec3( subtracter.oneMinus() ).toVar();\n\n\t\t\t\t\tIf( highlight.equal( 1 ).and( not( nextAlgoStorage.element( 0 ).equal( StepType.NONE ) ) ), () => {\n\n\t\t\t\t\t\tconst boolCheck = int( elementIndex.mod( nextBlockHeightRead.element( 0 ) ).lessThan( nextBlockHeightRead.element( 0 ).div( 2 ) ) );\n\t\t\t\t\t\tcolor.z.assign( nextAlgoStorage.element( 0 ).lessThanEqual( StepType.DISPERSE_LOCAL ) );\n\t\t\t\t\t\tcolor.x.mulAssign( boolCheck );\n\t\t\t\t\t\tcolor.y.mulAssign( abs( boolCheck.sub( 1 ) ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn color;\n\n\t\t\t\t} );\n\n\t\t\t\tmaterial.colorNode = display();\n\n\t\t\t\tconst plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth / 2, window.innerHeight );\n\n\t\t\t\tconst animate = () => {\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t};\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.domElement.style.position = 'absolute';\n\t\t\t\trenderer.domElement.style.top = '0';\n\t\t\t\trenderer.domElement.style.left = '0';\n\t\t\t\trenderer.domElement.style.width = '50%';\n\t\t\t\trenderer.domElement.style.height = '100%';\n\n\t\t\t\tif ( forceGlobalSwap ) {\n\n\t\t\t\t\trenderer.domElement.style.left = '50%';\n\n\t\t\t\t\tscene.background = new THREE.Color( 0x212121 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.background = new THREE.Color( 0x313131 );\n\n\t\t\t\t}\n\n\t\t\t\tawait renderer.computeAsync( computeInit );\n\n\t\t\t\trenderer.info.autoReset = false;\n\n\t\t\t\t const stepAnimation = async function () {\n\n\t\t\t\t\trenderer.info.reset();\n\n\t\t\t\t\tif ( currentStep !== MAX_STEPS ) {\n\n\t\t\t\t\t\trenderer.compute( computeBitonicStep );\n\n\t\t\t\t\t\tif ( nextStepGlobal ) {\n\n\t\t\t\t\t\t\trenderer.compute( computeAlignCurrent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderer.compute( computeSetAlgo );\n\n\t\t\t\t\t\tcurrentStep ++;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trenderer.compute( computeResetBuffers );\n\t\t\t\t\t\trenderer.compute( computeResetAlgo );\n\n\t\t\t\t\t\tcurrentStep = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );\n\n\n\t\t\t\t\tconst algo = new Uint32Array( await renderer.getArrayBufferAsync( nextAlgoBuffer ) );\n\t\t\t\t\tnextStepGlobal = algo[ 0 ] > StepType.DISPERSE_LOCAL;\n\t\t\t\t\tconst totalSwaps = new Uint32Array( await renderer.getArrayBufferAsync( counterBuffer ) );\n\n\t\t\t\t\trenderer.render( scene, camera );\n\t\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );\n\n\t\t\t\t\ttimestamps[ forceGlobalSwap ? 'global_swap' : 'local_swap' ].innerHTML = `\n\n\t\t\t\t\t\t\tCompute ${forceGlobalSwap ? 'Global' : 'Local'}: ${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>\n\t\t\t\t\t\t\tTotal Swaps: ${totalSwaps}<br>\n\t\t\t\t\t\t\t\t<div style=\"display: flex; flex-direction:row; justify-content: center; align-items: center;\">\n\t\t\t\t\t\t\t\t\t${forceGlobalSwap ? 'Global Swaps' : 'Local Swaps'} Compare Region&nbsp;\n\t\t\t\t\t\t\t\t\t<div style=\"background-color: ${ forceGlobalSwap ? globalColors[ 0 ] : localColors[ 0 ]}; width:12.5px; height: 1em; border-radius: 20%;\"></div>\n\t\t\t\t\t\t\t\t\t&nbsp;to Region&nbsp;\n\t\t\t\t\t\t\t\t\t<div style=\"background-color: ${ forceGlobalSwap ? globalColors[ 1 ] : localColors[ 1 ]}; width:12.5px; height: 1em; border-radius: 20%;\"></div>\n\t\t\t\t\t\t\t\t</div>`;\n\n\n\t\t\t\t\tif ( currentStep === MAX_STEPS ) {\n\n\t\t\t\t\t\tsetTimeout( stepAnimation, 1000 );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetTimeout( stepAnimation, 50 );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tstepAnimation();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tfunction onWindowResize() {\n\n\t\t\t\t\trenderer.setSize( window.innerWidth / 2, window.innerHeight );\n\n\t\t\t\t\tconst aspect = ( window.innerWidth / 2 ) / window.innerHeight;\n\n\t\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js This example demonstrates a bitonic sort running step by step in a compute shader. The left canvas swaps values within workgroup local arrays. The right swaps values within storage buffers. Reference implementation by Tim Gfrerer"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Compute Texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Compute Texture:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, textureStore, Fn, instanceIndex, float, uvec2, vec4 } from 'three/tsl';\n\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );\n\t\t\t\tcamera.position.z = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// texture\n\n\t\t\t\tconst width = 512, height = 512;\n\n\t\t\t\tconst storageTexture = new THREE.StorageTexture( width, height );\n\t\t\t\t//storageTexture.minFilter = THREE.LinearMipMapLinearFilter;\n\n\t\t\t\t// create function\n\n\t\t\t\tconst computeTexture = Fn( ( { storageTexture } ) => {\n\n\t\t\t\t\tconst posX = instanceIndex.mod( width );\n\t\t\t\t\tconst posY = instanceIndex.div( width );\n\t\t\t\t\tconst indexUV = uvec2( posX, posY );\n\n\t\t\t\t\t// https://www.shadertoy.com/view/Xst3zN\n\n\t\t\t\t\tconst x = float( posX ).div( 50.0 );\n\t\t\t\t\tconst y = float( posY ).div( 50.0 );\n\n\t\t\t\t\tconst v1 = x.sin();\n\t\t\t\t\tconst v2 = y.sin();\n\t\t\t\t\tconst v3 = x.add( y ).sin();\n\t\t\t\t\tconst v4 = x.mul( x ).add( y.mul( y ) ).sqrt().add( 5.0 ).sin();\n\t\t\t\t\tconst v = v1.add( v2, v3, v4 );\n\n\t\t\t\t\tconst r = v.sin();\n\t\t\t\t\tconst g = v.add( Math.PI ).sin();\n\t\t\t\t\tconst b = v.add( Math.PI ).sub( 0.5 ).sin();\n\n\t\t\t\t\ttextureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();\n\n\t\t\t\t} );\n\n\t\t\t\t// compute\n\n\t\t\t\tconst computeNode = computeTexture( { storageTexture } ).compute( width * height );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );\n\t\t\t\tmaterial.colorNode = texture( storageTexture );\n\n\t\t\t\tconst plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// compute texture\n\t\t\t\trenderer.computeAsync( computeNode );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Compute Texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - WebGPU - Compute Ping/Pong Texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - WebGPU - Compute Ping/Pong Texture:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { storageTexture, wgslFn, code, instanceIndex, uniform, NodeAccess } from 'three/tsl';\n\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet computeInitNode, computeToPing, computeToPong;\n\t\t\tlet pingTexture, pongTexture;\n\t\t\tlet material;\n\t\t\tlet phase = true;\n\t\t\tlet lastUpdate = - 1;\n\n\t\t\tconst seed = uniform( new THREE.Vector2() );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );\n\t\t\t\tcamera.position.z = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// texture\n\n\t\t\t\tconst hdr = true;\n\t\t\t\tconst width = 512, height = 512;\n\n\t\t\t\tpingTexture = new THREE.StorageTexture( width, height );\n\t\t\t\tpongTexture = new THREE.StorageTexture( width, height );\n\n\t\t\t\tif ( hdr ) {\n\n\t\t\t\t\tpingTexture.type = THREE.HalfFloatType;\n\t\t\t\t\tpongTexture.type = THREE.HalfFloatType;\n\n\t\t\t\t}\n\n\t\t\t\tconst wgslFormat = hdr ? 'rgba16float' : 'rgba8unorm';\n\t\t\t\n\t\t\t\tconst readPing = storageTexture( pingTexture ).setAccess( NodeAccess.READ_ONLY );\n\t\t\t\tconst writePing = storageTexture( pingTexture ).setAccess( NodeAccess.WRITE_ONLY );\n\t\t\t\tconst readPong = storageTexture( pongTexture ).setAccess( NodeAccess.READ_ONLY );\n\t\t\t\tconst writePong = storageTexture( pongTexture ).setAccess( NodeAccess.WRITE_ONLY );\n\n\t\t\t\t// compute init\n\n\t\t\t\tconst rand2 = code( `\n\t\t\t\t\tfn rand2( n: vec2f ) -> f32 {\n\n\t\t\t\t\t\treturn fract( sin( dot( n, vec2f( 12.9898, 4.1414 ) ) ) * 43758.5453 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfn blur( image : texture_storage_2d<${wgslFormat}, read>, uv : vec2i ) -> vec4f {\n\n\t\t\t\t\t\tvar color = vec4f( 0.0 );\n\n\t\t\t\t\t\tcolor += textureLoad( image, uv + vec2i( - 1, 1 ));\n\t\t\t\t\t\tcolor += textureLoad( image, uv + vec2i( - 1, - 1 ));\n\t\t\t\t\t\tcolor += textureLoad( image, uv + vec2i( 0, 0 ));\n\t\t\t\t\t\tcolor += textureLoad( image, uv + vec2i( 1, - 1 ));\n\t\t\t\t\t\tcolor += textureLoad( image, uv + vec2i( 1, 1 ));\n\n\t\t\t\t\t\treturn color / 5.0; \n\t\t\t\t\t}\n\n\t\t\t\t\tfn getUV( posX: u32, posY: u32 ) -> vec2f {\n\n\t\t\t\t\t\tlet uv = vec2f( f32( posX ) / ${ width }.0, f32( posY ) / ${ height }.0 );\n\n\t\t\t\t\t\treturn uv;\n\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\tconst computeInitWGSL = wgslFn( `\n\t\t\t\t\tfn computeInitWGSL( writeTex: texture_storage_2d<${ wgslFormat }, write>, index: u32, seed: vec2f ) -> void {\n\n\t\t\t\t\t\tlet posX = index % ${ width };\n\t\t\t\t\t\tlet posY = index / ${ width };\n\t\t\t\t\t\tlet indexUV = vec2u( posX, posY );\n\t\t\t\t\t\tlet uv = getUV( posX, posY );\n\n\t\t\t\t\t\tlet r = rand2( uv + seed * 100 ) - rand2( uv + seed * 300 );\n\t\t\t\t\t\tlet g = rand2( uv + seed * 200 ) - rand2( uv + seed * 300 );\n\t\t\t\t\t\tlet b = rand2( uv + seed * 200 ) - rand2( uv + seed * 100 );\n\n\t\t\t\t\t\ttextureStore( writeTex, indexUV, vec4( r, g, b, 1 ) );\n\n\t\t\t\t\t}\n\t\t\t\t`, [ rand2 ] );\n\n\t\t\t\tcomputeInitNode = computeInitWGSL( { writeTex: storageTexture( pingTexture ), index: instanceIndex, seed } ).compute( width * height );\n\n\t\t\t\t// compute loop\n\n\t\t\t\tconst computePingPongWGSL = wgslFn( `\n\t\t\t\t\tfn computePingPongWGSL( readTex: texture_storage_2d<${wgslFormat}, read>, writeTex: texture_storage_2d<${ wgslFormat }, write>, index: u32 ) -> void {\n\n\t\t\t\t\t\tlet posX = index % ${ width };\n\t\t\t\t\t\tlet posY = index / ${ width };\n\t\t\t\t\t\tlet indexUV = vec2i( i32( posX ), i32( posY ) );\n\n\t\t\t\t\t\tlet color = blur( readTex, indexUV ).rgb;\n\n\t\t\t\t\t\ttextureStore( writeTex, indexUV, vec4f( color * 1.05, 1 ) );\n\n\t\t\t\t\t}\n\t\t\t\t`, [ rand2 ] );\n\n\t\t\t\t//\n\n\t\t\t\tcomputeToPong = computePingPongWGSL( { readTex: readPing, writeTex: writePong, index: instanceIndex } ).compute( width * height );\n\t\t\t\tcomputeToPing = computePingPongWGSL( { readTex: readPong, writeTex: writePing, index: instanceIndex } ).compute( width * height );\n\n\t\t\t\t//\n\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, map: pongTexture } );\n\n\t\t\t\tconst plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// compute init\n\n\t\t\t\trenderer.computeAsync( computeInitNode );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = performance.now();\n\t\t\t\tconst seconds = Math.floor( time / 1000 );\n\n\t\t\t\t// reset every second\n\n\t\t\t\tif ( phase && seconds !== lastUpdate ) {\n\n\t\t\t\t\tseed.value.set( Math.random(), Math.random() );\n\n\t\t\t\t\trenderer.compute( computeInitNode );\n\n\t\t\t\t\tlastUpdate = seconds;\n\n\t\t\t\t}\n\n\t\t\t\t// compute step\n\n\t\t\t\trenderer.compute( phase ? computeToPong : computeToPing );\n\n\t\t\t\tmaterial.map = phase ? pongTexture : pingTexture;\n\n\t\t\t\tphase = ! phase;\n\n\t\t\t\t// render step\n\n\t\t\t\t// update material texture node\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Compute Ping/Pong Texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - compute water"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - compute water:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { instanceIndex, struct, If, uint, int, floor, float, length, clamp, vec2, cos, vec3, vertexIndex, Fn, uniform, instancedArray, min, max, positionLocal, transformNormalToView } from 'three/tsl';\n\n\t\t\timport { SimplexNoise } from 'three/addons/math/SimplexNoise.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n \t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\t// Dimensions of simulation grid.\n\t\t\tconst WIDTH = 128;\n\n\t\t\t// Water size in system units.\n\t\t\tconst BOUNDS = 6;\n\t\t\tconst BOUNDS_HALF = BOUNDS * 0.5;\n\t\t\tconst limit = BOUNDS_HALF - 0.2;\n\n\t\t\tconst waterMaxHeight = 0.1;\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tlet mouseDown = false;\n\t\t\tlet firstClick = true;\n\t\t\tlet updateOriginMouseDown = false;\n\n\t\t\tconst mouseCoords = new THREE.Vector2();\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tlet frame = 0;\n\n\t\t\tconst effectController = {\n\t\t\t\tmousePos: uniform( new THREE.Vector2() ).label( 'mousePos' ),\n\t\t\t\tmouseSpeed: uniform( new THREE.Vector2() ).label( 'mouseSpeed' ),\n\t\t\t\tmouseDeep: uniform( .5 ).label( 'mouseDeep' ),\n\t\t\t\tmouseSize: uniform( 0.12 ).label( 'mouseSize' ),\n\t\t\t\tviscosity: uniform( 0.96 ).label( 'viscosity' ),\n\t\t\t\tducksEnabled: true,\n\t\t\t\twireframe: false,\n\t\t\t\tspeed: 5,\n\t\t\t};\n\n\t\t\tlet sun;\n\t\t\tlet waterMesh;\n\t\t\tlet poolBorder;\n\t\t\tlet meshRay;\n\t\t\tlet computeHeight, computeDucks;\n\t\t\tlet duckModel = null;\n\n\t\t\tconst NUM_DUCKS = 100;\n\n\t\t\tconst simplex = new SimplexNoise();\n\n\t\t\tinit();\n\n\t\t\tfunction noise( x, y ) {\n\n\t\t\t\tlet multR = waterMaxHeight;\n\t\t\t\tlet mult = 0.025;\n\t\t\t\tlet r = 0;\n\t\t\t\tfor ( let i = 0; i < 15; i ++ ) {\n\n\t\t\t\t\tr += multR * simplex.noise( x * mult, y * mult );\n\t\t\t\t\tmultR *= 0.53 + 0.025 * i;\n\t\t\t\t\tmult *= 1.25;\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\n\t\t\t}\n\n\t\t\tasync function init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );\n\t\t\t\tcamera.position.set( 0, 2.00, 4 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tsun = new THREE.DirectionalLight( 0xFFFFFF, 4.0 );\n \t\t\t\tsun.position.set( - 1, 2.6, 1.4 );\n\t\t\t\tscene.add( sun );\n\n\t\t\t\t//\n\n\t\t\t\t// Initialize height storage buffers\n\t\t\t\tconst heightArray = new Float32Array( WIDTH * WIDTH );\n\t\t\t\tconst prevHeightArray = new Float32Array( WIDTH * WIDTH );\n\n\t\t\t\tlet p = 0;\n\t\t\t\tfor ( let j = 0; j < WIDTH; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < WIDTH; i ++ ) {\n\n\t\t\t\t\t\tconst x = i * 128 / WIDTH;\n\t\t\t\t\t\tconst y = j * 128 / WIDTH;\n\n\t\t\t\t\t\tconst height = noise( x, y );\n\n\t\t\t\t\t\theightArray[ p ] = height;\n\t\t\t\t\t\tprevHeightArray[ p ] = height;\n\n\t\t\t\t\t\tp ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst heightStorage = instancedArray( heightArray ).label( 'Height' );\n\t\t\t\tconst prevHeightStorage = instancedArray( prevHeightArray ).label( 'PrevHeight' );\n\n\t\t\t\t// Get Indices of Neighbor Values of an Index in the Simulation Grid\n\t\t\t\tconst getNeighborIndicesTSL = ( index ) => {\n\n\t\t\t\t\tconst width = uint( WIDTH );\n\n\t\t\t\t\t// Get 2-D compute coordinate from one-dimensional instanceIndex. The calculation will\n\t\t\t\t\t// still work even if you dispatch your compute shader 2-dimensionally, since within a compute\n\t\t\t\t\t// context, instanceIndex is a 1-dimensional value derived from the workgroup dimensions.\n\t\t\t\n\t\t\t\t\t// Cast to int to prevent unintended index overflow upon subtraction.\n\t\t\t\t\tconst x = int( index.mod( WIDTH ) );\n\t\t\t\t\tconst y = int( index.div( WIDTH ) );\n\n\t\t\t\t\t// The original shader accesses height via texture uvs. However, unlike with textures, we can't\n\t\t\t\t\t// access areas that are out of bounds. Accordingly, we emulate the Clamp to Edge Wrapping\n\t\t\t\t\t// behavior of accessing a DataTexture with out of bounds uvs.\n\n\t\t\t\t\tconst leftX = max( 0, x.sub( 1 ) );\n\t\t\t\t\tconst rightX = min( x.add( 1 ), width.sub( 1 ) );\n\n\t\t\t\t\tconst bottomY = max( 0, y.sub( 1 ) );\n\t\t\t\t\tconst topY = min( y.add( 1 ), width.sub( 1 ) );\n\n\t\t\t\t\tconst westIndex = y.mul( width ).add( leftX );\n\t\t\t\t\tconst eastIndex = y.mul( width ).add( rightX );\n\t\t\t\n\t\t\t\t\tconst southIndex = bottomY.mul( width ).add( x );\n\t\t\t\t\tconst northIndex = topY.mul( width ).add( x );\n\n\t\t\t\t\treturn { northIndex, southIndex, eastIndex, westIndex };\n\n\t\t\t\t};\n\n\t\t\t\t// Get simulation index neighbor values\n\t\t\t\tconst getNeighborValuesTSL = ( index, store ) => {\n\n\t\t\t\t\tconst { northIndex, southIndex, eastIndex, westIndex } = getNeighborIndicesTSL( index );\n\n\t\t\t\t\tconst north = store.element( northIndex );\n\t\t\t\t\tconst south = store.element( southIndex );\n\t\t\t\t\tconst east = store.element( eastIndex );\n\t\t\t\t\tconst west = store.element( westIndex );\n\n\t\t\t\t\treturn { north, south, east, west };\n\n\t\t\t\t};\n\n\t\t\t\t// Get new normals of simulation area.\n\t\t\t\tconst getNormalsFromHeightTSL = ( index, store ) => {\n\n\t\t\t\t\tconst { north, south, east, west } = getNeighborValuesTSL( index, store );\n\n\t\t\t\t\tconst normalX = ( west.sub( east ) ).mul( WIDTH / BOUNDS );\n\t\t\t\t\tconst normalY = ( south.sub( north ) ).mul( WIDTH / BOUNDS );\n\n\t\t\t\t\treturn { normalX, normalY };\n\n\t\t\t\t};\n\n\t\t\t\tcomputeHeight = Fn( () => {\n\n\t\t\t\t\tconst { viscosity, mousePos, mouseSize, mouseDeep, mouseSpeed } = effectController;\n\n\t\t\t\t\tconst height = heightStorage.element( instanceIndex ).toVar();\n\t\t\t\t\tconst prevHeight = prevHeightStorage.element( instanceIndex ).toVar();\n\n\t\t\t\t\tconst { north, south, east, west } = getNeighborValuesTSL( instanceIndex, heightStorage );\n\n\t\t\t\t\tconst neighborHeight = north.add( south ).add( east ).add( west );\n\t\t\t\t\tneighborHeight.mulAssign( 0.5 );\n\t\t\t\t\tneighborHeight.subAssign( prevHeight );\n\n\t\t\t\t\tconst newHeight = neighborHeight.mul( viscosity );\n\n\t\t\t\t\t// Get 2-D compute coordinate from one-dimensional instanceIndex.\n\t\t\t\t\tconst x = float( instanceIndex.mod( WIDTH ) ).mul( 1 / WIDTH );\n\t\t\t\t\tconst y = float( instanceIndex.div( WIDTH ) ).mul( 1 / WIDTH );\n\n\t\t\t\t\t// Mouse influence\n\t\t\t\t\tconst centerVec = vec2( 0.5 );\n\n\t\t\t\t\t// Get length of position in range [ -BOUNDS / 2, BOUNDS / 2 ], offset by mousePos, then scale.\n\t\t\t\t\tconst mousePhase = clamp( length( ( vec2( x, y ).sub( centerVec ) ).mul( BOUNDS ).sub( mousePos ) ).mul( Math.PI ).div( mouseSize ), 0.0, Math.PI );\n\n\t\t\t\t\t// \"Indent\" water down by scaled distance from center of mouse impact\n\t\t\t\t\tnewHeight.addAssign( cos( mousePhase ).add( 1.0 ).mul( mouseDeep ).mul( mouseSpeed.length() ) );\n\n\t\t\t\t\tprevHeightStorage.element( instanceIndex ).assign( height );\n\t\t\t\t\theightStorage.element( instanceIndex ).assign( newHeight );\n\n\t\t\t\t} )().compute( WIDTH * WIDTH );\n\n\t\t\t\t// Water Geometry corresponds with buffered compute grid.\n\t\t\t\tconst waterGeometry = new THREE.PlaneGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1 );\n\n\t\t\t\tconst waterMaterial = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tcolor: 0x9bd2ec,\n \t\t\t\t\tmetalness: 0.9,\n \t\t\t\t\troughness: 0,\n \t\t\t\t\ttransparent: true,\n \t\t\t\t\topacity: 0.8,\n \t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\twaterMaterial.normalNode = Fn( () => {\n\n\t\t\t\t\t// To correct the lighting as our mesh undulates, we have to reassign the normals in the normal shader.\n\t\t\t\t\tconst { normalX, normalY } = getNormalsFromHeightTSL( vertexIndex, heightStorage );\n\n\t\t\t\t\treturn transformNormalToView( vec3( normalX, normalY.negate(), 1.0 ) ).toVertexStage();\n\n\t\t\t\t} )();\n\n\t\t\t\twaterMaterial.positionNode = Fn( () => {\n\n\t\t\t\t\treturn vec3( positionLocal.x, positionLocal.y, heightStorage.element( vertexIndex ) );\n\n\t\t\t\t} )();\n\n\t\t\t\twaterMesh = new THREE.Mesh( waterGeometry, waterMaterial );\n\t\t\t\twaterMesh.rotation.x = - Math.PI * 0.5;\n\t\t\t\twaterMesh.matrixAutoUpdate = false;\n\t\t\t\twaterMesh.updateMatrix();\n\n\t\t\t\tscene.add( waterMesh );\n\n\t\t\t\t// Pool border\n\t\t\t\tconst borderGeom = new THREE.TorusGeometry( 4.2, 0.1, 12, 4 );\n \t\t\t\tborderGeom.rotateX( Math.PI * 0.5 );\n \t\t\t\tborderGeom.rotateY( Math.PI * 0.25 );\n \t\t\t\tpoolBorder = new THREE.Mesh( borderGeom, new THREE.MeshStandardMaterial( { color: 0x908877, roughness: 0.2 } ) );\n \t\t\t\tscene.add( poolBorder );\n\n\t\t\t\t// THREE.Mesh just for mouse raycasting\n\t\t\t\tconst geometryRay = new THREE.PlaneGeometry( BOUNDS, BOUNDS, 1, 1 );\n\t\t\t\tmeshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );\n\t\t\t\tmeshRay.rotation.x = - Math.PI / 2;\n\t\t\t\tmeshRay.matrixAutoUpdate = false;\n\t\t\t\tmeshRay.updateMatrix();\n\t\t\t\tscene.add( meshRay );\n\t\t\t\n\t\t\t\t// Initialize sphere mesh instance position and velocity.\n\t\t\t\t// position<vec3> + velocity<vec2> + unused<vec3> = 8 floats per sphere.\n\t\t\t\t// for structs arrays must be enclosed in multiple of 4\n\n\t\t\t\tconst duckStride = 8;\n\t\t\t\tconst duckInstanceDataArray = new Float32Array( NUM_DUCKS * duckStride );\n\n\t\t\t\t// Only hold velocity in x and z directions.\n\t\t\t\t// The sphere is wedded to the surface of the water, and will only move vertically with the water.\n\n\t\t\t\tfor ( let i = 0; i < NUM_DUCKS; i ++ ) {\n\n\t\t\t\t\tduckInstanceDataArray[ i * duckStride + 0 ] = ( Math.random() - 0.5 ) * BOUNDS * 0.7;\n\t\t\t\t\tduckInstanceDataArray[ i * duckStride + 1 ] = 0;\n\t\t\t\t\tduckInstanceDataArray[ i * duckStride + 2 ] = ( Math.random() - 0.5 ) * BOUNDS * 0.7;\n\n\t\t\t\t}\n\n\t\t\t\tconst DuckStruct = struct( {\n\t\t\t\t\tposition: 'vec3',\n\t\t\t\t\tvelocity: 'vec2'\n\t\t\t\t} );\n\n\t\t\t\t// Duck instance data storage\n\n\t\t\t\tconst duckInstanceDataStorage = instancedArray( duckInstanceDataArray, DuckStruct ).label( 'DuckInstanceData' );\n\n\t\t\t\tcomputeDucks = Fn( () => {\n\n\t\t\t\t\tconst yOffset = float( - 0.04 );\n\t\t\t\t\tconst verticalResponseFactor = float( 0.98 );\n\t\t\t\t\tconst waterPushFactor = float( 0.015 );\n\t\t\t\t\tconst linearDamping = float( 0.92 );\n\t\t\t\t\tconst bounceDamping = float( - 0.4 );\n\n\t\t\t\t\t// Get 2-D compute coordinate from one-dimensional instanceIndex. The calculation will\n\t\t\t\t\tconst instancePosition = duckInstanceDataStorage.element( instanceIndex ).get( 'position' ).toVar();\n\t\t\t\t\tconst velocity = duckInstanceDataStorage.element( instanceIndex ).get( 'velocity' ).toVar();\n\n\t\t\t\t\tconst gridCoordX = instancePosition.x.div( BOUNDS ).add( 0.5 ).mul( WIDTH );\n\t\t\t\t\tconst gridCoordZ = instancePosition.z.div( BOUNDS ).add( 0.5 ).mul( WIDTH );\n\n\t\t\t\t\t// Cast to int to prevent unintended index overflow upon subtraction.\n\t\t\t\t\tconst xCoord = uint( clamp( floor( gridCoordX ), 0, WIDTH - 1 ) );\n\t\t\t\t\tconst zCoord = uint( clamp( floor( gridCoordZ ), 0, WIDTH - 1 ) );\n\t\t\t\t\tconst heightInstanceIndex = zCoord.mul( WIDTH ).add( xCoord );\n\n\t\t\t\t\t// Get height of water at the duck's position\n\t\t\t\t\tconst waterHeight = heightStorage.element( heightInstanceIndex );\n\t\t\t\t\tconst { normalX, normalY } = getNormalsFromHeightTSL( heightInstanceIndex, heightStorage );\n\n\t\t\t\t\t// Calculate the target Y position based on the water height and the duck's vertical offset\n\t\t\t\t\tconst targetY = waterHeight.add( yOffset );\n\n\t\t\t\t\tconst deltaY = targetY.sub( instancePosition.y );\n\t\t\t\t\tinstancePosition.y.addAssign( deltaY.mul( verticalResponseFactor ) ); // Atualiza Y gradualmente\n\n\t\t\t\t\t// Get the normal of the water surface at the duck's position\n\t\t\t\t\tconst pushX = normalX.mul( waterPushFactor );\n\t\t\t\t\tconst pushZ = normalY.mul( waterPushFactor );\n\n\t\t\t\t\t// Apply the water push to the duck's velocity\n\t\t\t\t\tvelocity.x.mulAssign( linearDamping );\n\t\t\t\t\tvelocity.y.mulAssign( linearDamping );\n\n\t\t\t\t\tvelocity.x.addAssign( pushX );\n\t\t\t\t\tvelocity.y.addAssign( pushZ );\n\n\t\t\t\t\t// update position based on velocity\n\t\t\t\t\tinstancePosition.x.addAssign( velocity.x );\n\t\t\t\t\tinstancePosition.z.addAssign( velocity.y );\n\n\t\t\t\t\t// Clamp position to the pool bounds\n\n\t\t\t\t\tIf( instancePosition.x.lessThan( - limit ), () => {\n\n\t\t\t\t\t\tinstancePosition.x = - limit;\n\t\t\t\t\t\tvelocity.x.mulAssign( bounceDamping );\n\n\t\t\t\t\t} ).ElseIf( instancePosition.x.greaterThan( limit ), () => {\n\n\t\t\t\t\t\tinstancePosition.x = limit;\n\t\t\t\t\t\tvelocity.x.mulAssign( bounceDamping );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tIf( instancePosition.z.lessThan( - limit ), () => {\n\n\t\t\t\t\t\tinstancePosition.z = - limit;\n\t\t\t\t\t\tvelocity.y.mulAssign( bounceDamping ); // Inverte e amortece vz (velocity.y)\n\n\t\t\t\t\t} ).ElseIf( instancePosition.z.greaterThan( limit ), () => {\n\n\t\t\t\t\t\tinstancePosition.z = limit;\n\t\t\t\t\t\tvelocity.y.mulAssign( bounceDamping );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// assignment of new values to the instance data storage\n\n\t\t\t\t\tduckInstanceDataStorage.element( instanceIndex ).get( 'position' ).assign( instancePosition );\n\t\t\t\t\tduckInstanceDataStorage.element( instanceIndex ).get( 'velocity' ).assign( velocity );\n\n\t\t\t\t} )().compute( NUM_DUCKS );\n\n\t\t\t\t// Models / Textures\n\n\t\t\t\tconst rgbeLoader = new RGBELoader().setPath( './textures/equirectangular/' );\n \t\t\t\tconst glbloader = new GLTFLoader().setPath( 'models/gltf/' );\n \t\t\t\tglbloader.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) );\n\n \t\t\t\tconst [ env, model ] = await Promise.all( [ rgbeLoader.loadAsync( 'blouberg_sunrise_2_1k.hdr' ), glbloader.loadAsync( 'duck.glb' ) ] );\n \t\t\t\tenv.mapping = THREE.EquirectangularReflectionMapping;\n \t\t\t\tscene.environment = env;\n \t\t\t\tscene.background = env;\n \t\t\t\tscene.backgroundBlurriness = 0.3;\n \t\t\t\tscene.environmentIntensity = 1.25;\n\n\t\t\t\tduckModel = model.scene.children[ 0 ];\n\t\t\t\tduckModel.material.positionNode = Fn( () => {\n\n\t\t\t\t\tconst instancePosition = duckInstanceDataStorage.element( instanceIndex ).get( 'position' );\n\n\t\t\t\t\tconst newPosition = positionLocal.add( instancePosition );\n\n\t\t\t\t\treturn newPosition;\n\n\t\t\t\t} )();\n\n\t\t\t\tconst duckMesh = new THREE.InstancedMesh( duckModel.geometry, duckModel.material, NUM_DUCKS );\n\t\t\t\tscene.add( duckMesh );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\n\t\t\t\t// Stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tcontainer.style.touchAction = 'none';\n\t\t\t\tcontainer.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tcontainer.addEventListener( 'pointerdown', onPointerDown );\n\t\t\t\tcontainer.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( effectController.mouseSize, 'value', 0.1, .3 ).name( 'Mouse Size' );\n\t\t\t\tgui.add( effectController.mouseDeep, 'value', 0.1, 1 ).name( 'Mouse Deep' );\n\t\t\t\tgui.add( effectController.viscosity, 'value', 0.9, 0.96, 0.001 ).name( 'viscosity' );\n\t\t\t\tgui.add( effectController, 'speed', 1, 6, 1 );\n\t\t\t\tgui.add( effectController, 'ducksEnabled' ).onChange( () => {\n\t\t\t\n\t\t\t\t\tduckMesh.visible = effectController.ducksEnabled;\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.add( effectController, 'wireframe' ).onChange( () => {\n\t\t\t\n\t\t\t\t\twaterMesh.material.wireframe = ! waterMesh.material.wireframe;\n\t\t\t\t\tpoolBorder.material.wireframe = ! poolBorder.material.wireframe;\n\t\t\t\t\tduckModel.material.wireframe = ! duckModel.material.wireframe;\n\t\t\t\t\twaterMesh.material.needsUpdate = true;\n\t\t\t\t\tpoolBorder.material.needsUpdate = true;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction setMouseCoords( x, y ) {\n\n\t\t\t\tmouseCoords.set( ( x / renderer.domElement.clientWidth ) * 2 - 1, - ( y / renderer.domElement.clientHeight ) * 2 + 1 );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown() {\n\n\t\t\t\tmouseDown = true;\n\t\t\t\tfirstClick = true;\n\t\t\t\tupdateOriginMouseDown = true;\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction onPointerUp() {\n\n\t\t\t\tmouseDown = false;\n\t\t\t\tfirstClick = false;\n\t\t\t\tupdateOriginMouseDown = false;\n\n\t\t\t\tcontrols.enabled = true;\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tsetMouseCoords( event.clientX, event.clientY );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction raycast() {\n\n\t\t\t\tif ( mouseDown && ( firstClick || ! controls.enabled ) ) {\n\n\t\t\t\t\traycaster.setFromCamera( mouseCoords, camera );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObject( meshRay );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tconst point = intersects[ 0 ].point;\n\n\t\t\t\t\t\tif ( updateOriginMouseDown ) {\n\n\t\t\t\t\t\t\teffectController.mousePos.value.set( point.x, point.z );\n\n\t\t\t\t\t\t\tupdateOriginMouseDown = false;\n\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\teffectController.mouseSpeed.value.set(\n\t\t\t\t\t\t\t( point.x - effectController.mousePos.value.x ),\n\t\t\t\t\t\t\t( point.z - effectController.mousePos.value.y )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\teffectController.mousePos.value.set( point.x, point.z );\n\n\t\t\t\t\t\tif ( firstClick ) {\n\n\t\t\t\t\t\t\tcontrols.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tupdateOriginMouseDown = true;\n\n\t\t\t\t\t\teffectController.mouseSpeed.value.set( 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfirstClick = false;\n\t\t\t\n\t\t\t\t} else {\n\n\t\t\t\t\tupdateOriginMouseDown = true;\n\n\t\t\t\t\teffectController.mouseSpeed.value.set( 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\traycast();\n\n\t\t\t\tframe ++;\n\n\t\t\t\tif ( frame >= 7 - effectController.speed ) {\n\n\t\t\t\t\trenderer.computeAsync( computeHeight );\n\n\t\t\t\t\tif ( effectController.ducksEnabled ) {\n\n\t\t\t\t\t\trenderer.computeAsync( computeDucks );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tframe = 0;\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgpu compute water Click and move mouse to disturb water."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - cubemap adjustments"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - cubemap adjustments:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { uniform, mix, pmremTexture, reference, positionLocal, hue, saturation, positionWorld, normalWorld, positionWorldDirection, reflectVector } from 'three/tsl';\n\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst initialDistance = 2;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8 * initialDistance, 0.6 * initialDistance, 2.7 * initialDistance );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// cube textures\n\n\t\t\t\tconst rgbmUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\t\t\t\tconst cube1Texture = await new RGBMLoader()\n\t\t\t\t\t.setMaxRange( 16 )\n\t\t\t\t\t.setPath( './textures/cube/pisaRGBM16/' )\n\t\t\t\t\t.loadCubemapAsync( rgbmUrls );\n\n\t\t\t\tcube1Texture.generateMipmaps = true;\n\t\t\t\tcube1Texture.minFilter = THREE.LinearMipmapLinearFilter;\n\n\t\t\t\tconst cube2Urls = [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ];\n\t\t\t\tconst cube2Texture = await new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( './textures/cube/Park2/' )\n\t\t\t\t\t.loadAsync( cube2Urls );\n\n\t\t\t\tcube2Texture.generateMipmaps = true;\n\t\t\t\tcube2Texture.minFilter = THREE.LinearMipmapLinearFilter;\n\n\t\t\t\t// nodes and environment\n\n\t\t\t\tconst adjustments = {\n\t\t\t\t\tmix: 0,\n\t\t\t\t\tprocedural: 0,\n\t\t\t\t\tintensity: 1,\n\t\t\t\t\thue: 0,\n\t\t\t\t\tsaturation: 1\n\t\t\t\t};\n\n\t\t\t\tconst mixNode = reference( 'mix', 'float', adjustments );\n\t\t\t\tconst proceduralNode = reference( 'procedural', 'float', adjustments );\n\t\t\t\tconst intensityNode = reference( 'intensity', 'float', adjustments );\n\t\t\t\tconst hueNode = reference( 'hue', 'float', adjustments );\n\t\t\t\tconst saturationNode = reference( 'saturation', 'float', adjustments );\n\n\t\t\t\tconst rotateY1Matrix = new THREE.Matrix4();\n\t\t\t\tconst rotateY2Matrix = new THREE.Matrix4();\n\n\t\t\t\tconst getEnvironmentNode = ( reflectNode, positionNode ) => {\n\n\t\t\t\t\tconst custom1UV = reflectNode.xyz.mul( uniform( rotateY1Matrix ) );\n\t\t\t\t\tconst custom2UV = reflectNode.xyz.mul( uniform( rotateY2Matrix ) );\n\t\t\t\t\tconst mixCubeMaps = mix( pmremTexture( cube1Texture, custom1UV ), pmremTexture( cube2Texture, custom2UV ), positionNode.y.add( mixNode ).clamp() );\n\n\t\t\t\t\tconst proceduralEnv = mix( mixCubeMaps, normalWorld, proceduralNode );\n\n\t\t\t\t\tconst intensityFilter = proceduralEnv.mul( intensityNode );\n\t\t\t\t\tconst hueFilter = hue( intensityFilter, hueNode );\n\t\t\t\t\treturn saturation( hueFilter, saturationNode );\n\n\t\t\t\t};\n\n\t\t\t\tconst blurNode = uniform( 0 );\n\n\t\t\t\tscene.environmentNode = getEnvironmentNode( reflectVector, positionWorld );\n\n\t\t\t\tscene.backgroundNode = getEnvironmentNode( positionWorldDirection, positionLocal ).context( {\n\t\t\t\t\tgetTextureLevel: () => blurNode\n\t\t\t\t} );\n\n\t\t\t\t// scene objects\n\n\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\tconst gltf = await loader.loadAsync( 'DamagedHelmet.gltf' );\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( .5, 64, 32 );\n\n\t\t\t\tconst sphereRightView = new THREE.Mesh( sphereGeometry, new THREE.MeshStandardMaterial( { roughness: 0, metalness: 1 } ) );\n\t\t\t\tsphereRightView.position.x += 2;\n\n\t\t\t\tconst sphereLeftView = new THREE.Mesh( sphereGeometry, new THREE.MeshStandardMaterial( { roughness: 1, metalness: 1 } ) );\n\t\t\t\tsphereLeftView.position.x -= 2;\n\n\t\t\t\tscene.add( sphereLeftView );\n\t\t\t\tscene.add( sphereRightView );\n\n\t\t\t\t// renderer and controls\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( { blurBackground: blurNode.value }, 'blurBackground', 0, 1, 0.01 ).onChange( value => {\n\n\t\t\t\t\tblurNode.value = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( { offsetCube1: 0 }, 'offsetCube1', 0, Math.PI * 2, 0.01 ).onChange( value => {\n\n\t\t\t\t\trotateY1Matrix.makeRotationY( value );\n\n\t\t\t\t} );\n\t\t\t\tgui.add( { offsetCube2: 0 }, 'offsetCube2', 0, Math.PI * 2, 0.01 ).onChange( value => {\n\n\t\t\t\t\trotateY2Matrix.makeRotationY( value );\n\n\t\t\t\t} );\n\t\t\t\tgui.add( adjustments, 'mix', - 1, 2, 0.01 );\n\t\t\t\tgui.add( adjustments, 'procedural', 0, 1, 0.01 );\n\t\t\t\tgui.add( adjustments, 'intensity', 0, 5, 0.01 );\n\t\t\t\tgui.add( adjustments, 'hue', 0, Math.PI * 2, 0.01 );\n\t\t\t\tgui.add( adjustments, 'saturation', 0, 2, 0.01 );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Env. Adjustments Battle Damaged Sci-fi Helmet by theblueturtle_"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - dynamic cube reflection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - dynamic cube reflection:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet cube, sphere, torus, material;\n\n\t\t\tlet cubeCamera, cubeRenderTarget;\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 75;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst uvTexture = new THREE.TextureLoader().load( './textures/uv_grid_opengl.jpg' );\n\n\t\t\t\tconst rgbmUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\t\t\t\tconst texture = await new RGBMLoader()\n\t\t\t\t\t.setMaxRange( 16 )\n\t\t\t\t\t.setPath( './textures/cube/pisaRGBM16/' )\n\t\t\t\t\t.loadCubemapAsync( rgbmUrls );\n\n\t\t\t\ttexture.name = 'pisaRGBM16';\n\t\t\t\ttexture.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t//\n\n\t\t\t\tcubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );\n\t\t\t\tcubeRenderTarget.texture.type = THREE.HalfFloatType;\n\t\t\t\tcubeRenderTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\t\tcubeRenderTarget.texture.magFilter = THREE.LinearFilter;\n\t\t\t\tcubeRenderTarget.texture.generateMipmaps = true;\n\n\t\t\t\tcubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );\n\n\t\t\t\t//\n\n\t\t\t\tmaterial = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tenvMap: cubeRenderTarget.texture,\n\t\t\t\t\troughness: 0.05,\n\t\t\t\t\tmetalness: 1\n\t\t\t\t} );\n\n\t\t\t\tsphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 15, 8 ), material );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\tconst material1 = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tmap: uvTexture,\n\t\t\t\t\troughness: 0.1,\n\t\t\t\t\tmetalness: 0,\n\t\t\t\t} );\n\n\t\t\t\tconst material2 = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tmap: uvTexture,\n\t\t\t\t\troughness: 0.1,\n\t\t\t\t\tmetalness: 0,\n\t\t\t\t\tenvMap: texture,\n\t\t\t\t} );\n\n\t\t\t\tcube = new THREE.Mesh( new THREE.BoxGeometry( 15, 15, 15 ), material1 );\n\t\t\t\tscene.add( cube );\n\n\t\t\t\ttorus = new THREE.Mesh( new THREE.TorusKnotGeometry( 8, 3, 128, 16 ), material2 );\n\t\t\t\tscene.add( torus );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animation );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResized );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( material, 'roughness', 0, 1 );\n\t\t\t\tgui.add( material, 'metalness', 0, 1 );\n\t\t\t\tgui.add( renderer, 'toneMappingExposure', 0, 2 ).name( 'exposure' );\n\t\t\t\tgui.add( scene, 'environmentIntensity', 0, 1 );\n\t\t\t\tgui.add( material2, 'envMapIntensity', 0, 1 );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResized() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animation( msTime ) {\n\n\t\t\t\tconst time = msTime / 1000;\n\n\t\t\t\tcube.position.x = Math.cos( time ) * 30;\n\t\t\t\tcube.position.y = Math.sin( time ) * 30;\n\t\t\t\tcube.position.z = Math.sin( time ) * 30;\n\n\t\t\t\tcube.rotation.x += 0.02;\n\t\t\t\tcube.rotation.y += 0.03;\n\n\t\t\t\ttorus.position.x = Math.cos( time + 10 ) * 30;\n\t\t\t\ttorus.position.y = Math.sin( time + 10 ) * 30;\n\t\t\t\ttorus.position.z = Math.sin( time + 10 ) * 30;\n\n\t\t\t\ttorus.rotation.x += 0.02;\n\t\t\t\ttorus.rotation.y += 0.03;\n\n\t\t\t\tmaterial.visible = false;\n\n\t\t\t\tcubeCamera.update( renderer, scene );\n\n\t\t\t\tmaterial.visible = true;\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - dynamic cube reflection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - cubemap mix"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - cubemap mix:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mix, oscSine, time, pmremTexture, float } from 'three/tsl';\n\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst rgbmUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\t\t\t\tconst cube1Texture = new RGBMLoader()\n\t\t\t\t\t.setMaxRange( 16 )\n\t\t\t\t\t.setPath( './textures/cube/pisaRGBM16/' )\n\t\t\t\t\t.loadCubemap( rgbmUrls );\n\n\t\t\t\tcube1Texture.generateMipmaps = true;\n\t\t\t\tcube1Texture.minFilter = THREE.LinearMipmapLinearFilter;\n\n\t\t\t\tconst cube2Urls = [ 'dark-s_px.jpg', 'dark-s_nx.jpg', 'dark-s_py.jpg', 'dark-s_ny.jpg', 'dark-s_pz.jpg', 'dark-s_nz.jpg' ];\n\t\t\t\tconst cube2Texture = await new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( './textures/cube/MilkyWay/' )\n\t\t\t\t\t.loadAsync( cube2Urls );\n\n\t\t\t\tcube2Texture.generateMipmaps = true;\n\t\t\t\tcube2Texture.minFilter = THREE.LinearMipmapLinearFilter;\n\n\t\t\t\tscene.environmentNode = mix( pmremTexture( cube2Texture ), pmremTexture( cube1Texture ), oscSine( time.mul( .1 ) ) );\n\n\t\t\t\tscene.backgroundNode = scene.environmentNode.context( {\n\t\t\t\t\tgetTextureLevel: () => float( .5 )\n\t\t\t\t} );\n\n\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\tconst gltf = await loader.loadAsync( 'DamagedHelmet.gltf' );\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Mix Two CubeMaps Battle Damaged Sci-fi Helmet by theblueturtle_"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - custom fog"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - custom fog:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, fog, float, positionWorld, triNoise3D, positionView, normalWorld, uniform } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 600 );\n\t\t\t\tcamera.position.set( 30, 15, 30 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// custom fog\n\n\t\t\t\tconst skyColor = color( 0xf0f5f5 );\n\t\t\t\tconst groundColor = color( 0xd0dee7 );\n\n\t\t\t\tconst fogNoiseDistance = positionView.z.negate().smoothstep( 0, camera.far - 300 );\n\n\t\t\t\tconst distance = fogNoiseDistance.mul( 20 ).max( 4 );\n\t\t\t\tconst alpha = .98;\n\t\t\t\tconst groundFogArea = float( distance ).sub( positionWorld.y ).div( distance ).pow( 3 ).saturate().mul( alpha );\n\n\t\t\t\t// a alternative way to create a TimerNode\n\t\t\t\tconst timer = uniform( 0 ).onFrameUpdate( ( frame ) => frame.time );\n\n\t\t\t\tconst fogNoiseA = triNoise3D( positionWorld.mul( .005 ), 0.2, timer );\n\t\t\t\tconst fogNoiseB = triNoise3D( positionWorld.mul( .01 ), 0.2, timer.mul( 1.2 ) );\n\n\t\t\t\tconst fogNoise = fogNoiseA.add( fogNoiseB ).mul( groundColor );\n\n\t\t\t\t// apply custom fog\n\n\t\t\t\tscene.fogNode = fog( fogNoiseDistance.oneMinus().mix( groundColor, fogNoise ), groundFogArea );\n\t\t\t\tscene.backgroundNode = normalWorld.y.max( 0 ).mix( groundColor, skyColor );\n\n\t\t\t\t// builds\n\n\t\t\t\tconst buildWindows = positionWorld.y.mul( 10 ).floor().mod( 4 ).sign().mix( color( 0x000066 ).add( fogNoiseDistance ), color( 0xffffff ) );\n\n\t\t\t\tconst buildGeometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\tconst buildMaterial = new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolorNode: buildWindows\n\t\t\t\t} );\n\n\t\t\t\tconst buildMesh = new THREE.InstancedMesh( buildGeometry, buildMaterial, 4000 );\n\t\t\t\tscene.add( buildMesh );\n\n\t\t\t\tconst dummy = new THREE.Object3D();\n\t\t\t\tconst center = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < buildMesh.count; i ++ ) {\n\n\t\t\t\t\tconst scaleY = Math.random() * 7 + .5;\n\n\t\t\t\t\tdummy.position.x = Math.random() * 600 - 300;\n\t\t\t\t\tdummy.position.z = Math.random() * 600 - 300;\n\n\t\t\t\t\tconst distance = Math.max( dummy.position.distanceTo( center ) * .012, 1 );\n\n\t\t\t\t\tdummy.position.y = .5 * scaleY * distance;\n\n\t\t\t\t\tdummy.scale.x = dummy.scale.z = Math.random() * 3 + .5;\n\t\t\t\t\tdummy.scale.y = scaleY * distance;\n\n\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\tbuildMesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t}\n\n\t\t\t\t// lights\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( skyColor.value, groundColor.value, 0.5 ) );\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x999999\n\t\t\t\t} );\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.multiplyScalar( 3 );\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.minDistance = 7;\n\t\t\t\tcontrols.maxDistance = 100;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = .1;\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', resize );\n\n\t\t\t}\n\n\t\t\tfunction resize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - custom fog"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - custom fog background"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - custom fog background:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, color, rangeFogFactor } from 'three/tsl';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\t//renderer.toneMapping = THREE.ACESFilmicToneMapping; // apply tone mapping in post processing\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\t// render scene pass ( the same of css )\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassViewZ = scenePass.getViewZNode();\n\n\t\t\t\t// background color\n\t\t\t\tconst backgroundColor = color( 0x0066ff );\n\n\t\t\t\t// get fog factor from scene pass context\n\t\t\t\t// equivalent to: scene.fog = new THREE.Fog( 0x0066ff, 2.7, 4 );\n\t\t\t\tconst fogFactor = rangeFogFactor( 2.7, 4 ).context( { getViewZ: () => scenePassViewZ } );\n\n\t\t\t\t// tone mapping scene pass\n\t\t\t\tconst scenePassTM = scenePass.toneMapping( THREE.ACESFilmicToneMapping );\n\n\t\t\t\t// mix fog from fog factor and background color\n\t\t\t\tconst compose = fogFactor.mix( scenePassTM, backgroundColor );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = compose;\n\n\t\t\t\t//\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmet.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 5;\n\t\t\t\tcontrols.target.set( 0, - 0.1, - 0.2 );\n\t\t\t\tcontrols.update();\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tpostProcessing.renderAsync();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - custom fog background Battle Damaged Sci-fi Helmet by theblueturtle_ Royal Esplanade by HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - depth texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - depth texture:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, controls, renderer;\n\n\t\t\tlet quad, renderTarget;\n\n\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\t\t\t\tscene.overrideMaterial = new THREE.MeshBasicNodeMaterial();\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 1, 0.3, 128, 64 );\n\n\t\t\t\tconst count = 50;\n\t\t\t\tconst scale = 5;\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst r = Math.random() * 2.0 * Math.PI;\n\t\t\t\t\tconst z = ( Math.random() * 2.0 ) - 1.0;\n\t\t\t\t\tconst zScale = Math.sqrt( 1.0 - z * z ) * scale;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry );\n\t\t\t\t\tmesh.position.set(\n\t\t\t\t\t\tMath.cos( r ) * zScale,\n\t\t\t\t\t\tMath.sin( r ) * zScale,\n\t\t\t\t\t\tz * scale\n\t\t\t\t\t);\n\t\t\t\t\tmesh.rotation.set( Math.random(), Math.random(), Math.random() );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( dpr );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst depthTexture = new THREE.DepthTexture();\n\t\t\t\tdepthTexture.type = THREE.FloatType;\n\n\t\t\t\trenderTarget = new THREE.RenderTarget( window.innerWidth * dpr, window.innerHeight * dpr );\n\t\t\t\trenderTarget.depthTexture = depthTexture;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// FX\n\n\t\t\t\tconst materialFX = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterialFX.colorNode = texture( depthTexture );\n\n\t\t\t\tquad = new THREE.QuadMesh( materialFX );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tquad.render( renderer );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - depth texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - stereo effects"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - stereo effects:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { stereoPass } from 'three/addons/tsl/display/StereoPassNode.js';\n\t\t\timport { anaglyphPass } from 'three/addons/tsl/display/AnaglyphPassNode.js';\n\t\t\timport { parallaxBarrierPass } from 'three/addons/tsl/display/ParallaxBarrierPassNode.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, postProcessing;\n\n\t\t\tlet stereo, anaglyph, parallaxBarrier;\n\n\t\t\tlet mesh, dummy, timer;\n\n\t\t\tconst position = new THREE.Vector3();\n\n\t\t\tconst params = {\n\t\t\t\teffect: 'stereo',\n\t\t\t\teyeSep: 0.064,\n\t\t\t};\n\n\t\t\tconst effects = { Stereo: 'stereo', Anaglyph: 'anaglyph', ParallaxBarrier: 'parallaxBarrier' };\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/Park3Med/' )\n\t\t\t\t\t.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.1, 32, 16 );\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/Park3Med/' )\n\t\t\t\t\t.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, 500 );\n\t\t\t\tmesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\n\t\t\t\tdummy = new THREE.Mesh();\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tdummy.position.x = Math.random() * 10 - 5;\n\t\t\t\t\tdummy.position.y = Math.random() * 10 - 5;\n\t\t\t\t\tdummy.position.z = Math.random() * 10 - 5;\n\t\t\t\t\tdummy.scale.x = dummy.scale.y = dummy.scale.z = Math.random() * 3 + 1;\n\t\t\t\n\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tstereo = stereoPass( scene, camera );\n\t\t\t\tanaglyph = anaglyphPass( scene, camera );\n\t\t\t\tparallaxBarrier = parallaxBarrierPass( scene, camera );\n\n\t\t\t\tpostProcessing.outputNode = stereo;\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'effect', effects ).onChange( update );\n\t\t\t\tgui.add( params, 'eyeSep', 0.001, 0.15, 0.001 ).onChange( function ( value ) {\n\n\t\t\t\t\tstereo.stereo.eyeSep = value;\n\n\t\t\t\t\tanaglyph.stereo.eyeSep = value;\n\t\t\t\t\tparallaxBarrier.stereo.eyeSep = value;\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 25;\n\n\t\t\t}\n\n\t\t\tfunction update( value ) {\n\n\t\t\t\tif ( value === 'stereo' ) {\n\n\t\t\t\t\tpostProcessing.outputNode = stereo;\n\n\t\t\t\t} else if ( value === 'anaglyph' ) {\n\n\t\t\t\t\tpostProcessing.outputNode = anaglyph;\n\n\t\t\t\t} else if ( value === 'parallaxBarrier' ) {\n\n\t\t\t\t\tpostProcessing.outputNode = parallaxBarrier;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction extractPosition( matrix, position ) {\n\n\t\t\t\tposition.x = matrix.elements[ 12 ];\n\t\t\t\tposition.y = matrix.elements[ 13 ];\n\t\t\t\tposition.z = matrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\tconst elapsedTime = timer.getElapsed() * 0.1;\n\n\t\t\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\t\t\tmesh.getMatrixAt( i, dummy.matrix );\n\n\t\t\t\t\textractPosition( dummy.matrix, position );\n\n\t\t\t\t\tposition.x = 5 * Math.cos( elapsedTime + i );\n\t\t\t\t\tposition.y = 5 * Math.sin( elapsedTime + i * 1.1 );\n\n\t\t\t\t\tdummy.matrix.setPosition( position );\n\n\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js - stereo effects. skybox by Jochum Skoglund"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - equirectangular"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - equirectangular:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, equirectUV } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( 1, 0, 0 );\n\n\t\t\t\tconst equirectTexture = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );\n\t\t\t\tequirectTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = texture( equirectTexture, equirectUV(), 0 );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.rotateSpeed = - 0.125; // negative, to track mouse pointer\n\t\t\t\tcontrols.autoRotateSpeed = 1.0;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tconst gui = new GUI();\n\n\t\t\tconst params = {\n\t\t\t\tintensity: 1.0,\n\t\t\t};\n\t\t\tgui.add( params, 'intensity', 0, 1 ).onChange( function ( value ) {\n\n\t\t\t\tscene.backgroundIntensity = value;\n\t\t\t\trender();\n\n\t\t\t} );\n```\n\nThis example three.js webgpu - equirectangular panorama demo. photo by J\u00f3n Ragnarsson ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - instance mesh"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - instance mesh:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mix, range, normalWorld, oscSine, time } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tlet mesh;\n\t\t\tconst amount = parseInt( window.location.search.slice( 1 ) ) || 10;\n\t\t\tconst count = Math.pow( amount, 3 );\n\t\t\tconst dummy = new THREE.Object3D();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( amount * 0.9, amount * 0.9, amount * 0.9 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial();\n\n\t\t\t\t// random colors between instances from 0x000000 to 0xFFFFFF\n\t\t\t\tconst randomColors = range( new THREE.Color( 0x000000 ), new THREE.Color( 0xFFFFFF ) );\n\n\t\t\t\tmaterial.colorNode = mix( normalWorld, randomColors, oscSine( time.mul( .1 ) ) );\n\n\t\t\t\tconst loader = new THREE.BufferGeometryLoader();\n\t\t\t\tloader.load( 'models/json/suzanne_buffergeometry.json', function ( geometry ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\tgeometry.scale( 0.5, 0.5, 0.5 );\n\n\t\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, count );\n\t\t\t\t\tmesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\tgui.add( mesh, 'count', 1, count );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tasync function render() {\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tconst time = Date.now() * 0.001;\n\n\t\t\t\t\tmesh.rotation.x = Math.sin( time / 4 );\n\t\t\t\t\tmesh.rotation.y = Math.sin( time / 2 );\n\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\tconst offset = ( amount - 1 ) / 2;\n\n\t\t\t\t\tfor ( let x = 0; x < amount; x ++ ) {\n\n\t\t\t\t\t\tfor ( let y = 0; y < amount; y ++ ) {\n\n\t\t\t\t\t\t\tfor ( let z = 0; z < amount; z ++ ) {\n\n\t\t\t\t\t\t\t\tdummy.position.set( offset - x, offset - y, offset - z );\n\t\t\t\t\t\t\t\tdummy.rotation.y = ( Math.sin( x / 4 + time ) + Math.sin( y / 4 + time ) + Math.sin( z / 4 + time ) );\n\t\t\t\t\t\t\t\tdummy.rotation.z = dummy.rotation.y * 2;\n\n\t\t\t\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\t\t\t\tmesh.setMatrixAt( i ++, dummy.matrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tawait renderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - instance mesh"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - geometry path"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - geometry path:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { abs, add, instancedBufferAttribute, positionLocal, mod, time, sin, vec3, select, float, screenUV, color } from 'three/tsl';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tconst count = 1000;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 15;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = screenUV.distance( .5 ).remap( 0, 0.65 ).mix( color( 0x94254c ), color( 0x000000 ) );\n\n\t\t\t\t// generate a path representing a heart shape\n\n\t\t\t\tconst x = 0, y = 0;\n\n\t\t\t\tconst path = new THREE.Path()\n\t\t\t\t\t.moveTo( x - 2.5, y - 2.5 )\n\t\t\t\t\t.bezierCurveTo( x - 2.5, y - 2.5, x - 2, y, x, y )\n\t\t\t\t\t.bezierCurveTo( x + 3, y, x + 3, y - 3.5, x + 3, y - 3.5 )\n\t\t\t\t\t.bezierCurveTo( x + 3, y - 5.5, x + 1, y - 7.7, x - 2.5, y - 9.5 )\n\t\t\t\t\t.bezierCurveTo( x - 6, y - 7.7, x - 8, y - 5.5, x - 8, y - 3.5 )\n\t\t\t\t\t.bezierCurveTo( x - 8, y - 3.5, x - 8, y, x - 5, y )\n\t\t\t\t\t.bezierCurveTo( x - 3.5, y, x - 2.5, y - 2.5, x - 2.5, y - 2.5 );\n\n\t\t\t\t// generate instanced ico-spheres along the path\n\t\t\t\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 0.1 );\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial();\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.position.set( 2.5, 5, 0 );\n\t\t\t\tmesh.count = count;\n\t\t\t\tmesh.frustumCulled = false;\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// instance data\n\n\t\t\t\tconst v = new THREE.Vector3();\n\t\t\t\tconst c = new THREE.Color();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst times = [];\n\t\t\t\tconst seeds = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst t = i / count;\n\t\t\t\t\tpath.getPointAt( t, v );\n\n\t\t\t\t\tv.x += ( 0.5 - Math.random() );\n\t\t\t\t\tv.y += ( 0.5 - Math.random() );\n\t\t\t\t\tv.z = ( 0.5 - Math.random() );\n\n\t\t\t\t\tpositions.push( v.x, v.y, v.z );\n\t\t\t\t\ttimes.push( t );\n\t\t\t\t\tseeds.push( Math.random() );\n\n\t\t\t\t\tc.setHSL( 0.75 + ( Math.random() * 0.25 ), 1, 0.4 );\n\n\t\t\t\t\tcolors.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t\t\tconst colorAttribute = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );\n\t\t\t\tconst timeAttribute = new THREE.InstancedBufferAttribute( new Float32Array( times ), 1 );\n\t\t\t\tconst seedAttribute = new THREE.InstancedBufferAttribute( new Float32Array( seeds ), 1 );\n\n\t\t\t\t// TSL\n\n\t\t\t\tconst instancePosition = instancedBufferAttribute( positionAttribute );\n\t\t\t\tconst instanceColor = instancedBufferAttribute( colorAttribute );\n\t\t\t\tconst instanceSeed = instancedBufferAttribute( seedAttribute );\n\t\t\t\tconst instanceTime = instancedBufferAttribute( timeAttribute );\n\n\t\t\t\tconst localTime = instanceTime.add( time );\n\t\t\t\tconst modTime = mod( time.mul( 0.4 ), 1 );\n\t\t\t\n\t\t\t\tconst s0 = sin( localTime.add( instanceSeed ) ).mul( 0.25 );\n\t\t\t\n\t\t\t\tconst dist = abs( instanceTime.sub( modTime ) ).toConst(); // modTime and instanceTime are in the range [0,1]\n\t\t\t\tconst wrapDist = select( dist.greaterThan( 0.5 ), dist.oneMinus(), dist ).toConst(); // the normalized distance should wrap around 0/1\n\t\t\t\tconst s1 = select( wrapDist.greaterThan( 0.1 ), float( 1 ), wrapDist.remap( 0, 0.1, 3, 1 ) ); // compute a scale in a range around the current interpolated value\n\t\t\t\n\t\t\t\tconst offset = vec3( instancePosition.x, instancePosition.y.add( s0 ), instancePosition.z ).toConst( 'offset' );\n\t\t\t\tmaterial.positionNode = add( positionLocal.mul( s1 ), offset );\n\t\t\t\tmaterial.colorNode = instanceColor;\n\t\t\t\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - geometry path"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - points instanced"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - points instanced:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, storage, Fn, instancedBufferAttribute, instanceIndex, sin, time, float, uniform, shapeCircle, mix, vec3 } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n\n\t\t\tlet renderer, scene, camera, camera2, controls, backgroundNode;\n\t\t\tlet material;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\t\t\tlet effectController;\n\n\t\t\t// viewport\n\t\t\tlet insetWidth;\n\t\t\tlet insetHeight;\n\n\t\t\t// compute\n\t\t\tlet computeSize;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 40, 0, 60 );\n\n\t\t\t\tcamera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );\n\t\t\t\tcamera2.position.copy( camera.position );\n\n\t\t\t\tbackgroundNode = color( 0x222222 );\n\n\t\t\t\teffectController = {\n\n\t\t\t\t\tpulseSpeed: uniform( 6 ),\n\t\t\t\t\tminWidth: uniform( 6 ),\n\t\t\t\t\tmaxWidth: uniform( 20 ),\n\t\t\t\t\talphaToCoverage: true\n\n\t\t\t\t};\n\n\t\t\t\t// Position and THREE.Color Data\n\n\t\t\t\tconst points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );\n\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( points );\n\t\t\t\tconst divisions = Math.round( 4 * points.length );\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst pointColor = new THREE.Color();\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\t\t\t\tconst sizes = new Float32Array( divisions );\n\n\t\t\t\tfor ( let i = 0, l = divisions; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = i / l;\n\n\t\t\t\t\tspline.getPoint( t, point );\n\t\t\t\t\tpositions.push( point.x, point.y, point.z );\n\n\t\t\t\t\tpointColor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors.push( pointColor.r, pointColor.g, pointColor.b );\n\n\t\t\t\t\tsizes[ i ] = 10.0;\n\n\t\t\t\t}\n\n\t\t\t\t// Instanced Points\n\n\t\t\t\tconst positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t\t\tconst colorsAttribute = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );\n\n\t\t\t\tconst instanceSizeBufferAttribute = new THREE.StorageInstancedBufferAttribute( sizes, 1 );\n\t\t\t\tconst instanceSizeStorage = storage( instanceSizeBufferAttribute, 'float', instanceSizeBufferAttribute.count );\n\n\t\t\t\tcomputeSize = Fn( () => {\n\n\t\t\t\t\tconst { pulseSpeed, minWidth, maxWidth } = effectController;\n\n\t\t\t\t\tconst relativeTime = time.add( float( instanceIndex ) );\n\n\t\t\t\t\tconst sizeFactor = sin( relativeTime.mul( pulseSpeed ) ).add( 1 ).div( 2 );\n\n\t\t\t\t\tinstanceSizeStorage.element( instanceIndex ).assign( sizeFactor.mul( maxWidth.sub( minWidth ) ).add( minWidth ) );\n\n\t\t\t\t} )().compute( divisions );\n\t\t\t\n\t\t\t\t// Material / Sprites\n\n\t\t\t\tconst attributeRange = instancedBufferAttribute( instanceSizeBufferAttribute );\n\t\t\t\tconst pointColors = mix( vec3( 0.0 ), instancedBufferAttribute( colorsAttribute ), attributeRange.div( float( effectController.maxWidth ) ) );\n\n\t\t\t\tmaterial = new THREE.PointsNodeMaterial( {\n\n\t\t\t\t\tcolorNode: pointColors,\n\t\t\t\t\topacityNode: shapeCircle(),\n\t\t\t\t\tpositionNode: instancedBufferAttribute( positionAttribute ),\n\t\t\t\t\t// rotationNode: time,\n\t\t\t\t\tsizeNode: instancedBufferAttribute( instanceSizeBufferAttribute ),\n\t\t\t\t\t// size: 40, // in pixels units\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tsizeAttenuation: false,\n\t\t\t\t\talphaToCoverage: true\n\n\t\t\t\t} );\n\n\t\t\t\tconst instancedPoints = new THREE.Sprite( material );\n\t\t\t\tinstancedPoints.count = divisions;\n\t\t\t\tscene.add( instancedPoints );\n\n\t\t\t\t// Renderer / Controls\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\t//renderer.logarithmicDepthBuffer = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\t// GUI\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( effectController, 'alphaToCoverage' ).onChange( function ( val ) {\n\n\t\t\t\t\tmaterial.alphaToCoverage = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( effectController.minWidth, 'value', 1, 30, 1 ).name( 'minWidth' );\n\t\t\t\tgui.add( effectController.maxWidth, 'value', 2, 30, 1 ).name( 'maxWidth' );\n\t\t\t\tgui.add( effectController.pulseSpeed, 'value', 1, 20, 0.1 ).name( 'pulseSpeed' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tinsetWidth = window.innerHeight / 4; // square\n\t\t\t\tinsetHeight = window.innerHeight / 4;\n\n\t\t\t\tcamera2.aspect = insetWidth / insetHeight;\n\t\t\t\tcamera2.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\t// compute\n\n\t\t\t\trenderer.compute( computeSize );\n\n\t\t\t\t// main scene\n\n\t\t\t\trenderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.autoClear = true;\n\n\t\t\t\tscene.backgroundNode = null;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// inset scene\n\n\t\t\t\tconst posY = window.innerHeight - insetHeight - 20;\n\n\t\t\t\trenderer.clearDepth(); // important!\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 20, posY, insetWidth, insetHeight );\n\n\t\t\t\trenderer.setViewport( 20, posY, insetWidth, insetHeight );\n\n\t\t\t\tcamera2.position.copy( camera.position );\n\n\t\t\t\tcamera2.quaternion.copy( camera.quaternion );\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tscene.backgroundNode = backgroundNode;\n\n\t\t\t\trenderer.render( scene, camera2 );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n\n\t\t\t//\n```\n\nThis example three.js webgpu - instanced points"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - instance sprites"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - instance sprites:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { uniform, time, instanceIndex, instancedBufferAttribute } from 'three/tsl';\n\n\n\t\t\tlet camera, scene, renderer, stats, material;\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 2, 2000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.FogExp2( 0x000000, 0.001 );\n\n\t\t\t\t// positions\n\n\t\t\t\tconst count = 10000;\n\n\t\t\t\tconst positions = [];\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tpositions.push( 2000 * Math.random() - 1000, 2000 * Math.random() - 1000, 2000 * Math.random() - 1000 );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\n\t\t\t\t// texture\n\n\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/sprites/snowflake1.png' );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// material\n\n\t\t\t\tmaterial = new THREE.SpriteNodeMaterial( { sizeAttenuation: true, map, alphaMap: map, alphaTest: 0.1 } );\n\t\t\t\tmaterial.color.setHSL( 1.0, 0.3, 0.7, THREE.SRGBColorSpace );\n\t\t\t\tmaterial.positionNode = instancedBufferAttribute( positionAttribute );\n\t\t\t\tmaterial.rotationNode = time.add( instanceIndex ).sin();\n\t\t\t\tmaterial.scaleNode = uniform( 15 );\n\n\t\t\t\t// sprites\n\n\t\t\t\tconst particles = new THREE.Sprite( material );\n\t\t\t\tparticles.count = count;\n\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( material, 'sizeAttenuation' ).onChange( function () {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\tmaterial.scaleNode.value = material.sizeAttenuation ? 15 : 0.03;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.style.touchAction = 'none';\n\t\t\t\tdocument.body.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.00005;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst h = ( 360 * ( 1.0 + time ) % 360 ) / 360;\n\t\t\t\tmaterial.color.setHSL( h, 0.5, 0.5 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - instance sprites"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - instance uniform"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - instance uniform:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { nodeObject, uniform, cubeTexture } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tclass InstanceUniformNode extends THREE.Node {\n\n\t\t\t\tconstructor() {\n\n\t\t\t\t\tsuper( 'vec3' );\n\n\t\t\t\t\tthis.updateType = THREE.NodeUpdateType.OBJECT;\n\n\t\t\t\t\tthis.uniformNode = uniform( new THREE.Color() );\n\n\t\t\t\t}\n\n\t\t\t\tupdate( frame ) {\n\n\t\t\t\t\tconst mesh = frame.object;\n\n\t\t\t\t\tconst meshColor = mesh.color;\n\n\t\t\t\t\tthis.uniformNode.value.copy( meshColor );\n\n\t\t\t\t}\n\n\t\t\t\tsetup( /*builder*/ ) {\n\n\t\t\t\t\treturn this.uniformNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet stats;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tconst objects = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );\n\t\t\t\tcamera.position.set( 0, 200, 1200 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Grid\n\n\t\t\t\tconst helper = new THREE.GridHelper( 1000, 40, 0x303030, 0x303030 );\n\t\t\t\thelper.position.y = - 75;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\t// CubeMap\n\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst cTexture = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\t// Materials\n\n\t\t\t\tconst instanceUniform = nodeObject( new InstanceUniformNode() );\n\t\t\t\tconst cubeTextureNode = cubeTexture( cTexture );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = instanceUniform.add( cubeTextureNode );\n\t\t\t\tmaterial.emissiveNode = instanceUniform.mul( cubeTextureNode );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tconst geometry = new TeapotGeometry( 50, 18 );\n\n\t\t\t\tfor ( let i = 0, l = 12; i < l; i ++ ) {\n\n\t\t\t\t\taddMesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 400;\n\t\t\t\tcontrols.maxDistance = 2000;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction addMesh( geometry, material ) {\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\tmesh.color = new THREE.Color( Math.random() * 0xffffff );\n\n\t\t\t\tmesh.position.x = ( objects.length % 4 ) * 200 - 300;\n\t\t\t\tmesh.position.z = Math.floor( objects.length / 4 ) * 200 - 200;\n\n\t\t\t\tmesh.rotation.x = Math.random() * 200 - 100;\n\t\t\t\tmesh.rotation.y = Math.random() * 200 - 100;\n\t\t\t\tmesh.rotation.z = Math.random() * 200 - 100;\n\n\t\t\t\tobjects.push( mesh );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tobject.rotation.x += 0.01;\n\t\t\t\t\tobject.rotation.y += 0.005;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - instance uniform"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - instancing morph target animations"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - instancing morph target animations:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats, mesh, mixer, dummy;\n\n\t\t\tconst offset = 5000;\n\n\t\t\tconst timeOffsets = new Float32Array( 1024 );\n\n\t\t\tfor ( let i = 0; i < 1024; i ++ ) {\n\n\t\t\t\ttimeOffsets[ i ] = Math.random() * 3;\n\n\t\t\t}\n\n\t\t\tconst clock = new THREE.Clock( true );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 10000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.background = new THREE.Color( 0x99DDFF );\n\n\t\t\t\tscene.fog = new THREE.Fog( 0x99DDFF, 5000, 10000 );\n\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\n\t\t\t\tlight.position.set( 200, 1000, 50 );\n\n\t\t\t\tlight.shadow.mapSize.width = 2048;\n\t\t\t\tlight.shadow.mapSize.height = 2048;\n\t\t\t\tlight.castShadow = true;\n\n\t\t\t\tlight.shadow.camera.left = - 5000;\n\t\t\t\tlight.shadow.camera.right = 5000;\n\t\t\t\tlight.shadow.camera.top = 5000;\n\t\t\t\tlight.shadow.camera.bottom = - 5000;\n\t\t\t\tlight.shadow.camera.far = 2000;\n\n\t\t\t\tlight.shadow.bias = - 0.01;\n\n\t\t\t\tlight.shadow.camera.updateProjectionMatrix();\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst hemi = new THREE.HemisphereLight( 0x99DDFF, 0x669933, 1 / 3 );\n\n\t\t\t\tscene.add( hemi );\n\n\t\t\t\tconst ground = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 1000000, 1000000 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( { color: 0x669933 } )\n\t\t\t\t);\n\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\n\t\t\t\tloader.load( 'models/gltf/Horse.glb', function ( glb ) {\n\n\t\t\t\t\tdummy = glb.scene.children[ 0 ];\n\n\t\t\t\t\tmesh = new THREE.InstancedMesh( dummy.geometry, new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\t\tflatShading: true,\n\t\t\t\t\t} ), 1024 );\n\n\t\t\t\t\tmesh.castShadow = true;\n\n\t\t\t\t\tfor ( let x = 0, i = 0; x < 32; x ++ ) {\n\n\t\t\t\t\t\tfor ( let y = 0; y < 32; y ++ ) {\n\n\t\t\t\t\t\t\tdummy.position.set( offset - 300 * x + 200 * Math.random(), 0, offset - 300 * y );\n\n\t\t\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\n\t\t\t\t\t\t\tmesh.setColorAt( i, new THREE.Color( `hsl(${Math.random() * 360}, 50%, 66%)` ) );\n\n\t\t\t\t\t\t\ti ++;\n\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( glb.scene );\n\n\t\t\t\t\tconst action = mixer.clipAction( glb.animations[ 0 ] );\n\n\t\t\t\t\taction.play();\n\t\t\t\n\t\t\t\t} );\n\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\t\tconst r = 3000;\n\t\t\t\tcamera.position.set( Math.sin( time / 10 ) * r, 1500 + 1000 * Math.cos( time / 5 ), Math.cos( time / 10 ) * r );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 1024; i ++ ) {\n\n\t\t\t\t\t\tmixer.setTime( time + timeOffsets[ i ] );\n\n\t\t\t\t\t\tmesh.setMorphAt( i, dummy );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.morphTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - layers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - layers:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { positionLocal, time, mod, instancedBufferAttribute, rotate, screenUV, color, vec2 } from 'three/tsl';\n\n\t\t\tlet camera, scene, renderer;\n\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.layers.enable( 0 ); // enabled by default\n\t\t\t\tcamera.layers.enable( 1 );\n\t\t\t\tcamera.layers.enable( 2 );\n\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\n\t\t\t\tconst horizontalEffect = screenUV.x.mix( color( 0xf996ae ), color( 0xf6f0a3 ) );\n\t\t\t\tconst lightEffect = screenUV.distance( vec2( 0.5, 1.0 ) ).oneMinus().mul( color( 0xd9b6fd ) );\n\n\t\t\t\tscene.backgroundNode = horizontalEffect.add( lightEffect );\n\n\t\t\t\tconst sprite = new THREE.TextureLoader().load( 'textures/sprites/blossom.png' );\n\t\t\t\tsprite.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst count = 2500;\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 0.25, 0.25 );\n\n\t\t\t\tconst colors = [ 0xD70654, 0xFFD95F, 0xB8D576 ];\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst particles = new THREE.Mesh( geometry, getMaterial( count, colors[ i ], sprite ) );\n\t\t\t\t\tparticles.layers.set( i );\n\t\t\t\t\tparticles.count = count;\n\t\t\t\t\tscene.add( particles );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst layers = {\n\n\t\t\t\t\t'toggle red': function () {\n\n\t\t\t\t\t\tcamera.layers.toggle( 0 );\n\n\t\t\t\t\t},\n\n\t\t\t\t\t'toggle yellow': function () {\n\n\t\t\t\t\t\tcamera.layers.toggle( 1 );\n\n\t\t\t\t\t},\n\n\t\t\t\t\t'toggle green': function () {\n\n\t\t\t\t\t\tcamera.layers.toggle( 2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t\t'enable all': function () {\n\n\t\t\t\t\t\tcamera.layers.enableAll();\n\n\t\t\t\t\t},\n\n\t\t\t\t\t'disable all': function () {\n\n\t\t\t\t\t\tcamera.layers.disableAll();\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( layers, 'toggle red' );\n\t\t\t\tgui.add( layers, 'toggle yellow' );\n\t\t\t\tgui.add( layers, 'toggle green' );\n\t\t\t\tgui.add( layers, 'enable all' );\n\t\t\t\tgui.add( layers, 'disable all' );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( count, color, sprite ) {\n\n\t\t\t\t// instance data\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst rotations = [];\n\t\t\t\tconst directions = [];\n\t\t\t\tconst timeOffsets = [];\n\n\t\t\t\tconst v = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\t\t\t\n\t\t\t\t\tpositions.push(\n\t\t\t\t\t\tTHREE.MathUtils.randFloat( - 25, - 20 ),\n\t\t\t\t\t\tTHREE.MathUtils.randFloat( - 10, 50 ),\n\t\t\t\t\t\tTHREE.MathUtils.randFloat( - 5, 5 )\n\t\t\t\t\t);\n\n\t\t\t\t\tv.set( THREE.MathUtils.randFloat( 0.7, 0.9 ), THREE.MathUtils.randFloat( - 0.3, - 0.15 ), 0 ).normalize();\n\n\t\t\t\t\trotations.push( Math.random(), Math.random(), Math.random() );\n\n\t\t\t\t\tdirections.push( v.x, v.y, v.z );\n\n\t\t\t\t\ttimeOffsets.push( i / count );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t\t\tconst rotationAttribute = new THREE.InstancedBufferAttribute( new Float32Array( rotations ), 3 );\n\t\t\t\tconst directionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( directions ), 3 );\n\t\t\t\tconst timeAttribute = new THREE.InstancedBufferAttribute( new Float32Array( timeOffsets ), 1 );\n\n\t\t\t\t// material\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( {\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tmap: sprite,\n\t\t\t\t\talphaMap: sprite,\n\t\t\t\t\talphaTest: 0.1,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tforceSinglePass: true\n\t\t\t\t} );\n\n\t\t\t\t// TSL\n\n\t\t\t\tconst instancePosition = instancedBufferAttribute( positionAttribute );\n\t\t\t\tconst instanceDirection = instancedBufferAttribute( directionAttribute );\n\t\t\t\tconst instanceRotation = instancedBufferAttribute( rotationAttribute );\n\n\t\t\t\tconst localTime = instancedBufferAttribute( timeAttribute ).add( time.mul( 0.02 ) );\n\t\t\t\tconst modTime = mod( localTime, 1.0 );\n\n\t\t\t\tconst rotatedPositon = rotate( positionLocal, instanceRotation.mul( modTime.mul( 20 ) ) );\n\t\t\t\tmaterial.positionNode = rotatedPositon.add( instancePosition ).add( instanceDirection.mul( modTime.mul( 50 ) ) );\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgpu layers"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - lensflares"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - lensflares:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { FlyControls } from 'three/addons/controls/FlyControls.js';\n\t\t\timport { LensflareMesh, LensflareElement } from 'three/addons/objects/LensflareMesh.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 15000 );\n\t\t\t\tcamera.position.z = 250;\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color().setHSL( 0.51, 0.4, 0.01, THREE.SRGBColorSpace );\n\t\t\t\tscene.fog = new THREE.Fog( scene.background, 3500, 15000 );\n\n\t\t\t\t// world\n\n\t\t\t\tconst s = 250;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( s, s, s );\n\t\t\t\tconst material = new THREE.MeshPhongNodeMaterial( { color: 0xffffff, specular: 0xffffff, shininess: 50 } );\n\n\t\t\t\tfor ( let i = 0; i < 3000; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = 8000 * ( 2.0 * Math.random() - 1.0 );\n\t\t\t\t\tmesh.position.y = 8000 * ( 2.0 * Math.random() - 1.0 );\n\t\t\t\t\tmesh.position.z = 8000 * ( 2.0 * Math.random() - 1.0 );\n\n\t\t\t\t\tmesh.rotation.x = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.y = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.z = Math.random() * Math.PI;\n\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tmesh.updateMatrix();\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\n\t\t\t\t// lights\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 0.15 );\n\t\t\t\tdirLight.position.set( 0, - 1, 0 ).normalize();\n\t\t\t\tdirLight.color.setHSL( 0.1, 0.7, 0.5 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t// lensflares\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst textureFlare0 = textureLoader.load( 'textures/lensflare/lensflare0.png' );\n\t\t\t\tconst textureFlare3 = textureLoader.load( 'textures/lensflare/lensflare3.png' );\n\n\t\t\t\ttextureFlare0.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttextureFlare3.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\taddLight( 0.55, 0.95, 0.6, 5000, 0, - 1000 );\n\t\t\t\taddLight( 0.1, 0.85, 0.65, 0, 0, - 1000 );\n\t\t\t\taddLight( 0.995, 0.5, 0.95, 5000, 5000, - 1000 );\n\n\t\t\t\tfunction addLight( h, s, l, x, y, z ) {\n\n\t\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 1.5, 2000, 0 );\n\t\t\t\t\tlight.color.setHSL( h, s, l );\n\t\t\t\t\tlight.position.set( x, y, z );\n\t\t\t\t\tscene.add( light );\n\n\t\t\t\t\tconst lensflare = new LensflareMesh();\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare0, 700, 0, light.color ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 60, 0.6 ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 70, 0.7 ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 120, 0.9 ) );\n\t\t\t\t\tlensflare.addElement( new LensflareElement( textureFlare3, 70, 1 ) );\n\t\t\t\t\tlight.add( lensflare );\n\n\t\t\t\t}\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new FlyControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.movementSpeed = 2500;\n\t\t\t\tcontrols.domElement = container;\n\t\t\t\tcontrols.rollSpeed = Math.PI / 6;\n\t\t\t\tcontrols.autoForward = false;\n\t\t\t\tcontrols.dragToLook = false;\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// events\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tcontrols.update( delta );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - lensflares textures from ro.me fly with WASD/RF/QE + mouse"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - light probe"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - light probe:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n\n\t\t\timport { LightProbeHelper } from 'three/addons/helpers/LightProbeHelperGPU.js';\n\n\t\t\tlet mesh, renderer, scene, camera;\n\n\t\t\tlet gui;\n\n\t\t\tlet lightProbe;\n\t\t\tlet directionalLight;\n\n\t\t\t// linear color space\n\t\t\tconst API = {\n\t\t\t\tlightProbeIntensity: 1.0,\n\t\t\t\tdirectionalLightIntensity: 0.6,\n\t\t\t\tenvMapIntensity: 1\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// tone mapping\n\t\t\t\trenderer.toneMapping = THREE.NoToneMapping;\n\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 30 );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// probe\n\t\t\t\tlightProbe = new THREE.LightProbe();\n\t\t\t\tscene.add( lightProbe );\n\n\t\t\t\t// light\n\t\t\t\tdirectionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );\n\t\t\t\tdirectionalLight.position.set( 10, 10, 10 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// envmap\n\t\t\t\tconst genCubeUrls = function ( prefix, postfix ) {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tprefix + 'px' + postfix, prefix + 'nx' + postfix,\n\t\t\t\t\t\tprefix + 'py' + postfix, prefix + 'ny' + postfix,\n\t\t\t\t\t\tprefix + 'pz' + postfix, prefix + 'nz' + postfix\n\t\t\t\t\t];\n\n\t\t\t\t};\n\n\t\t\t\tconst urls = genCubeUrls( 'textures/cube/pisa/', '.png' );\n\n\t\t\t\tnew THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {\n\n\t\t\t\t\tscene.background = cubeTexture;\n\n\t\t\t\t\tlightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );\n\t\t\t\t\tlightProbe.intensity = API.lightProbeIntensity;\n\t\t\t\t\tlightProbe.position.set( - 10, 0, 0 ); // position not used in scene lighting calculations (helper honors the position, however)\n\n\t\t\t\t\tconst geometry = new THREE.SphereGeometry( 5, 64, 32 );\n\t\t\t\t\t//const geometry = new THREE.TorusKnotGeometry( 4, 1.5, 256, 32, 2, 3 );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\tmetalness: 0,\n\t\t\t\t\t\troughness: 0,\n\t\t\t\t\t\tenvMap: cubeTexture,\n\t\t\t\t\t\tenvMapIntensity: API.envMapIntensity,\n\t\t\t\t\t} );\n\n\t\t\t\t\t// mesh\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t// helper\n\t\t\t\t\tconst helper = new LightProbeHelper( lightProbe, 1 );\n\t\t\t\t\tscene.add( helper );\n\n\t\t\t\t} );\n\n\n\t\t\t\t// gui\n\t\t\t\tgui = new GUI( { title: 'Intensity' } );\n\n\t\t\t\tgui.add( API, 'lightProbeIntensity', 0, 1, 0.02 )\n\t\t\t\t\t.name( 'light probe' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tlightProbe.intensity = API.lightProbeIntensity;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( API, 'directionalLightIntensity', 0, 1, 0.02 )\n\t\t\t\t\t.name( 'directional light' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tdirectionalLight.intensity = API.directionalLightIntensity;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( API, 'envMapIntensity', 0, 1, 0.02 )\n\t\t\t\t\t.name( 'envMap' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmesh.material.envMapIntensity = API.envMapIntensity;\n\n\t\t\t\t\t} );\n\n\t\t\t\t// listener\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - light probe"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - light probe from cubeCamera"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - light probe from cubeCamera:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { LightProbeHelper } from 'three/addons/helpers/LightProbeHelperGPU.js';\n\t\t\timport { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n\n\t\t\tlet renderer, scene, camera, cubeCamera;\n\n\t\t\tlet lightProbe;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 30 );\n\n\t\t\t\tconst cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );\n\n\t\t\t\tcubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// probe\n\t\t\t\tlightProbe = new THREE.LightProbe();\n\t\t\t\tscene.add( lightProbe );\n\n\t\t\t\t// envmap\n\t\t\t\tconst genCubeUrls = function ( prefix, postfix ) {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tprefix + 'px' + postfix, prefix + 'nx' + postfix,\n\t\t\t\t\t\tprefix + 'py' + postfix, prefix + 'ny' + postfix,\n\t\t\t\t\t\tprefix + 'pz' + postfix, prefix + 'nz' + postfix\n\t\t\t\t\t];\n\n\t\t\t\t};\n\n\t\t\t\tconst urls = genCubeUrls( 'textures/cube/pisa/', '.png' );\n\n\t\t\t\tnew THREE.CubeTextureLoader().load( urls, async function ( cubeTexture ) {\n\n\t\t\t\t\tscene.background = cubeTexture;\n\n\t\t\t\t\tawait renderer.init();\n\n\t\t\t\t\tcubeCamera.update( renderer, scene );\n\n\t\t\t\t\tconst probe = await LightProbeGenerator.fromCubeRenderTarget( renderer, cubeRenderTarget );\n\n\t\t\t\t\tlightProbe.copy( probe );\n\n\t\t\t\t\tscene.add( new LightProbeHelper( lightProbe, 5 ) );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t// listener\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - light probe from cubeCamera"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - custom lighting model"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - custom lighting model:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, lights } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tclass CustomLightingModel extends THREE.LightingModel {\n\n\t\t\t\tdirect( { lightColor, reflectedLight }, stack ) {\n\n\t\t\t\t\treflectedLight.directDiffuse.addAssign( lightColor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet light1, light2, light3;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.z = 1.5;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );\n\n\t\t\t\tconst addLight = ( hexColor ) => {\n\n\t\t\t\t\tconst material = new THREE.NodeMaterial();\n\t\t\t\t\tmaterial.colorNode = color( hexColor );\n\t\t\t\t\tmaterial.lightsNode = lights(); // ignore scene lights\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( sphereGeometry, material );\n\n\t\t\t\t\tconst light = new THREE.PointLight( hexColor, 0.1, 1 );\n\t\t\t\t\tlight.add( mesh );\n\n\t\t\t\t\tscene.add( light );\n\n\t\t\t\t\treturn light;\n\n\t\t\t\t};\n\n\t\t\t\tlight1 = addLight( 0xffaa00 );\n\t\t\t\tlight2 = addLight( 0x0040ff );\n\t\t\t\tlight3 = addLight( 0x80ff80 );\n\n\t\t\t\t//light nodes ( selective lights )\n\n\t\t\t\tconst allLightsNode = lights( [ light1, light2, light3 ] );\n\n\t\t\t\t// points\n\n\t\t\t\tconst points = [];\n\n\t\t\t\tfor ( let i = 0; i < 500_000; i ++ ) {\n\n\t\t\t\t\tconst point = new THREE.Vector3().random().subScalar( 0.5 ).multiplyScalar( 3 );\n\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometryPoints = new THREE.BufferGeometry().setFromPoints( points );\n\t\t\t\tconst materialPoints = new THREE.PointsNodeMaterial();\n\n\t\t\t\t// custom lighting model\n\n\t\t\t\tconst lightingModel = new CustomLightingModel();\n\t\t\t\tconst lightingModelContext = allLightsNode.context( { lightingModel } );\n\n\t\t\t\tmaterialPoints.lightsNode = lightingModelContext;\n\n\t\t\t\t//\n\n\t\t\t\tconst pointCloud = new THREE.Points( geometryPoints, materialPoints );\n\t\t\t\tscene.add( pointCloud );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 0;\n\t\t\t\tcontrols.maxDistance = 4;\n\n\t\t\t\t// events\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = Date.now() * 0.001;\n\t\t\t\tconst scale = .5;\n\n\t\t\t\tlight1.position.x = Math.sin( time * 0.7 ) * scale;\n\t\t\t\tlight1.position.y = Math.cos( time * 0.5 ) * scale;\n\t\t\t\tlight1.position.z = Math.cos( time * 0.3 ) * scale;\n\n\t\t\t\tlight2.position.x = Math.cos( time * 0.3 ) * scale;\n\t\t\t\tlight2.position.y = Math.sin( time * 0.5 ) * scale;\n\t\t\t\tlight2.position.z = Math.sin( time * 0.7 ) * scale;\n\n\t\t\t\tlight3.position.x = Math.sin( time * 0.7 ) * scale;\n\t\t\t\tlight3.position.y = Math.cos( time * 0.3 ) * scale;\n\t\t\t\tlight3.position.z = Math.sin( time * 0.5 ) * scale;\n\n\t\t\t\tscene.rotation.y = time * 0.1;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - custom lighting model"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - ies spotlight"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - ies spotlight:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from './jsm/controls/OrbitControls.js';\n\n\t\t\timport { IESLoader } from 'three/addons/loaders/IESLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet lights;\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst iesLoader = new IESLoader().setPath( './ies/' );\n\t\t\t\t//iesLoader.type = THREE.UnsignedByteType; // LDR\n\n\t\t\t\tconst [ iesTexture1, iesTexture2, iesTexture3, iesTexture4 ] = await Promise.all( [\n\t\t\t\t\tiesLoader.loadAsync( '007cfb11e343e2f42e3b476be4ab684e.ies' ),\n\t\t\t\t\tiesLoader.loadAsync( '06b4cfdc8805709e767b5e2e904be8ad.ies' ),\n\t\t\t\t\tiesLoader.loadAsync( '02a7562c650498ebb301153dbbf59207.ies' ),\n\t\t\t\t\tiesLoader.loadAsync( '1a936937a49c63374e6d4fbed9252b29.ies' )\n\t\t\t\t] );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst spotLight = new THREE.IESSpotLight( 0xff0000, 500 );\n\t\t\t\tspotLight.position.set( 6.5, 3, 6.5 );\n\t\t\t\tspotLight.angle = Math.PI / 8;\n\t\t\t\tspotLight.penumbra = 0.7;\n\t\t\t\tspotLight.distance = 20;\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.iesMap = iesTexture1;\n\t\t\t\tspotLight.userData.helper = new THREE.SpotLightHelper( spotLight );\n\t\t\t\tscene.add( spotLight );\n\t\t\t\tscene.add( spotLight.target );\n\t\t\t\tscene.add( spotLight.userData.helper );\n\n\t\t\t\t//\n\n\t\t\t\tconst spotLight2 = new THREE.IESSpotLight( 0x00ff00, 500 );\n\t\t\t\tspotLight2.position.set( - 6.5, 3, 6.5 );\n\t\t\t\tspotLight2.angle = Math.PI / 8;\n\t\t\t\tspotLight2.penumbra = 0.7;\n\t\t\t\tspotLight2.distance = 20;\n\t\t\t\tspotLight2.castShadow = true;\n\t\t\t\tspotLight2.iesMap = iesTexture2;\n\t\t\t\tspotLight2.userData.helper = new THREE.SpotLightHelper( spotLight2 );\n\t\t\t\tscene.add( spotLight2 );\n\t\t\t\tscene.add( spotLight2.target );\n\t\t\t\tscene.add( spotLight2.userData.helper );\n\n\t\t\t\t//\n\n\t\t\t\tconst spotLight3 = new THREE.IESSpotLight( 0x0000ff, 500 );\n\t\t\t\tspotLight3.position.set( - 6.5, 3, - 6.5 );\n\t\t\t\tspotLight3.angle = Math.PI / 8;\n\t\t\t\tspotLight3.penumbra = 0.7;\n\t\t\t\tspotLight3.distance = 20;\n\t\t\t\tspotLight3.castShadow = true;\n\t\t\t\tspotLight3.iesMap = iesTexture3;\n\t\t\t\tspotLight3.userData.helper = new THREE.SpotLightHelper( spotLight3 );\n\t\t\t\tscene.add( spotLight3 );\n\t\t\t\tscene.add( spotLight3.target );\n\t\t\t\tscene.add( spotLight3.userData.helper );\n\n\t\t\t\t//\n\n\t\t\t\tconst spotLight4 = new THREE.IESSpotLight( 0xffffff, 500 );\n\t\t\t\tspotLight4.position.set( 6.5, 3, - 6.5 );\n\t\t\t\tspotLight4.angle = Math.PI / 8;\n\t\t\t\tspotLight4.penumbra = 0.7;\n\t\t\t\tspotLight4.distance = 20;\n\t\t\t\tspotLight4.castShadow = true;\n\t\t\t\tspotLight4.iesMap = iesTexture4;\n\t\t\t\tspotLight4.userData.helper = new THREE.SpotLightHelper( spotLight4 );\n\t\t\t\tscene.add( spotLight4 );\n\t\t\t\tscene.add( spotLight4.target );\n\t\t\t\tscene.add( spotLight4.userData.helper );\n\n\t\t\t\t//\n\n\t\t\t\tlights = [ spotLight, spotLight2, spotLight3, spotLight4 ];\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0x999999/*, dithering: true*/ } );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 200, 200 );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.rotation.x = - Math.PI * 0.5;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst geometry2 = new THREE.BoxGeometry( 2, 2, 2 );\n\t\t\t\t//const geometry2 = new THREE.IcosahedronGeometry( 1, 5 );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry2, material );\n\t\t\t\tmesh2.position.y = 1;\n\t\t\t\tmesh2.castShadow = true;\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 100 );\n\t\t\t\tcamera.position.set( 16, 4, 1 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t//\n\n\t\t\t\tfunction setHelperVisible( value ) {\n\n\t\t\t\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\t\t\t\tlights[ i ].userData.helper.visible = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tsetHelperVisible( false );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( { helper: false }, 'helper' ).onChange( ( v ) => setHelperVisible( v ) );\n\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render( time ) {\n\n\t\t\t\ttime = time / 1000;\n\n\t\t\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\t\t\tconst t = ( Math.sin( ( time + i ) * ( Math.PI / 2 ) ) + 1 ) / 2;\n\n\t\t\t\t\tconst x = THREE.MathUtils.lerp( lights[ i ].position.x, 0, t );\n\t\t\t\t\tconst z = THREE.MathUtils.lerp( lights[ i ].position.z, 0, t );\n\n\t\t\t\t\tlights[ i ].target.position.x = x;\n\t\t\t\t\tlights[ i ].target.position.z = z;\n\t\t\t\t\tif ( lights[ i ].userData.helper ) lights[ i ].userData.helper.update();\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js webgpu - ies spotlight"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - phong lighting model"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - phong lighting model:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, fog, rangeFogFactor, checker, uv, mix, texture, lights, normalMap } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\n\t\t\tlet camera, scene, renderer,\n\t\t\t\tlight1, light2, light3, light4,\n\t\t\t\tstats, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 7;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fogNode = fog( color( 0xFF00FF ), rangeFogFactor( 12, 30 ) );\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.1, 16, 8 );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst normalMapTexture = textureLoader.load( './textures/water/Water_1_M_Normal.jpg' );\n\t\t\t\tnormalMapTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tnormalMapTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst alphaTexture = textureLoader.load( './textures/roughness_map.jpg' );\n\t\t\t\talphaTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\talphaTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// lights\n\n\t\t\t\tconst addLight = ( hexColor, power = 1700, distance = 100 ) => {\n\n\t\t\t\t\tconst material = new THREE.MeshPhongNodeMaterial();\n\t\t\t\t\tmaterial.colorNode = color( hexColor );\n\t\t\t\t\tmaterial.lights = false;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( sphereGeometry, material );\n\n\t\t\t\t\tconst light = new THREE.PointLight( hexColor, 1, distance );\n\t\t\t\t\tlight.power = power;\n\t\t\t\t\tlight.add( mesh );\n\n\t\t\t\t\tscene.add( light );\n\n\t\t\t\t\treturn light;\n\n\t\t\t\t};\n\n\t\t\t\tlight1 = addLight( 0x0040ff );\n\t\t\t\tlight2 = addLight( 0xffffff );\n\t\t\t\tlight3 = addLight( 0x80ff80 );\n\t\t\t\tlight4 = addLight( 0xffaa00 );\n\n\t\t\t\t// light nodes ( selective lights )\n\n\t\t\t\tconst blueLightsNode = lights( [ light1 ] );\n\t\t\t\tconst whiteLightsNode = lights( [ light2 ] );\n\n\t\t\t\t// models\n\n\t\t\t\tconst geometryTeapot = new TeapotGeometry( .8, 18 );\n\n\t\t\t\tconst leftObject = new THREE.Mesh( geometryTeapot, new THREE.MeshPhongNodeMaterial( { color: 0x555555 } ) );\n\t\t\t\tleftObject.material.lightsNode = blueLightsNode;\n\t\t\t\tleftObject.material.specularNode = texture( alphaTexture );\n\t\t\t\tleftObject.position.x = - 3;\n\t\t\t\tscene.add( leftObject );\n\n\t\t\t\tconst centerObject = new THREE.Mesh( geometryTeapot, new THREE.MeshPhongNodeMaterial( { color: 0x555555 } ) );\n\t\t\t\tcenterObject.material.normalNode = normalMap( texture( normalMapTexture ) );\n\t\t\t\tcenterObject.material.shininess = 80;\n\t\t\t\tscene.add( centerObject );\n\n\t\t\t\tconst rightObject = new THREE.Mesh( geometryTeapot, new THREE.MeshPhongNodeMaterial( { color: 0x555555 } ) );\n\t\t\t\trightObject.material.lightsNode = whiteLightsNode;\n\t\t\t\t//rightObject.material.specular.setHex( 0xFF00FF );\n\t\t\t\trightObject.material.specularNode = mix( color( 0x0000FF ), color( 0xFF0000 ), checker( uv().mul( 5 ) ) );\n\t\t\t\trightObject.material.shininess = 90;\n\t\t\t\trightObject.position.x = 3;\n\t\t\t\tscene.add( rightObject );\n\n\t\t\t\tleftObject.rotation.y = centerObject.rotation.y = rightObject.rotation.y = Math.PI * - 0.5;\n\t\t\t\tleftObject.position.y = centerObject.position.y = rightObject.position.y = - 1;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 25;\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 1000;\n\t\t\t\tconst lightTime = time * 0.5;\n\n\t\t\t\tlight1.position.x = Math.sin( lightTime * 0.7 ) * 3;\n\t\t\t\tlight1.position.y = Math.cos( lightTime * 0.5 ) * 4;\n\t\t\t\tlight1.position.z = Math.cos( lightTime * 0.3 ) * 3;\n\n\t\t\t\tlight2.position.x = Math.cos( lightTime * 0.3 ) * 3;\n\t\t\t\tlight2.position.y = Math.sin( lightTime * 0.5 ) * 4;\n\t\t\t\tlight2.position.z = Math.sin( lightTime * 0.7 ) * 3;\n\n\t\t\t\tlight3.position.x = Math.sin( lightTime * 0.7 ) * 3;\n\t\t\t\tlight3.position.y = Math.cos( lightTime * 0.3 ) * 4;\n\t\t\t\tlight3.position.z = Math.sin( lightTime * 0.5 ) * 3;\n\n\t\t\t\tlight4.position.x = Math.sin( lightTime * 0.3 ) * 3;\n\t\t\t\tlight4.position.y = Math.cos( lightTime * 0.7 ) * 4;\n\t\t\t\tlight4.position.z = Math.sin( lightTime * 0.5 ) * 3;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - phong lighting model Left: Red lights - Center: All lights - Right: blue light"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - physical lights"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - physical lights:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;\n\t\t\tlet ballMat, cubeMat, floorMat;\n\n\t\t\tlet previousShadowMap = false;\n\n\t\t\t// ref for lumens: http://www.power-sure.com/lumens.htm\n\t\t\tconst bulbLuminousPowers = {\n\t\t\t\t'110000 lm (1000W)': 110000,\n\t\t\t\t'3500 lm (300W)': 3500,\n\t\t\t\t'1700 lm (100W)': 1700,\n\t\t\t\t'800 lm (60W)': 800,\n\t\t\t\t'400 lm (40W)': 400,\n\t\t\t\t'180 lm (25W)': 180,\n\t\t\t\t'20 lm (4W)': 20,\n\t\t\t\t'Off': 0\n\t\t\t};\n\n\t\t\t// ref for solar irradiances: https://en.wikipedia.org/wiki/Lux\n\t\t\tconst hemiLuminousIrradiances = {\n\t\t\t\t'0.0001 lx (Moonless Night)': 0.0001,\n\t\t\t\t'0.002 lx (Night Airglow)': 0.002,\n\t\t\t\t'0.5 lx (Full Moon)': 0.5,\n\t\t\t\t'3.4 lx (City Twilight)': 3.4,\n\t\t\t\t'50 lx (Living Room)': 50,\n\t\t\t\t'100 lx (Very Overcast)': 100,\n\t\t\t\t'350 lx (Office Room)': 350,\n\t\t\t\t'400 lx (Sunrise/Sunset)': 400,\n\t\t\t\t'1000 lx (Overcast)': 1000,\n\t\t\t\t'18000 lx (Daylight)': 18000,\n\t\t\t\t'50000 lx (Direct Sun)': 50000\n\t\t\t};\n\n\t\t\tconst params = {\n\t\t\t\tshadows: true,\n\t\t\t\texposure: 0.68,\n\t\t\t\tbulbPower: Object.keys( bulbLuminousPowers )[ 4 ],\n\t\t\t\themiIrradiance: Object.keys( hemiLuminousIrradiances )[ 0 ]\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.x = - 4;\n\t\t\t\tcamera.position.z = 4;\n\t\t\t\tcamera.position.y = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst bulbGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );\n\t\t\t\tbulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );\n\n\t\t\t\tbulbMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\temissive: 0xffffee,\n\t\t\t\t\temissiveIntensity: 1,\n\t\t\t\t\tcolor: 0x000000\n\t\t\t\t} );\n\t\t\t\tbulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );\n\t\t\t\tbulbLight.position.set( 0, 2, 0 );\n\t\t\t\tbulbLight.castShadow = true;\n\t\t\t\tscene.add( bulbLight );\n\n\t\t\t\themiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tfloorMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\troughness: 0.8,\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tmetalness: 0.2,\n\t\t\t\t\tbumpScale: 1\n\t\t\t\t} );\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_diffuse.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 10, 24 );\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tfloorMat.map = map;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_bump.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 10, 24 );\n\t\t\t\t\tfloorMat.bumpMap = map;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/hardwood2_roughness.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 10, 24 );\n\t\t\t\t\tfloorMat.roughnessMap = map;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tcubeMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\troughness: 0.7,\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tbumpScale: 1,\n\t\t\t\t\tmetalness: 0.2\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/brick_diffuse.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 1, 1 );\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tcubeMat.map = map;\n\t\t\t\t\tcubeMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/brick_bump.jpg', function ( map ) {\n\n\t\t\t\t\tmap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tmap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.repeat.set( 1, 1 );\n\t\t\t\t\tcubeMat.bumpMap = map;\n\t\t\t\t\tcubeMat.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tballMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\troughness: 0.5,\n\t\t\t\t\tmetalness: 1.0\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/planets/earth_atmos_2048.jpg', function ( map ) {\n\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tballMat.map = map;\n\t\t\t\t\tballMat.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\ttextureLoader.load( 'textures/planets/earth_specular_2048.jpg', function ( map ) {\n\n\t\t\t\t\tmap.anisotropy = 4;\n\t\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\tballMat.metalnessMap = map;\n\t\t\t\t\tballMat.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 20, 20 );\n\t\t\t\tconst floorMesh = new THREE.Mesh( floorGeometry, floorMat );\n\t\t\t\tfloorMesh.receiveShadow = true;\n\t\t\t\tfloorMesh.rotation.x = - Math.PI / 2.0;\n\t\t\t\tscene.add( floorMesh );\n\n\t\t\t\tconst ballGeometry = new THREE.SphereGeometry( 0.25, 32, 32 );\n\t\t\t\tconst ballMesh = new THREE.Mesh( ballGeometry, ballMat );\n\t\t\t\tballMesh.position.set( 1, 0.25, 1 );\n\t\t\t\tballMesh.rotation.y = Math.PI;\n\t\t\t\tballMesh.castShadow = true;\n\t\t\t\tscene.add( ballMesh );\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );\n\t\t\t\tconst boxMesh = new THREE.Mesh( boxGeometry, cubeMat );\n\t\t\t\tboxMesh.position.set( - 0.5, 0.25, - 1 );\n\t\t\t\tboxMesh.castShadow = true;\n\t\t\t\tscene.add( boxMesh );\n\n\t\t\t\tconst boxMesh2 = new THREE.Mesh( boxGeometry, cubeMat );\n\t\t\t\tboxMesh2.position.set( 0, 0.25, - 5 );\n\t\t\t\tboxMesh2.castShadow = true;\n\t\t\t\tscene.add( boxMesh2 );\n\n\t\t\t\tconst boxMesh3 = new THREE.Mesh( boxGeometry, cubeMat );\n\t\t\t\tboxMesh3.position.set( 7, 0.25, 0 );\n\t\t\t\tboxMesh3.castShadow = true;\n\t\t\t\tscene.add( boxMesh3 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 20;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );\n\t\t\t\tgui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );\n\t\t\t\tgui.add( params, 'exposure', 0, 1 );\n\t\t\t\tgui.add( params, 'shadows' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.\n\t\t\t\trenderer.shadowMap.enabled = params.shadows;\n\t\t\t\tbulbLight.castShadow = params.shadows;\n\n\t\t\t\tif ( params.shadows !== previousShadowMap ) {\n\n\t\t\t\t\tballMat.needsUpdate = true;\n\t\t\t\t\tcubeMat.needsUpdate = true;\n\t\t\t\t\tfloorMat.needsUpdate = true;\n\t\t\t\t\tpreviousShadowMap = params.shadows;\n\n\t\t\t\t}\n\n\t\t\t\tbulbLight.power = bulbLuminousPowers[ params.bulbPower ];\n\t\t\t\tbulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface\n\n\t\t\t\themiLight.intensity = hemiLuminousIrradiances[ params.hemiIrradiance ];\n\t\t\t\tconst time = Date.now() * 0.0005;\n\n\t\t\t\tbulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Physically accurate incandescent bulb by Ben Houston Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter. Reinhard inline tonemapping with real-world light falloff (decay = 2)."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - lights - point lights"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - lights - point lights:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\n\t\t\timport { abs, attribute, distance, float, max, modelWorldMatrixInverse, positionLocal, sin, time, uniform } from 'three/tsl';\n\n\t\t\tlet camera, scene, timer, renderer, controls;\n\t\t\t\n\t\t\tlet light1, light2;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 100;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/walt/WaltHead.obj', function ( obj ) {\n\n\t\t\t\t\tconst mesh = obj.children[ 0 ];\n\t\t\t\t\tmesh.geometry = createGeometry( mesh.geometry );\n\t\t\t\t\tmesh.material = createMaterial();\n\n\t\t\t\t\tmesh.scale.multiplyScalar( 0.8 );\n\t\t\t\t\tmesh.position.y = - 30;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\tconst sphere = new THREE.SphereGeometry( 0.5, 16, 8 );\n\n\t\t\t\t// lights\n\n\t\t\t\tlight1 = new THREE.PointLight( 0xff0040, 2000 );\n\t\t\t\tlight1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );\n\t\t\t\tscene.add( light1 );\n\n\t\t\t\tlight2 = new THREE.PointLight( 0x0040ff, 2000 );\n\t\t\t\tlight2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa, 0.1 ) );\n\t\t\t\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\tconst time = timer.getElapsed() * 0.5;\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tlight1.position.x = Math.sin( time ) * 20;\n\t\t\t\tlight1.position.y = Math.cos( time * 0.75 ) * - 30;\n\t\t\t\tlight1.position.z = Math.cos( time * 0.5 ) * 20;\n\n\t\t\t\tlight2.position.x = Math.cos( time * 0.5 ) * 20;\n\t\t\t\tlight2.position.y = Math.sin( time * 0.75 ) * - 30;\n\t\t\t\tlight2.position.z = Math.sin( time ) * 20;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\t// helpers\n\n\t\t\tfunction createMaterial() {\n\n\t\t\t\tconst material = new THREE.MeshPhongNodeMaterial();\n\t\t\t\n\t\t\t\tconst seedAttribute = attribute( 'seed' );\n\t\t\t\tconst displaceNormalAttribute = attribute( 'displaceNormal' );\n\n\t\t\t\tconst localTime = attribute( 'time' ).add( time );\n\n\t\t\t\tconst effector1 = uniform( light1.position ).toVar();\n\t\t\t\tconst effector2 = uniform( light2.position ).toVar();\n\n\t\t\t\tconst distance1 = distance( positionLocal, modelWorldMatrixInverse.mul( effector1 ) );\n\t\t\t\tconst distance2 = distance( positionLocal, modelWorldMatrixInverse.mul( effector2 ) );\n\n\t\t\t\tconst invDistance1 = max( 0.0, float( 20.0 ).sub( distance1 ) ).div( 2.0 );\n\t\t\t\tconst invDistance2 = max( 0.0, float( 20.0 ).sub( distance2 ) ).div( 2.0 );\n\n\t\t\t\tconst s = abs( sin( localTime.mul( 2 ).add( seedAttribute ) ).mul( 0.5 ) ).add( invDistance1 ).add( invDistance2 );\n\n\t\t\t\tmaterial.positionNode = positionLocal.add( displaceNormalAttribute.mul( s ) );\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction createGeometry( geometry ) {\n\t\t\t\n\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\tconst v0 = new THREE.Vector3();\n\t\t\t\tconst v1 = new THREE.Vector3();\n\t\t\t\tconst v2 = new THREE.Vector3();\n\t\t\t\tconst v3 = new THREE.Vector3();\n\t\t\t\tconst n = new THREE.Vector3();\n\n\t\t\t\tconst plane = new THREE.Plane();\n\n\t\t\t\tconst vertices = [];\n\t\t\t\tconst times = [];\n\t\t\t\tconst seeds = [];\n\t\t\t\tconst displaceNormal = [];\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\t\tv0.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tv1.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tv2.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tplane.setFromCoplanarPoints( v0, v1, v2 );\n\n\t\t\t\t\tv3.copy( v0 ).add( v1 ).add( v2 ).divideScalar( 3 ); // compute center\n\t\t\t\t\tv3.add( n.copy( plane.normal ).multiplyScalar( - 1 ) ); // displace center inwards\n\n\t\t\t\t\t// generate tetraeder for each triangle\n\n\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z );\n\t\t\t\t\tvertices.push( v3.x, v3.y, v3.z, v1.x, v1.y, v1.z, v0.x, v0.y, v0.z );\n\t\t\t\t\tvertices.push( v3.x, v3.y, v3.z, v2.x, v2.y, v2.z, v1.x, v1.y, v1.z );\n\t\t\t\t\tvertices.push( v3.x, v3.y, v3.z, v0.x, v0.y, v0.z, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tconst t = Math.random();\n\t\t\t\t\tconst s = Math.random();\n\t\t\t\t\tn.copy( plane.normal );\n\n\t\t\t\t\ttimes.push( t, t, t ); times.push( t, t, t ); times.push( t, t, t ); times.push( t, t, t );\n\t\t\t\t\tseeds.push( s, s, s ); seeds.push( s, s, s ); seeds.push( s, s, s ); seeds.push( s, s, s );\n\n\t\t\t\t\tdisplaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );\n\t\t\t\t\tdisplaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );\n\t\t\t\t\tdisplaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );\n\t\t\t\t\tdisplaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );\n\n\t\t\t\t}\n\n\t\t\t\tconst newGeometry = new THREE.BufferGeometry();\n\t\t\t\tnewGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tnewGeometry.setAttribute( 'time', new THREE.Float32BufferAttribute( times, 1 ) );\n\t\t\t\tnewGeometry.setAttribute( 'seed', new THREE.Float32BufferAttribute( seeds, 1 ) );\n\t\t\t\tnewGeometry.setAttribute( 'displaceNormal', new THREE.Float32BufferAttribute( displaceNormal, 3 ) );\n\n\t\t\t\tnewGeometry.computeVertexNormals();\n\n\t\t\t\treturn newGeometry;\n\n\n\t\t\t}\n```\n\nThis example three.js - point lights Walt Disney head by David OReilly Displacement effect by oosmoxiecode"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - projector light"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - projector light:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, color, mx_worley_noise_float, time } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tlet projectorLight, lightHelper;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// Renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 7, 4, 1 );\n\n\t\t\t\t// Controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// Textures\n\n\t\t\t\tconst loader = new THREE.TextureLoader().setPath( 'textures/' );\n\n\t\t\t\t// Lights\n\n\t\t\t\tconst causticEffect = Fn( ( [ projectorUV ] ) => {\n\n\t\t\t\t\tconst waterLayer0 = mx_worley_noise_float( projectorUV.mul( 10 ).add( time ) );\n\n\t\t\t\t\tconst caustic = waterLayer0.mul( color( 0x5abcd8 ) ).mul( 2 );\n\n\t\t\t\t\treturn caustic;\n\n\t\t\t\t} );\n\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 0.15 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tprojectorLight = new THREE.ProjectorLight( 0xffffff, 100 );\n\t\t\t\tprojectorLight.colorNode = causticEffect;\n\t\t\t\tprojectorLight.position.set( 2.5, 5, 2.5 );\n\t\t\t\tprojectorLight.angle = Math.PI / 6;\n\t\t\t\tprojectorLight.penumbra = 1;\n\t\t\t\tprojectorLight.decay = 2;\n\t\t\t\tprojectorLight.distance = 0;\n\n\t\t\t\tprojectorLight.castShadow = true;\n\t\t\t\tprojectorLight.shadow.mapSize.width = 1024;\n\t\t\t\tprojectorLight.shadow.mapSize.height = 1024;\n\t\t\t\tprojectorLight.shadow.camera.near = 1;\n\t\t\t\tprojectorLight.shadow.camera.far = 10;\n\t\t\t\tprojectorLight.shadow.focus = 1;\n\t\t\t\tprojectorLight.shadow.bias = - .003;\n\t\t\t\tscene.add( projectorLight );\n\n\t\t\t\tlightHelper = new THREE.SpotLightHelper( projectorLight );\n\t\t\t\tscene.add( lightHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xbcbcbc } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.position.set( 0, - 1, 0 );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// Models\n\n\t\t\t\tnew PLYLoader().load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {\n\n\t\t\t\t\tgeometry.scale( 0.0024, 0.0024, 0.0024 );\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.rotation.y = - Math.PI / 2;\n\t\t\t\t\tmesh.position.y = 0.8;\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst params = {\n\t\t\t\t\ttype: 'procedural',\n\t\t\t\t\tcolor: projectorLight.color.getHex(),\n\t\t\t\t\tintensity: projectorLight.intensity,\n\t\t\t\t\tdistance: projectorLight.distance,\n\t\t\t\t\tangle: projectorLight.angle,\n\t\t\t\t\tpenumbra: projectorLight.penumbra,\n\t\t\t\t\tdecay: projectorLight.decay,\n\t\t\t\t\tfocus: projectorLight.shadow.focus,\n\t\t\t\t\tshadows: true,\n\t\t\t\t};\n\n\t\t\t\tlet videoTexture, mapTexture;\n\n\t\t\t\tgui.add( params, 'type', [ 'procedural', 'video', 'texture' ] ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.colorNode = null;\n\t\t\t\t\tprojectorLight.map = null;\n\n\t\t\t\t\tif ( val === 'procedural' ) {\n\n\t\t\t\t\t\tprojectorLight.colorNode = causticEffect;\n\n\t\t\t\t\t\tfocus.setValue( 1 );\n\n\t\t\t\t\t} else if ( val === 'video' ) {\n\n\t\t\t\t\t\tif ( videoTexture === undefined ) {\n\n\t\t\t\t\t\t\tconst video = document.getElementById( 'video' );\n\t\t\t\t\t\t\tvideo.play();\n\n\t\t\t\t\t\t\tvideoTexture = new THREE.VideoTexture( video );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprojectorLight.map = videoTexture;\n\n\t\t\t\t\t\tfocus.setValue( .46 );\n\n\t\t\t\t\t} else if ( val === 'texture' ) {\n\n\t\t\t\t\t\tmapTexture = loader.load( 'colors.png' );\n\t\t\t\t\t\tmapTexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\tmapTexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\tmapTexture.generateMipmaps = false;\n\t\t\t\t\t\tmapTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\t\tprojectorLight.map = mapTexture;\n\n\t\t\t\t\t\tfocus.setValue( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'color' ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.color.setHex( val );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'intensity', 0, 500 ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.intensity = val;\n\n\t\t\t\t} );\n\n\n\t\t\t\tgui.add( params, 'distance', 0, 20 ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.distance = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.angle = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.penumbra = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.decay = val;\n\n\t\t\t\t} );\n\n\t\t\t\tconst focus = gui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {\n\n\t\t\t\t\tprojectorLight.shadow.focus = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'shadows' ).onChange( function ( val ) {\n\n\t\t\t\t\trenderer.shadowMap.enabled = val;\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.material ) {\n\n\t\t\t\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 3000;\n\n\t\t\t\tprojectorLight.position.x = Math.cos( time ) * 2.5;\n\t\t\t\tprojectorLight.position.z = Math.sin( time ) * 2.5;\n\n\t\t\t\tlightHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - projector light"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webGPU - rect area light"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webGPU - rect area light:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';\n\t\t\timport { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet stats, meshKnot;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tTHREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animation );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 5, - 15 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst rectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );\n\t\t\t\trectLight1.position.set( - 5, 5, 5 );\n\t\t\t\tscene.add( rectLight1 );\n\n\t\t\t\tconst rectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );\n\t\t\t\trectLight2.position.set( 0, 5, 5 );\n\t\t\t\tscene.add( rectLight2 );\n\n\t\t\t\tconst rectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );\n\t\t\t\trectLight3.position.set( 5, 5, 5 );\n\t\t\t\tscene.add( rectLight3 );\n\n\t\t\t\tscene.add( new RectAreaLightHelper( rectLight1 ) );\n\t\t\t\tscene.add( new RectAreaLightHelper( rectLight2 ) );\n\t\t\t\tscene.add( new RectAreaLightHelper( rectLight3 ) );\n\n\t\t\t\tconst geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );\n\t\t\t\tconst matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );\n\t\t\t\tconst mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );\n\t\t\t\tscene.add( mshStdFloor );\n\n\t\t\t\tconst geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );\n\t\t\t\tconst matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );\n\t\t\t\tmeshKnot = new THREE.Mesh( geoKnot, matKnot );\n\t\t\t\tmeshKnot.position.set( 0, 5, 0 );\n\t\t\t\tscene.add( meshKnot );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.copy( meshKnot.position );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcamera.aspect = ( window.innerWidth / window.innerHeight );\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animation( time ) {\n\n\t\t\t\tmeshKnot.rotation.y = time / 1000;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - rect area light by abelnation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - selective lights"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - selective lights:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { fog, rangeFogFactor, color, lights, texture, normalMap } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\n\t\t\tlet camera, scene, renderer,\n\t\t\t\tlight1, light2, light3, light4,\n\t\t\t\tstats, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 7;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fogNode = fog( color( 0xFF00FF ), rangeFogFactor( 12, 30 ) );\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.1, 16, 8 );\n\n\t\t\t\t//textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst normalMapTexture = textureLoader.load( './textures/water/Water_1_M_Normal.jpg' );\n\t\t\t\tnormalMapTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tnormalMapTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst alphaTexture = textureLoader.load( './textures/roughness_map.jpg' );\n\t\t\t\talphaTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\talphaTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t//lights\n\n\t\t\t\tconst addLight = ( hexColor, power = 1700, distance = 100 ) => {\n\n\t\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial();\n\t\t\t\t\tmaterial.colorNode = color( hexColor );\n\t\t\t\t\tmaterial.lights = false;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( sphereGeometry, material );\n\n\t\t\t\t\tconst light = new THREE.PointLight( hexColor, 1, distance );\n\t\t\t\t\tlight.power = power;\n\t\t\t\t\tlight.add( mesh );\n\n\t\t\t\t\tscene.add( light );\n\n\t\t\t\t\treturn light;\n\n\t\t\t\t};\n\n\t\t\t\tlight1 = addLight( 0xff0040 );\n\t\t\t\tlight2 = addLight( 0x0040ff );\n\t\t\t\tlight3 = addLight( 0x80ff80 );\n\t\t\t\tlight4 = addLight( 0xffaa00 );\n\n\t\t\t\t//light nodes ( selective lights )\n\n\t\t\t\tconst redLightsNode = lights( [ light1 ] );\n\t\t\t\tconst blueLightsNode = lights( [ light2 ] );\n\n\t\t\t\t//models\n\n\t\t\t\tconst geometryTeapot = new TeapotGeometry( .8, 18 );\n\n\t\t\t\tconst leftObject = new THREE.Mesh( geometryTeapot, new THREE.MeshStandardNodeMaterial( { color: 0x555555 } ) );\n\t\t\t\tleftObject.material.lightsNode = redLightsNode;\n\t\t\t\tleftObject.material.roughnessNode = texture( alphaTexture );\n\t\t\t\tleftObject.material.metalness = 0;\n\t\t\t\tleftObject.position.x = - 3;\n\t\t\t\tscene.add( leftObject );\n\n\t\t\t\tconst centerObject = new THREE.Mesh( geometryTeapot, new THREE.MeshStandardNodeMaterial( { color: 0x555555 } ) );\n\t\t\t\tcenterObject.material.normalNode = normalMap( texture( normalMapTexture ) );\n\t\t\t\tcenterObject.material.metalness = .5;\n\t\t\t\tcenterObject.material.roughness = .5;\n\t\t\t\tscene.add( centerObject );\n\n\t\t\t\tconst rightObject = new THREE.Mesh( geometryTeapot, new THREE.MeshStandardNodeMaterial( { color: 0x555555 } ) );\n\t\t\t\trightObject.material.lightsNode = blueLightsNode;\n\t\t\t\trightObject.material.metalnessNode = texture( alphaTexture );\n\t\t\t\trightObject.position.x = 3;\n\t\t\t\tscene.add( rightObject );\n\n\t\t\t\tleftObject.rotation.y = centerObject.rotation.y = rightObject.rotation.y = Math.PI * - 0.5;\n\t\t\t\tleftObject.position.y = centerObject.position.y = rightObject.position.y = - 1;\n\n\t\t\t\t//renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 25;\n\n\t\t\t\t//stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( centerObject.material, 'roughness', 0, 1, 0.01 );\n\t\t\t\tgui.add( centerObject.material, 'metalness', 0, 1, 0.01 );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 1000;\n\t\t\t\tconst lightTime = time * 0.5;\n\n\t\t\t\tlight1.position.x = Math.sin( lightTime * 0.7 ) * 3;\n\t\t\t\tlight1.position.y = Math.cos( lightTime * 0.5 ) * 4;\n\t\t\t\tlight1.position.z = Math.cos( lightTime * 0.3 ) * 3;\n\n\t\t\t\tlight2.position.x = Math.cos( lightTime * 0.3 ) * 3;\n\t\t\t\tlight2.position.y = Math.sin( lightTime * 0.5 ) * 4;\n\t\t\t\tlight2.position.z = Math.sin( lightTime * 0.7 ) * 3;\n\n\t\t\t\tlight3.position.x = Math.sin( lightTime * 0.7 ) * 3;\n\t\t\t\tlight3.position.y = Math.cos( lightTime * 0.3 ) * 4;\n\t\t\t\tlight3.position.z = Math.sin( lightTime * 0.5 ) * 3;\n\n\t\t\t\tlight4.position.x = Math.sin( lightTime * 0.3 ) * 3;\n\t\t\t\tlight4.position.y = Math.cos( lightTime * 0.7 ) * 4;\n\t\t\t\tlight4.position.z = Math.sin( lightTime * 0.5 ) * 3;\n\t\t\t\t/*\n\t\t\t\t@TODO: Used to test scene light change ( currently unavailable )\n\n\t\t\t\tif ( time > 2.0 && light1.parent === null ) scene.add( light1 );\n\t\t\t\tif ( time > 2.5 && light2.parent === null ) scene.add( light2 );\n\t\t\t\tif ( time > 3.0 && light3.parent === null ) scene.add( light3 );\n\t\t\t\tif ( time > 3.5 && light4.parent === null ) scene.add( light4 );\n\t\t\t\t*/\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - selective lights Left: Red lights - Center: All lights - Right: blue light"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - spotlight"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - spotlight:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet renderer, scene, camera;\n\n\t\t\tlet spotLight, lightHelper;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// Renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 7, 4, 1 );\n\n\t\t\t\t// Controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// Textures\n\n\t\t\t\tconst loader = new THREE.TextureLoader().setPath( 'textures/' );\n\t\t\t\tconst filenames = [ 'disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg' ];\n\n\t\t\t\tconst textures = { none: null };\n\n\t\t\t\tfor ( let i = 0; i < filenames.length; i ++ ) {\n\n\t\t\t\t\tconst filename = filenames[ i ];\n\n\t\t\t\t\tconst texture = loader.load( filename );\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\ttextures[ filename ] = texture;\n\n\t\t\t\t}\n\n\t\t\t\t// Lights\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 0.15 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xffffff, 100 );\n\t\t\t\tspotLight.map = textures[ 'disturb.jpg' ];\n\t\t\t\tspotLight.position.set( 2.5, 5, 2.5 );\n\t\t\t\tspotLight.angle = Math.PI / 6;\n\t\t\t\tspotLight.penumbra = 1;\n\t\t\t\tspotLight.decay = 2;\n\t\t\t\tspotLight.distance = 0;\n\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tspotLight.shadow.camera.near = 1;\n\t\t\t\tspotLight.shadow.camera.far = 10;\n\t\t\t\tspotLight.shadow.focus = 1;\n\t\t\t\tspotLight.shadow.bias = - .003;\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\tlightHelper = new THREE.SpotLightHelper( spotLight );\n\t\t\t\tscene.add( lightHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0xbcbcbc } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.position.set( 0, - 1, 0 );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// Models\n\n\t\t\t\tnew PLYLoader().load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {\n\n\t\t\t\t\tgeometry.scale( 0.0024, 0.0024, 0.0024 );\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.rotation.y = - Math.PI / 2;\n\t\t\t\t\tmesh.position.y = 0.8;\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst params = {\n\t\t\t\t\tmap: textures[ 'disturb.jpg' ],\n\t\t\t\t\tcolor: spotLight.color.getHex(),\n\t\t\t\t\tintensity: spotLight.intensity,\n\t\t\t\t\tdistance: spotLight.distance,\n\t\t\t\t\tangle: spotLight.angle,\n\t\t\t\t\tpenumbra: spotLight.penumbra,\n\t\t\t\t\tdecay: spotLight.decay,\n\t\t\t\t\tfocus: spotLight.shadow.focus,\n\t\t\t\t\tshadows: true,\n\t\t\t\t\tcustomAttenuation: false\n\t\t\t\t};\n\n\t\t\t\tgui.add( params, 'map', textures ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.map = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'color' ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.color.setHex( val );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'intensity', 0, 500 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.intensity = val;\n\n\t\t\t\t} );\n\n\n\t\t\t\tgui.add( params, 'distance', 0, 20 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.distance = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.angle = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.penumbra = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.decay = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {\n\n\t\t\t\t\tspotLight.shadow.focus = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'shadows' ).onChange( function ( val ) {\n\n\t\t\t\t\trenderer.shadowMap.enabled = val;\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.material ) {\n\n\t\t\t\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 3000;\n\n\t\t\t\tspotLight.position.x = Math.cos( time ) * 2.5;\n\t\t\t\tspotLight.position.z = Math.sin( time ) * 2.5;\n\n\t\t\t\tlightHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - spotlight"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - tiled lighting"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - tiled lighting:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, uv, pass, normalMap, uniform } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport { TiledLighting } from 'three/addons/lighting/TiledLighting.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\tlet camera, scene, renderer,\n\t\t\t\tlights, lightDummy,\n\t\t\t\tstats, controls,\n\t\t\t\tcompose, tileInfluence,\n\t\t\t\tlighting,\n\t\t\t\tcount,\n\t\t\t\tpostProcessing;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 600 );\n\t\t\t\tcamera.position.z = 200;\n\t\t\t\tcamera.position.y = 30;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x111111, 300, 500 );\n\t\t\t\tscene.background = new THREE.Color( 0x111111 );\n\n\t\t\t\tcount = 1000;\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial();\n\n\t\t\t\tlightDummy = new THREE.InstancedMesh( new THREE.SphereGeometry( 0.1, 16, 8 ), material, count );\n\t\t\t\tlightDummy.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\tscene.add( lightDummy );\n\n\t\t\t\t// lights\n\n\t\t\t\tlights = new THREE.Group();\n\t\t\t\tscene.add( lights );\n\n\t\t\t\tconst addLight = ( hexColor, power = 10, distance = 3 ) => {\n\n\t\t\t\t\tconst light = new THREE.PointLight( hexColor, 1, distance );\n\t\t\t\t\tlight.position.set( Math.random() * 300 - 150, 1, Math.random() * 300 - 150 );\n\t\t\t\t\tlight.power = power;\n\t\t\t\t\tlight.userData.fixedPosition = light.position.clone();\n\t\t\t\t\tlights.add( light );\n\n\t\t\t\t\treturn light;\n\n\t\t\t\t};\n\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst hex = ( Math.random() * 0xffffff ) + 0x666666;\n\n\t\t\t\t\tlightDummy.setColorAt( i, color.setHex( hex ) );\n\n\t\t\t\t\taddLight( hex );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tconst lightAmbient = new THREE.AmbientLight( 0xffffff, .1 );\n\t\t\t\tscene.add( lightAmbient );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst floorColor = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tfloorColor.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorColor.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorColor.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorNormal.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorNormal.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst uvTile = uv().mul( 50 );\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 1000, 1000 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolorNode: texture( floorColor, uvTile ),\n\t\t\t\t\tnormalNode: normalMap( texture( floorNormal, uvTile ) ),\n\t\t\t\t} );\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.position.y = 0;\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// renderer\n\n\t\t\t\tlighting = new TiledLighting(); // ( maxLights = 1024, tileSize = 32 )\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.lighting = lighting; // set lighting system\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 5;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxDistance = 400;\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst bloomPass = bloom( scenePass, 3, .9, .2 );\n\n\t\t\t\t// compose\n\n\t\t\t\tcompose = scenePass.add( bloomPass );\n\t\t\t\ttileInfluence = uniform( 0 );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tupdatePostProcessing();\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( tileInfluence, 'value', 0, 1 ).name( 'tile indexes debug' );\n\n\t\t\t}\n\n\t\t\tfunction updatePostProcessing() {\n\n\t\t\t\t// tile indexes debug, needs to be updated every time the renderer size changes\n\n\t\t\t\tconst debugBlockIndexes = lighting.getNode( scene, camera ).setSize( window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio ).getBlock().toColor().div( count * 2 );\n\n\t\t\t\tpostProcessing.outputNode = compose.add( debugBlockIndexes.mul( tileInfluence ) );\n\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tupdatePostProcessing();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() / 1000;\n\n\t\t\t\tfor ( let i = 0; i < lights.children.length; i ++ ) {\n\n\t\t\t\t\tconst light = lights.children[ i ];\n\t\t\t\t\tconst lightTime = ( time * 0.5 ) + light.id;\n\n\t\t\t\t\tlight.position.copy( light.userData.fixedPosition );\n\t\t\t\t\tlight.position.x += Math.sin( lightTime * 0.7 ) * 3;\n\t\t\t\t\tlight.position.y += Math.cos( lightTime * 0.5 ) * .5;\n\t\t\t\t\tlight.position.z += Math.cos( lightTime * 0.3 ) * 3;\n\n\t\t\t\t\tlightDummy.setMatrixAt( i, light.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - Compute-based Tiled Lighting"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - lines - fat"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - lines - fat:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'stats-gl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { LineSegments2 } from 'three/addons/lines/webgpu/LineSegments2.js';\n\t\t\timport { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';\n\t\t\timport { Line2 } from 'three/addons/lines/webgpu/Line2.js';\n\t\t\timport { LineGeometry } from 'three/addons/lines/LineGeometry.js';\n\n\n\t\t\tlet line, thresholdLine, segments, thresholdSegments;\n\t\t\tlet renderer, scene, camera, controls;\n\t\t\tlet sphereInter, sphereOnLine;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\t\t\tlet clock;\n\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tconst pointer = new THREE.Vector2( Infinity, Infinity );\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\n\t\t\traycaster.params.Line2 = {};\n\t\t\traycaster.params.Line2.threshold = 0;\n\n\t\t\tconst matLine = new THREE.Line2NodeMaterial( {\n\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tlinewidth: 1, // in world units with size attenuation, pixels otherwise\n\t\t\t\tworldUnits: true,\n\t\t\t\tvertexColors: true,\n\n\t\t\t\talphaToCoverage: true,\n\n\t\t\t} );\n\n\t\t\tconst matThresholdLine = new THREE.Line2NodeMaterial( {\n\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tlinewidth: matLine.linewidth, // in world units with size attenuation, pixels otherwise\n\t\t\t\tworldUnits: true,\n\t\t\t\t// vertexColors: true,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.2,\n\t\t\t\tdepthTest: false,\n\t\t\t\tvisible: false,\n\n\t\t\t} );\n\n\t\t\tconst params = {\n\n\t\t\t\t'line type': 0,\n\t\t\t\t'world units': matLine.worldUnits,\n\t\t\t\t'visualize threshold': matThresholdLine.visible,\n\t\t\t\t'width': matLine.linewidth,\n\t\t\t\t'alphaToCoverage': matLine.alphaToCoverage,\n\t\t\t\t'threshold': raycaster.params.Line2.threshold,\n\t\t\t\t'translation': raycaster.params.Line2.threshold,\n\t\t\t\t'animate': true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, alpha: true, trackTimestamp: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 40, 0, 60 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.25, 8, 4 );\n\t\t\t\tconst sphereInterMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, depthTest: false } );\n\t\t\t\tconst sphereOnLineMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, depthTest: false } );\n\n\t\t\t\tsphereInter = new THREE.Mesh( sphereGeometry, sphereInterMaterial );\n\t\t\t\tsphereOnLine = new THREE.Mesh( sphereGeometry, sphereOnLineMaterial );\n\t\t\t\tsphereInter.visible = false;\n\t\t\t\tsphereOnLine.visible = false;\n\t\t\t\tsphereInter.renderOrder = 10;\n\t\t\t\tsphereOnLine.renderOrder = 10;\n\t\t\t\tscene.add( sphereInter );\n\t\t\t\tscene.add( sphereOnLine );\n\n\t\t\t\t// Position and THREE.Color Data\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\t\t\t\tconst points = [];\n\t\t\t\tfor ( let i = - 50; i < 50; i ++ ) {\n\n\t\t\t\t\tconst t = i / 3;\n\t\t\t\t\tpoints.push( new THREE.Vector3( t * Math.sin( 2 * t ), t, t * Math.cos( 2 * t ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( points );\n\t\t\t\tconst divisions = Math.round( 3 * points.length );\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0, l = divisions; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = i / l;\n\n\t\t\t\t\tspline.getPoint( t, point );\n\t\t\t\t\tpositions.push( point.x, point.y, point.z );\n\n\t\t\t\t\tcolor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tconst lineGeometry = new LineGeometry();\n\t\t\t\tlineGeometry.setPositions( positions );\n\t\t\t\tlineGeometry.setColors( colors );\n\n\t\t\t\tconst segmentsGeometry = new LineSegmentsGeometry();\n\t\t\t\tsegmentsGeometry.setPositions( positions );\n\t\t\t\tsegmentsGeometry.setColors( colors );\n\n\t\t\t\tsegments = new LineSegments2( segmentsGeometry, matLine );\n\t\t\t\tsegments.computeLineDistances();\n\t\t\t\tsegments.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( segments );\n\t\t\t\tsegments.visible = false;\n\n\t\t\t\tthresholdSegments = new LineSegments2( segmentsGeometry, matThresholdLine );\n\t\t\t\tthresholdSegments.computeLineDistances();\n\t\t\t\tthresholdSegments.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( thresholdSegments );\n\t\t\t\tthresholdSegments.visible = false;\n\n\t\t\t\tline = new Line2( lineGeometry, matLine );\n\t\t\t\tline.computeLineDistances();\n\t\t\t\tline.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( line );\n\n\t\t\t\tthresholdLine = new Line2( lineGeometry, matThresholdLine );\n\t\t\t\tthresholdLine.computeLineDistances();\n\t\t\t\tthresholdLine.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( thresholdLine );\n\n\t\t\t\tconst geo = new THREE.BufferGeometry();\n\t\t\t\tgeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tstats = new Stats( { horizontal: false, trackGPU: true } );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\t\t\t\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tconst obj = line.visible ? line : segments;\n\t\t\t\tthresholdLine.position.copy( line.position );\n\t\t\t\tthresholdLine.quaternion.copy( line.quaternion );\n\t\t\t\tthresholdSegments.position.copy( segments.position );\n\t\t\t\tthresholdSegments.quaternion.copy( segments.quaternion );\n\n\t\t\t\tif ( params.animate ) {\n\n\t\t\t\t\tline.rotation.y += delta * 0.1;\n\n\t\t\t\t\tsegments.rotation.y = line.rotation.y;\n\n\t\t\t\t}\n\n\t\t\t\traycaster.setFromCamera( pointer, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObject( obj );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tsphereInter.visible = true;\n\t\t\t\t\tsphereOnLine.visible = true;\n\n\t\t\t\t\tsphereInter.position.copy( intersects[ 0 ].point );\n\t\t\t\t\tsphereOnLine.position.copy( intersects[ 0 ].pointOnLine );\n\n\t\t\t\t\tconst index = intersects[ 0 ].faceIndex;\n\t\t\t\t\tconst colors = obj.geometry.getAttribute( 'instanceColorStart' );\n\n\t\t\t\t\tcolor.fromBufferAttribute( colors, index );\n\n\t\t\t\t\tsphereInter.material.color.copy( color ).offsetHSL( 0.3, 0, 0 );\n\t\t\t\t\tsphereOnLine.material.color.copy( color ).offsetHSL( 0.7, 0, 0 );\n\n\t\t\t\t\trenderer.domElement.style.cursor = 'crosshair';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphereInter.visible = false;\n\t\t\t\t\tsphereOnLine.visible = false;\n\t\t\t\t\trenderer.domElement.style.cursor = '';\n\n\t\t\t\t}\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction switchLine( val ) {\n\n\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tline.visible = true;\n\t\t\t\t\t\tthresholdLine.visible = true;\n\n\t\t\t\t\t\tsegments.visible = false;\n\t\t\t\t\t\tthresholdSegments.visible = false;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tline.visible = false;\n\t\t\t\t\t\tthresholdLine.visible = false;\n\n\t\t\t\t\t\tsegments.visible = true;\n\t\t\t\t\t\tthresholdSegments.visible = true;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( params, 'line type', { 'LineGeometry': 0, 'LineSegmentsGeometry': 1 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitchLine( val );\n\n\t\t\t\t} ).setValue( 1 );\n\n\t\t\t\tgui.add( params, 'world units' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.worldUnits = val;\n\t\t\t\t\tmatLine.needsUpdate = true;\n\n\t\t\t\t\tmatThresholdLine.worldUnits = val;\n\t\t\t\t\tmatThresholdLine.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'visualize threshold' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatThresholdLine.visible = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'width', 1, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.linewidth = val;\n\t\t\t\t\tmatThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'alphaToCoverage' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.alphaToCoverage = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'threshold', 0, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\traycaster.params.Line2.threshold = val;\n\t\t\t\t\tmatThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'translation', 0, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tline.position.x = val;\n\t\t\t\t\tsegments.position.x = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'animate' );\n\n\t\t\t}\n```\n\nThis example three.js - fat lines raycasting"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - lines - fat - wireframe"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - lines - fat - wireframe:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Wireframe } from 'three/addons/lines/webgpu/Wireframe.js';\n\t\t\timport { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';\n\n\t\t\tlet wireframe, renderer, scene, camera, camera2, controls, backgroundNode;\n\t\t\tlet wireframe1;\n\t\t\tlet matLine, matLineBasic, matLineDashed;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\n\t\t\t// viewport\n\t\t\tlet insetWidth;\n\t\t\tlet insetHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 50, 0, 50 );\n\n\t\t\t\tcamera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );\n\t\t\t\tcamera2.position.copy( camera.position );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tbackgroundNode = color( 0x222222 );\n\n\t\t\t\t// Wireframe ( WireframeGeometry2, Line2NodeMaterial )\n\n\t\t\t\tlet geo = new THREE.IcosahedronGeometry( 20, 1 );\n\n\t\t\t\tconst geometry = new WireframeGeometry2( geo );\n\n\t\t\t\tmatLine = new THREE.Line2NodeMaterial( {\n\n\t\t\t\t\tcolor: 0x4080ff,\n\t\t\t\t\tlinewidth: 5, // in world units with size attenuation, pixels otherwise\n\t\t\t\t\tdashed: false\n\n\t\t\t\t} );\n\n\t\t\t\twireframe = new Wireframe( geometry, matLine );\n\t\t\t\twireframe.computeLineDistances();\n\t\t\t\twireframe.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( wireframe );\n\n\t\t\t\t// Line ( THREE.WireframeGeometry, THREE.LineBasicMaterial ) - rendered with gl.LINE\n\n\t\t\t\tgeo = new THREE.WireframeGeometry( geo );\n\n\t\t\t\tmatLineBasic = new THREE.LineBasicMaterial( { color: 0x4080ff } );\n\t\t\t\tmatLineDashed = new THREE.LineDashedMaterial( { scale: 2, dashSize: 1, gapSize: 1 } );\n\n\t\t\t\twireframe1 = new THREE.LineSegments( geo, matLineBasic );\n\t\t\t\twireframe1.computeLineDistances();\n\t\t\t\twireframe1.visible = false;\n\t\t\t\tscene.add( wireframe1 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tinsetWidth = window.innerHeight / 4; // square\n\t\t\t\tinsetHeight = window.innerHeight / 4;\n\n\t\t\t\tcamera2.aspect = insetWidth / insetHeight;\n\t\t\t\tcamera2.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// main scene\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t\t\trenderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );\n\n\t\t\t\trenderer.autoClear = true;\n\n\t\t\t\tscene.backgroundNode = null;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// inset scene\n\n\t\t\t\tconst posY = window.innerHeight - insetHeight - 20;\n\n\t\t\t\trenderer.clearDepth(); // important!\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 20, posY, insetWidth, insetHeight );\n\n\t\t\t\trenderer.setViewport( 20, posY, insetWidth, insetHeight );\n\n\t\t\t\tcamera2.position.copy( camera.position );\n\t\t\t\tcamera2.quaternion.copy( camera.quaternion );\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tscene.backgroundNode = backgroundNode;\n\t\t\t\trenderer.render( scene, camera2 );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tconst param = {\n\t\t\t\t\t'line type': 0,\n\t\t\t\t\t'width (px)': 5,\n\t\t\t\t\t'dashed': false,\n\t\t\t\t\t'dash scale': 1,\n\t\t\t\t\t'dash / gap': 1\n\t\t\t\t};\n\n\n\t\t\t\tgui.add( param, 'line type', { 'LineGeometry': 0, 'gl.LINE': 1 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\twireframe.visible = true;\n\n\t\t\t\t\t\t\twireframe1.visible = false;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\twireframe.visible = false;\n\n\t\t\t\t\t\t\twireframe1.visible = true;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'width (px)', 1, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.linewidth = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dashed' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashed = val;\n\t\t\t\t\twireframe1.material = val ? matLineDashed : matLineBasic;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash scale', 0.5, 1, 0.1 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.scale = val;\n\t\t\t\t\tmatLineDashed.scale = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tmatLine.dashSize = 2;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 2;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 2;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 2;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - fat lines"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - fat lines"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - fat lines:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Line2 } from 'three/addons/lines/webgpu/Line2.js';\n\t\t\timport { LineGeometry } from 'three/addons/lines/LineGeometry.js';\n\t\t\timport * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n\n\t\t\tlet line, renderer, scene, camera, camera2, controls, backgroundNode;\n\t\t\tlet line1;\n\t\t\tlet matLine, matLineBasic, matLineDashed;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\n\t\t\t// viewport\n\t\t\tlet insetWidth;\n\t\t\tlet insetHeight;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( - 40, 0, 60 );\n\n\t\t\t\tcamera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );\n\t\t\t\tcamera2.position.copy( camera.position );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tbackgroundNode = color( 0x222222 );\n\n\t\t\t\t// Position and THREE.Color Data\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tconst points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );\n\n\t\t\t\tconst spline = new THREE.CatmullRomCurve3( points );\n\t\t\t\tconst divisions = Math.round( 12 * points.length );\n\t\t\t\tconst point = new THREE.Vector3();\n\t\t\t\tconst lineColor = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0, l = divisions; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = i / l;\n\n\t\t\t\t\tspline.getPoint( t, point );\n\t\t\t\t\tpositions.push( point.x, point.y, point.z );\n\n\t\t\t\t\tlineColor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors.push( lineColor.r, lineColor.g, lineColor.b );\n\n\t\t\t\t}\n\n\n\t\t\t\t// Line2 ( LineGeometry, LineMaterial )\n\n\t\t\t\tconst geometry = new LineGeometry();\n\t\t\t\tgeometry.setPositions( positions );\n\t\t\t\tgeometry.setColors( colors );\n\n\t\t\t\tmatLine = new THREE.Line2NodeMaterial( {\n\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tlinewidth: 5, // in world units with size attenuation, pixels otherwise\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tdashed: false,\n\t\t\t\t\talphaToCoverage: true,\n\n\t\t\t\t} );\n\n\t\t\t\tline = new Line2( geometry, matLine );\n\t\t\t\tline.computeLineDistances();\n\t\t\t\tline.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( line );\n\n\t\t\t\tconst geo = new THREE.BufferGeometry();\n\t\t\t\tgeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\tmatLineBasic = new THREE.LineBasicNodeMaterial( { vertexColors: true } );\n\t\t\t\tmatLineDashed = new THREE.LineDashedNodeMaterial( { vertexColors: true, scale: 2, dashSize: 1, gapSize: 1 } );\n\n\t\t\t\tline1 = new THREE.Line( geo, matLineBasic );\n\t\t\t\tline1.computeLineDistances();\n\t\t\t\tline1.visible = false;\n\t\t\t\tscene.add( line1 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tonWindowResize();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tinsetWidth = window.innerHeight / 4; // square\n\t\t\t\tinsetHeight = window.innerHeight / 4;\n\n\t\t\t\tcamera2.aspect = insetWidth / insetHeight;\n\t\t\t\tcamera2.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\t// main scene\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t\t\trenderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.autoClear = true;\n\n\t\t\t\tscene.backgroundNode = null;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// inset scene\n\n\t\t\t\tconst posY = window.innerHeight - insetHeight - 20;\n\n\t\t\t\trenderer.clearDepth(); // important!\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 20, posY, insetWidth, insetHeight );\n\n\t\t\t\trenderer.setViewport( 20, posY, insetWidth, insetHeight );\n\n\t\t\t\tcamera2.position.copy( camera.position );\n\t\t\t\tcamera2.quaternion.copy( camera.quaternion );\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tscene.backgroundNode = backgroundNode;\n\t\t\t\trenderer.render( scene, camera2 );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tconst param = {\n\t\t\t\t\t'line type': 0,\n\t\t\t\t\t'world units': false,\n\t\t\t\t\t'width': 5,\n\t\t\t\t\t'alphaToCoverage': true,\n\t\t\t\t\t'dashed': false,\n\t\t\t\t\t'dash offset': 0,\n\t\t\t\t\t'dash scale': 1,\n\t\t\t\t\t'dash / gap': 1\n\t\t\t\t};\n\n\t\t\t\tgui.add( param, 'line type', { 'LineGeometry': 0, '\"line-strip\"': 1 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tline.visible = true;\n\n\t\t\t\t\t\t\tline1.visible = false;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tline.visible = false;\n\n\t\t\t\t\t\t\tline1.visible = true;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'world units' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.worldUnits = val;\n\t\t\t\t\tmatLine.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'width', 1, 10 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.linewidth = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'alphaToCoverage' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.alphaToCoverage = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dashed' ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashed = val;\n\t\t\t\t\tline1.material = val ? matLineDashed : matLineBasic;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash scale', 0.5, 2, 0.1 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.scale = val;\n\t\t\t\t\tmatLineDashed.scale = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash offset', 0, 5, 0.1 ).onChange( function ( val ) {\n\n\t\t\t\t\tmatLine.dashOffset = val;\n\t\t\t\t\tmatLineDashed.dashOffset = val;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {\n\n\t\t\t\t\tswitch ( val ) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tmatLine.dashSize = 2;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 2;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 1;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 1;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tmatLine.dashSize = 1;\n\t\t\t\t\t\t\tmatLine.gapSize = 2;\n\n\t\t\t\t\t\t\tmatLineDashed.dashSize = 1;\n\t\t\t\t\t\t\tmatLineDashed.gapSize = 2;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js - fat lines"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - gltf loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - gltf loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\t//texture.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\t\t\t\t//texture.generateMipmaps = true;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmet.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true/*, compatibilityMode: true*/ } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - gltf loader Battle Damaged Sci-fi Helmet by theblueturtle_ Royal Esplanade by HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - glTF + anisotropy"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - glTF + anisotropy:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.35;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( - 0.35, - 0.2, 0.35 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, - 0.08, 0.11 );\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 2;\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader().setPath( 'textures/equirectangular/' );\n\t\t\t\tconst gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );\n\n\t\t\t\tconst [ texture, gltf ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'royal_esplanade_1k.hdr' ),\n\t\t\t\t\tgltfLoader.loadAsync( 'AnisotropyBarnLamp.glb' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - glTF + KHR_materials_anisotropy Anisotropy Barn Lamp from glTF-Sample-Models Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - glTF + compressed"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - glTF + compressed:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.set( 2, 2, 2 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xEEEEEE );\n\n\t\t\t\t//lights\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff );\n\t\t\t\tlight.power = 1300;\n\t\t\t\tcamera.add( light );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t//renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 6;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst ktx2Loader = await new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupportAsync( renderer );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.setKTX2Loader( ktx2Loader );\n\t\t\t\tloader.setMeshoptDecoder( MeshoptDecoder );\n\t\t\t\tloader.load( 'models/gltf/coffeemat.glb', function ( gltf ) {\n\n\t\t\t\t\tconst gltfScene = gltf.scene;\n\t\t\t\t\tgltfScene.position.y = - .8;\n\t\t\t\t\tgltfScene.scale.setScalar( .01 );\n\n\t\t\t\t\tscene.add( gltfScene );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - glTF + compression extensions"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - glTF + dispersion"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - glTF + dispersion:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 5 );\n\t\t\t\tcamera.position.set( 0.1, 0.05, 0.15 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping; // TODO: Add THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst rgbeLoader = await new RGBELoader().setPath( 'textures/equirectangular/' ).loadAsync( 'pedestrian_overpass_1k.hdr' );\n\t\t\t\trgbeLoader.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\tscene.environment = rgbeLoader;\n\t\t\t\tscene.background = rgbeLoader;\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/DispersionTest.glb' );\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - glTF + KHR_materials_dispersion HDR by Poly Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - glTF + iridescence"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - glTF + iridescence:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\n\t\t\tinit().catch( function ( err ) {\n\n\t\t\t\tconsole.error( err );\n\n\t\t\t} );\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.05, 20 );\n\t\t\t\tcamera.position.set( 0.35, 0.05, 0.35 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 0.5;\n\t\t\t\tcontrols.target.set( 0, 0.2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );\n\n\t\t\t\tconst [ texture, gltf ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'venice_sunset_1k.hdr' ),\n\t\t\t\t\tgltfLoader.loadAsync( 'IridescenceLamp.glb' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\trender();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - glTF + KHR_materials_iridescence Iridescence Lamp from glTF-Sample-Models Venice Sunset from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - sheen"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - sheen:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 20 );\n\t\t\t\tcamera.position.set( - 0.75, 0.7, 1.25 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\t//scene.add( new THREE.DirectionalLight( 0xffffff, 2 ) );\n\n\t\t\t\t// model\n\n\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t.setPath( 'models/gltf/' )\n\t\t\t\t\t.load( 'SheenChair.glb', function ( gltf ) {\n\n\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\tconst object = gltf.scene.getObjectByName( 'SheenChair_fabric' );\n\n\t\t\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t\t\tgui.add( object.material, 'sheen', 0, 1 );\n\t\t\t\t\t\tgui.open();\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tscene.background = new THREE.Color( 0xAAAAAA );\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\t//scene.backgroundBlurriness = 1; // @TODO: Needs PMREM\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t} );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0.35, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update(); // required if damping enabled\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - glTF + KHR_materials_sheen Sheen Chair from glTF-Sample-Models"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - glTF + transmission"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - glTF + transmission:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\tlet camera, scene, renderer, controls, clock, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( 0, 0.4, 0.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.backgroundBlurriness = 0.35;\n\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t\t\t.setPath( 'models/gltf/' )\n\t\t\t\t\t\t\t.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) )\n\t\t\t\t\t\t\t.load( 'IridescentDishWithOlives.glb', function ( gltf ) {\n\n\t\t\t\t\t\t\t\tmixer = new THREE.AnimationMixer( gltf.scene );\n\t\t\t\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 0.75;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.5;\n\t\t\t\tcontrols.maxDistance = 1;\n\t\t\t\tcontrols.target.set( 0, 0.1, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( mixer ) mixer.update( clock.getDelta() );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - glTF + KHR_materials_transmission Iridescent Dish With Olives by Eric Chadwick Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materialx loader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materialx loader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from './jsm/controls/OrbitControls.js';\n\n\t\t\timport { RGBELoader } from './jsm/loaders/RGBELoader.js';\n\t\t\timport { GLTFLoader } from './jsm/loaders/GLTFLoader.js';\n\n\t\t\timport { MaterialXLoader } from './jsm/loaders/MaterialXLoader.js';\n\n\t\t\tconst SAMPLE_PATH = 'https://raw.githubusercontent.com/materialx/MaterialX/main/resources/Materials/Examples/StandardSurface/';\n\n\t\t\tconst samples = [\n\t\t\t\t'standard_surface_brass_tiled.mtlx',\n\t\t\t\t'standard_surface_brick_procedural.mtlx',\n\t\t\t\t'standard_surface_carpaint.mtlx',\n\t\t\t\t//'standard_surface_chess_set.mtlx',\n\t\t\t\t'standard_surface_chrome.mtlx',\n\t\t\t\t'standard_surface_copper.mtlx',\n\t\t\t\t//'standard_surface_default.mtlx',\n\t\t\t\t//'standard_surface_glass.mtlx',\n\t\t\t\t//'standard_surface_glass_tinted.mtlx',\n\t\t\t\t'standard_surface_gold.mtlx',\n\t\t\t\t//'standard_surface_greysphere.mtlx',\n\t\t\t\t//'standard_surface_greysphere_calibration.mtlx',\n\t\t\t\t'standard_surface_jade.mtlx',\n\t\t\t\t//'standard_surface_look_brass_tiled.mtlx',\n\t\t\t\t//'standard_surface_look_wood_tiled.mtlx',\n\t\t\t\t'standard_surface_marble_solid.mtlx',\n\t\t\t\t'standard_surface_metal_brushed.mtlx',\n\t\t\t\t'standard_surface_plastic.mtlx',\n\t\t\t\t//'standard_surface_thin_film.mtlx',\n\t\t\t\t'standard_surface_velvet.mtlx',\n\t\t\t\t'standard_surface_wood_tiled.mtlx'\n\t\t\t];\n\n\t\t\tlet camera, scene, renderer, prefab;\n\t\t\tconst models = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 50 );\n\t\t\t\tcamera.position.set( 0, 3, 20 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\trenderer.toneMappingExposure = .5;\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 40;\n\n\t\t\t\t//\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'san_giuseppe_bridge_2k.hdr', async ( texture ) => {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\tprefab = ( await new GLTFLoader().loadAsync( './models/gltf/ShaderBall.glb' ) ).scene;\n\n\t\t\t\t\t\tfor ( const sample of samples ) {\n\n\t\t\t\t\t\t\taddSample( sample );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction updateModelsAlign() {\n\n\t\t\t\tconst COLUMN_COUNT = 6;\n\t\t\t\tconst DIST_X = 3;\n\t\t\t\tconst DIST_Y = 4;\n\n\t\t\t\tconst lineCount = Math.floor( models.length / COLUMN_COUNT ) - 1.5;\n\n\t\t\t\tconst offsetX = ( DIST_X * ( COLUMN_COUNT - 1 ) ) * - .5;\n\t\t\t\tconst offsetY = ( DIST_Y * lineCount ) * .5;\n\n\t\t\t\tfor ( let i = 0; i < models.length; i ++ ) {\n\n\t\t\t\t\tconst model = models[ i ];\n\n\t\t\t\t\tmodel.position.x = ( ( i % COLUMN_COUNT ) * DIST_X ) + offsetX;\n\t\t\t\t\tmodel.position.y = ( Math.floor( i / COLUMN_COUNT ) * - DIST_Y ) + offsetY;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tasync function addSample( sample ) {\n\n\t\t\t\tconst model = prefab.clone();\n\n\t\t\t\tmodels.push( model );\n\n\t\t\t\tscene.add( model );\n\n\t\t\t\tupdateModelsAlign();\n\n\t\t\t\t//\n\n\t\t\t\tconst material = await new MaterialXLoader()\n\t\t\t\t\t.setPath( SAMPLE_PATH )\n\t\t\t\t\t.loadAsync( sample )\n\t\t\t\t\t.then( ( { materials } ) => Object.values( materials ).pop() );\n\n\t\t\t\tconst calibrationMesh = model.getObjectByName( 'Calibration_Mesh' );\n\t\t\t\tcalibrationMesh.material = material;\n\n\t\t\t\tconst Preview_Mesh = model.getObjectByName( 'Preview_Mesh' );\n\t\t\t\tPreview_Mesh.material = material;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - materialx loader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materials"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materials:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport * as TSL from 'three/tsl';\n\n\t\t\timport { Fn, wgslFn, positionLocal, scriptable, positionWorld, normalLocal, normalWorld, normalView, color, texture, uv, float, vec2, vec3, vec4, oscSine, triplanarTexture, screenUV, js, string, Loop, cameraProjectionMatrix, ScriptableNodeResources } from 'three/tsl';\n\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst objects = [], materials = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 0, 200, 800 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Grid\n\n\t\t\t\tconst helper = new THREE.GridHelper( 1000, 40, 0x303030, 0x303030 );\n\t\t\t\thelper.position.y = - 75;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\t// Materials\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst uvTexture = textureLoader.load( './textures/uv_grid_opengl.jpg' );\n\t\t\t\tuvTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tuvTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst opacityTexture = textureLoader.load( './textures/alphaMap.jpg' );\n\t\t\t\topacityTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\topacityTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tlet material;\n\n\t\t\t\t//\n\t\t\t\t//\tBASIC\n\t\t\t\t//\n\n\t\t\t\t// PositionLocal\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = positionLocal;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// PositionWorld\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = positionWorld;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// NormalLocal\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = normalLocal;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// NormalWorld\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = normalWorld;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// NormalView\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = normalView;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Texture\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = texture( uvTexture );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Opacity\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = color( 0x0099FF );\n\t\t\t\tmaterial.opacityNode = texture( uvTexture );\n\t\t\t\tmaterial.transparent = true;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// AlphaTest\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = texture( uvTexture );\n\t\t\t\tmaterial.opacityNode = texture( opacityTexture );\n\t\t\t\tmaterial.alphaTestNode = 0.5;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// camera\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = cameraProjectionMatrix.mul( positionLocal );\n\t\t\t\tmaterials.push( material );\n\n\n\t\t\t\t// Normal\n\t\t\t\tmaterial = new THREE.MeshNormalMaterial();\n\t\t\t\tmaterial.opacity = .5;\n\t\t\t\tmaterial.transparent = true;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t//\n\t\t\t\t//\tADVANCED\n\t\t\t\t//\n\n\t\t\t\t// Custom ShaderNode ( desaturate filter )\n\n\t\t\t\tconst desaturateShaderNode = Fn( ( input ) => {\n\n\t\t\t\t\treturn vec3( 0.299, 0.587, 0.114 ).dot( input.color.xyz );\n\n\t\t\t\t} );\n\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = desaturateShaderNode( { color: texture( uvTexture ) } );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Custom ShaderNode(no inputs) > Approach 2\n\n\t\t\t\tconst desaturateNoInputsShaderNode = Fn( () => {\n\n\t\t\t\t\treturn vec3( 0.299, 0.587, 0.114 ).dot( texture( uvTexture ).xyz );\n\n\t\t\t\t} );\n\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = desaturateNoInputsShaderNode();\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Custom WGSL ( desaturate filter )\n\n\t\t\t\tconst desaturateWGSLFn = wgslFn( `\n\t\t\t\t\tfn desaturate( color:vec3<f32> ) -> vec3<f32> {\n\n\t\t\t\t\t\tlet lum = vec3<f32>( 0.299, 0.587, 0.114 );\n\n\t\t\t\t\t\treturn vec3<f32>( dot( lum, color ) );\n\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\t// include example\n\n\t\t\t\tconst someWGSLFn = wgslFn( `\n\t\t\t\t\tfn someFn( color:vec3<f32> ) -> vec3<f32> {\n\n\t\t\t\t\t\treturn desaturate( color );\n\n\t\t\t\t\t}\n\t\t\t\t`, [ desaturateWGSLFn ] );\n\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = someWGSLFn( { color: texture( uvTexture ) } );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Custom WGSL\n\n\t\t\t\tconst getWGSLTextureSample = wgslFn( `\n\t\t\t\t\tfn getWGSLTextureSample( tex: texture_2d<f32>, tex_sampler: sampler, uv:vec2<f32> ) -> vec4<f32> {\n\n\t\t\t\t\t\treturn textureSample( tex, tex_sampler, uv ) * vec4<f32>( 0.0, 1.0, 0.0, 1.0 );\n\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\tconst textureNode = texture( uvTexture );\n\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = getWGSLTextureSample( { tex: textureNode, tex_sampler: textureNode, uv: uv() } );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Triplanar Texture Mapping\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = triplanarTexture( texture( uvTexture ), null, null, float( .01 ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Screen Projection Texture\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = texture( uvTexture, screenUV.flipY() );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\t// Loop\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tconst loopCount = 10;\n\t\t\t\tmaterial.colorNode = Loop( loopCount, ( { i } ) => {\n\n\t\t\t\t\tconst output = vec4().toVar();\n\t\t\t\t\tconst scale = oscSine().mul( .09 ); // just a value to test\n\n\t\t\t\t\tconst scaleI = scale.mul( i );\n\t\t\t\t\tconst scaleINeg = scaleI.negate();\n\n\t\t\t\t\tconst leftUV = uv().add( vec2( scaleI, 0 ) );\n\t\t\t\t\tconst rightUV = uv().add( vec2( scaleINeg, 0 ) );\n\t\t\t\t\tconst topUV = uv().add( vec2( 0, scaleI ) );\n\t\t\t\t\tconst bottomUV = uv().add( vec2( 0, scaleINeg ) );\n\n\t\t\t\t\toutput.assign( output.add( texture( uvTexture, leftUV ) ) );\n\t\t\t\t\toutput.assign( output.add( texture( uvTexture, rightUV ) ) );\n\t\t\t\t\toutput.assign( output.add( texture( uvTexture, topUV ) ) );\n\t\t\t\t\toutput.assign( output.add( texture( uvTexture, bottomUV ) ) );\n\n\t\t\t\t\treturn output.div( loopCount * 4 );\n\n\t\t\t\t} );\n\n\t\t\t\t// Scriptable\n\n\t\t\t\tScriptableNodeResources.set( 'TSL', TSL );\n\n\t\t\t\tconst asyncNode = scriptable( js( `\n\n\t\t\t\t\tlayout = {\n\t\t\t\t\t\toutputType: 'node'\n\t\t\t\t\t};\n\n\t\t\t\t\tconst { float } = TSL;\n\n\t\t\t\t\tfunction init() {\n\n\t\t\t\t\t\tsetTimeout( () => {\n\n\t\t\t\t\t\t\tlocal.set( 'result', float( 1.0 ) );\n\n\t\t\t\t\t\t\trefresh(); // refresh the node\n\n\t\t\t\t\t\t}, 1000 );\n\n\t\t\t\t\t\treturn float( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction main() {\n\n\t\t\t\t\t\tconst result = local.get( 'result', init );\n\n\t\t\t\t\t\t//console.log( 'result', result );\n\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t}\n\n\t\t\t\t` ) );\n\n\t\t\t\tconst scriptableNode = scriptable( js( `\n\n\t\t\t\t\tlayout = {\n\t\t\t\t\t\toutputType: 'node',\n\t\t\t\t\t\telements: [\n\t\t\t\t\t\t\t{ name: 'source', inputType: 'node' },\n\t\t\t\t\t\t\t{ name: 'contrast', inputType: 'node' },\n\t\t\t\t\t\t\t{ name: 'vector3', inputType: 'Vector3' },\n\t\t\t\t\t\t\t{ name: 'message', inputType: 'string' },\n\t\t\t\t\t\t\t{ name: 'binary', inputType: 'ArrayBuffer' },\n\t\t\t\t\t\t\t{ name: 'object3d', inputType: 'Object3D' },\n\t\t\t\t\t\t\t{ name: 'execFrom', inputType: 'string' }\n\t\t\t\t\t\t]\n\t\t\t\t\t};\n\n\t\t\t\t\tconst { saturation, float, oscSine, mul } = TSL;\n\n\t\t\t\t\tfunction helloWorld() {\n\n\t\t\t\t\t\tconsole.log( \"Hello World!\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction main() {\n\n\t\t\t\t\t\tconst source = parameters.get( 'source' ) || float();\n\t\t\t\t\t\tconst contrast = parameters.get( 'contrast' ) || float();\n\n\t\t\t\t\t\tconst material = local.get( 'material' );\n\n\t\t\t\t\t\t//console.log( 'vector3', parameters.get( 'vector3' ) );\n\n\t\t\t\t\t\tif ( parameters.get( 'execFrom' ) === 'serialized' ) {\n\n\t\t\t\t\t\t\t//console.log( 'message', parameters.get( 'message' ).value );\n\t\t\t\t\t\t\t//console.log( 'binary', parameters.get( 'binary' ) );\n\t\t\t\t\t\t\t//console.log( 'object3d', parameters.get( 'object3d' ) ); // unserializable yet\n\n\t\t\t\t\t\t\t//console.log( global.get( 'renderer' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material ) material.needsUpdate = true;\n\n\t\t\t\t\t\treturn mul( saturation( source, oscSine() ), contrast );\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput = { helloWorld };\n\n\t\t\t\t` ) );\n\n\t\t\t\tscriptableNode.setParameter( 'source', texture( uvTexture ).xyz );\n\t\t\t\tscriptableNode.setParameter( 'contrast', asyncNode );\n\t\t\t\tscriptableNode.setParameter( 'vector3', vec3( new THREE.Vector3( 1, 1, 1 ) ) );\n\t\t\t\tscriptableNode.setParameter( 'message', string( 'Hello World!' ) );\n\t\t\t\tscriptableNode.setParameter( 'binary', new ArrayBuffer( 4 ) );\n\t\t\t\tscriptableNode.setParameter( 'object3d', new THREE.Group() );\n\n\t\t\t\tscriptableNode.call( 'helloWorld' );\n\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = scriptableNode;\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tscriptableNode.setLocal( 'material', material );\n\n\t\t\t\t//\n\t\t\t\t// Geometry\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new TeapotGeometry( 50, 18 );\n\n\t\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\taddMesh( geometry, materials[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tconst serializeMesh = scene.children[ scene.children.length - 1 ];\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tsetTimeout( () => testSerialization( serializeMesh ), 1000 );\n\n\t\t\t}\n\n\t\t\tfunction addMesh( geometry, material ) {\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\tmesh.position.x = ( objects.length % 4 ) * 200 - 400;\n\t\t\t\tmesh.position.z = Math.floor( objects.length / 4 ) * 200 - 200;\n\n\t\t\t\tmesh.rotation.x = Math.random() * 200 - 100;\n\t\t\t\tmesh.rotation.y = Math.random() * 200 - 100;\n\t\t\t\tmesh.rotation.z = Math.random() * 200 - 100;\n\n\t\t\t\tobjects.push( mesh );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction moduleToLib( module ) {\n\n\t\t\t\tconst lib = {};\n\n\t\t\t\tfor ( const nodeElement of Object.values( module ) ) {\n\n\t\t\t\t\tif ( typeof nodeElement === 'function' && nodeElement.type !== undefined ) {\n\n\t\t\t\t\t\tlib[ nodeElement.type ] = nodeElement;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn lib;\n\n\t\t\t}\n\n\t\t\tfunction testSerialization( mesh ) {\n\n\t\t\t\tconst json = mesh.toJSON();\n\t\t\t\tconst loader = new THREE.NodeObjectLoader().setNodes( moduleToLib( THREE ) ).setNodeMaterials( moduleToLib( THREE ) );\n\t\t\t\tconst serializedMesh = loader.parse( json );\n\n\t\t\t\tserializedMesh.position.x = ( objects.length % 4 ) * 200 - 400;\n\t\t\t\tserializedMesh.position.z = Math.floor( objects.length / 4 ) * 200 - 200;\n\n\t\t\t\tconst scriptableNode = serializedMesh.material.colorNode;\n\n\t\t\t\t// it's because local.get( 'material' ) is used in the example ( local/global is unserializable )\n\t\t\t\tscriptableNode.setLocal( 'material', serializedMesh.material );\n\t\t\t\tscriptableNode.setParameter( 'execFrom', 'serialized' );\n\n\t\t\t\tobjects.push( serializedMesh );\n\n\t\t\t\tscene.add( serializedMesh );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = 0.0001 * Date.now();\n\n\t\t\t\tcamera.position.x = Math.cos( timer ) * 1000;\n\t\t\t\tcamera.position.z = Math.sin( timer ) * 1000;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tobject.rotation.x += 0.01;\n\t\t\t\t\tobject.rotation.y += 0.005;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - materials"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materials - alpha hash"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materials - alpha hash:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';\n\n\t\t\tlet camera, scene, renderer, controls, stats, mesh, material, postProcessing;\n\n\t\t\tconst amount = parseInt( window.location.search.slice( 1 ) ) || 3;\n\t\t\tconst count = Math.pow( amount, 3 );\n\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tconst params = {\n\t\t\t\talpha: 0.5,\n\t\t\t\talphaHash: true\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( amount, amount, amount );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 0.5, 3 );\n\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\talphaHash: params.alphaHash,\n\t\t\t\t\topacity: params.alpha\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, count );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst offset = ( amount - 1 ) / 2;\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tfor ( let x = 0; x < amount; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < amount; y ++ ) {\n\n\t\t\t\t\t\tfor ( let z = 0; z < amount; z ++ ) {\n\n\t\t\t\t\t\t\tmatrix.setPosition( offset - x, offset - y, offset - z );\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( i, matrix );\n\t\t\t\t\t\t\tmesh.setColorAt( i, color.setHex( Math.random() * 0xffffff ) );\n\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\t//\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\t\t\t\tenvironment.dispose();\n\n\t\t\t\t//\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tconst scenePass = ssaaPass( scene, camera );\n\t\t\t\tscenePass.sampleLevel = 3;\n\n\t\t\t\tpostProcessing.outputNode = scenePass;\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'alpha', 0, 1 ).onChange( onMaterialUpdate );\n\t\t\t\tgui.add( params, 'alphaHash' ).onChange( onMaterialUpdate );\n\n\t\t\t\tconst ssaaFolder = gui.addFolder( 'SSAA' );\n\t\t\t\tssaaFolder.add( scenePass, 'sampleLevel', 0, 4, 1 );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onMaterialUpdate() {\n\n\t\t\t\tmaterial.opacity = params.alpha;\n\t\t\t\tmaterial.alphaHash = params.alphaHash;\n\t\t\t\tmaterial.transparent = ! params.alphaHash;\n\t\t\t\tmaterial.depthWrite = params.alphaHash;\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materials arrays and geometry groups"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materials arrays and geometry groups:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\t\t\tlet planeMesh, boxMesh, boxMeshWireframe, planeMeshWireframe;\n\t\t\tlet materials;\n\n\t\t\tconst api = {\n\t\t\t\twebgpu: true\n\t\t\t};\n\n\n\t\t\tinit( ! api.webgpu );\n\n\t\t\tfunction init( forceWebGL = false ) {\n\n\t\t\t\tif ( renderer ) {\n\n\t\t\t\t\trenderer.dispose();\n\t\t\t\t\tcontrols.dispose();\n\t\t\t\t\tdocument.body.removeChild( renderer.domElement );\n\n\t\t\t\t}\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGPURenderer( {\n\t\t\t\t\tforceWebGL,\n\t\t\t\t\tantialias: true,\n\t\t\t\t} );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x000000 );\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 10 );\n\n\t\t\t\t// controls\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t// materials\n\t\t\t\tmaterials = [\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xff1493, side: THREE.DoubleSide } ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide } ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide } ),\n\t\t\t\t];\n\n\t\t\t\t// plane geometry\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 1, 1, 4, 4 );\n\n\t\t\t\tplaneGeometry.clearGroups();\n\t\t\t\tconst numFacesPerRow = 4; // Number of faces in a row (since each face is made of 2 triangles)\n\n\t\t\t\tplaneGeometry.addGroup( 0, 6 * numFacesPerRow, 0 );\n\t\t\t\tplaneGeometry.addGroup( 6 * numFacesPerRow, 6 * numFacesPerRow, 1 );\n\t\t\t\tplaneGeometry.addGroup( 12 * numFacesPerRow, 6 * numFacesPerRow, 2 );\n\n\t\t\t\t// box geometry\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( .75, .75, .75 );\n\n\t\t\t\tboxGeometry.clearGroups();\n\t\t\t\tboxGeometry.addGroup( 0, 6, 0 ); // front face\n\t\t\t\tboxGeometry.addGroup( 6, 6, 0 ); // back face\n\t\t\t\tboxGeometry.addGroup( 12, 6, 2 ); // top face\n\t\t\t\tboxGeometry.addGroup( 18, 6, 2 ); // bottom face\n\t\t\t\tboxGeometry.addGroup( 24, 6, 1 ); // left face\n\t\t\t\tboxGeometry.addGroup( 30, 6, 1 ); // right face\n\n\t\t\t\tscene.background = forceWebGL ? new THREE.Color( 0x000000 ) : new THREE.Color( 0x222222 );\n\n\t\t\t\t// meshes\n\t\t\t\tplaneMesh = new THREE.Mesh( planeGeometry, materials );\n\n\t\t\t\tconst materialsWireframe = [];\n\n\t\t\t\tfor ( let index = 0; index < materials.length; index ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: materials[ index ].color, side: THREE.DoubleSide, wireframe: true } );\n\t\t\t\t\tmaterialsWireframe.push( material );\n\n\t\t\t\t}\n\n\t\t\t\tplaneMeshWireframe = new THREE.Mesh( planeGeometry, materialsWireframe );\n\t\t\t\tboxMeshWireframe = new THREE.Mesh( boxGeometry, materialsWireframe );\n\n\t\t\t\tboxMesh = new THREE.Mesh( boxGeometry, materials );\n\n\t\t\t\tplaneMesh.position.set( - 1.5, - 1, 0 );\n\t\t\t\tboxMesh.position.set( 1.5, - 0.75, 0 );\n\t\t\t\tboxMesh.rotation.set( - Math.PI / 8, Math.PI / 4, Math.PI / 4 );\n\n\t\t\t\tplaneMeshWireframe.position.set( - 1.5, 1, 0 );\n\t\t\t\tboxMeshWireframe.position.set( 1.5, 1.25, 0 );\n\t\t\t\tboxMeshWireframe.rotation.set( - Math.PI / 8, Math.PI / 4, Math.PI / 4 );\n\n\t\t\t\tscene.add( planeMesh, planeMeshWireframe );\n\t\t\t\tscene.add( boxMesh, boxMeshWireframe );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tboxMesh.rotation.y += 0.005;\n\t\t\t\tboxMesh.rotation.x += 0.005;\n\t\t\t\tboxMeshWireframe.rotation.y += 0.005;\n\t\t\t\tboxMeshWireframe.rotation.x += 0.005;\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\n\t\t\t// gui\n\n\t\t\tconst gui = new GUI();\n\n\t\t\tgui.add( api, 'webgpu' ).onChange( () => {\n\n\t\t\t\tinit( ! api.webgpu );\n\n\t\t\t} );\n\n\t\t\t// listeners\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n```\n\nThis example three.js - WebGPU Materials Arrays and Geometry Groups"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - material - basic"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - material - basic:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst spheres = [];\n\n\t\t\tlet mouseX = 0;\n\t\t\tlet mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tconst params = {\n\t\t\t\tcolor: '#ffffff',\n\t\t\t\tmapping: THREE.CubeReflectionMapping,\n\t\t\t\trefractionRatio: 0.98,\n\t\t\t\ttransparent: false,\n\t\t\t\topacity: 1\n\t\t\t};\n\n\t\t\tconst mappings = { ReflectionMapping: THREE.CubeReflectionMapping, RefractionMapping: THREE.CubeRefractionMapping };\n\n\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tconst path = './textures/cube/pisa/';\n\t\t\t\tconst format = '.png';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.1, 32, 16 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = Math.random() * 10 - 5;\n\t\t\t\t\tmesh.position.y = Math.random() * 10 - 5;\n\t\t\t\t\tmesh.position.z = Math.random() * 10 - 5;\n\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tspheres.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\n\t\t\t\tgui.addColor( params, 'color' ).onChange( ( value ) => material.color.set( value ) );\n\t\t\t\tgui.add( params, 'mapping', mappings ).onChange( ( value ) => {\n\n\t\t\t\t\ttextureCube.mapping = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'refractionRatio' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( ( value ) => material.refractionRatio = value );\n\t\t\t\tgui.add( params, 'transparent' ).onChange( ( value ) => {\n\t\t\t\n\t\t\t\t\tmaterial.transparent = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'opacity' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( ( value ) => material.opacity = value );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX ) / 100;\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) / 100;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = 0.0001 * Date.now();\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * .05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0, il = spheres.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst sphere = spheres[ i ];\n\n\t\t\t\t\tsphere.position.x = 5 * Math.cos( timer + i );\n\t\t\t\t\tsphere.position.y = 5 * Math.sin( timer + i * 1.1 );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - displacement map"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - displacement map:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\n\t\t\tlet stats;\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tconst settings = {\n\t\t\t\tmetalness: 1.0,\n\t\t\t\troughness: 0.4,\n\t\t\t\tambientIntensity: 0.2,\n\t\t\t\taoMapIntensity: 1.0,\n\t\t\t\tenvMapIntensity: 1.0,\n\t\t\t\tdisplacementScale: 2.436143, // from original model\n\t\t\t\tnormalScale: 1.0\n\t\t\t};\n\n\t\t\tlet mesh, material;\n\n\t\t\tlet pointLight, ambientLight;\n\n\t\t\tconst height = 500; // of camera frustum\n\n\t\t\tlet r = 0.0;\n\n\t\t\tinit();\n\t\t\tinitGui();\n\n\t\t\t// Init gui\n\t\t\tfunction initGui() {\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( settings, 'metalness' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.metalness = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'roughness' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.roughness = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'aoMapIntensity' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.aoMapIntensity = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'ambientIntensity' ).min( 0 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tambientLight.intensity = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'envMapIntensity' ).min( 0 ).max( 3 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.envMapIntensity = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'displacementScale' ).min( 0 ).max( 3.0 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.displacementScale = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( settings, 'normalScale' ).min( - 1 ).max( 1 ).onChange( function ( value ) {\n\n\t\t\t\t\tmaterial.normalScale.set( 1, - 1 ).multiplyScalar( value );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( - height * aspect, height * aspect, height, - height, 1, 10000 );\n\t\t\t\tcamera.position.z = 1500;\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t// lights\n\n\t\t\t\tambientLight = new THREE.AmbientLight( 0xffffff, settings.ambientIntensity );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tpointLight = new THREE.PointLight( 0xff0000, 1.5, 0, 0 );\n\t\t\t\tpointLight.position.z = 2500;\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tconst pointLight2 = new THREE.PointLight( 0xff6666, 3, 0, 0 );\n\t\t\t\tcamera.add( pointLight2 );\n\n\t\t\t\tconst pointLight3 = new THREE.PointLight( 0x0000ff, 1.5, 0, 0 );\n\t\t\t\tpointLight3.position.x = - 1000;\n\t\t\t\tpointLight3.position.z = 1000;\n\t\t\t\tscene.add( pointLight3 );\n\n\t\t\t\t// env map\n\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst reflectionCube = new THREE.CubeTextureLoader().load( urls );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst normalMap = textureLoader.load( 'models/obj/ninja/normal.png' );\n\t\t\t\tconst aoMap = textureLoader.load( 'models/obj/ninja/ao.jpg' );\n\t\t\t\tconst displacementMap = textureLoader.load( 'models/obj/ninja/displacement.jpg' );\n\n\t\t\t\t// material\n\n\t\t\t\tmaterial = new THREE.MeshStandardNodeMaterial( {\n\n\t\t\t\t\tcolor: 0xc1c1c1,\n\t\t\t\t\troughness: settings.roughness,\n\t\t\t\t\tmetalness: settings.metalness,\n\n\t\t\t\t\tnormalMap: normalMap,\n\t\t\t\t\tnormalScale: new THREE.Vector2( 1, - 1 ), // why does the normal map require negation in this case?\n\n\t\t\t\t\taoMap: aoMap,\n\t\t\t\t\taoMapIntensity: 1,\n\n\t\t\t\t\tdisplacementMap: displacementMap,\n\t\t\t\t\tdisplacementScale: settings.displacementScale,\n\t\t\t\t\tdisplacementBias: - 0.428408, // from original model\n\n\t\t\t\t\tenvMap: reflectionCube,\n\t\t\t\t\tenvMapIntensity: settings.envMapIntensity,\n\n\t\t\t\t\tside: THREE.DoubleSide\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/ninja/ninjaHead_Low.obj', function ( group ) {\n\n\t\t\t\t\tconst geometry = group.children[ 0 ].geometry;\n\t\t\t\t\tgeometry.center();\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.scale.multiplyScalar( 25 );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.left = - height * aspect;\n\t\t\t\tcamera.right = height * aspect;\n\t\t\t\tcamera.top = height;\n\t\t\t\tcamera.bottom = - height;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats.begin();\n\t\t\t\trender();\n\t\t\t\tstats.end();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tpointLight.position.x = 2500 * Math.cos( r );\n\t\t\t\tpointLight.position.z = 2500 * Math.sin( r );\n\n\t\t\t\tr += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - ( normal + ao + displacement + environment ) maps ninja head from AMD GPU MeshMapper"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materials - bpcem"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materials - bpcem:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { bumpMap, float, getParallaxCorrectNormal, pmremTexture, reflectVector, texture, uniform, vec3 } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';\n\t\t\timport { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet controls, cubeCamera;\n\n\t\t\tlet groundPlane, wallMat;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tTHREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );\n\n\t\t\t\t// scene\n\t\t\t\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\t\tcamera.position.set( 0, 200, - 200 );\n\n\t\t\t\t// cube camera for environment map\n\n\t\t\t\tconst renderTarget = new THREE.WebGLCubeRenderTarget( 512 );\n\t\t\t\trenderTarget.texture.type = THREE.HalfFloatType;\n\t\t\t\trenderTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\t\trenderTarget.texture.magFilter = THREE.LinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\t\t\t\trenderTarget.texture.mapping = THREE.CubeReflectionMapping;\n\n\t\t\t\tcubeCamera = new THREE.CubeCamera( 1, 1000, renderTarget );\n\t\t\t\tcubeCamera.position.set( 0, - 100, 0 );\n\n\t\t\t\t// ground floor ( with box projected environment mapping )\n\t\t\t\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst rMap = loader.load( 'textures/lava/lavatile.jpg' );\n\t\t\t\trMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\trMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\trMap.repeat.set( 2, 1 );\n\n\t\t\t\tconst roughnessUniform = uniform( 0.25 );\n\n\t\t\t\tconst defaultMat = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tdefaultMat.envNode = pmremTexture( renderTarget.texture );\n\t\t\t\tdefaultMat.roughnessNode = texture( rMap ).mul( roughnessUniform );\n\t\t\t\tdefaultMat.metalnessNode = float( 1 );\n\n\t\t\t\tconst boxProjectedMat = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tboxProjectedMat.envNode = pmremTexture( renderTarget.texture, getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) ) );\n\t\t\t\tboxProjectedMat.roughnessNode = texture( rMap ).mul( roughnessUniform );\n\t\t\t\tboxProjectedMat.metalnessNode = float( 1 );\n\n\t\t\t\tgroundPlane = new THREE.Mesh( new THREE.PlaneGeometry( 200, 100, 100 ), boxProjectedMat );\n\t\t\t\tgroundPlane.rotateX( - Math.PI / 2 );\n\t\t\t\tgroundPlane.position.set( 0, - 49, 0 );\n\t\t\t\tscene.add( groundPlane );\n\n\t\t\t\t// walls\n\t\t\t\n\t\t\t\tconst diffuseTex = loader.load( 'textures/brick_diffuse.jpg' );\n\t\t\t\tdiffuseTex.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst bumpTex = loader.load( 'textures/brick_bump.jpg' );\n\n\t\t\t\twallMat = new THREE.MeshStandardNodeMaterial();\n\n\t\t\t\twallMat.colorNode = texture( diffuseTex );\n\t\t\t\twallMat.normalNode = bumpMap( texture( bumpTex ), float( 5 ) );\n\n\t\t\t\tconst planeGeo = new THREE.PlaneGeometry( 100, 100 );\n\n\t\t\t\tconst planeBack1 = new THREE.Mesh( planeGeo, wallMat );\n\t\t\t\tplaneBack1.position.z = - 50;\n\t\t\t\tplaneBack1.position.x = - 50;\n\t\t\t\tscene.add( planeBack1 );\n\n\t\t\t\tconst planeBack2 = new THREE.Mesh( planeGeo, wallMat );\n\t\t\t\tplaneBack2.position.z = - 50;\n\t\t\t\tplaneBack2.position.x = 50;\n\t\t\t\tscene.add( planeBack2 );\n\n\t\t\t\tconst planeFront1 = new THREE.Mesh( planeGeo, wallMat );\n\t\t\t\tplaneFront1.position.z = 50;\n\t\t\t\tplaneFront1.position.x = - 50;\n\t\t\t\tplaneFront1.rotateY( Math.PI );\n\t\t\t\tscene.add( planeFront1 );\n\n\t\t\t\tconst planeFront2 = new THREE.Mesh( planeGeo, wallMat );\n\t\t\t\tplaneFront2.position.z = 50;\n\t\t\t\tplaneFront2.position.x = 50;\n\t\t\t\tplaneFront2.rotateY( Math.PI );\n\t\t\t\tscene.add( planeFront2 );\n\n\t\t\t\tconst planeRight = new THREE.Mesh( planeGeo, wallMat );\n\t\t\t\tplaneRight.position.x = 100;\n\t\t\t\tplaneRight.rotateY( - Math.PI / 2 );\n\t\t\t\tscene.add( planeRight );\n\n\t\t\t\tconst planeLeft = new THREE.Mesh( planeGeo, wallMat );\n\t\t\t\tplaneLeft.position.x = - 100;\n\t\t\t\tplaneLeft.rotateY( Math.PI / 2 );\n\t\t\t\tscene.add( planeLeft );\n\n\t\t\t\t// area lights\n\n\t\t\t\tconst width = 50;\n\t\t\t\tconst height = 50;\n\t\t\t\tconst intensity = 5;\n\t\t\t\n\t\t\t\tconst blueRectLight = new THREE.RectAreaLight( 0x9aaeff, intensity, width, height );\n\t\t\t\tblueRectLight.position.set( - 99, 5, 0 );\n\t\t\t\tblueRectLight.lookAt( 0, 5, 0 );\n\t\t\t\tscene.add( blueRectLight );\n\n\t\t\t\tconst blueRectLightHelper = new RectAreaLightHelper( blueRectLight, 0xffffff );\n\t\t\t\tblueRectLight.add( blueRectLightHelper );\n\n\t\t\t\tconst redRectLight = new THREE.RectAreaLight( 0xf3aaaa, intensity, width, height );\n\t\t\t\tredRectLight.position.set( 99, 5, 0 );\n\t\t\t\tredRectLight.lookAt( 0, 5, 0 );\n\t\t\t\tscene.add( redRectLight );\n\n\t\t\t\tconst redRectLightHelper = new RectAreaLightHelper( redRectLight, 0xffffff );\n\t\t\t\tredRectLight.add( redRectLightHelper );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, - 10, 0 );\n\t\t\t\tcontrols.maxDistance = 400;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tconst params = {\n\t\t\t\t\t'box projected': true\n\t\t\t\t};\n\t\t\t\tgui.add( params, 'box projected' ).onChange( ( value ) => {\n\n\t\t\t\t\tgroundPlane.material = ( value ) ? boxProjectedMat : defaultMat;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( roughnessUniform, 'value', 0, 1 ).name( 'roughness' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction updateCubeMap() {\n\n\t\t\t\tgroundPlane.visible = false;\n\n\t\t\t\tcubeCamera.position.copy( groundPlane.position );\n\n\t\t\t\tcubeCamera.update( renderer, scene );\n\n\t\t\t\tgroundPlane.visible = true;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tupdateCubeMap();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgpu - box projected cube environment mapping (BPCEM)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materials - environment maps"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materials - environment maps:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet controls, camera, scene, renderer;\n\t\t\tlet textureEquirec, textureCube;\n\t\t\tlet sphereMesh, sphereMaterial, params;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// CAMERAS\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 2.5 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Textures\n\n\t\t\t\tconst loader = new THREE.CubeTextureLoader();\n\t\t\t\tloader.setPath( 'textures/cube/Bridge2/' );\n\n\t\t\t\ttextureCube = loader.load( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\ttextureEquirec = textureLoader.load( 'textures/2294472375_24a3b8ef46_o.jpg' );\n\t\t\t\ttextureEquirec.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\ttextureEquirec.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 15 );\n\t\t\t\tsphereMaterial = new THREE.MeshBasicMaterial( { envMap: textureCube } );\n\t\t\t\tsphereMesh = new THREE.Mesh( geometry, sphereMaterial );\n\t\t\t\tscene.add( sphereMesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1.5;\n\t\t\t\tcontrols.maxDistance = 6;\n\n\t\t\t\t//\n\n\t\t\t\tparams = {\n\t\t\t\t\tCube: function () {\n\n\t\t\t\t\t\tscene.background = textureCube;\n\n\t\t\t\t\t\tsphereMaterial.envMap = textureCube;\n\t\t\t\t\t\tsphereMaterial.needsUpdate = true;\n\n\t\t\t\t\t},\n\t\t\t\t\tEquirectangular: function () {\n\n\t\t\t\t\t\tscene.background = textureEquirec;\n\n\t\t\t\t\t\tsphereMaterial.envMap = textureEquirec;\n\t\t\t\t\t\tsphereMaterial.needsUpdate = true;\n\n\t\t\t\t\t},\n\t\t\t\t\tRefraction: false,\n\t\t\t\t\tbackgroundRotationX: false,\n\t\t\t\t\tbackgroundRotationY: false,\n\t\t\t\t\tbackgroundRotationZ: false,\n\t\t\t\t\tsyncMaterial: false\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\t\t\t\tgui.add( params, 'Cube' );\n\t\t\t\tgui.add( params, 'Equirectangular' );\n\t\t\t\tgui.add( params, 'Refraction' ).onChange( function ( value ) {\n\n\t\t\t\t\tif ( value ) {\n\n\t\t\t\t\t\ttextureEquirec.mapping = THREE.EquirectangularRefractionMapping;\n\t\t\t\t\t\ttextureCube.mapping = THREE.CubeRefractionMapping;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureEquirec.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\ttextureCube.mapping = THREE.CubeReflectionMapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsphereMaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'backgroundRotationX' );\n\t\t\t\tgui.add( params, 'backgroundRotationY' );\n\t\t\t\tgui.add( params, 'backgroundRotationZ' );\n\t\t\t\tgui.add( params, 'syncMaterial' );\n\t\t\t\tgui.open();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( params.backgroundRotationX ) {\n\n\t\t\t\t\tscene.backgroundRotation.x += 0.001;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.backgroundRotationY ) {\n\n\t\t\t\t\tscene.backgroundRotation.y += 0.001;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.backgroundRotationZ ) {\n\n\t\t\t\t\tscene.backgroundRotation.z += 0.001;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.syncMaterial ) {\n\n\t\t\t\t\tsphereMesh.material.envMapRotation.copy( scene.backgroundRotation );\n\n\t\t\t\t}\n\n\t\t\t\tcamera.lookAt( scene.position );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgpu environment mapping example Equirectangular Map by J\u00f3n Ragnarsson ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - lightmap"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - lightmap:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { vec4, color, positionLocal, mix } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst params = {\n\t\t\t\tintensity: 1\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, innerWidth / innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 700, 200, - 500 );\n\n\t\t\t\t// SCENE\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xd5deff );\n\t\t\t\tlight.position.x = 300;\n\t\t\t\tlight.position.y = 250;\n\t\t\t\tlight.position.z = - 500;\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// SKYDOME\n\n\t\t\t\tconst topColor = new THREE.Color().copy( light.color );\n\t\t\t\tconst bottomColor = new THREE.Color( 0xffffff );\n\t\t\t\tconst offset = 400;\n\t\t\t\tconst exponent = 0.6;\n\n\t\t\t\tconst h = positionLocal.add( offset ).normalize().y;\n\n\t\t\t\tconst skyMat = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tskyMat.colorNode = vec4( mix( color( bottomColor ), color( topColor ), h.max( 0.0 ).pow( exponent ) ), 1.0 );\n\t\t\t\tskyMat.side = THREE.BackSide;\n\n\t\t\t\tconst sky = new THREE.Mesh( new THREE.SphereGeometry( 4000, 32, 15 ), skyMat );\n\t\t\t\tscene.add( sky );\n\n\t\t\t\t// MODEL\n\n\t\t\t\tconst loader = new THREE.ObjectLoader();\n\t\t\t\tconst object = await loader.loadAsync( 'models/json/lightmap/lightmap.json' );\n\t\t\t\tscene.add( object );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( innerWidth, innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// CONTROLS\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = 0.9 * Math.PI / 2;\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'intensity', 0, 1 ).name( 'Light Map Intensity' ).onChange( ( value ) => {\n\n\t\t\t\t\tfor ( const material of object.material ) {\n\n\t\t\t\t\t\tmaterial.lightMapIntensity = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - matcap material"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - matcap material:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n\n\t\t\tlet mesh, renderer, scene, camera;\n\n\t\t\tconst API = {\n\t\t\t\tcolor: 0xffffff, // sRGB\n\t\t\t\texposure: 1.0\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// tone mapping\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t \trenderer.toneMappingExposure = API.exposure;\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 13 );\n\n\t\t\t\t// controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\t// manager\n\t\t\t\tconst manager = new THREE.LoadingManager( render );\n\n\t\t\t\t// matcap\n\t\t\t\tconst loaderEXR = new EXRLoader( manager );\n\t\t\t\tconst matcap = loaderEXR.load( 'textures/matcaps/040full.exr' );\n\n\t\t\t\t// normalmap\n\t\t\t\tconst loader = new THREE.TextureLoader( manager );\n\n\t\t\t\tconst normalmap = loader.load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' );\n\n\t\t\t\t// model\n\t\t\t\tnew GLTFLoader( manager ).load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {\n\n\t\t\t\t\tmesh = gltf.scene.children[ 0 ];\n\t\t\t\t\tmesh.position.y = - 0.25;\n\n\t\t\t\t\tmesh.material = new THREE.MeshMatcapNodeMaterial( {\n\n\t\t\t\t\t\tcolor: new THREE.Color().setHex( API.color ),\n\t\t\t\t\t\tmatcap: matcap,\n\t\t\t\t\t\tnormalMap: normalmap\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// gui\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( API, 'color' )\n\t\t\t\t\t.listen()\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmesh.material.color.set( API.color );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( API, 'exposure', 0, 2 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = API.exposure;\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.domElement.style.webkitUserSelect = 'none';\n\n\t\t\t\t// drag 'n drop\n\t\t\t\tinitDragAndDrop();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.renderAsync( scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\t\t\t// drag and drop anywhere in document\n\t\t\t//\n\n\t\t\tfunction updateMatcap( texture ) {\n\n\t\t\t\tif ( mesh.material.matcap ) {\n\n\t\t\t\t\tmesh.material.matcap.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tmesh.material.matcap = texture;\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tmesh.material.needsUpdate = true; // because the color space can change\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction handleJPG( event ) { // PNG, WebP, AVIF, too\n\n\t\t\t\tfunction imgCallback( event ) {\n\n\t\t\t\t\tconst texture = new THREE.Texture( event.target );\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t\tupdateMatcap( texture );\n\n\t\t\t\t}\n\n\t\t\t\tconst img = new Image();\n\n\t\t\t\timg.onload = imgCallback;\n\n\t\t\t\timg.src = event.target.result;\n\n\t\t\t}\n\n\t\t\tfunction handleEXR( event ) {\n\n\t\t\t\tconst contents = event.target.result;\n\n\t\t\t\tconst loader = new EXRLoader();\n\n\t\t\t\tloader.setDataType( THREE.HalfFloatType );\n\n\t\t\t\tconst texData = loader.parse( contents );\n\n\t\t\t\tconst texture = new THREE.DataTexture();\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\ttexture.format = texData.format;\n\t\t\t\ttexture.type = texData.type;\n\t\t\t\ttexture.colorSpace = THREE.LinearSRGBColorSpace;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttexture.flipY = false;\n\n\t\t\t\tupdateMatcap( texture );\n\n\t\t\t}\n\n\t\t\tfunction loadFile( file ) {\n\n\t\t\t\tconst filename = file.name;\n\t\t\t\tconst extension = filename.split( '.' ).pop().toLowerCase();\n\n\t\t\t\tif ( extension === 'exr' ) {\n\n\t\t\t\t\tconst reader = new FileReader();\n\n\t\t\t\t\treader.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\t\thandleEXR( event );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treader.readAsArrayBuffer( file );\n\n\t\t\t\t} else { // 'jpg', 'png'\n\n\t\t\t\t\tconst reader = new FileReader();\n\n\t\t\t\t\treader.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\t\thandleJPG( event );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treader.readAsDataURL( file );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction initDragAndDrop() {\n\n\t\t\t\tdocument.addEventListener( 'dragover', function ( event ) {\n\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.dataTransfer.dropEffect = 'copy';\n\n\t\t\t\t} );\n\n\t\t\t\tdocument.addEventListener( 'drop', function ( event ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\tloadFile( event.dataTransfer.files[ 0 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - matcap material Drag-and-drop JPG, PNG, WebP, AVIF, or EXR MatCap image files"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - sss"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - sss:\n\n```javascript\nimport * as THREE from 'three/webgpu';\n\t\t\timport { texture, uniform, vec3 } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { FBXLoader } from 'three/addons/loaders/FBXLoader.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet model;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.set( 0.0, 300, 400 * 4 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xc1c1c1 ) );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 0.03 );\n\t\t\t\tdirectionalLight.position.set( 0.0, 0.5, 0.5 ).normalize();\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tconst pointLight1 = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xc1c1c1 } ) );\n\t\t\t\tpointLight1.add( new THREE.PointLight( 0xc1c1c1, 4.0, 300, 0 ) );\n\t\t\t\tscene.add( pointLight1 );\n\t\t\t\tpointLight1.position.x = 0;\n\t\t\t\tpointLight1.position.y = - 50;\n\t\t\t\tpointLight1.position.z = 350;\n\n\t\t\t\tconst pointLight2 = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xc1c100 } ) );\n\t\t\t\tpointLight2.add( new THREE.PointLight( 0xc1c100, 0.75, 500, 0 ) );\n\t\t\t\tscene.add( pointLight2 );\n\t\t\t\tpointLight2.position.x = - 100;\n\t\t\t\tpointLight2.position.y = 20;\n\t\t\t\tpointLight2.position.z = - 260;\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tconst controls = new OrbitControls( camera, container );\n\t\t\t\tcontrols.minDistance = 500;\n\t\t\t\tcontrols.maxDistance = 3000;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tinitMaterial();\n\n\t\t\t}\n\n\t\t\tfunction initMaterial() {\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst imgTexture = loader.load( 'models/fbx/white.jpg' );\n\t\t\t\timgTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst thicknessTexture = loader.load( 'models/fbx/bunny_thickness.jpg' );\n\t\t\t\timgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst material = new THREE.MeshSSSNodeMaterial();\n\t\t\t\tmaterial.color = new THREE.Color( 1.0, 0.2, 0.2 );\n\t\t\t\tmaterial.roughness = 0.3;\n\t\t\t\tmaterial.thicknessColorNode = texture( thicknessTexture ).mul( vec3( 0.5, 0.3, 0.0 ) );\n\t\t\t\tmaterial.thicknessDistortionNode = uniform( 0.1 );\n\t\t\t\tmaterial.thicknessAmbientNode = uniform( 0.4 );\n\t\t\t\tmaterial.thicknessAttenuationNode = uniform( 0.8 );\n\t\t\t\tmaterial.thicknessPowerNode = uniform( 2.0 );\n\t\t\t\tmaterial.thicknessScaleNode = uniform( 16.0 );\n\n\t\t\t\t// LOADER\n\n\t\t\t\tconst loaderFBX = new FBXLoader();\n\t\t\t\tloaderFBX.load( 'models/fbx/stanford-bunny.fbx', function ( object ) {\n\n\t\t\t\t\tmodel = object.children[ 0 ];\n\t\t\t\t\tmodel.position.set( 0, 0, 10 );\n\t\t\t\t\tmodel.scale.setScalar( 1 );\n\t\t\t\t\tmodel.material = material;\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\tinitGUI( material );\n\n\t\t\t}\n\n\t\t\tfunction initGUI( material ) {\n\n\t\t\t\tconst gui = new GUI( { title: 'Thickness Control' } );\n\n\t\t\t\tconst ThicknessControls = function () {\n\n\t\t\t\t\tthis.distortion = material.thicknessDistortionNode.value;\n\t\t\t\t\tthis.ambient = material.thicknessAmbientNode.value;\n\t\t\t\t\tthis.attenuation = material.thicknessAttenuationNode.value;\n\t\t\t\t\tthis.power = material.thicknessPowerNode.value;\n\t\t\t\t\tthis.scale = material.thicknessScaleNode.value;\n\n\t\t\t\t};\n\n\t\t\t\tconst thicknessControls = new ThicknessControls();\n\n\t\t\t\tgui.add( thicknessControls, 'distortion' ).min( 0.01 ).max( 1 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\t\tmaterial.thicknessDistortionNode.value = thicknessControls.distortion;\n\t\t\t\t\tconsole.log( 'distortion' );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( thicknessControls, 'ambient' ).min( 0.01 ).max( 5.0 ).step( 0.05 ).onChange( function () {\n\n\t\t\t\t\tmaterial.thicknessAmbientNode.value = thicknessControls.ambient;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( thicknessControls, 'attenuation' ).min( 0.01 ).max( 5.0 ).step( 0.05 ).onChange( function () {\n\n\t\t\t\t\tmaterial.thicknessAttenuationNode.value = thicknessControls.attenuation;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( thicknessControls, 'power' ).min( 0.01 ).max( 16.0 ).step( 0.1 ).onChange( function () {\n\n\t\t\t\t\tmaterial.thicknessPowerNode.value = thicknessControls.power;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( thicknessControls, 'scale' ).min( 0.01 ).max( 50.0 ).step( 0.1 ).onChange( function () {\n\n\t\t\t\t\tmaterial.thicknessScaleNode.value = thicknessControls.scale;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( model ) model.rotation.y = performance.now() / 5000;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - sss Fast subsurface scattering [Thanks for the art support from Shaochun Lin ]"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates threejs webgpu - transmission"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for threejs webgpu - transmission:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tconst params = {\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\ttransmission: 1,\n\t\t\t\topacity: 1,\n\t\t\t\tmetalness: 0,\n\t\t\t\troughness: 0,\n\t\t\t\tior: 1.5,\n\t\t\t\tthickness: 0.01,\n\t\t\t\tspecularIntensity: 1,\n\t\t\t\tspecularColor: 0xffffff,\n\t\t\t\tenvMapIntensity: 1,\n\t\t\t\tlightIntensity: 1,\n\t\t\t\texposure: 1\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mesh;\n\n\t\t\tconst hdrEquirect = new RGBELoader()\n\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t.load( 'royal_esplanade_1k.hdr', function () {\n\n\t\t\t\t\thdrEquirect.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\tinit();\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 0, 0, 120 );\n\n\t\t\t\t//\n\n\t\t\t\tscene.background = hdrEquirect;\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 20, 64, 32 );\n\n\t\t\t\tconst texture = new THREE.CanvasTexture( generateTexture() );\n\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.repeat.set( 1, 3.5 );\n\n\t\t\t\tconst material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\tcolor: params.color,\n\t\t\t\t\tmetalness: params.metalness,\n\t\t\t\t\troughness: params.roughness,\n\t\t\t\t\tior: params.ior,\n\t\t\t\t\talphaMap: texture,\n\t\t\t\t\tenvMap: hdrEquirect,\n\t\t\t\t\tenvMapIntensity: params.envMapIntensity,\n\t\t\t\t\ttransmission: params.transmission, // use material.transmission for glass materials\n\t\t\t\t\tspecularIntensity: params.specularIntensity,\n\t\t\t\t\tspecularColor: params.specularColor,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.maxDistance = 150;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( params, 'color' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.color.set( params.color );\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'transmission', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.transmission = params.transmission;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'opacity', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.opacity = params.opacity;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'metalness', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.metalness = params.metalness;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'roughness', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.roughness = params.roughness;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'ior', 1, 2, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.ior = params.ior;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'thickness', 0, 5, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.thickness = params.thickness;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'specularIntensity', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.specularIntensity = params.specularIntensity;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.addColor( params, 'specularColor' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.specularColor.set( params.specularColor );\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'envMapIntensity', 0, 1, 0.01 )\n\t\t\t\t\t.name( 'envMap intensity' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tmaterial.envMapIntensity = params.envMapIntensity;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'exposure', 0, 1, 0.01 )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction generateTexture() {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 2;\n\t\t\t\tcanvas.height = 2;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 1, 2, 1 );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example threejs webgpu - transmission"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - toon material"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - toon material:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { toonOutlinePass } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer, postProcessing;\n\t\t\tlet particleLight;\n\n\t\t\tconst loader = new FontLoader();\n\t\t\tloader.load( 'fonts/gentilis_regular.typeface.json', function ( font ) {\n\n\t\t\t\tinit( font );\n\n\t\t\t} );\n\n\t\t\tfunction init( font ) {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2500 );\n\t\t\t\tcamera.position.set( 0.0, 400, 400 * 3.5 );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x444488 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tpostProcessing.outputNode = toonOutlinePass( scene, camera );\n\n\n\t\t\t\t// Materials\n\n\t\t\t\tconst cubeWidth = 400;\n\t\t\t\tconst numberOfSpheresPerSide = 5;\n\t\t\t\tconst sphereRadius = ( cubeWidth / numberOfSpheresPerSide ) * 0.8 * 0.5;\n\t\t\t\tconst stepSize = 1.0 / numberOfSpheresPerSide;\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( sphereRadius, 32, 16 );\n\n\t\t\t\tfor ( let alpha = 0, alphaIndex = 0; alpha <= 1.0; alpha += stepSize, alphaIndex ++ ) {\n\n\t\t\t\t\tconst colors = new Uint8Array( alphaIndex + 2 );\n\n\t\t\t\t\tfor ( let c = 0; c <= colors.length; c ++ ) {\n\n\t\t\t\t\t\tcolors[ c ] = ( c / colors.length ) * 256;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst gradientMap = new THREE.DataTexture( colors, colors.length, 1, THREE.RedFormat );\n\t\t\t\t\tgradientMap.needsUpdate = true;\n\n\t\t\t\t\tfor ( let beta = 0; beta <= 1.0; beta += stepSize ) {\n\n\t\t\t\t\t\tfor ( let gamma = 0; gamma <= 1.0; gamma += stepSize ) {\n\n\t\t\t\t\t\t\t// basic monochromatic energy preservation\n\t\t\t\t\t\t\tconst diffuseColor = new THREE.Color().setHSL( alpha, 0.5, gamma * 0.5 + 0.1 ).multiplyScalar( 1 - beta * 0.2 );\n\n\t\t\t\t\t\t\tconst material = new THREE.MeshToonNodeMaterial( {\n\t\t\t\t\t\t\t\tcolor: diffuseColor,\n\t\t\t\t\t\t\t\tgradientMap: gradientMap\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t\tmesh.position.x = alpha * 400 - 200;\n\t\t\t\t\t\t\tmesh.position.y = beta * 400 - 200;\n\t\t\t\t\t\t\tmesh.position.z = gamma * 400 - 200;\n\n\t\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction addLabel( name, location ) {\n\n\t\t\t\t\tconst textGeo = new TextGeometry( name, {\n\n\t\t\t\t\t\tfont: font,\n\n\t\t\t\t\t\tsize: 20,\n\t\t\t\t\t\tdepth: 1,\n\t\t\t\t\t\tcurveSegments: 1\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst textMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\t\tconst textMesh = new THREE.Mesh( textGeo, textMaterial );\n\t\t\t\t\ttextMesh.position.copy( location );\n\t\t\t\t\tscene.add( textMesh );\n\n\t\t\t\t}\n\n\t\t\t\taddLabel( '-gradientMap', new THREE.Vector3( - 350, 0, 0 ) );\n\t\t\t\taddLabel( '+gradientMap', new THREE.Vector3( 350, 0, 0 ) );\n\n\t\t\t\taddLabel( '-diffuse', new THREE.Vector3( 0, 0, - 300 ) );\n\t\t\t\taddLabel( '+diffuse', new THREE.Vector3( 0, 0, 300 ) );\n\n\t\t\t\tparticleLight = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 4, 8, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicNodeMaterial( { color: 0xffffff } )\n\t\t\t\t);\n\t\t\t\tscene.add( particleLight );\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xc1c1c1, 3 ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 2, 800, 0 );\n\t\t\t\tparticleLight.add( pointLight );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 200;\n\t\t\t\tcontrols.maxDistance = 2000;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.00025;\n\n\t\t\t\tparticleLight.position.x = Math.sin( timer * 7 ) * 300;\n\t\t\t\tparticleLight.position.y = Math.cos( timer * 5 ) * 400;\n\t\t\t\tparticleLight.position.z = Math.cos( timer * 3 ) * 300;\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - toon material"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - video material"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - video material:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet container;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet video, texture, material, mesh;\n\n\t\t\tlet mouseX = 0;\n\t\t\tlet mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet cube_count;\n\n\t\t\tconst meshes = [],\n\t\t\t\tmaterials = [],\n\n\t\t\t\txgrid = 20,\n\t\t\t\tygrid = 10;\n\n\t\t\tconst startButton = document.getElementById( 'startButton' );\n\t\t\tstartButton.addEventListener( 'click', function () {\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\t\toverlay.remove();\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 7 );\n\t\t\t\tlight.position.set( 0.5, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tvideo = document.getElementById( 'video' );\n\t\t\t\tvideo.play();\n\t\t\t\tvideo.addEventListener( 'play', function () {\n\n\t\t\t\t\tthis.currentTime = 3;\n\n\t\t\t\t} );\n\n\t\t\t\ttexture = new THREE.VideoTexture( video );\n\n\t\t\t\t//\n\n\t\t\t\tlet i, j, ox, oy, geometry;\n\n\t\t\t\tconst ux = 1 / xgrid;\n\t\t\t\tconst uy = 1 / ygrid;\n\n\t\t\t\tconst xsize = 480 / xgrid;\n\t\t\t\tconst ysize = 204 / ygrid;\n\n\t\t\t\tconst parameters = { color: 0xffffff, map: texture };\n\n\t\t\t\tcube_count = 0;\n\n\t\t\t\tfor ( i = 0; i < xgrid; i ++ ) {\n\n\t\t\t\t\tfor ( j = 0; j < ygrid; j ++ ) {\n\n\t\t\t\t\t\tox = i;\n\t\t\t\t\t\toy = j;\n\n\t\t\t\t\t\tgeometry = new THREE.BoxGeometry( xsize, ysize, xsize );\n\n\t\t\t\t\t\tchange_uvs( geometry, ux, uy, ox, oy );\n\n\t\t\t\t\t\tmaterials[ cube_count ] = new THREE.MeshPhongMaterial( parameters );\n\n\t\t\t\t\t\tmaterial = materials[ cube_count ];\n\n\t\t\t\t\t\tmaterial.hue = i / xgrid;\n\t\t\t\t\t\tmaterial.saturation = 1 - j / ygrid;\n\n\t\t\t\t\t\tmaterial.color.setHSL( material.hue, material.saturation, 0.5 );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tmesh.position.x = ( i - xgrid / 2 ) * xsize;\n\t\t\t\t\t\tmesh.position.y = ( j - ygrid / 2 ) * ysize;\n\t\t\t\t\t\tmesh.position.z = 0;\n\n\t\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 1;\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmesh.dx = 0.001 * ( 0.5 - Math.random() );\n\t\t\t\t\t\tmesh.dy = 0.001 * ( 0.5 - Math.random() );\n\n\t\t\t\t\t\tmeshes[ cube_count ] = mesh;\n\n\t\t\t\t\t\tcube_count += 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction change_uvs( geometry, unitx, unity, offsetx, offsety ) {\n\n\t\t\t\tconst uvs = geometry.attributes.uv.array;\n\n\t\t\t\tfor ( let i = 0; i < uvs.length; i += 2 ) {\n\n\t\t\t\t\tuvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;\n\t\t\t\t\tuvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY ) * 0.3;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet h, counter = 1;\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.00005;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.05;\n\t\t\t\tcamera.position.y += ( - mouseY - camera.position.y ) * 0.05;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tfor ( let i = 0; i < cube_count; i ++ ) {\n\n\t\t\t\t\tmaterial = materials[ i ];\n\n\t\t\t\t\th = ( 360 * ( material.hue + time ) % 360 ) / 360;\n\t\t\t\t\tmaterial.color.setHSL( h, material.saturation, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( counter % 1000 > 200 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < cube_count; i ++ ) {\n\n\t\t\t\t\t\tmesh = meshes[ i ];\n\n\t\t\t\t\t\tmesh.rotation.x += 10 * mesh.dx;\n\t\t\t\t\t\tmesh.rotation.y += 10 * mesh.dy;\n\n\t\t\t\t\t\tmesh.position.x -= 150 * mesh.dx;\n\t\t\t\t\t\tmesh.position.y += 150 * mesh.dy;\n\t\t\t\t\t\tmesh.position.z += 300 * mesh.dx;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( counter % 1000 === 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < cube_count; i ++ ) {\n\n\t\t\t\t\t\tmesh = meshes[ i ];\n\n\t\t\t\t\t\tmesh.dx *= - 1;\n\t\t\t\t\t\tmesh.dy *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcounter ++;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - video material playing sintel trailer"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - materialx noise"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - materialx noise:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { normalWorld, time, mx_noise_vec3, mx_worley_noise_vec3, mx_cell_noise_float, mx_fractal_noise_vec3 } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet particleLight;\n\t\t\tlet group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 100;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tnew HDRCubeTextureLoader()\n\t\t\t\t\t.setPath( 'textures/cube/pisaHDR/' )\n\t\t\t\t\t.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],\n\t\t\t\t\t\tfunction ( hdrTexture ) {\n\n\t\t\t\t\t\t\tconst geometry = new THREE.SphereGeometry( 8, 64, 32 );\n\n\t\t\t\t\t\t\tconst customUV = normalWorld.mul( 10 ).add( time );\n\n\t\t\t\t\t\t\t// left top\n\n\t\t\t\t\t\t\tlet material = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\t\t\t\tmaterial.colorNode = mx_noise_vec3( customUV );\n\n\t\t\t\t\t\t\tlet mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = - 10;\n\t\t\t\t\t\t\tmesh.position.y = 10;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// right top\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\t\t\t\tmaterial.colorNode = mx_cell_noise_float( customUV );\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = 10;\n\t\t\t\t\t\t\tmesh.position.y = 10;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// left bottom\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\t\t\t\tmaterial.colorNode = mx_worley_noise_vec3( customUV );\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = - 10;\n\t\t\t\t\t\t\tmesh.position.y = - 10;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t// right bottom\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\t\t\t\tmaterial.colorNode = mx_fractal_noise_vec3( customUV.mul( .2 ) );\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\tmesh.position.x = 10;\n\t\t\t\t\t\t\tmesh.position.y = - 10;\n\t\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tscene.background = hdrTexture;\n\t\t\t\t\t\t\tscene.environment = hdrTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t);\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tparticleLight = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 0.4, 8, 8 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xffffff } )\n\t\t\t\t);\n\t\t\t\tscene.add( particleLight );\n\n\t\t\t\tparticleLight.add( new THREE.PointLight( 0xffffff, 1000 ) );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.25;\n\n\t\t\t\t//\n\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// EVENTS\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst timer = Date.now() * 0.00025;\n\n\t\t\t\tparticleLight.position.x = Math.sin( timer * 7 ) * 30;\n\t\t\t\tparticleLight.position.y = Math.cos( timer * 5 ) * 40;\n\t\t\t\tparticleLight.position.z = Math.cos( timer * 3 ) * 30;\n\n\t\t\t\tfor ( let i = 0; i < group.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = group.children[ i ];\n\t\t\t\t\tchild.rotation.y += 0.005;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - materialx noise"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - mesh - batch"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - mesh - batch:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { radixSort } from 'three/addons/utils/SortUtils.js';\n\n\t\timport { normalView, directionToColor, diffuseColor } from 'three/tsl';\n\n\t\tlet camera, scene, renderer;\n\t\tlet controls, stats;\n\t\tlet gui;\n\t\tlet geometries, mesh, material;\n\t\tconst ids = [];\n\n\t\tconst matrix = new THREE.Matrix4();\n\n\t\t//\n\n\t\tconst position = new THREE.Vector3();\n\t\tconst rotation = new THREE.Euler();\n\t\tconst quaternion = new THREE.Quaternion();\n\t\tconst scale = new THREE.Vector3();\n\n\t\t//\n\n\t\tconst MAX_GEOMETRY_COUNT = 20000;\n\n\t\tconst api = {\n\t\t\twebgpu: true,\n\t\t\tcount: 512,\n\t\t\tdynamic: 16,\n\n\t\t\tsortObjects: true,\n\t\t\tperObjectFrustumCulled: true,\n\t\t\topacity: 1,\n\t\t\tuseCustomSort: true,\n\t\t\trandomizeGeometry: ()=>{\n\n\t\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\t\tmesh.setGeometryIdAt( i, Math.floor( Math.random() * geometries.length ) );\n\t\t\n\t\t\t\t}\n\t\t\n\t\t\t}\n\t\t};\n\n\n\t\tinit();\n\n\t\t//\n\n\t\tfunction randomizeMatrix( matrix ) {\n\n\t\t\tposition.x = Math.random() * 40 - 20;\n\t\t\tposition.y = Math.random() * 40 - 20;\n\t\t\tposition.z = Math.random() * 40 - 20;\n\n\t\t\trotation.x = Math.random() * 2 * Math.PI;\n\t\t\trotation.y = Math.random() * 2 * Math.PI;\n\t\t\trotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\tquaternion.setFromEuler( rotation );\n\n\t\t\tscale.x = scale.y = scale.z = 0.5 + ( Math.random() * 0.5 );\n\n\t\t\treturn matrix.compose( position, quaternion, scale );\n\n\t\t}\n\n\t\tfunction randomizeRotationSpeed( rotation ) {\n\n\t\t\trotation.x = Math.random() * 0.01;\n\t\t\trotation.y = Math.random() * 0.01;\n\t\t\trotation.z = Math.random() * 0.01;\n\t\t\treturn rotation;\n\n\t\t}\n\n\t\tfunction initGeometries() {\n\n\t\t\tgeometries = [\n\t\t\t\tnew THREE.ConeGeometry( 1.0, 2.0 ),\n\t\t\t\tnew THREE.BoxGeometry( 2.0, 2.0, 2.0 ),\n\t\t\t\tnew THREE.SphereGeometry( 1.0, 16, 8 ),\n\t\t\t];\n\n\t\t}\n\n\t\tfunction createMaterial() {\n\n\t\t\tif ( ! material ) {\n\n\t\t\t\tmaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.outputNode = diffuseColor.mul( directionToColor( normalView ).y.add( 0.5 ) );\n\t\t\n\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction cleanup() {\n\n\t\t\tif ( mesh ) {\n\n\t\t\t\tmesh.parent.remove( mesh );\n\n\t\t\t\tif ( mesh.dispose ) {\n\n\t\t\t\t\tmesh.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMesh() {\n\n\t\t\tcleanup();\n\t\t\tinitBatchedMesh();\n\n\t\t}\n\n\t\tfunction initBatchedMesh() {\n\n\t\t\tconst geometryCount = api.count;\n\t\t\tconst vertexCount = geometries.length * 512;\n\t\t\tconst indexCount = geometries.length * 1024;\n\n\t\t\tconst euler = new THREE.Euler();\n\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\tmesh = new THREE.BatchedMesh( geometryCount, vertexCount, indexCount, createMaterial() );\n\t\t\tmesh.userData.rotationSpeeds = [];\n\n\t\t\t// disable full-object frustum culling since all of the objects can be dynamic.\n\t\t\tmesh.frustumCulled = false;\n\n\t\t\tids.length = 0;\n\n\t\t\tconst geometryIds = [\n\t\t\t\tmesh.addGeometry( geometries[ 0 ] ),\n\t\t\t\tmesh.addGeometry( geometries[ 1 ] ),\n\t\t\t\tmesh.addGeometry( geometries[ 2 ] ),\n\t\t\t];\n\t\t\tfor ( let i = 0; i < api.count; i ++ ) {\n\n\t\t\t\tconst id = mesh.addInstance( geometryIds[ i % geometryIds.length ] );\n\t\t\t\tmesh.setMatrixAt( id, randomizeMatrix( matrix ) );\n\t\t\t\tmesh.setColorAt( id, new THREE.Color( Math.random() * 0xffffff ) );\n\n\t\t\t\tconst rotationMatrix = new THREE.Matrix4();\n\t\t\t\trotationMatrix.makeRotationFromEuler( randomizeRotationSpeed( euler ) );\n\t\t\t\tmesh.userData.rotationSpeeds.push( rotationMatrix );\n\n\t\t\t\tids.push( id );\n\n\t\t\t}\n\n\t\t\tscene.add( mesh );\n\n\t\t}\n\n\t\tfunction init( forceWebGL = false ) {\n\n\t\t\tif ( renderer ) {\n\n\t\t\t\trenderer.dispose();\n\t\t\t\tcontrols.dispose();\n\t\t\t\tdocument.body.removeChild( stats.dom );\n\t\t\t\tdocument.body.removeChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\t// camera\n\n\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 70, aspect, 1, 100 );\n\t\t\tcamera.position.z = 30;\n\n\t\t\t// renderer\n\n\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t// scene\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = forceWebGL ? new THREE.Color( 0xffc1c1 ) : new THREE.Color( 0xc1c1ff );\n\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\n\n\t\t\tinitGeometries();\n\t\t\tinitMesh();\n\n\t\t\t// controls\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.autoRotate = true;\n\t\t\tcontrols.autoRotateSpeed = 1.0;\n\n\t\t\t// stats\n\n\t\t\tstats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t// gui\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( api, 'webgpu' ).onChange( () => {\n\n\t\t\t\tinit( ! api.webgpu );\n\n\t\t\t} );\n\t\t\tgui.add( api, 'count', 1, MAX_GEOMETRY_COUNT ).step( 1 ).onChange( initMesh );\n\t\t\tgui.add( api, 'dynamic', 0, MAX_GEOMETRY_COUNT ).step( 1 );\n\n\t\t\tgui.add( api, 'opacity', 0, 1 ).onChange( v => {\n\n\t\t\t\tif ( v < 1 ) {\n\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\tmaterial.depthWrite = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.transparent = false;\n\t\t\t\t\tmaterial.depthWrite = true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.opacity = v;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\t\t\tgui.add( api, 'sortObjects' );\n\t\t\tgui.add( api, 'perObjectFrustumCulled' );\n\t\t\tgui.add( api, 'useCustomSort' );\n\t\t\tgui.add( api, 'randomizeGeometry' );\n\n\n\t\t\t// listeners\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\n\t\t\tasync function animate() {\n\n\t\t\t\tanimateMeshes();\n\n\t\t\t\tcontrols.update();\n\n\n\t\t\t\tif ( mesh.isBatchedMesh ) {\n\n\t\t\t\t\tmesh.sortObjects = api.sortObjects;\n\t\t\t\t\tmesh.perObjectFrustumCulled = api.perObjectFrustumCulled;\n\t\t\t\t\tmesh.setCustomSort( api.useCustomSort ? sortFunction : null );\n\n\t\t\t\t}\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction animateMeshes() {\n\n\t\t\t\tconst loopNum = Math.min( api.count, api.dynamic );\n\n\n\t\t\t\tfor ( let i = 0; i < loopNum; i ++ ) {\n\n\t\t\t\t\tconst rotationMatrix = mesh.userData.rotationSpeeds[ i ];\n\t\t\t\t\tconst id = ids[ i ];\n\n\t\t\t\t\tmesh.getMatrixAt( id, matrix );\n\t\t\t\t\tmatrix.multiply( rotationMatrix );\n\t\t\t\t\tmesh.setMatrixAt( id, matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction sortFunction( list, camera ) {\n\n\t\t\t// initialize options\n\t\t\tthis._options = this._options || {\n\t\t\t\tget: el => el.z,\n\t\t\t\taux: new Array( this.maxInstanceCount )\n\t\t\t};\n\n\t\t\tconst options = this._options;\n\t\t\toptions.reversed = this.material.transparent;\n\n\t\t\t// convert depth to unsigned 32 bit range\n\t\t\tconst factor = ( 2 ** 32 - 1 ) / camera.far; // UINT32_MAX / max_depth\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tlist[ i ].z *= factor;\n\n\t\t\t}\n\n\t\t\t// perform a fast-sort using the hybrid radix sort function\n\t\t\tradixSort( list, options );\n\n\t\t}\n```\n\nThis example three.js webgpu - mesh - batch"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - mirror"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - mirror:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { reflector, uv, texture, color } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet cameraControls;\n\n\t\t\tlet sphereGroup, smallSphere;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );\n\t\t\t\tcamera.position.set( 0, 75, 160 );\n\n\t\t\t\t//\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\t//\n\n\t\t\t\tsphereGroup = new THREE.Object3D();\n\t\t\t\tscene.add( sphereGroup );\n\n\t\t\t\tgeometry = new THREE.CylinderGeometry( 0.1, 15 * Math.cos( Math.PI / 180 * 30 ), 0.1, 24, 1 );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x8d8d8d } );\n\t\t\t\tconst sphereCap = new THREE.Mesh( geometry, material );\n\t\t\t\tsphereCap.position.y = - 15 * Math.sin( Math.PI / 180 * 30 ) - 0.05;\n\t\t\t\tsphereCap.rotateX( - Math.PI );\n\n\t\t\t\tgeometry = new THREE.SphereGeometry( 15, 24, 24, Math.PI / 2, Math.PI * 2, 0, Math.PI / 180 * 120 );\n\t\t\t\tconst halfSphere = new THREE.Mesh( geometry, material );\n\t\t\t\thalfSphere.add( sphereCap );\n\t\t\t\thalfSphere.rotateX( - Math.PI / 180 * 135 );\n\t\t\t\thalfSphere.rotateZ( - Math.PI / 180 * 20 );\n\t\t\t\thalfSphere.position.y = 7.5 + 15 * Math.sin( Math.PI / 180 * 30 );\n\n\t\t\t\tsphereGroup.add( halfSphere );\n\n\t\t\t\tgeometry = new THREE.IcosahedronGeometry( 5, 0 );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x7b7b7b, flatShading: true } );\n\t\t\t\tsmallSphere = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( smallSphere );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorNormal.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorNormal.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst decalDiffuse = textureLoader.load( 'textures/decal/decal-diffuse.png' );\n\t\t\t\tdecalDiffuse.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst decalNormal = textureLoader.load( 'textures/decal/decal-normal.jpg' );\n\n\t\t\t\t// reflectors / mirrors\n\n\t\t\t\tconst groundReflector = reflector();\n\t\t\t\tconst verticalReflector = reflector();\n\n\t\t\t\tconst groundNormalScale = - 0.08;\n\t\t\t\tconst verticalNormalScale = 0.1;\n\n\t\t\t\tconst groundUVOffset = texture( decalNormal ).xy.mul( 2 ).sub( 1 ).mul( groundNormalScale );\n\t\t\t\tconst verticalUVOffset = texture( floorNormal, uv().mul( 5 ) ).xy.mul( 2 ).sub( 1 ).mul( verticalNormalScale );\n\n\t\t\t\tgroundReflector.uvNode = groundReflector.uvNode.add( groundUVOffset );\n\t\t\t\tverticalReflector.uvNode = verticalReflector.uvNode.add( verticalUVOffset );\n\n\t\t\t\tconst groundNode = texture( decalDiffuse ).a.mix( color( 0xffffff ), groundReflector );\n\t\t\t\tconst verticalNode = color( 0x0000ff ).mul( .1 ).add( verticalReflector );\n\n\t\t\t\t// walls\n\n\t\t\t\tconst planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );\n\n\t\t\t\t//\n\n\t\t\t\tconst planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolorNode: groundNode\n\t\t\t\t} ) );\n\t\t\t\tplaneBottom.rotateX( - Math.PI / 2 );\n\t\t\t\tplaneBottom.add( groundReflector.target );\n\t\t\t\tscene.add( planeBottom );\n\n\t\t\t\tconst planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolorNode: verticalNode\n\t\t\t\t} ) );\n\t\t\t\tplaneBack.position.z = - 50;\n\t\t\t\tplaneBack.position.y = 50;\n\t\t\t\tplaneBack.add( verticalReflector.target );\n\t\t\t\tscene.add( planeBack );\n\n\t\t\t\t//\n\n\t\t\t\tconst planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneTop.position.y = 100;\n\t\t\t\tplaneTop.rotateX( Math.PI / 2 );\n\t\t\t\tscene.add( planeTop );\n\n\t\t\t\tconst planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );\n\t\t\t\tplaneFront.position.z = 50;\n\t\t\t\tplaneFront.position.y = 50;\n\t\t\t\tplaneFront.rotateY( Math.PI );\n\t\t\t\tscene.add( planeFront );\n\n\t\t\t\tconst planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );\n\t\t\t\tplaneRight.position.x = 50;\n\t\t\t\tplaneRight.position.y = 50;\n\t\t\t\tplaneRight.rotateY( - Math.PI / 2 );\n\t\t\t\tscene.add( planeRight );\n\n\t\t\t\tconst planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );\n\t\t\t\tplaneLeft.position.x = - 50;\n\t\t\t\tplaneLeft.position.y = 50;\n\t\t\t\tplaneLeft.rotateY( Math.PI / 2 );\n\t\t\t\tscene.add( planeLeft );\n\n\t\t\t\t// lights\n\n\t\t\t\tconst mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );\n\t\t\t\tmainLight.position.y = 60;\n\t\t\t\tscene.add( mainLight );\n\n\t\t\t\tconst greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );\n\t\t\t\tgreenLight.position.set( 550, 50, 0 );\n\t\t\t\tscene.add( greenLight );\n\n\t\t\t\tconst redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );\n\t\t\t\tredLight.position.set( - 550, 50, 0 );\n\t\t\t\tscene.add( redLight );\n\n\t\t\t\tconst blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );\n\t\t\t\tblueLight.position.set( 0, 50, 550 );\n\t\t\t\tscene.add( blueLight );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcameraControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcameraControls.target.set( 0, 40, 0 );\n\t\t\t\tcameraControls.maxDistance = 400;\n\t\t\t\tcameraControls.minDistance = 10;\n\t\t\t\tcameraControls.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = Date.now() * 0.01;\n\n\t\t\t\tsphereGroup.rotation.y -= 0.002;\n\n\t\t\t\tsmallSphere.position.set(\n\t\t\t\t\tMath.cos( timer * 0.1 ) * 30,\n\t\t\t\t\tMath.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,\n\t\t\t\t\tMath.sin( timer * 0.1 ) * 30\n\t\t\t\t);\n\t\t\t\tsmallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;\n\t\t\t\tsmallSphere.rotation.z = timer * 0.8;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - mirror"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - curve modifier"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - curve modifier:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { Flow } from 'three/addons/modifiers/CurveModifierGPU.js';\n\t\t\timport { FontLoader } from 'three/addons/loaders/FontLoader.js';\n\t\t\timport { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n\n\t\t\tconst ACTION_SELECT = 1, ACTION_NONE = 0;\n\t\t\tconst curveHandles = [];\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tlet stats;\n\t\t\tlet scene,\n\t\t\t\tcamera,\n\t\t\t\trenderer,\n\t\t\t\trayCaster,\n\t\t\t\tcontrol,\n\t\t\t\tflow,\n\t\t\t\taction = ACTION_NONE;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t40,\n\t\t\t\t\twindow.innerWidth / window.innerHeight,\n\t\t\t\t\t1,\n\t\t\t\t\t1000\n\t\t\t\t);\n\t\t\t\tcamera.position.set( 2, 2, 4 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tconst initialPoints = [\n\t\t\t\t\t{ x: 1, y: 0, z: - 1 },\n\t\t\t\t\t{ x: 1, y: 0, z: 1 },\n\t\t\t\t\t{ x: - 1, y: 0, z: 1 },\n\t\t\t\t\t{ x: - 1, y: 0, z: - 1 },\n\t\t\t\t];\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );\n\t\t\t\tconst boxMaterial = new THREE.MeshBasicNodeMaterial();\n\n\t\t\t\tfor ( const handlePos of initialPoints ) {\n\n\t\t\t\t\tconst handle = new THREE.Mesh( boxGeometry, boxMaterial );\n\t\t\t\t\thandle.position.copy( handlePos );\n\t\t\t\t\tcurveHandles.push( handle );\n\t\t\t\t\tscene.add( handle );\n\n\t\t\t\t}\n\n\t\t\t\tconst curve = new THREE.CatmullRomCurve3(\n\t\t\t\t\tcurveHandles.map( ( handle ) => handle.position )\n\t\t\t\t);\n\t\t\t\tcurve.curveType = 'centripetal';\n\t\t\t\tcurve.closed = true;\n\n\t\t\t\tconst points = curve.getPoints( 50 );\n\t\t\t\tconst line = new THREE.Line(\n\t\t\t\t\tnew THREE.BufferGeometry().setFromPoints( points ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0x00ff00 } )\n\t\t\t\t);\n\n\t\t\t\tscene.add( line );\n\n\t\t\t\t//\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffaa33, 3 );\n\t\t\t\tlight.position.set( - 10, 10, 10 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.AmbientLight( 0x003973, 3 );\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new FontLoader();\n\t\t\t\tloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n\t\t\t\t\tconst geometry = new TextGeometry( 'Hello three.js!', {\n\t\t\t\t\t\tfont: font,\n\t\t\t\t\t\tsize: 0.2,\n\t\t\t\t\t\tdepth: 0.05,\n\t\t\t\t\t\tcurveSegments: 12,\n\t\t\t\t\t\tbevelEnabled: true,\n\t\t\t\t\t\tbevelThickness: 0.02,\n\t\t\t\t\t\tbevelSize: 0.01,\n\t\t\t\t\t\tbevelOffset: 0,\n\t\t\t\t\t\tbevelSegments: 5,\n\t\t\t\t\t} );\n\n\t\t\t\t\tgeometry.rotateX( Math.PI );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\t\tcolor: 0x99ffff\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst objectToCurve = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tflow = new Flow( objectToCurve );\n\t\t\t\t\tflow.updateCurve( 0, curve );\n\t\t\t\t\tscene.add( flow.object3D );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.domElement.addEventListener( 'pointerdown', onPointerDown );\n\n\t\t\t\trayCaster = new THREE.Raycaster();\n\t\t\t\tcontrol = new TransformControls( camera, renderer.domElement );\n\t\t\t\tcontrol.addEventListener( 'dragging-changed', function ( event ) {\n\n\t\t\t\t\tif ( ! event.value ) {\n\n\t\t\t\t\t\tconst points = curve.getPoints( 50 );\n\t\t\t\t\t\tline.geometry.setFromPoints( points );\n\t\t\t\t\t\tflow.updateCurve( 0, curve );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\taction = ACTION_SELECT;\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( action === ACTION_SELECT ) {\n\n\t\t\t\t\trayCaster.setFromCamera( mouse, camera );\n\t\t\t\t\taction = ACTION_NONE;\n\t\t\t\t\tconst intersects = rayCaster.intersectObjects( curveHandles, false );\n\t\t\t\t\tif ( intersects.length ) {\n\n\t\t\t\t\t\tconst target = intersects[ 0 ].object;\n\t\t\t\t\t\tcontrol.attach( target );\n\t\t\t\t\t\tscene.add( control.getHelper() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( flow ) {\n\n\t\t\t\t\tflow.moveAlongCurve( 0.001 );\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - curve modifier"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - morph targets"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - morph targets:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet container, camera, scene, renderer, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x8FBCD4 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.z = 10;\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x8FBCD4, 1.5 ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 200 );\n\t\t\t\tcamera.add( pointLight );\n\n\t\t\t\tconst geometry = createGeometry();\n\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\tflatShading: true\n\t\t\t\t} );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tinitGUI();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( function () {\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t} );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createGeometry() {\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 2, 2, 2, 32, 32, 32 );\n\n\t\t\t\t// create an empty array to hold targets for the attribute we want to morph\n\t\t\t\t// morphing positions and normals is supported\n\t\t\t\tgeometry.morphAttributes.position = [];\n\n\t\t\t\t// the original positions of the cube's vertices\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\n\t\t\t\t// for the first morph target we'll move the cube's vertices onto the surface of a sphere\n\t\t\t\tconst spherePositions = [];\n\n\t\t\t\t// for the second morph target, we'll twist the cubes vertices\n\t\t\t\tconst twistPositions = [];\n\t\t\t\tconst direction = new THREE.Vector3( 1, 0, 0 );\n\t\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tconst x = positionAttribute.getX( i );\n\t\t\t\t\tconst y = positionAttribute.getY( i );\n\t\t\t\t\tconst z = positionAttribute.getZ( i );\n\n\t\t\t\t\tspherePositions.push(\n\n\t\t\t\t\t\tx * Math.sqrt( 1 - ( y * y / 2 ) - ( z * z / 2 ) + ( y * y * z * z / 3 ) ),\n\t\t\t\t\t\ty * Math.sqrt( 1 - ( z * z / 2 ) - ( x * x / 2 ) + ( z * z * x * x / 3 ) ),\n\t\t\t\t\t\tz * Math.sqrt( 1 - ( x * x / 2 ) - ( y * y / 2 ) + ( x * x * y * y / 3 ) )\n\n\t\t\t\t\t);\n\n\t\t\t\t\t// stretch along the x-axis so we can see the twist better\n\t\t\t\t\tvertex.set( x * 2, y, z );\n\n\t\t\t\t\tvertex.applyAxisAngle( direction, Math.PI * x / 2 ).toArray( twistPositions, twistPositions.length );\n\n\t\t\t\t}\n\n\t\t\t\t// add the spherical positions as the first morph target\n\t\t\t\tgeometry.morphAttributes.position[ 0 ] = new THREE.Float32BufferAttribute( spherePositions, 3 );\n\n\t\t\t\t// add the twisted positions as the second morph target\n\t\t\t\tgeometry.morphAttributes.position[ 1 ] = new THREE.Float32BufferAttribute( twistPositions, 3 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\t// Set up dat.GUI to control targets\n\t\t\t\tconst params = {\n\t\t\t\t\tSpherify: 0,\n\t\t\t\t\tTwist: 0,\n\t\t\t\t};\n\t\t\t\tconst gui = new GUI( { title: 'Morph Targets' } );\n\n\t\t\t\tgui.add( params, 'Spherify', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 0 ] = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'Twist', 0, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ 1 ] = value;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - morph targets by Discover three.js"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - morph face targets"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - morph face targets:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tlet mixer;\n\n\t\t\t\tconst clock = new THREE.Clock();\n\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.8, 3 );\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\n\t\t\t\tconst ktx2Loader = await new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupportAsync( renderer );\n\n\t\t\t\tnew GLTFLoader()\n\t\t\t\t\t.setKTX2Loader( ktx2Loader )\n\t\t\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t\t\t.load( 'models/gltf/facecap.glb', ( gltf ) => {\n\n\t\t\t\t\t\tconst mesh = gltf.scene.children[ 0 ];\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\n\t\t\t\t\t\tmixer.clipAction( gltf.animations[ 0 ] ).play();\n\n\t\t\t\t\t\t// GUI\n\n\t\t\t\t\t\tconst head = mesh.getObjectByName( 'mesh_2' );\n\t\t\t\t\t\tconst influences = head.morphTargetInfluences;\n\n\t\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\t\tgui.close();\n\n\t\t\t\t\t\tfor ( const [ key, value ] of Object.entries( head.morphTargetDictionary ) ) {\n\n\t\t\t\t\t\t\tgui.add( influences, value, 0, 1, 0.01 )\n\t\t\t\t\t\t\t\t.name( key.replace( 'blendShape1.', '' ) )\n\t\t\t\t\t\t\t\t.listen();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 2.5;\n\t\t\t\tcontrols.maxDistance = 5;\n\t\t\t\tcontrols.minAzimuthAngle = - Math.PI / 2;\n\t\t\t\tcontrols.maxAzimuthAngle = Math.PI / 2;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.8;\n\t\t\t\tcontrols.target.set( 0, 0.15, - 0.2 );\n\n\t\t\t\tconst stats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\n\n\t\t\t\tfunction animate() {\n\n\t\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t\tcontrols.update();\n\n\t\t\t\t\tstats.update();\n\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener( 'resize', () => {\n\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\t} );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - morph face targets model by Face Cap"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - mrt"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - mrt:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { output, normalView, pass, step, diffuseColor, emissive, directionToColor, screenUV, mix, mrt, Fn } from 'three/tsl';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// scene\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmet.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst scenePass = pass( scene, camera, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter } );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput: output,\n\t\t\t\t\tnormal: directionToColor( normalView ),\n\t\t\t\t\tdiffuse: diffuseColor,\n\t\t\t\t\temissive: emissive\n\t\t\t\t} ) );\n\n\t\t\t\t// optimize textures\n\n\t\t\t\tconst normalTexture = scenePass.getTexture( 'normal' );\n\t\t\t\tconst diffuseTexture = scenePass.getTexture( 'diffuse' );\n\t\t\t\tconst emissiveTexture = scenePass.getTexture( 'emissive' );\n\n\t\t\t\tnormalTexture.type = diffuseTexture.type = emissiveTexture.type = THREE.UnsignedByteType;\n\n\t\t\t\t// post processing - mrt\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputColorTransform = false;\n\t\t\t\tpostProcessing.outputNode = Fn( () => {\n\n\t\t\t\t\tconst output = scenePass.getTextureNode( 'output' ); // output name is optional here\n\t\t\t\t\tconst normal = scenePass.getTextureNode( 'normal' );\n\t\t\t\t\tconst diffuse = scenePass.getTextureNode( 'diffuse' );\n\t\t\t\t\tconst emissive = scenePass.getTextureNode( 'emissive' );\n\n\t\t\t\t\tconst out = mix( output.renderOutput(), output, step( 0.2, screenUV.x ) );\n\t\t\t\t\tconst nor = mix( out, normal, step( 0.4, screenUV.x ) );\n\t\t\t\t\tconst emi = mix( nor, emissive, step( 0.6, screenUV.x ) );\n\t\t\t\t\tconst dif = mix( emi, diffuse, step( 0.8, screenUV.x ) );\n\n\t\t\t\t\treturn dif;\n\n\t\t\t\t} )();\n\n\t\t\t\t// controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - mrt Final / Beauty / Normal / Emissive / Diffuse"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - mrt mask"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - mrt mask:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, screenUV, mrt, output, pass, vec4 } from 'three/tsl';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet postProcessing;\n\t\t\tlet spheres, rotate = true;\n\t\t\tlet mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.set( 1, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) ).mul( .05 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst light = new THREE.SpotLight( 0xffffff, 1 );\n\t\t\t\tlight.power = 2000;\n\t\t\t\tcamera.add( light );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tconst object = gltf.scene;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\tconst material = object.children[ 0 ].children[ 0 ].material;\n\n\t\t\t\t\t// add glow effect\n\t\t\t\t\tmaterial.mrtNode = mrt( { mask: output.add( 1 ) } );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t// spheres\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( .3, 32, 16 );\n\n\t\t\t\tspheres = new THREE.Group();\n\t\t\t\tscene.add( spheres );\n\n\t\t\t\tfunction addSphere( color, mrtNode = null ) {\n\n\t\t\t\t\tconst distance = 1;\n\t\t\t\t\tconst id = spheres.children.length;\n\t\t\t\t\tconst rotation = THREE.MathUtils.degToRad( id * 90 );\n\n\t\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( { color } );\n\t\t\t\t\tmaterial.mrtNode = mrtNode;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set(\n\t\t\t\t\t\tMath.cos( rotation ) * distance,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tMath.sin( rotation ) * distance\n\t\t\t\t\t);\n\n\t\t\t\t\tspheres.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\taddSphere( 0x0000ff, mrt( { mask: output } ) );\n\t\t\t\taddSphere( 0x00ff00 );\n\t\t\t\taddSphere( 0xff0000 );\n\t\t\t\taddSphere( 0x00ffff );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.4;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput: output.renderOutput(),\n\t\t\t\t\tmask: vec4( 0 ) // empty as default, custom materials can set this\n\t\t\t\t} ) );\n\n\t\t\t\tconst colorPass = scenePass.getTextureNode();\n\t\t\t\tconst maskPass = scenePass.getTextureNode( 'mask' );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputColorTransform = false;\n\t\t\t\tpostProcessing.outputNode = colorPass.add( gaussianBlur( maskPass, 1, 10 ).mul( .3 ) ).renderOutput();\n\n\t\t\t\t// controls\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.addEventListener( 'start', () => rotate = false );\n\t\t\t\tcontrols.addEventListener( 'end', () => rotate = true );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\tif ( rotate ) spheres.rotation.y += delta * 0.5;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - mrt mask The mask is applied followed by a gaussian blur only on some selected materials."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - multiple render targets"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - multiple render targets:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mix, vec2, step, texture, uv, screenUV, normalWorld, output, mrt } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, torus;\n\t\t\tlet postProcessing, renderTarget;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Create a multi render target with Float buffers\n\n\t\t\t\trenderTarget = new THREE.RenderTarget(\n\t\t\t\t\twindow.innerWidth * window.devicePixelRatio,\n\t\t\t\t\twindow.innerHeight * window.devicePixelRatio,\n\t\t\t\t\t{ count: 2, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter }\n\t\t\t\t);\n\n\t\t\t\t// Name our G-Buffer attachments for debugging\n\n\t\t\t\trenderTarget.textures[ 0 ].name = 'output';\n\t\t\t\trenderTarget.textures[ 1 ].name = 'normal';\n\n\t\t\t\t// Scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tconst diffuse = loader.load( 'textures/hardwood2_diffuse.jpg' );\n\t\t\t\tdiffuse.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tdiffuse.wrapS = THREE.RepeatWrapping;\n\t\t\t\tdiffuse.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst torusMaterial = new THREE.NodeMaterial();\n\t\t\t\ttorusMaterial.colorNode = texture( diffuse, uv().mul( vec2( 10, 4 ) ) );\n\n\t\t\t\ttorus = new THREE.Mesh( new THREE.TorusKnotGeometry( 1, 0.3, 128, 32 ), torusMaterial );\n\t\t\t\tscene.add( torus );\n\n\t\t\t\t// MRT\n\n\t\t\t\trenderer.setMRT( mrt( {\n\t\t\t\t\t'output': output,\n\t\t\t\t\t'normal': normalWorld\n\t\t\t\t} ) );\n\n\t\t\t\t// Post Processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = mix( texture( renderTarget.textures[ 0 ] ), texture( renderTarget.textures[ 1 ] ), step( 0.5, screenUV.x ) );\n\n\t\t\t\t// Controls\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tconst dpr = renderer.getPixelRatio();\n\t\t\t\trenderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t}\n\n\t\t\tfunction render( time ) {\n\n\t\t\t\ttorus.rotation.y = ( time / 1000 ) * .4;\n\n\t\t\t\t// render scene into target\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// render post FX\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example threejs webgpu - multiple rendertargets"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - mrt readback"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - mrt readback:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mix, step, texture, screenUV, mrt, output, normalWorld, uv, vec2 } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, torus;\n\t\t\tlet quadMesh, sceneMRT, renderTarget, readbackTarget, material, readbackMaterial, pixelBuffer, pixelBufferTexture;\n\n\t\t\tconst gui = new GUI();\n\n\t\t\tconst options = {\n\t\t\t\tselection: 'mrt',\n\t\t\t};\n\n\t\t\tgui.add( options, 'selection', [ 'mrt', 'diffuse', 'normal' ] );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Create a multi render target with Float buffers\n\n\t\t\t\trenderTarget = new THREE.RenderTarget(\n\t\t\t\t\twindow.innerWidth * window.devicePixelRatio,\n\t\t\t\t\twindow.innerHeight * window.devicePixelRatio,\n\t\t\t\t\t{ count: 2, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter }\n\t\t\t\t);\n\n\t\t\t\t// Name our G-Buffer attachments for debugging\n\n\t\t\t\trenderTarget.textures[ 0 ].name = 'output';\n\t\t\t\trenderTarget.textures[ 1 ].name = 'normal';\n\n\t\t\t\t// Init readback render target, readback data texture, readback material\n\t\t\t\t// Be careful with the size! 512 is already big. Reading data back from the GPU is computationally intensive\n\n\t\t\t\tconst size = 512;\n\n\t\t\t\treadbackTarget = new THREE.RenderTarget( size, size, { count: 2 } );\n\n\t\t\t\tpixelBuffer = new Uint8Array( size ** 2 * 4 ).fill( 0 );\n\t\t\t\tpixelBufferTexture = new THREE.DataTexture( pixelBuffer, size, size );\n\t\t\t\tpixelBufferTexture.type = THREE.UnsignedByteType;\n\t\t\t\tpixelBufferTexture.format = THREE.RGBAFormat;\n\n\t\t\t\treadbackMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\treadbackMaterial.colorNode = texture( pixelBufferTexture );\n\n\t\t\t\t// MRT\n\n\t\t\t\tsceneMRT = mrt( {\n\t\t\t\t\t'output': output,\n\t\t\t\t\t'normal': normalWorld\n\t\t\t\t} );\n\n\t\t\t\t// Scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tconst diffuse = loader.load( 'textures/hardwood2_diffuse.jpg' );\n\t\t\t\tdiffuse.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tdiffuse.wrapS = THREE.RepeatWrapping;\n\t\t\t\tdiffuse.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst torusMaterial = new THREE.NodeMaterial();\n\t\t\t\ttorusMaterial.colorNode = texture( diffuse, uv().mul( vec2( 10, 4 ) ) );\n\n\t\t\t\ttorus = new THREE.Mesh( new THREE.TorusKnotGeometry( 1, 0.3, 128, 32 ), torusMaterial );\n\t\t\t\tscene.add( torus );\n\n\t\t\t\t// Output\n\n\t\t\t\tmaterial = new THREE.NodeMaterial();\n\t\t\t\tmaterial.colorNode = mix( texture( renderTarget.textures[ 0 ] ), texture( renderTarget.textures[ 1 ] ), step( 0.5, screenUV.x ) );\n\n\t\t\t\tquadMesh = new THREE.QuadMesh( material );\n\n\t\t\t\t// Controls\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tconst dpr = renderer.getPixelRatio();\n\t\t\t\trenderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t}\n\n\t\t\tasync function render( time ) {\n\n\t\t\t\tconst selection = options.selection;\n\n\t\t\t\ttorus.rotation.y = ( time / 1000 ) * .4;\n\n\t\t\t\tconst isMRT = selection === 'mrt';\n\n\t\t\t\t// render scene into target\n\t\t\t\trenderer.setMRT( isMRT ? sceneMRT : null );\n\t\t\t\trenderer.setRenderTarget( isMRT ? renderTarget : readbackTarget );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// render post FX\n\t\t\t\trenderer.setMRT( null );\n\t\t\t\trenderer.setRenderTarget( null );\n\n\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\tquadMesh.material = material;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tquadMesh.material = readbackMaterial;\n\n\t\t\t\t\tawait readback();\n\n\t\t\t\t}\n\n\t\t\t\tquadMesh.render( renderer );\n\n\t\t\t}\n\n\t\t\tasync function readback() {\n\n\t\t\t\tconst width = readbackTarget.width;\n\t\t\t\tconst height = readbackTarget.height;\n\n\t\t\t\tconst selection = options.selection;\n\n\t\t\t\tif ( selection === 'diffuse' ) {\n\n\t\t\t\t\tpixelBuffer = await renderer.readRenderTargetPixelsAsync( readbackTarget, 0, 0, width, height, 0 ); // zero is optional\n\n\t\t\t\t\tpixelBufferTexture.image.data = pixelBuffer;\n\t\t\t\t\tpixelBufferTexture.needsUpdate = true;\n\n\t\t\t\t} else if ( selection === 'normal' ) {\n\n\t\t\t\t\tpixelBuffer = await renderer.readRenderTargetPixelsAsync( readbackTarget, 0, 0, width, height, 1 );\n\n\t\t\t\t\tpixelBufferTexture.image.data = pixelBuffer;\n\t\t\t\t\tpixelBufferTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js webgpu - mrt readback"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - multisampled renderbuffers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - multisampled renderbuffers:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tlet quadMesh, renderTarget;\n\n\t\t\tlet box, box2;\n\n\t\t\tconst dpr = 1;\n\n\t\t\tconst params = {\n\t\t\t\tanimated: true,\n\t\t\t\tsamples: 4\n\t\t\t};\n\n\t\t\tconst mat4 = new THREE.Matrix4();\n\n\t\t\tconst count = 50;\n\t\t\tconst fullRadius = 20; // Radius of the sphere\n\t\t\tconst halfRadius = 10; // Radius of the sphere\n\t\t\tconst positions = new Array( count ).fill().map( ( _, i ) => {\n\n\t\t\t\tconst radius = ( i % 2 === 0 ) ? fullRadius : halfRadius;\n\n\t\t\t\tconst phi = Math.acos( 2 * Math.random() - 1 ) - Math.PI / 2; // phi: latitude, range -\u03c0/2 to \u03c0/2\n\t\t\t\tconst theta = 2 * Math.PI * Math.random(); // theta: longitude, range 0 to 2\u03c0\n\n\t\t\t\treturn new THREE.Vector3(\n\t\t\t\t\tradius * Math.cos( phi ) * Math.cos( theta ), // x\n\t\t\t\t\tradius * Math.sin( phi ), // y\n\t\t\t\t\tradius * Math.cos( phi ) * Math.sin( theta ) // z\n\t\t\t\t);\n\n\t\t\t} );\n\n\n\t\t\tinitGUI();\n\t\t\tinit();\n\n\t\t\tfunction initGUI() {\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'samples', 0, 4 ).step( 1 );\n\t\t\t\tgui.add( params, 'animated' );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x111111 );\n\n\t\t\t\t// textured mesh\n\n\t\t\t\tconst geometryBox = new THREE.BoxGeometry( 7, 7, 7, 12, 12, 12 );\n\t\t\t\tconst materialBox = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tconst materialBoxInner = new THREE.MeshBasicNodeMaterial( { color: 0xff0000 } );\n\n\t\t\t\tmaterialBox.wireframe = true;\n\n\t\t\t\t//\n\n\t\t\t\tbox = new THREE.InstancedMesh( geometryBox, materialBox, count );\n\t\t\t\tbox2 = new THREE.InstancedMesh( geometryBox, materialBoxInner, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tbox.setMatrixAt( i, mat4.identity().setPosition( positions[ i ] ) );\n\t\t\t\t\tbox2.setMatrixAt( i, mat4.multiplyScalar( 0.996 ).setPosition( positions[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( box, box2 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( dpr );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderTarget = new THREE.RenderTarget( window.innerWidth * dpr, window.innerHeight * dpr, {\n\t\t\t\t\tsamples: params.samples,\n\t\t\t\t\tdepthBuffer: true,\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'mousemove', onWindowMouseMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// FX\n\n\t\t\t\t// modulate the final color based on the mouse position\n\n\t\t\t\tconst materialFX = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterialFX.colorNode = texture( renderTarget.texture ).rgb;\n\n\t\t\t\tquadMesh = new THREE.QuadMesh( materialFX );\n\n\t\t\t}\n\n\t\t\tfunction onWindowMouseMove( e ) {\n\n\t\t\t\tmouse.x = e.offsetX / window.innerWidth;\n\t\t\t\tmouse.y = e.offsetY / window.innerHeight;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( params.animated ) {\n\n\t\t\t\t\tbox.rotation.x += 0.001;\n\t\t\t\t\tbox.rotation.y += 0.002;\n\t\t\t\t\tbox2.rotation.x += 0.001;\n\t\t\t\t\tbox2.rotation.y += 0.002;\n\n\t\t\t\t}\n\n\t\t\t\trenderTarget.samples = params.samples;\n\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tquadMesh.render( renderer );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - multisampled renderbuffers"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - occlusion"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - occlusion:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { nodeObject, uniform } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tclass OcclusionNode extends THREE.Node {\n\n\t\t\t\tconstructor( testObject, normalColor, occludedColor ) {\n\n\t\t\t\t\tsuper( 'vec3' );\n\n\t\t\t\t\tthis.updateType = THREE.NodeUpdateType.OBJECT;\n\n\t\t\t\t\tthis.uniformNode = uniform( new THREE.Color() );\n\n\t\t\t\t\tthis.testObject = testObject;\n\t\t\t\t\tthis.normalColor = normalColor;\n\t\t\t\t\tthis.occludedColor = occludedColor;\n\n\t\t\t\t}\n\n\t\t\t\tasync update( frame ) {\n\n\t\t\t\t\tconst isOccluded = frame.renderer.isOccluded( this.testObject );\n\n\t\t\t\t\tthis.uniformNode.value.copy( isOccluded ? this.occludedColor : this.normalColor );\n\n\t\t\t\t}\n\n\t\t\t\tsetup( /* builder */ ) {\n\n\t\t\t\t\treturn this.uniformNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.z = 7;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xb0b0b0 );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );\n\t\t\t\tlight.position.set( 0.32, 0.39, 0.7 );\n\n\t\t\t\tscene.add( ambientLight );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// models\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 0.5 );\n\n\t\t\t\tconst plane = new THREE.Mesh( planeGeometry, new THREE.MeshPhongNodeMaterial( { color: 0x00ff00, side: THREE.DoubleSide } ) );\n\t\t\t\tconst sphere = new THREE.Mesh( sphereGeometry, new THREE.MeshPhongNodeMaterial( { color: 0xffff00 } ) );\n\n\t\t\t\tconst instanceUniform = nodeObject( new OcclusionNode( sphere, new THREE.Color( 0x0000ff ), new THREE.Color( 0x00ff00 ) ) );\n\n\t\t\t\tplane.material.colorNode = instanceUniform;\n\n\t\t\t\tsphere.position.z = - 1;\n\t\t\t\tsphere.occlusionTest = true;\n\n\t\t\t\tscene.add( plane );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 25;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - occlusion The plane is green when the sphere is completely occluded."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - ocean"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - ocean:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { WaterMesh } from 'three/addons/objects/WaterMesh.js';\n\t\t\timport { SkyMesh } from 'three/addons/objects/SkyMesh.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, water, sun, mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 1, 20000 );\n\t\t\t\tcamera.position.set( 30, 30, 100 );\n\n\t\t\t\t//\n\n\t\t\t\tsun = new THREE.Vector3();\n\n\t\t\t\t// Water\n\n\t\t\t\tconst waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst waterNormals = loader.load( 'textures/waternormals.jpg' );\n\t\t\t\twaterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\twater = new WaterMesh(\n\t\t\t\t\twaterGeometry,\n\t\t\t\t\t{\n\t\t\t\t\t\twaterNormals: waterNormals,\n\t\t\t\t\t\tsunDirection: new THREE.Vector3(),\n\t\t\t\t\t\tsunColor: 0xffffff,\n\t\t\t\t\t\twaterColor: 0x001e0f,\n\t\t\t\t\t\tdistortionScale: 3.7\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\twater.rotation.x = - Math.PI / 2;\n\n\t\t\t\tscene.add( water );\n\n\t\t\t\t// Skybox\n\n\t\t\t\tconst sky = new SkyMesh();\n\t\t\t\tsky.scale.setScalar( 10000 );\n\t\t\t\tscene.add( sky );\n\n\t\t\t\tsky.turbidity.value = 10;\n\t\t\t\tsky.rayleigh.value = 2;\n\t\t\t\tsky.mieCoefficient.value = 0.005;\n\t\t\t\tsky.mieDirectionalG.value = 0.8;\n\n\t\t\t\tconst parameters = {\n\t\t\t\t\televation: 2,\n\t\t\t\t\tazimuth: 180\n\t\t\t\t};\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tconst sceneEnv = new THREE.Scene();\n\n\t\t\t\tlet renderTarget;\n\n\t\t\t\tfunction updateSun() {\n\n\t\t\t\t\tconst phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );\n\t\t\t\t\tconst theta = THREE.MathUtils.degToRad( parameters.azimuth );\n\n\t\t\t\t\tsun.setFromSphericalCoords( 1, phi, theta );\n\n\t\t\t\t\tsky.sunPosition.value.copy( sun );\n\t\t\t\t\twater.sunDirection.value.copy( sun ).normalize();\n\n\t\t\t\t\tif ( renderTarget !== undefined ) renderTarget.dispose();\n\n\t\t\t\t\tsceneEnv.add( sky );\n\t\t\t\t\trenderTarget = pmremGenerator.fromScene( sceneEnv );\n\t\t\t\t\tscene.add( sky );\n\n\t\t\t\t\tscene.environment = renderTarget.texture;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.init().then( updateSun );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 30, 30, 30 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { roughness: 0 } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.495;\n\t\t\t\tcontrols.target.set( 0, 10, 0 );\n\t\t\t\tcontrols.minDistance = 40.0;\n\t\t\t\tcontrols.maxDistance = 200.0;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst folderSky = gui.addFolder( 'Sky' );\n\t\t\t\tfolderSky.add( parameters, 'elevation', 0, 90, 0.1 ).onChange( updateSun );\n\t\t\t\tfolderSky.add( parameters, 'azimuth', - 180, 180, 0.1 ).onChange( updateSun );\n\t\t\t\tfolderSky.open();\n\n\n\t\t\t\tconst folderWater = gui.addFolder( 'Water' );\n\t\t\t\tfolderWater.add( water.distortionScale, 'value', 0, 8, 0.1 ).name( 'distortionScale' );\n\t\t\t\tfolderWater.add( water.size, 'value', 0.1, 10, 0.1 ).name( 'size' );\n\t\t\t\tfolderWater.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = performance.now() * 0.001;\n\n\t\t\t\tmesh.position.y = Math.sin( time ) * 20 + 5;\n\t\t\t\tmesh.rotation.x = time * 0.5;\n\t\t\t\tmesh.rotation.z = time * 0.51;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - webgpu ocean"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - parallax uv"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - parallax uv:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, parallaxUV, blendOverlay, uv } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .1, 50 );\n\t\t\t\tcamera.position.set( 10, 14, 10 );\n\n\t\t\t\t// environment\n\n\t\t\t\tconst environmentTexture = await new THREE.CubeTextureLoader()\n\t\t\t\t\t.setPath( './textures/cube/Park2/' )\n\t\t\t\t\t.loadAsync( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );\n\n\n\t\t\t\tscene.environment = environmentTexture;\n\t\t\t\tscene.background = environmentTexture;\n\n\t\t\t\t// textures\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tconst topTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_Color.jpg' );\n\t\t\t\ttopTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst roughnessTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_Roughness.jpg' );\n\t\t\t\troughnessTexture.colorSpace = THREE.NoColorSpace;\n\n\t\t\t\tconst normalTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_NormalGL.jpg' );\n\t\t\t\tnormalTexture.colorSpace = THREE.NoColorSpace;\n\n\t\t\t\tconst displaceTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_Displacement.jpg' );\n\t\t\t\tdisplaceTexture.colorSpace = THREE.NoColorSpace;\n\n\t\t\t\t//\n\n\t\t\t\tconst bottomTexture = await loader.loadAsync( 'textures/ambientcg/Ice003_1K-JPG_Color.jpg' );\n\t\t\t\tbottomTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tbottomTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tbottomTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// parallax effect\n\n\t\t\t\tconst parallaxScale = .3;\n\t\t\t\tconst offsetUV = texture( displaceTexture ).mul( parallaxScale );\n\n\t\t\t\tconst parallaxUVOffset = parallaxUV( uv(), offsetUV );\n\t\t\t\tconst parallaxResult = texture( bottomTexture, parallaxUVOffset );\n\n\t\t\t\tconst iceNode = blendOverlay( texture( topTexture ), parallaxResult );\n\n\t\t\t\t// material\n\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tmaterial.colorNode = iceNode.mul( 5 ); // increase the color intensity to 5 ( contrast )\n\t\t\t\tmaterial.roughnessNode = texture( roughnessTexture );\n\t\t\t\tmaterial.normalMap = normalTexture;\n\t\t\t\tmaterial.metalness = 0;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 10, 10, 10 );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, material );\n\t\t\t\tground.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 6;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.maxDistance = 40;\n\t\t\t\tcontrols.minDistance = 10;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - 1;\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - parallax uv Textures by ambientCG"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - Particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - Particles:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { range, texture, mix, uv, color, rotateUV, positionLocal, time, uniform } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.set( 1300, 500, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst map = textureLoader.load( 'textures/opengameart/smoke1.png' );\n\n\t\t\t\t// create nodes\n\n\t\t\t\tconst lifeRange = range( .1, 1 );\n\t\t\t\tconst offsetRange = range( new THREE.Vector3( - 2, 3, - 2 ), new THREE.Vector3( 2, 5, 2 ) );\n\n\t\t\t\tconst speed = uniform( .2 );\n\t\t\t\tconst scaledTime = time.add( 5 ).mul( speed );\n\n\t\t\t\tconst lifeTime = scaledTime.mul( lifeRange ).mod( 1 );\n\t\t\t\tconst scaleRange = range( .3, 2 );\n\t\t\t\tconst rotateRange = range( .1, 4 );\n\n\t\t\t\tconst life = lifeTime.div( lifeRange );\n\n\t\t\t\tconst fakeLightEffect = positionLocal.y.oneMinus().max( 0.2 );\n\n\t\t\t\tconst textureNode = texture( map, rotateUV( uv(), scaledTime.mul( rotateRange ) ) );\n\n\t\t\t\tconst opacityNode = textureNode.a.mul( life.oneMinus() );\n\n\t\t\t\tconst smokeColor = mix( color( 0x2c1501 ), color( 0x222222 ), positionLocal.y.mul( 3 ).clamp() );\n\n\t\t\t\t// create particles\n\n\t\t\t\tconst smokeNodeMaterial = new THREE.SpriteNodeMaterial();\n\t\t\t\tsmokeNodeMaterial.colorNode = mix( color( 0xf27d0c ), smokeColor, life.mul( 2.5 ).min( 1 ) ).mul( fakeLightEffect );\n\t\t\t\tsmokeNodeMaterial.opacityNode = opacityNode;\n\t\t\t\tsmokeNodeMaterial.positionNode = offsetRange.mul( lifeTime );\n\t\t\t\tsmokeNodeMaterial.scaleNode = scaleRange.mul( lifeTime.max( 0.3 ) );\n\t\t\t\tsmokeNodeMaterial.depthWrite = false;\n\n\t\t\t\tconst smokeInstancedSprite = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), smokeNodeMaterial );\n\t\t\t\tsmokeInstancedSprite.scale.setScalar( 400 );\n\t\t\t\tsmokeInstancedSprite.count = 2000;\n\t\t\t\tscene.add( smokeInstancedSprite );\n\n\t\t\t\t//\n\n\t\t\t\tconst fireGeometry = new THREE.PlaneGeometry( 1, 1 );\n\t\t\t\tconst fireCount = 1000;\n\n\t\t\t\tconst fireNodeMaterial = new THREE.SpriteNodeMaterial();\n\t\t\t\tfireNodeMaterial.colorNode = mix( color( 0xb72f17 ), color( 0xb72f17 ), life );\n\t\t\t\tfireNodeMaterial.positionNode = range( new THREE.Vector3( - 1, 1, - 1 ), new THREE.Vector3( 1, 2, 1 ) ).mul( lifeTime );\n\t\t\t\tfireNodeMaterial.scaleNode = smokeNodeMaterial.scaleNode;\n\t\t\t\tfireNodeMaterial.opacityNode = opacityNode.mul( .5 );\n\t\t\t\tfireNodeMaterial.blending = THREE.AdditiveBlending;\n\t\t\t\tfireNodeMaterial.transparent = true;\n\t\t\t\tfireNodeMaterial.depthWrite = false;\n\n\t\t\t\tconst fireInstancedSprite = new THREE.Mesh( fireGeometry, fireNodeMaterial );\n\t\t\t\tfireInstancedSprite.scale.setScalar( 400 );\n\t\t\t\tfireInstancedSprite.count = fireCount;\n\t\t\t\tfireInstancedSprite.position.y = - 100;\n\t\t\t\tfireInstancedSprite.renderOrder = 1;\n\t\t\t\tscene.add( fireInstancedSprite );\n\n\t\t\t\t// indirect draw ( optional )\n\t\t\t\t// each indirect draw call is 5 uint32 values for indexes ( different structure for non-indexed draw calls using 4 uint32 values )\n\n\t\t\t\tconst indexCount = fireGeometry.index.array.length;\n\n\t\t\t\tconst uint32 = new Uint32Array( 5 );\n\t\t\t\tuint32[ 0 ] = indexCount;\t// indexCount\n\t\t\t\tuint32[ 1 ] = fireCount; \t// instanceCount\n\t\t\t\tuint32[ 2 ] = 0;\t\t\t// firstIndex\n\t\t\t\tuint32[ 3 ] = 0;\t\t\t// baseVertex\n\t\t\t\tuint32[ 4 ] = 0;\t\t\t// firstInstance\n\n\t\t\t\tconst indirectAttribute = new THREE.IndirectStorageBufferAttribute( uint32, 5 );\n\t\t\t\tfireGeometry.setIndirect( indirectAttribute );\n\n\t\t\t\t//\n\n\t\t\t\tconst helper = new THREE.GridHelper( 3000, 40, 0x303030, 0x303030 );\n\t\t\t\thelper.position.y = - 75;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxDistance = 2700;\n\t\t\t\tcontrols.target.set( 0, 500, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( speed, 'value', 0, 1, 0.01 ).name( 'speed' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst { innerWidth, innerHeight } = window;\n\n\t\t\t\tcamera.aspect = innerWidth / innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( innerWidth, innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - GLTFloader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - GLTFloader:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'stats-gl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet model;\n\n\t\t\tconst options = { static: true };\n\n\t\t\tinit();\n\n\t\t\tfunction setStatic( object, value ) {\n\n\t\t\t\tobject.traverse( child => {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tchild.static = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 60, 60, 60 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats( {\n\t\t\t\t\tprecision: 3,\n\t\t\t\t\thorizontal: false,\n\t\t\t\t\ttrackGPU: true,\n\t\t\t\t} );\n\t\t\t\tstats.init( renderer );\n\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\t\t\tloader.setDRACOLoader( dracoLoader );\n\n\t\t\t\t\t\tloader.load( 'dungeon_warkarma.glb', async function ( gltf ) {\n\n\t\t\t\t\t\t\tmodel = gltf.scene;\n\n\t\t\t\t\t\t\t// wait until the model can be added to the scene without blocking due to shader compilation\n\n\t\t\t\t\t\t\tawait renderer.compileAsync( model, camera, scene );\n\n\t\t\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tsetStatic( model, options.static );\n\t\t\t\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 60;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( options, 'static' ).onChange( () => {\n\n\t\t\t\t\tsetStatic( model, options.static );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tasync function render() {\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - WebGPU Performance Dungeon - Low Poly Game Level Challenge by Warkarma Royal Esplanade from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - renderbundle"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - renderbundle:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'stats-gl';\n\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\tlet camera, scene, renderer;\n\t\tlet controls, stats;\n\t\tlet gui;\n\t\tlet geometries, group;\n\n\t\tlet renderTimeAverages = [];\n\t\t//\n\n\t\tconst position = new THREE.Vector3();\n\t\tconst rotation = new THREE.Euler();\n\t\tconst quaternion = new THREE.Quaternion();\n\t\tconst scale = new THREE.Vector3();\n\n\t\t//\n\n\t\tconst MAX_GEOMETRY_COUNT = 4000;\n\n\t\tconst api = {\n\t\t\twebgpu: true,\n\t\t\trenderBundle: true,\n\t\t\tcount: MAX_GEOMETRY_COUNT,\n\t\t\topacity: 1,\n\t\t\tdynamic: false\n\t\t};\n\n\n\t\tinit( ! api.webgpu );\n\n\t\t//\n\n\t\tfunction randomizeMatrix( matrix ) {\n\n\t\t\tposition.x = Math.random() * 80 - 40;\n\t\t\tposition.y = Math.random() * 80 - 40;\n\t\t\tposition.z = Math.random() * 80 - 40;\n\n\t\t\trotation.x = Math.random() * 2 * Math.PI;\n\t\t\trotation.y = Math.random() * 2 * Math.PI;\n\t\t\trotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\tquaternion.setFromEuler( rotation );\n\n\t\t\tconst factorScale = api.webgpu ? 1 : 2.0;\n\t\t\tscale.x = scale.y = scale.z = 0.35 * factorScale + ( Math.random() * 0.5 * factorScale );\n\n\t\t\treturn matrix.compose( position, quaternion, scale );\n\n\t\t}\n\n\t\tfunction randomizeRotationSpeed( rotation ) {\n\n\t\t\trotation.x = Math.random() * .05;\n\t\t\trotation.y = Math.random() * .05;\n\t\t\trotation.z = Math.random() * .05;\n\t\t\treturn rotation;\n\n\t\t}\n\n\t\tfunction initGeometries() {\n\n\t\t\tgeometries = [\n\t\t\t\tnew THREE.ConeGeometry( 1.0, 2.0, 3, 1 ),\n\t\t\t\tnew THREE.BoxGeometry( 2.0, 2.0, 2.0 ),\n\t\t\t\tnew THREE.PlaneGeometry( 2.0, 2, 1, 1 ),\n\t\t\t\tnew THREE.CapsuleGeometry( ),\n\t\t\t\tnew THREE.CircleGeometry( 1.0, 3 ),\n\t\t\t\tnew THREE.CylinderGeometry( 1.0, 1.0, 2.0, 3, 1 ),\n\t\t\t\tnew THREE.DodecahedronGeometry( 1.0, 0 ),\n\t\t\t\tnew THREE.IcosahedronGeometry( 1.0, 0 ),\n\t\t\t\tnew THREE.OctahedronGeometry( 1.0, 0 ),\n\t\t\t\tnew THREE.PolyhedronGeometry( [ 0, 0, 0 ], [ 0, 0, 0 ], 1, 0 ),\n\t\t\t\tnew THREE.RingGeometry( 1.0, 1.5, 3 ),\n\t\t\t\tnew THREE.SphereGeometry( 1.0, 3, 2 ),\n\t\t\t\tnew THREE.TetrahedronGeometry( 1.0, 0 ),\n\t\t\t\tnew THREE.TorusGeometry( 1.0, 0.5, 3, 3 ),\n\t\t\t\tnew THREE.TorusKnotGeometry( 1.0, 0.5, 20, 3, 1, 1 ),\n\t\t\t];\n\n\t\t}\n\n\t\tfunction cleanup() {\n\n\t\t\tif ( group ) {\n\n\t\t\t\tgroup.parent.remove( group );\n\n\t\t\t\tif ( group.dispose ) {\n\n\t\t\t\t\tgroup.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMesh( count ) {\n\n\t\t\tcleanup();\n\t\t\tinitRegularMesh( count );\n\n\t\t}\n\n\n\t\tfunction initRegularMesh( count ) {\n\n\t\t\tgroup = api.renderBundle ? new THREE.BundleGroup() : new THREE.Group();\n\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst material = new THREE.MeshToonNodeMaterial( {\n\t\t\t\t\tcolor: new THREE.Color( Math.random() * 0xffffff ),\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t} );\n\n\t\t\t\tconst child = new THREE.Mesh( geometries[ i % geometries.length ], material );\n\t\t\t\trandomizeMatrix( child.matrix );\n\t\t\t\tchild.matrix.decompose( child.position, child.quaternion, child.scale );\n\t\t\t\tchild.userData.rotationSpeed = randomizeRotationSpeed( new THREE.Euler() );\n\t\t\t\tchild.frustumCulled = false;\n\t\t\t\tgroup.add( child );\n\n\t\t\t}\n\n\t\t\tscene.add( group );\n\n\t\t}\n\n\t\tasync function init( forceWebGL = false ) {\n\n\t\t\tconst count = api.count / ( api.webgpu ? 1 : 10 );\n\n\t\t\trenderTimeAverages = [];\n\n\t\t\tif ( renderer ) {\n\n\t\t\t\trenderer.dispose();\n\t\t\t\tcontrols.dispose();\n\t\t\t\tdocument.body.removeChild( stats.dom );\n\t\t\t\tdocument.body.removeChild( renderer.domElement );\n\n\t\t\t}\n\n\t\t\t// camera\n\n\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 70, aspect, 1, 100 );\n\t\t\tcamera.position.z = 50;\n\n\t\t\t// renderer\n\n\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t// scene\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xc1c1c1 );\n\n\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3.4 );\n\t\t\tscene.add( light );\n\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tawait renderer.init();\n\n\n\t\t\tinitGeometries();\n\t\t\tinitMesh( count );\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.autoRotate = true;\n\t\t\tcontrols.autoRotateSpeed = 1.0;\n\n\t\t\t// stats\n\n\t\t\tstats = new Stats( {\n\t\t\t\tprecision: 3,\n\t\t\t\thorizontal: false,\n\t\t\t\ttrackGPU: true,\n\t\t\t} );\n\t\t\tstats.init( renderer );\n\t\t\tdocument.body.appendChild( stats.dom );\n\t\t\tstats.dom.style.position = 'absolute';\n\n\t\t\t// gui\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( api, 'renderBundle' ).onChange( () => {\n\n\t\t\t\tinit( ! api.webgpu );\n\n\t\t\t} );\n\n\t\t\tgui.add( api, 'webgpu' ).onChange( () => {\n\n\t\t\t\tinit( ! api.webgpu );\n\n\t\t\t} );\n\n\t\t\tgui.add( api, 'dynamic' ).onChange( () => {\n\n\t\t\t\tgroup.static = ! group.static;\n\n\t\t\t} );\n\n\n\t\t\t// listeners\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\tgroup.needsUpdate = true;\n\t\t\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tanimateMeshes();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst renderTimeAverage = performance.now();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t// push only the last 60 render times\n\t\t\t\trenderTimeAverages.push( performance.now() - renderTimeAverage );\n\t\t\t\tif ( renderTimeAverages.length > 60 ) renderTimeAverages.shift();\n\t\t\n\t\t\t\tconst average = renderTimeAverages.reduce( ( a, b ) => a + b, 0 ) / renderTimeAverages.length;\n\n\t\t\t\trenderer.resolveTimestampsAsync();\n\t\t\t\tstats.update();\n\n\t\t\t\tdocument.getElementById( 'backend' ).innerText = `Average Render Time ${api.renderBundle ? '(Bundle)' : ''}: ` + average.toFixed( 2 ) + 'ms';\n\n\t\t\t}\n\n\t\t\tfunction animateMeshes() {\n\n\t\t\t\tconst count = api.count / ( api.webgpu ? 1 : 10 );\n\t\t\t\tconst loopNum = api.dynamic ? count : 0;\n\n\t\t\t\tfor ( let i = 0; i < loopNum; i ++ ) {\n\n\t\t\t\t\tconst child = group.children[ i ];\n\t\t\t\t\tconst rotationSpeed = child.userData.rotationSpeed;\n\n\t\t\t\t\tchild.rotation.set(\n\t\t\t\t\t\tchild.rotation.x + rotationSpeed.x,\n\t\t\t\t\t\tchild.rotation.y + rotationSpeed.y,\n\t\t\t\t\t\tchild.rotation.z + rotationSpeed.z\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n```\n\nThis example three.js webgpu - renderbundle (WebGL uses 10 times fewer meshes to prevent performance issues.)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - pmrem cubemap"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - pmrem cubemap:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { normalWorldGeometry, uniform, normalView, positionViewDirection, cameraViewMatrix, pmremTexture } from 'three/tsl';\n\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst forceWebGL = false;\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tnew RGBMLoader()\n\t\t\t\t\t.setPath( './textures/cube/pisaRGBM16/' )\n\t\t\t\t\t.loadCubemap( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ], function ( map ) {\n\n\t\t\t\t\t\tconst reflectVec = positionViewDirection.negate().reflect( normalView ).transformDirection( cameraViewMatrix );\n\n\t\t\t\t\t\tconst pmremRoughness = uniform( .5 );\n\t\t\t\t\t\tconst pmremNode = pmremTexture( map, reflectVec, pmremRoughness );\n\n\t\t\t\t\t\tscene.backgroundNode = pmremTexture( map, normalWorldGeometry, pmremRoughness );\n\n\t\t\t\t\t\tscene.add( new THREE.Mesh( new THREE.SphereGeometry( .5, 64, 64 ), new THREE.MeshBasicNodeMaterial( { colorNode: pmremNode } ) ) );\n\n\t\t\t\t\t\t// gui\n\n\t\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\t\tgui.add( pmremRoughness, 'value', 0, 1, 0.001 ).name( 'roughness' ).onChange( () => render() );\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - pmrem equirectangular"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - pmrem equirectangular:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { normalWorldGeometry, uniform, normalView, positionViewDirection, cameraViewMatrix, pmremTexture } from 'three/tsl';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst forceWebGL = false;\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( map ) {\n\n\t\t\t\t\t\tmap.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tconst reflectVec = positionViewDirection.negate().reflect( normalView ).transformDirection( cameraViewMatrix );\n\n\t\t\t\t\t\tconst pmremRoughness = uniform( .5 );\n\t\t\t\t\t\tconst pmremNode = pmremTexture( map, reflectVec, pmremRoughness );\n\n\t\t\t\t\t\tscene.backgroundNode = pmremTexture( map, normalWorldGeometry, pmremRoughness );\n\n\t\t\t\t\t\tscene.add( new THREE.Mesh( new THREE.SphereGeometry( .5, 64, 64 ), new THREE.MeshBasicNodeMaterial( { colorNode: pmremNode } ) ) );\n\n\t\t\t\t\t\t// gui\n\n\t\t\t\t\t\tconst gui = new GUI();\n\t\t\t\t\t\tgui.add( pmremRoughness, 'value', 0, 1, 0.001 ).name( 'roughness' ).onChange( () => render() );\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - pmrem scene"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - pmrem scene:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { normalWorld, uniform, pmremTexture } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst forceWebGL = false;\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\t\t\t\tconst loader = new THREE.CubeTextureLoader().setPath( './textures/cube/Park3Med/' );\n\n\t\t\t\tscene.background = await loader.loadAsync( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );\n\n\t\t\t\tlet model;\n\n\t\t\t\tmodel = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0x0000ff } ) );\n\t\t\t\tmodel.position.z -= 1;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmodel = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0xff0000 } ) );\n\t\t\t\tmodel.position.z += 1;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmodel = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0xff00ff } ) );\n\t\t\t\tmodel.position.x += 1;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmodel = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0x00ffff } ) );\n\t\t\t\tmodel.position.x -= 1;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmodel = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0xffff00 } ) );\n\t\t\t\tmodel.position.y -= 1;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmodel = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0x00ff00 } ) );\n\t\t\t\tmodel.position.y += 1;\n\t\t\t\tscene.add( model );\n\n\t\t\t\t//while ( scene.children.length > 0 ) scene.remove( scene.children[ 0 ] );\n\n\t\t\t\tconst sceneRT = new THREE.PMREMGenerator( renderer ).fromScene( scene );\n\n\n\t\t\t\t//\n\n\t\t\t\tconst pmremRoughness = uniform( .5 );\n\t\t\t\tconst pmremNode = pmremTexture( sceneRT.texture, normalWorld, pmremRoughness );\n\n\t\t\t\tscene.add( new THREE.Mesh( new THREE.SphereGeometry( .5, 64, 64 ), new THREE.MeshBasicNodeMaterial( { colorNode: pmremNode } ) ) );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( pmremRoughness, 'value', 0, 1, 0.001 ).name( 'roughness' ).onChange( () => render() );\n\n\t\t\t\trender();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - portal"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - portal:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, color, mx_worley_noise_float, time, screenUV, vec2, uv, normalWorld, mx_fractal_noise_vec3 } from 'three/tsl';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, sceneMain, scenePortal, renderer;\n\t\t\tlet clock;\n\n\t\t\tconst mixers = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t//\n\n\t\t\t\tsceneMain = new THREE.Scene();\n\t\t\t\tsceneMain.background = new THREE.Color( 0x222222 );\n\t\t\t\tsceneMain.backgroundNode = normalWorld.y.mix( color( 0x0066ff ), color( 0xff0066 ) );\n\n\t\t\t\tscenePortal = new THREE.Scene();\n\t\t\t\tscenePortal.backgroundNode = mx_worley_noise_float( normalWorld.mul( 20 ).add( vec2( 0, time.oneMinus() ) ) ).mul( color( 0x0066ff ) );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 30 );\n\t\t\t\tcamera.position.set( 2.5, 1, 3 );\n\t\t\t\tcamera.position.multiplyScalar( .8 );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 1 );\n\t\t\t\tlight.position.set( 0, 1, 5 );\n\t\t\t\tlight.power = 17000;\n\n\t\t\t\tsceneMain.add( new THREE.HemisphereLight( 0xff0066, 0x0066ff, 7 ) );\n\t\t\t\tsceneMain.add( light );\n\t\t\t\tscenePortal.add( light.clone() );\n\n\t\t\t\t// models\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Xbot.glb', function ( gltf ) {\n\n\t\t\t\t\tconst createModel = ( colorNode = null ) => {\n\n\t\t\t\t\t\tlet object;\n\t\t\t\n\t\t\t\t\t\tif ( mixers.length === 0 ) {\n\n\t\t\t\t\t\t\tobject = gltf.scene;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = gltf.scene.clone();\n\n\t\t\t\t\t\t\tconst children = object.children[ 0 ].children;\n\n\t\t\t\t\t\t\tconst applyFX = ( index ) => {\n\n\t\t\t\t\t\t\t\tchildren[ index ].material = children[ index ].material.clone();\n\t\t\t\t\t\t\t\tchildren[ index ].material.colorNode = colorNode;\n\t\t\t\t\t\t\t\tchildren[ index ].material.wireframe = true;\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tapplyFX( 0 );\n\t\t\t\t\t\t\tapplyFX( 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst mixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 6 ] );\n\t\t\t\t\t\taction.play();\n\n\t\t\t\t\t\tmixers.push( mixer );\n\n\t\t\t\t\t\treturn object;\n\n\t\t\t\t\t};\n\n\t\t\t\t\tconst colorNode = mx_fractal_noise_vec3( uv().mul( 20 ).add( time ) );\n\n\t\t\t\t\tconst modelMain = createModel();\n\t\t\t\t\tconst modelPortal = createModel( colorNode );\n\n\t\t\t\t\t// model portal\n\n\t\t\t\t\tsceneMain.add( modelMain );\n\t\t\t\t\tscenePortal.add( modelPortal );\n\n\t\t\t\t} );\n\n\t\t\t\t// portal\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 1.7, 2 );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = pass( scenePortal, camera ).context( { getUV: () => screenUV } );\n\t\t\t\tmaterial.opacityNode = uv().distance( .5 ).remapClamp( .3, .5 ).oneMinus();\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\tconst plane = new THREE.Mesh( geometry, material );\n\t\t\t\tplane.position.set( 0, 1, .8 );\n\t\t\t\tsceneMain.add( plane );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.15;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.update();\n\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tfor ( const mixer of mixers ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( sceneMain, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - portal"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - 3d luts"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - 3d luts:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mix, mul, oneMinus, positionLocal, smoothstep, texture, time, rotateUV, Fn, uv, vec2, vec3, vec4, pass, texture3D, uniform, renderOutput } from 'three/tsl';\n\t\t\timport { lut3D } from 'three/addons/tsl/display/Lut3DNode.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { LUTCubeLoader } from 'three/addons/loaders/LUTCubeLoader.js';\n\t\t\timport { LUT3dlLoader } from 'three/addons/loaders/LUT3dlLoader.js';\n\t\t\timport { LUTImageLoader } from 'three/addons/loaders/LUTImageLoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst params = {\n\t\t\t\tlut: 'Bourbon 64.CUBE',\n\t\t\t\tintensity: 1\n\t\t\t};\n\n\t\t\tconst lutMap = {\n\t\t\t\t'Bourbon 64.CUBE': null,\n\t\t\t\t'Chemical 168.CUBE': null,\n\t\t\t\t'Clayton 33.CUBE': null,\n\t\t\t\t'Cubicle 99.CUBE': null,\n\t\t\t\t'Remy 24.CUBE': null,\n\t\t\t\t'Presetpro-Cinematic.3dl': null,\n\t\t\t\t'NeutralLUT': null,\n\t\t\t\t'B&WLUT': null,\n\t\t\t\t'NightLUT': null\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer, postProcessing, controls, lutPass;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 8, 10, 12 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Loaders\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\t// LUTs\n\n\t\t\t\tconst lutCubeLoader = new LUTCubeLoader();\n\t\t\t\tconst lutImageLoader = new LUTImageLoader();\n\t\t\t\tconst lut3dlLoader = new LUT3dlLoader();\n\n\t\t\t\tfor ( const name in lutMap ) {\n\n\t\t\t\t\tif ( /\\.CUBE$/i.test( name ) ) {\n\n\t\t\t\t\t\tlutMap[ name ] = lutCubeLoader.loadAsync( 'luts/' + name );\n\n\t\t\t\t\t} else if ( /\\LUT$/i.test( name ) ) {\n\n\t\t\t\t\t\tlutMap[ name ] = lutImageLoader.loadAsync( `luts/${name}.png` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlutMap[ name ] = lut3dlLoader.loadAsync( 'luts/' + name );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst pendings = Object.values( lutMap );\n\t\t\t\tawait Promise.all( pendings );\n\n\t\t\t\tfor ( const name in lutMap ) {\n\n\t\t\t\t\tlutMap[ name ] = await lutMap[ name ];\n\n\t\t\t\t}\n\n\t\t\t\t// baked model\n\n\t\t\t\tgltfLoader.load(\n\t\t\t\t\t'./models/gltf/coffeeMug.glb',\n\t\t\t\t\t( gltf ) => {\n\n        \t\t\t\tgltf.scene.getObjectByName( 'baked' ).material.map.anisotropy = 8;\n\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst smokeGeometry = new THREE.PlaneGeometry( 1, 1, 16, 64 );\n\t\t\t\tsmokeGeometry.translate( 0, 0.5, 0 );\n\t\t\t\tsmokeGeometry.scale( 1.5, 6, 1.5 );\n\n\t\t\t\t// texture\n\n\t\t\t\tconst noiseTexture = textureLoader.load( './textures/noises/perlin/128x128.png' );\n\t\t\t\tnoiseTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tnoiseTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// material\n\n\t\t\t\tconst smokeMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, side: THREE.DoubleSide, depthWrite: false } );\n\n\t\t\t\t// position\n\n\t\t\t\tsmokeMaterial.positionNode = Fn( () => {\n\n\t\t\t\t\t// twist\n\n\t\t\t\t\tconst twistNoiseUv = vec2( 0.5, uv().y.mul( 0.2 ).sub( time.mul( 0.005 ) ).mod( 1 ) );\n\t\t\t\t\tconst twist = texture( noiseTexture, twistNoiseUv ).r.mul( 10 );\n\t\t\t\t\tpositionLocal.xz.assign( rotateUV( positionLocal.xz, twist, vec2( 0 ) ) );\n\n\t\t\t\t\t// wind\n\n\t\t\t\t\tconst windOffset = vec2(\n\t\t\t\t\t\ttexture( noiseTexture, vec2( 0.25, time.mul( 0.01 ) ).mod( 1 ) ).r.sub( 0.5 ),\n\t\t\t\t\t\ttexture( noiseTexture, vec2( 0.75, time.mul( 0.01 ) ).mod( 1 ) ).r.sub( 0.5 ),\n\t\t\t\t\t).mul( uv().y.pow( 2 ).mul( 10 ) );\n\t\t\t\t\tpositionLocal.addAssign( windOffset );\n\n\t\t\t\t\treturn positionLocal;\n\n\t\t\t\t} )();\n\n\t\t\t\t// color\n\n\t\t\t\tsmokeMaterial.colorNode = Fn( () => {\n\n\t\t\t\t\t// alpha\n\n\t\t\t\t\tconst alphaNoiseUv = uv().mul( vec2( 0.5, 0.3 ) ).add( vec2( 0, time.mul( 0.03 ).negate() ) );\n\t\t\t\t\tconst alpha = mul(\n\n\t\t\t\t\t\t// pattern\n\t\t\t\t\t\ttexture( noiseTexture, alphaNoiseUv ).r.smoothstep( 0.4, 1 ),\n\n\t\t\t\t\t\t// edges fade\n\t\t\t\t\t\tsmoothstep( 0, 0.1, uv().x ),\n\t\t\t\t\t\tsmoothstep( 0, 0.1, oneMinus( uv().x ) ),\n\t\t\t\t\t\tsmoothstep( 0, 0.1, uv().y ),\n\t\t\t\t\t\tsmoothstep( 0, 0.1, oneMinus( uv().y ) )\n\n\t\t\t\t\t);\n\n\t\t\t\t\t// color\n\n\t\t\t\t\tconst finalColor = mix( vec3( 0.6, 0.3, 0.2 ), vec3( 1, 1, 1 ), alpha.pow( 3 ) );\n\n\t\t\t\t\treturn vec4( finalColor, alpha );\n\n\t\t\t\t} )();\n\n\t\t\t\t// mesh\n\n\t\t\t\tconst smoke = new THREE.Mesh( smokeGeometry, smokeMaterial );\n\t\t\t\tsmoke.position.y = 1.83;\n\t\t\t\tscene.add( smoke );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\t// ignore default output color transform ( toneMapping and outputColorSpace )\n\t\t\t\t// use renderOutput() for control the sequence\n\n\t\t\t\tpostProcessing.outputColorTransform = false;\n\n\t\t\t\t// scene pass\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst outputPass = renderOutput( scenePass );\n\n\t\t\t\tconst lut = lutMap[ params.lut ];\n\t\t\t\tlutPass = lut3D( outputPass, texture3D( lut.texture3D ), lut.texture3D.image.width, uniform( 1 ) );\n\n\t\t\t\tpostProcessing.outputNode = lutPass;\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.target.y = 3;\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'lut', Object.keys( lutMap ) );\n\t\t\t\tgui.add( params, 'intensity' ).min( 0 ).max( 1 );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tlutPass.intensityNode.value = params.intensity;\n\n\t\t\t\tif ( lutMap[ params.lut ] ) {\n\n\t\t\t\t\tconst lut = lutMap[ params.lut ];\n\t\t\t\t\tlutPass.lutNode.value = lut.texture3D;\n\t\t\t\t\tlutPass.size.value = lut.texture3D.image.width;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - post processing - 3D LUTs Based on Three.js Journey lesson Perlin noise texture from Perlin Noise Maker , LUTs from RocketStock , FreePresets.com"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing afterimage"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing afterimage:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { instancedBufferAttribute, mod, pass, texture, float, time, vec2, vec3, vec4, sin, cos } from 'three/tsl';\n\t\t\timport { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, particles, stats;\n\t\t\tlet postProcessing, afterImagePass, scenePass;\n\n\t\t\tconst params = {\n\n\t\t\t\tdamp: 0.8,\n\t\t\t\tenabled: true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst sprite = new THREE.TextureLoader().load( 'textures/sprites/circle.png' );\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst radius = 600;\n\t\t\t\tconst count = 50000;\n\n\t\t\t\tconst vertex = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst colors = [];\n\t\t\t\tconst vertices = [];\n\t\t\t\tconst timeOffsets = [];\n\n\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tgetRandomPointOnSphere( radius, vertex );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tcolor.setHSL( i / count, 0.7, 0.7, THREE.SRGBColorSpace );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t\ttimeOffsets.push( i / count );\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( vertices ), 3 );\n\t\t\t\tconst colorAttribute = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );\n\t\t\t\tconst timeAttribute = new THREE.InstancedBufferAttribute( new Float32Array( timeOffsets ), 1 );\n\n\t\t\t\t// material and TSL\n\n\t\t\t\tconst material = new THREE.SpriteNodeMaterial( { blending: THREE.AdditiveBlending, depthWrite: false } );\n\n\t\t\t\tconst localTime = instancedBufferAttribute( timeAttribute ).add( time.mul( 0.1 ) );\n\t\t\t\tconst modTime = mod( localTime, 1.0 );\n\t\t\t\tconst accTime = modTime.mul( modTime );\n\n\t\t\t\tconst angle = accTime.mul( 40.0 );\n\t\t\t\tconst pulse = vec2( sin( angle ).mul( 20.0 ), cos( angle ).mul( 20.0 ) );\n\t\t\t\tconst pos = instancedBufferAttribute( positionAttribute );\n\n\t\t\t\tconst animated = vec3( pos.x.mul( accTime ).add( pulse.x ), pos.y.mul( accTime ).add( pulse.y ), pos.z.mul( accTime ).mul( 1.75 ) );\n\t\t\t\tconst fAlpha = modTime.oneMinus().mul( 2.0 );\n\n\t\t\t\tmaterial.colorNode = texture( sprite ).mul( vec4( instancedBufferAttribute( colorAttribute ), fAlpha ) );\n\t\t\t\tmaterial.positionNode = animated;\n\t\t\t\tmaterial.scaleNode = float( 2 );\n\n\t\t\t\tparticles = new THREE.Sprite( material );\n\t\t\t\tparticles.count = count;\n\t\t\t\tscene.add( particles );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tscenePass = pass( scene, camera );\n\n\t\t\t\tafterImagePass = afterImage( scenePass, params.damp );\n\n\t\t\t\tpostProcessing.outputNode = afterImagePass;\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI( { title: 'Damp setting' } );\n\t\t\t\tgui.add( afterImagePass.damp, 'value', 0.25, 1 );\n\t\t\t\tgui.add( params, 'enabled' ).onChange( updatePassChain );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction updatePassChain() {\n\n\t\t\t\tif ( params.enabled === true ) {\n\n\t\t\t\t\tpostProcessing.outputNode = afterImagePass;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpostProcessing.outputNode = scenePass;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.needsUpdate = true;\n\n\n\t\t\t}\n\n\n\t\t\tfunction getRandomPointOnSphere( r, v ) {\n\n\t\t\t\tconst angle = Math.random() * Math.PI * 2;\n\t\t\t\tconst u = Math.random() * 2 - 1;\n\t\t\t\n\t\t\t\tv.set(\n\t\t\t\t\tMath.cos( angle ) * Math.sqrt( 1 - Math.pow( u, 2 ) ) * r,\n\t\t\t\t\tMath.sin( angle ) * Math.sqrt( 1 - Math.pow( u, 2 ) ) * r,\n\t\t\t\t\tu * r\n\t\t\t\t);\n\t\t\t\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate( time ) {\n\n\t\t\t\tparticles.rotation.z = time * 0.001;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - postprocessing - after image Based on Particle Spiral by oosmoxiecode"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing anamorphic"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing anamorphic:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, cubeTexture, screenUV, grayscale, uniform } from 'three/tsl';\n\t\t\timport { anamorphic } from 'three/addons/tsl/display/AnamorphicNode.js';\n\n\t\t\timport { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, - 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst rgbmUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];\n\t\t\t\tconst cube1Texture = await new RGBMLoader()\n\t\t\t\t\t.setMaxRange( 16 )\n\t\t\t\t\t.setPath( './textures/cube/pisaRGBM16/' )\n\t\t\t\t\t.loadCubemapAsync( rgbmUrls );\n\n\t\t\t\tscene.environment = cube1Texture;\n\t\t\t\tscene.backgroundNode = grayscale( cubeTexture( cube1Texture ).mul( screenUV.distance( .5 ).oneMinus().remapClamp( .1, 4 ) ) );\n\n\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\tloader.load( 'DamagedHelmet.gltf', function ( gltf ) {\n\n\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\n\t\t\t\t// post-processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\n\t\t\t\tconst threshold = uniform( 1.4 );\n\t\t\t\tconst scaleNode = uniform( 5 );\n\t\t\t\tconst intensity = uniform( 1 );\n\t\t\t\tconst samples = 64;\n\n\t\t\t\tconst anamorphicPass = anamorphic( scenePass.getTextureNode(), threshold, scaleNode, samples );\n\t\t\t\tanamorphicPass.resolution = new THREE.Vector2( .2, .2 ); // 1 = full resolution\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = scenePass.add( anamorphicPass.mul( intensity ) );\n\t\t\t\t//postProcessing.outputNode = scenePass.add( anamorphicPass.getTextureNode().gaussianBlur() );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( intensity, 'value', 0, 4, 0.1 ).name( 'intensity' );\n\t\t\t\tgui.add( threshold, 'value', .8, 3, .001 ).name( 'threshold' );\n\t\t\t\tgui.add( scaleNode, 'value', 1, 10, 0.1 ).name( 'scale' );\n\t\t\t\tgui.add( anamorphicPass.resolution, 'x', .1, 1, 0.1 ).name( 'resolution' ).onChange( ( v ) => anamorphicPass.resolution.y = v );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - postprocessing anamorphic Battle Damaged Sci-fi Helmet by theblueturtle_"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - ambient occlusion"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - ambient occlusion:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, mrt, output, normalView } from 'three/tsl';\n\t\t\timport { ao } from 'three/addons/tsl/display/GTAONode.js';\n\t\t\timport { denoise } from 'three/addons/tsl/display/DenoiseNode.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, postProcessing, controls;\n\n\t\t\tlet aoPass, denoisePass, blendPassAO, blendPassDenoise, scenePassColor;\n\n\t\t\tconst params = {\n\t\t\t\tdistanceExponent: 1,\n\t\t\t\tdistanceFallOff: 1,\n\t\t\t\tradius: 0.25,\n\t\t\t\tscale: 1,\n\t\t\t\tthickness: 1,\n\t\t\t\tdenoised: false,\n\t\t\t\tenabled: true,\n\t\t\t\tdenoiseRadius: 5,\n\t\t\t\tlumaPhi: 5,\n\t\t\t\tdepthPhi: 5,\n\t\t\t\tnormalPhi: 5\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.set( 1, 1.3, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\t\t\t\tenvironment.dispose();\n\t\t\t\tpmremGenerator.dispose();\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0.5, - 1 );\n\t\t\t\tcontrols.update();\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 8;\n\n\t\t\t\t//\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput: output,\n\t\t\t\t\tnormal: normalView\n\t\t\t\t} ) );\n\n\t\t\t\tscenePassColor = scenePass.getTextureNode( 'output' );\n\t\t\t\tconst scenePassNormal = scenePass.getTextureNode( 'normal' );\n\t\t\t\tconst scenePassDepth = scenePass.getTextureNode( 'depth' );\n\n\t\t\t\t// ao\n\n\t\t\t\taoPass = ao( scenePassDepth, scenePassNormal, camera );\n\t\t\t\taoPass.resolutionScale = 0.5; // running AO in half resolution is often sufficient\n\t\t\t\tblendPassAO = aoPass.getTextureNode().mul( scenePassColor );\n\n\t\t\t\t// denoise (optional, use it if you need best quality but is has a noticeable hit on performance)\n\n\t\t\t\tdenoisePass = denoise( aoPass.getTextureNode(), scenePassDepth, scenePassNormal, camera );\n\t\t\t\tblendPassDenoise = denoisePass.mul( scenePassColor );\n\n\t\t\t\tpostProcessing.outputNode = blendPassAO;\n\n\t\t\t\t//\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\t\tloader.setPath( 'models/gltf/' );\n\n\t\t\t\tconst gltf = await loader.loadAsync( 'minimalistic_modern_bedroom.glb' );\n\n\t\t\t\tconst model = gltf.scene;\n\t\t\t\tmodel.position.set( 0, 1, 0 );\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmodel.traverse( ( o ) => {\n\n\t\t\t\t\t// Transparent objects (e.g. loaded via GLTFLoader) might have \"depthWrite\" set to \"false\".\n\t\t\t\t\t// This is wanted when rendering the beauty pass however it produces wrong results when computing\n\t\t\t\t\t// AO since depth and normal data are out of sync. Computing normals from depth by not using MRT\n\t\t\t\t\t// can mitigate the issue although the depth information (and thus the normals) are not correct in\n\t\t\t\t\t// first place. Besides, normal estimation is computationally more expensive than just sampling a\n\t\t\t\t\t// normal texture. So depending on your scene, consider to enable \"depthWrite\" for all transparent objects.\n\n\t\t\t\t\tif ( o.material ) o.material.depthWrite = true;\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.title( 'AO settings' );\n\t\t\t\tgui.add( params, 'distanceExponent' ).min( 1 ).max( 4 ).onChange( updateParameters );\n\t\t\t\tgui.add( params, 'distanceFallOff' ).min( 0.01 ).max( 1 ).onChange( updateParameters );\n\t\t\t\tgui.add( params, 'radius' ).min( 0.01 ).max( 1 ).onChange( updateParameters );\n\t\t\t\tgui.add( params, 'scale' ).min( 0.01 ).max( 2 ).onChange( updateParameters );\n\t\t\t\tgui.add( params, 'thickness' ).min( 0.01 ).max( 2 ).onChange( updateParameters );\n\t\t\t\tgui.add( params, 'enabled' ).onChange( updatePassChain );\n\t\t\t\tconst folder = gui.addFolder( 'Denoise settings' );\n\t\t\t\tfolder.add( params, 'denoiseRadius' ).min( 0.01 ).max( 10 ).name( 'radius' ).onChange( updateParameters );\n\t\t\t\tfolder.add( params, 'lumaPhi' ).min( 0.01 ).max( 10 ).onChange( updateParameters );\n\t\t\t\tfolder.add( params, 'depthPhi' ).min( 0.01 ).max( 10 ).onChange( updateParameters );\n\t\t\t\tfolder.add( params, 'normalPhi' ).min( 0.01 ).max( 10 ).onChange( updateParameters );\n\t\t\t\tfolder.add( params, 'denoised' ).name( 'enabled' ).onChange( updatePassChain );\n\n\t\t\t}\n\n\t\t\tfunction updatePassChain() {\n\n\t\t\t\tif ( params.enabled === true ) {\n\n\t\t\t\t\tif ( params.denoised === true ) {\n\n\t\t\t\t\t\tpostProcessing.outputNode = blendPassDenoise;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpostProcessing.outputNode = blendPassAO;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.needsUpdate = true;\n\n\n\t\t\t}\n\n\t\t\tfunction updateParameters() {\n\n\t\t\t\taoPass.distanceExponent.value = params.distanceExponent;\n\t\t\t\taoPass.distanceFallOff.value = params.distanceFallOff;\n\t\t\t\taoPass.radius.value = params.radius;\n\t\t\t\taoPass.scale.value = params.scale;\n\t\t\t\taoPass.thickness.value = params.thickness;\n\n\t\t\t\tdenoisePass.radius.value = params.denoiseRadius;\n\t\t\t\tdenoisePass.lumaPhi.value = params.lumaPhi;\n\t\t\t\tdenoisePass.depthPhi.value = params.depthPhi;\n\t\t\t\tdenoisePass.normalPhi.value = params.normalPhi;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - postprocessing - ambient occlusion Minimalistic Modern Bedroom by dylanheyes is licensed under Creative Commons Attribution ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing - bloom"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing - bloom:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\n\t\t\tlet camera, stats;\n\t\t\tlet postProcessing, renderer, mixer, clock;\n\n\t\t\tconst params = {\n\t\t\t\tthreshold: 0,\n\t\t\t\tstrength: 1,\n\t\t\t\tradius: 0,\n\t\t\t\texposure: 1\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( - 5, 2.5, - 3.5 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xffffff, 100 );\n\t\t\t\tcamera.add( pointLight );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/PrimaryIonDrive.glb' );\n\n\t\t\t\tconst model = gltf.scene;\n\t\t\t\tscene.add( model );\n\n\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\t\t\t\tconst clip = gltf.animations[ 0 ];\n\t\t\t\tmixer.clipAction( clip.optimize() ).play();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode( 'output' );\n\n\t\t\t\tconst bloomPass = bloom( scenePassColor );\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor.add( bloomPass );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.5;\n\t\t\t\tcontrols.minDistance = 3;\n\t\t\t\tcontrols.maxDistance = 8;\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\n\t\t\t\tbloomFolder.add( params, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {\n\n\t\t\t\t\tbloomPass.threshold.value = value;\n\n\t\t\t\t} );\n\n\t\t\t\tbloomFolder.add( params, 'strength', 0.0, 3.0 ).onChange( function ( value ) {\n\n\t\t\t\t\tbloomPass.strength.value = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'radius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\tbloomPass.radius.value = value;\n\n\t\t\t\t} );\n\n\t\t\t\tconst toneMappingFolder = gui.addFolder( 'tone mapping' );\n\n\t\t\t\ttoneMappingFolder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {\n\n\t\t\t\t\trenderer.toneMappingExposure = Math.pow( value, 4.0 );\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Bloom pass by Prashant Sharma and Ben Houston Model: Primary Ion Drive by Mike Murdock , CC Attribution."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - bloom emissive"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - bloom emissive:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, mrt, output, emissive } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 1.8, 0.6, 2.7 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'moonless_golf_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t\t// model\n\n\t\t\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\t\t\tloader.load( 'DamagedHelmet.gltf', function ( gltf ) {\n\n\t\t\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput,\n\t\t\t\t\temissive\n\t\t\t\t} ) );\n\n\t\t\t\tconst outputPass = scenePass.getTextureNode();\n\t\t\t\tconst emissivePass = scenePass.getTextureNode( 'emissive' );\n\n\t\t\t\tconst bloomPass = bloom( emissivePass, 2.5, .5 );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = outputPass.add( bloomPass );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, - 0.2 );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\t\t\t\tbloomFolder.add( bloomPass.strength, 'value', 0.0, 5.0 ).name( 'strength' );\n\t\t\t\tbloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );\n\n\t\t\t\tconst toneMappingFolder = gui.addFolder( 'tone mapping' );\n\t\t\t\ttoneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 2 ).name( 'exposure' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - bloom emissive"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - bloom selective"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - bloom selective:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, mrt, output, float, uniform } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\t// scene\n\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );\n\t\t\tcamera.position.set( 0, 0, 20 );\n\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\tconst geometry = new THREE.IcosahedronGeometry( 1, 15 );\n\n\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\tconst color = new THREE.Color();\n\t\t\t\tcolor.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );\n\n\t\t\t\tconst bloomIntensity = Math.random() > 0.5 ? 1 : 0;\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( { color: color } );\n\t\t\t\tmaterial.mrtNode = mrt( {\n\t\t\t\t\tbloomIntensity: uniform( bloomIntensity )\n\t\t\t\t} );\n\n\t\t\t\tconst sphere = new THREE.Mesh( geometry, material );\n\t\t\t\tsphere.position.x = Math.random() * 10 - 5;\n\t\t\t\tsphere.position.y = Math.random() * 10 - 5;\n\t\t\t\tsphere.position.z = Math.random() * 10 - 5;\n\t\t\t\tsphere.position.normalize().multiplyScalar( Math.random() * 4.0 + 2.0 );\n\t\t\t\tsphere.scale.setScalar( Math.random() * Math.random() + 0.5 );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t}\n\n\t\t\t// renderer\n\n\t\t\tconst renderer = new THREE.WebGPURenderer();\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t// post processing\n\n\t\t\tconst scenePass = pass( scene, camera );\n\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\toutput,\n\t\t\t\tbloomIntensity: float( 0 ) // default bloom intensity\n\t\t\t} ) );\n\n\t\t\tconst outputPass = scenePass.getTextureNode();\n\t\t\tconst bloomIntensityPass = scenePass.getTextureNode( 'bloomIntensity' );\n\n\t\t\tconst bloomPass = bloom( outputPass.mul( bloomIntensityPass ) );\n\n\t\t\tconst postProcessing = new THREE.PostProcessing( renderer );\n\t\t\tpostProcessing.outputColorTransform = false;\n\t\t\tpostProcessing.outputNode = outputPass.add( bloomPass ).renderOutput();\n\n\t\t\t// controls\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.maxPolarAngle = Math.PI * 0.5;\n\t\t\tcontrols.minDistance = 1;\n\t\t\tcontrols.maxDistance = 100;\n\n\t\t\t// raycaster\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\twindow.addEventListener( 'pointerdown', ( event ) => {\n\n\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( scene.children, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tconst material = intersects[ 0 ].object.material;\n\n\t\t\t\t\tconst bloomIntensity = material.mrtNode.get( 'bloomIntensity' );\n\t\t\t\t\tbloomIntensity.value = bloomIntensity.value === 0 ? 1 : 0;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// gui\n\n\t\t\tconst gui = new GUI();\n\n\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\t\t\tbloomFolder.add( bloomPass.threshold, 'value', 0.0, 1.0 ).name( 'threshold' );\n\t\t\tbloomFolder.add( bloomPass.strength, 'value', 0.0, 3 ).name( 'strength' );\n\t\t\tbloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );\n\n\t\t\tconst toneMappingFolder = gui.addFolder( 'tone mapping' );\n\t\t\ttoneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 3 ).name( 'exposure' );\n\n\t\t\t// events\n\n\t\t\twindow.onresize = function () {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t};\n\n\t\t\t// animate\n\n\t\t\tfunction animate() {\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - bloom selective"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - frame difference"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - frame difference:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, luminance, saturation } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst params = {\n\t\t\t\tspeed: 0\n\t\t\t};\n\n\t\t\tlet camera, renderer, postProcessing;\n\t\t\tlet timer, mesh, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );\n\t\t\t\tcamera.position.set( 1, 2, 3 );\n\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x0487e2, 7, 25 );\n\t\t\t\tscene.background = new THREE.Color( 0x0487e2 );\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/crate.gif' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\n\t\t\t\tconst currentTexture = scenePass.getTextureNode();\n\t\t\t\tconst previousTexture = scenePass.getPreviousTextureNode();\n\n\t\t\t\tconst frameDiff = previousTexture.sub( currentTexture ).abs();\n\n\t\t\t\tconst saturationAmount = luminance( frameDiff ).mul( 1000 ).clamp( 0, 3 );\n\n\t\t\t\tpostProcessing.outputNode = saturation( currentTexture, saturationAmount );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.dampingFactor = 0.01;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'speed', 0, 2 );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tmesh.rotation.y += timer.getDelta() * 5 * params.speed;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js saturated color of objects according to the difference from one frame to another"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing dof"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing dof:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { cubeTexture, positionWorld, oscSine, time, pass, uniform } from 'three/tsl';\n\t\t\timport { dof } from 'three/addons/tsl/display/DepthOfFieldNode.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\t//\n\n\t\t\tlet camera, scene, renderer, mesh, stats;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tlet windowHalfX = window.innerWidth / 2;\n\t\t\tlet windowHalfY = window.innerHeight / 2;\n\n\t\t\tlet width = window.innerWidth;\n\t\t\tlet height = window.innerHeight;\n\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, width / height, 1, 3000 );\n\t\t\t\tcamera.position.z = 200;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst xgrid = 14, ygrid = 9, zgrid = 14;\n\t\t\t\tconst count = xgrid * ygrid * zgrid;\n\n\t\t\t\tconst textureCube = new THREE.CubeTextureLoader().load( urls );\n\t\t\t\tconst cubeTextureNode = cubeTexture( textureCube );\n\t\t\t\tconst oscPos = oscSine( positionWorld.div( 1000 /* scene distance */ ).add( time.mul( .2 ) ) );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 60, 20, 10 );\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = cubeTextureNode.mul( oscPos );\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, count );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0; i < xgrid; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < ygrid; j ++ ) {\n\n\t\t\t\t\t\tfor ( let k = 0; k < zgrid; k ++ ) {\n\n\t\t\t\t\t\t\tconst x = 200 * ( i - xgrid / 2 );\n\t\t\t\t\t\t\tconst y = 200 * ( j - ygrid / 2 );\n\t\t\t\t\t\t\tconst z = 200 * ( k - zgrid / 2 );\n\n\t\t\t\t\t\t\tmesh.setMatrixAt( index, matrix.identity().setPosition( x, y, z ) );\n\t\t\t\t\t\t\tindex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst effectController = {\n\t\t\t\t\tfocus: uniform( 500.0 ),\n\t\t\t\t\taperture: uniform( 5 ),\n\t\t\t\t\tmaxblur: uniform( 0.01 )\n\t\t\t\t};\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\t\t\t\tconst scenePassViewZ = scenePass.getViewZNode();\n\n\t\t\t\tconst dofPass = dof( scenePassColor, scenePassViewZ, effectController.focus, effectController.aperture.mul( 0.00001 ), effectController.maxblur );\n\n\t\t\t\tpostProcessing.outputNode = dofPass;\n\n\t\t\t\t// controls\n\n\t\t\t\trenderer.domElement.style.touchAction = 'none';\n\t\t\t\trenderer.domElement.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( effectController.focus, 'value', 10.0, 3000.0, 10 ).name( 'focus' );\n\t\t\t\tgui.add( effectController.aperture, 'value', 0, 10, 0.1 ).name( 'aperture' );\n\t\t\t\tgui.add( effectController.maxblur, 'value', 0.0, 0.01, 0.001 ).name( 'maxblur' );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\tmouseX = event.clientX - windowHalfX;\n\t\t\t\tmouseY = event.clientY - windowHalfY;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\twindowHalfX = window.innerWidth / 2;\n\t\t\t\twindowHalfY = window.innerHeight / 2;\n\n\t\t\t\twidth = window.innerWidth;\n\t\t\t\theight = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * 0.036;\n\t\t\t\tcamera.position.y += ( - ( mouseY ) - camera.position.y ) * 0.036;\n\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing pixel"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing pixel:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\timport { uniform } from 'three/tsl';\n\t\timport { pixelationPass } from 'three/addons/tsl/display/PixelationPassNode.js';\n\n\t\tlet camera, scene, renderer, postProcessing, crystalMesh, clock;\n\t\tlet gui, effectController;\n\n\t\tinit();\n\n\t\tfunction init() {\n\n\t\t\tconst aspectRatio = window.innerWidth / window.innerHeight;\n\n\t\t\tcamera = new THREE.OrthographicCamera( - aspectRatio, aspectRatio, 1, - 1, 0.1, 10 );\n\t\t\tcamera.position.y = 2 * Math.tan( Math.PI / 6 );\n\t\t\tcamera.position.z = 2;\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x151729 );\n\n\t\t\tclock = new THREE.Clock();\n\n\t\t\t// textures\n\n\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\tconst texChecker = pixelTexture( loader.load( 'textures/checker.png' ) );\n\t\t\tconst texChecker2 = pixelTexture( loader.load( 'textures/checker.png' ) );\n\t\t\ttexChecker.repeat.set( 3, 3 );\n\t\t\ttexChecker2.repeat.set( 1.5, 1.5 );\n\n\t\t\t// meshes\n\n\t\t\tconst boxMaterial = new THREE.MeshPhongMaterial( { map: texChecker2 } );\n\n\t\t\tfunction addBox( boxSideLength, x, z, rotation ) {\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.BoxGeometry( boxSideLength, boxSideLength, boxSideLength ), boxMaterial );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tmesh.rotation.y = rotation;\n\t\t\t\tmesh.position.y = boxSideLength / 2;\n\t\t\t\tmesh.position.set( x, boxSideLength / 2 + .0001, z );\n\t\t\t\tscene.add( mesh );\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\taddBox( .4, 0, 0, Math.PI / 4 );\n\t\t\taddBox( .5, - .5, - .5, Math.PI / 4 );\n\n\t\t\tconst planeSideLength = 2;\n\t\t\tconst planeMesh = new THREE.Mesh(\n\t\t\t\tnew THREE.PlaneGeometry( planeSideLength, planeSideLength ),\n\t\t\t\tnew THREE.MeshPhongMaterial( { map: texChecker } )\n\t\t\t);\n\t\t\tplaneMesh.receiveShadow = true;\n\t\t\tplaneMesh.rotation.x = - Math.PI / 2;\n\t\t\tscene.add( planeMesh );\n\n\t\t\tconst radius = .2;\n\t\t\tconst geometry = new THREE.IcosahedronGeometry( radius );\n\t\t\tcrystalMesh = new THREE.Mesh(\n\t\t\t\tgeometry,\n\t\t\t\tnew THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x68b7e9,\n\t\t\t\t\temissive: 0x4f7e8b,\n\t\t\t\t\tshininess: 10,\n\t\t\t\t\tspecular: 0xffffff\n\t\t\t\t} )\n\t\t\t);\n\t\t\tcrystalMesh.receiveShadow = true;\n\t\t\tcrystalMesh.castShadow = true;\n\t\t\tscene.add( crystalMesh );\n\n\t\t\t// lights\n\n\t\t\tscene.add( new THREE.AmbientLight( 0x757f8e, 3 ) );\n\n\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xfffecd, 1.5 );\n\t\t\tdirectionalLight.position.set( 100, 100, 100 );\n\t\t\tdirectionalLight.castShadow = true;\n\t\t\tdirectionalLight.shadow.mapSize.set( 2048, 2048 );\n\t\t\tdirectionalLight.shadow.bias = - 0.0001;\n\t\t\tscene.add( directionalLight );\n\n\t\t\tconst spotLight = new THREE.SpotLight( 0xffc100, 10, 10, Math.PI / 16, .02, 2 );\n\t\t\tspotLight.position.set( 2, 2, 0 );\n\t\t\tconst target = spotLight.target;\n\t\t\tscene.add( target );\n\t\t\ttarget.position.set( 0, 0, 0 );\n\t\t\tspotLight.castShadow = true;\n\t\t\tspotLight.shadow.bias = - 0.001;\n\t\t\tscene.add( spotLight );\n\n\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\trenderer.shadowMap.type = THREE.BasicShadowMap;\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\teffectController = {\n\t\t\t\tpixelSize: uniform( 6 ),\n\t\t\t\tnormalEdgeStrength: uniform( 0.3 ),\n\t\t\t\tdepthEdgeStrength: uniform( 0.4 ),\n\t\t\t\tpixelAlignedPanning: true\n\t\t\t};\n\n\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\tconst scenePass = pixelationPass( scene, camera, effectController.pixelSize, effectController.normalEdgeStrength, effectController.depthEdgeStrength );\n\t\t\tpostProcessing.outputNode = scenePass;\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.maxZoom = 2;\n\n\t\t\t// gui\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( effectController.pixelSize, 'value', 1, 16, 1 ).name( 'Pixel Size' );\n\t\t\tgui.add( effectController.normalEdgeStrength, 'value', 0, 2, 0.05 ).name( 'Normal Edge Strength' );\n\t\t\tgui.add( effectController.depthEdgeStrength, 'value', 0, 1, 0.05 ).name( 'Depth Edge Strength' );\n\t\t\tgui.add( effectController, 'pixelAlignedPanning' );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tconst aspectRatio = window.innerWidth / window.innerHeight;\n\t\t\tcamera.left = - aspectRatio;\n\t\t\tcamera.right = aspectRatio;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst t = clock.getElapsedTime();\n\n\t\t\tcrystalMesh.material.emissiveIntensity = Math.sin( t * 3 ) * .5 + .5;\n\t\t\tcrystalMesh.position.y = .7 + Math.sin( t * 2 ) * .05;\n\t\t\tcrystalMesh.rotation.y = stopGoEased( t, 2, 4 ) * 2 * Math.PI;\n\n\t\t\tconst rendererSize = renderer.getSize( new THREE.Vector2() );\n\t\t\tconst aspectRatio = rendererSize.x / rendererSize.y;\n\n\t\t\tif ( effectController.pixelAlignedPanning ) {\n\n\t\t\t\tconst pixelSize = effectController.pixelSize.value;\n\n\t\t\t\tpixelAlignFrustum( camera, aspectRatio, Math.floor( rendererSize.x / pixelSize ),\n\t\t\t\t\tMath.floor( rendererSize.y / pixelSize ) );\n\n\t\t\t} else if ( camera.left != - aspectRatio || camera.top != 1.0 ) {\n\n\t\t\t\t// Reset the Camera Frustum if it has been modified\n\t\t\t\tcamera.left = - aspectRatio;\n\t\t\t\tcamera.right = aspectRatio;\n\t\t\t\tcamera.top = 1.0;\n\t\t\t\tcamera.bottom = - 1.0;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tpostProcessing.render();\n\n\t\t}\n\n\t\t// Helper functions\n\n\t\tfunction pixelTexture( texture ) {\n\n\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\ttexture.generateMipmaps = false;\n\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction easeInOutCubic( x ) {\n\n\t\t\treturn x ** 2 * 3 - x ** 3 * 2;\n\n\t\t}\n\n\t\tfunction linearStep( x, edge0, edge1 ) {\n\n\t\t\tconst w = edge1 - edge0;\n\t\t\tconst m = 1 / w;\n\t\t\tconst y0 = - m * edge0;\n\t\t\treturn THREE.MathUtils.clamp( y0 + m * x, 0, 1 );\n\n\t\t}\n\n\t\tfunction stopGoEased( x, downtime, period ) {\n\n\t\t\tconst cycle = ( x / period ) | 0;\n\t\t\tconst tween = x - cycle * period;\n\t\t\tconst linStep = easeInOutCubic( linearStep( tween, downtime, period ) );\n\t\t\treturn cycle + linStep;\n\n\t\t}\n\n\t\tfunction pixelAlignFrustum( camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight ) {\n\n\t\t\t// 0. Get Pixel Grid Units\n\t\t\tconst worldScreenWidth = ( ( camera.right - camera.left ) / camera.zoom );\n\t\t\tconst worldScreenHeight = ( ( camera.top - camera.bottom ) / camera.zoom );\n\t\t\tconst pixelWidth = worldScreenWidth / pixelsPerScreenWidth;\n\t\t\tconst pixelHeight = worldScreenHeight / pixelsPerScreenHeight;\n\n\t\t\t// 1. Project the current camera position along its local rotation bases\n\t\t\tconst camPos = new THREE.Vector3(); camera.getWorldPosition( camPos );\n\t\t\tconst camRot = new THREE.Quaternion(); camera.getWorldQuaternion( camRot );\n\t\t\tconst camRight = new THREE.Vector3( 1.0, 0.0, 0.0 ).applyQuaternion( camRot );\n\t\t\tconst camUp = new THREE.Vector3( 0.0, 1.0, 0.0 ).applyQuaternion( camRot );\n\t\t\tconst camPosRight = camPos.dot( camRight );\n\t\t\tconst camPosUp = camPos.dot( camUp );\n\n\t\t\t// 2. Find how far along its position is along these bases in pixel units\n\t\t\tconst camPosRightPx = camPosRight / pixelWidth;\n\t\t\tconst camPosUpPx = camPosUp / pixelHeight;\n\n\t\t\t// 3. Find the fractional pixel units and convert to world units\n\t\t\tconst fractX = camPosRightPx - Math.round( camPosRightPx );\n\t\t\tconst fractY = camPosUpPx - Math.round( camPosUpPx );\n\n\t\t\t// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid\n\t\t\tcamera.left = - aspectRatio - ( fractX * pixelWidth );\n\t\t\tcamera.right = aspectRatio - ( fractX * pixelWidth );\n\t\t\tcamera.top = 1.0 - ( fractY * pixelHeight );\n\t\t\tcamera.bottom = - 1.0 - ( fractY * pixelHeight );\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n```\n\nThis example three.js - Node based pixelation pass with optional single pixel outlines by Kody King"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - FXAA"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - FXAA:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, renderOutput } from 'three/tsl';\n\t\t\timport { fxaa } from 'three/addons/tsl/display/FXAANode.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst params = {\n\t\t\t\tenabled: true,\n\t\t\t\tanimated: false\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer, clock, group;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );\n\t\t\t\tcamera.position.z = 50;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d );\n\t\t\t\themiLight.position.set( 0, 1000, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 3000, 1000, - 1000 );\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t//\n\n\t\t\t\tgroup = new THREE.Group();\n\n\t\t\t\tconst geometry = new THREE.TetrahedronGeometry();\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xf73232, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tmesh.position.x = Math.random() * 50 - 25;\n\t\t\t\t\tmesh.position.y = Math.random() * 50 - 25;\n\t\t\t\t\tmesh.position.z = Math.random() * 50 - 25;\n\n\t\t\t\t\tmesh.scale.setScalar( Math.random() * 2 + 1 );\n\n\t\t\t\t\tmesh.rotation.x = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.y = Math.random() * Math.PI;\n\t\t\t\t\tmesh.rotation.z = Math.random() * Math.PI;\n\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\t// ignore default output color transform ( toneMapping and outputColorSpace )\n\t\t\t\t// use renderOutput() for control the sequence\n\n\t\t\t\tpostProcessing.outputColorTransform = false;\n\n\t\t\t\t// scene pass\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst outputPass = renderOutput( scenePass );\n\n\t\t\t\t// FXAA must be computed in sRGB color space (so after tone mapping and color space conversion)\n\n\t\t\t\tconst fxaaPass = fxaa( outputPass );\n\t\t\t\tpostProcessing.outputNode = fxaaPass;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.title( 'FXAA settings' );\n\t\t\t\tgui.add( params, 'enabled' ).onChange( ( value ) => {\n\t\t\t\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tpostProcessing.outputNode = fxaaPass;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpostProcessing.outputNode = outputPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'animated' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( params.animated === true ) {\n\n\t\t\t\t\tgroup.rotation.y += delta * 0.1;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing lensflares"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing lensflares:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, mrt, output, emissive, uniform } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\t\t\timport { lensflare } from 'three/addons/tsl/display/LensflareNode.js';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, controls, stats;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0.5, - 0.5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst texture = await new UltraHDRLoader().loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\tscene.backgroundIntensity = 2;\n\t\t\t\tscene.environmentIntensity = 15;\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/space_ship_hallway.glb' );\n\n\t\t\t\tconst object = gltf.scene;\n\n\t\t\t\tconst aabb = new THREE.Box3().setFromObject( object );\n\t\t\t\tconst center = aabb.getCenter( new THREE.Vector3() );\n\n\t\t\t\tobject.position.x += ( object.position.x - center.x );\n\t\t\t\tobject.position.y += ( object.position.y - center.y );\n\t\t\t\tobject.position.z += ( object.position.z - center.z );\n\n\t\t\t\tscene.add( object );\n\t\t\t\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput,\n\t\t\t\t\temissive\n\t\t\t\t} ) );\n\n\t\t\t\tconst outputPass = scenePass.getTextureNode();\n\t\t\t\tconst emissivePass = scenePass.getTextureNode( 'emissive' );\n\n\t\t\t\tconst bloomPass = bloom( emissivePass, 1, 1 );\n\n\t\t\t\tconst threshold = uniform( 0.5 );\n\t\t\t\tconst ghostAttenuationFactor = uniform( 25 );\n\t\t\t\tconst ghostSpacing = uniform( 0.25 );\n\n\t\t\t\tconst flarePass = lensflare( bloomPass, {\n\t\t\t\t\tthreshold,\n\t\t\t\t\tghostAttenuationFactor,\n\t\t\t\t\tghostSpacing\n\t\t\t\t} );\n\n\t\t\t\tconst blurPass = gaussianBlur( flarePass, 8 ); // optional (blurring produces better flare quality but also adds some overhead)\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = outputPass.add( bloomPass ).add( blurPass );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.target.copy( camera.position );\n\t\t\t\tcontrols.target.z -= 0.01;\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\t\t\t\tbloomFolder.add( bloomPass.strength, 'value', 0.0, 2.0 ).name( 'strength' );\n\t\t\t\tbloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );\n\t\t\t\n\t\t\t\tconst lensflareFolder = gui.addFolder( 'lensflare' );\n\t\t\t\tlensflareFolder.add( threshold, 'value', 0.0, 1.0 ).name( 'threshold' );\n\t\t\t\tlensflareFolder.add( ghostAttenuationFactor, 'value', 10.0, 50.0 ).name( 'attenuation' );\n\t\t\t\tlensflareFolder.add( ghostSpacing, 'value', 0.0, 0.3 ).name( 'spacing' );\n\n\t\t\t\tconst toneMappingFolder = gui.addFolder( 'tone mapping' );\n\t\t\t\ttoneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 2 ).name( 'exposure' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - postprocessing lensflares Space Ship Hallway by yeeyeeman is licensed under Creative Commons Attribution . Ice Planet Close from Space Spheremaps ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - masking"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - masking:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, texture } from 'three/tsl';\n\n\t\t\tlet camera, postProcessing, renderer;\n\t\t\tlet box, torus;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// scene\n\n\t\t\t\tconst baseScene = new THREE.Scene();\n\t\t\t\tbaseScene.background = new THREE.Color( 0xe0e0e0 );\n\n\t\t\t\tconst maskScene1 = new THREE.Scene();\n\t\t\t\tbox = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ) );\n\t\t\t\tmaskScene1.add( box );\n\n\t\t\t\tconst maskScene2 = new THREE.Scene();\n\t\t\t\ttorus = new THREE.Mesh( new THREE.TorusGeometry( 3, 1, 16, 32 ) );\n\t\t\t\tmaskScene2.add( torus );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\t// textures\n\n\t\t\t\tconst texture1 = new THREE.TextureLoader().load( 'textures/758px-Canestra_di_frutta_(Caravaggio).jpg' );\n\t\t\t\ttexture1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture1.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture1.generateMipmaps = false;\n\t\t\t\ttexture1.flipY = false;\n\n\t\t\t\tconst texture2 = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );\n\t\t\t\ttexture2.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture2.flipY = false;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst base = pass( baseScene, camera );\n\t\t\t\tconst sceneMask1 = pass( maskScene1, camera ).a;\n\t\t\t\tconst sceneMask2 = pass( maskScene2, camera ).a;\n\n\t\t\t\tlet compose = base;\n\t\t\t\tcompose = sceneMask1.mix( compose, texture( texture1 ) );\n\t\t\t\tcompose = sceneMask2.mix( compose, texture( texture2 ) );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = compose;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() * 0.001 + 6000;\n\n\t\t\t\tbox.position.x = Math.cos( time / 1.5 ) * 2;\n\t\t\t\tbox.position.y = Math.sin( time ) * 2;\n\t\t\t\tbox.rotation.x = time;\n\t\t\t\tbox.rotation.y = time / 2;\n\n\t\t\t\ttorus.position.x = Math.cos( time ) * 2;\n\t\t\t\ttorus.position.y = Math.sin( time / 1.5 ) * 2;\n\t\t\t\ttorus.rotation.x = time;\n\t\t\t\ttorus.rotation.y = time / 2;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - chromatic aberration"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - chromatic aberration:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, renderOutput, uniform } from 'three/tsl';\n\n\t\t\timport { chromaticAberration } from 'three/addons/tsl/display/ChromaticAberrationNode.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst params = {\n\t\t\t\tenabled: true,\n\t\t\t\tanimated: true,\n\t\t\t\tstrength: 1.5,\n\t\t\t\tcenter: new THREE.Vector2(0.5, 0.5),\n\t\t\t\tscale: 1.2,\n\t\t\t\tautoRotate: true,\n\t\t\t\tcameraDistance: 40\n\t\t\t};\n\n\t\t\tlet camera, scene, renderer, clock, mainGroup;\n\t\t\tlet postProcessing;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );\n\t\t\t\tcamera.position.set( 0, 15, params.cameraDistance );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x0a0a0a );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// Lighting\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 0.3 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst dirLight1 = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tdirLight1.position.set( 10, 20, 10 );\n\t\t\t\tscene.add( dirLight1 );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0x4080ff, 0.5 );\n\t\t\t\tdirLight2.position.set( -10, 20, -10 );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tconst pointLight = new THREE.PointLight( 0xff4080, 1, 50 );\n\t\t\t\tpointLight.position.set( 0, 10, 0 );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\t// Create main group\n\t\t\t\tmainGroup = new THREE.Group();\n\t\t\t\tscene.add( mainGroup );\n\n\t\t\t\t// Create shapes\n\t\t\t\tcreateShapes();\n\n\t\t\t\t// Add a grid for reference\n\t\t\t\tconst gridHelper = new THREE.GridHelper( 40, 20, 0x444444, 0x222222 );\n\t\t\t\tgridHelper.position.y = -10;\n\t\t\t\tscene.add( gridHelper );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputColorTransform = false;\n\n\t\t\t\t// scene pass\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst outputPass = renderOutput( scenePass );\n\n\t\t\t\t// Create uniform nodes for the static version that can be updated\n\t\t\t\tconst staticStrength = uniform( params.strength );\n\t\t\t\tconst staticCenter = uniform( new THREE.Vector2( params.center.x, params.center.y ) );\n\t\t\t\tconst staticScale = uniform( params.scale );\n\n\t\t\t\t// With static values (using uniform nodes)\n\t\t\t\tconst caPass = chromaticAberration( outputPass, staticStrength, staticCenter, staticScale );\n\n\t\t\t\t// Set initial output based on params\n\t\t\t\tpostProcessing.outputNode = params.enabled ? caPass : outputPass;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.title( 'Chromatic Aberration' );\n\n\t\t\t\tgui.add( params, 'enabled' ).onChange( ( value ) => {\n\n\t\t\t\t\tpostProcessing.outputNode = value ? caPass : outputPass;\n\t\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst staticFolder = gui.addFolder( 'Static Parameters' );\n\n\t\t\t\tstaticFolder.add( staticStrength, 'value', 0, 3 ).name( 'Strength' );\n\t\t\t\tstaticFolder.add( staticCenter.value, 'x', - 1, 1 ).name( 'Center X' );\n\t\t\t\tstaticFolder.add( staticCenter.value, 'y', - 1, 1 ).name( 'Center Y' );\n\t\t\t\tstaticFolder.add( staticScale, 'value', 0.5, 2 ).name( 'Scale' );\n\n\t\t\t\tconst animationFolder = gui.addFolder( 'Animation' );\n\t\t\t\tanimationFolder.add( params, 'animated' );\n\t\t\t\tanimationFolder.add( params, 'autoRotate' );\n\t\t\t\tanimationFolder.add( params, 'cameraDistance', 20, 60 ).onChange( ( value ) => {\n\n\t\t\t\t    camera.position.z = value;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction createShapes() {\n\n\t\t\t\tconst shapes = [];\n\t\t\t\tconst materials = [];\n\n\t\t\t\t// Define colors for different materials\n\t\t\t\tconst colors = [\n\t\t\t\t\t0xff0000, // Red\n\t\t\t\t\t0x00ff00, // Green\n\t\t\t\t\t0x0000ff, // Blue\n\t\t\t\t\t0xffff00, // Yellow\n\t\t\t\t\t0xff00ff, // Magenta\n\t\t\t\t\t0x00ffff, // Cyan\n\t\t\t\t\t0xffffff, // White\n\t\t\t\t\t0xff8800  // Orange\n\t\t\t\t];\n\n\t\t\t\t// Create materials\n\t\t\t\tcolors.forEach( color => {\n\n\t\t\t\t\tmaterials.push( new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: color,\n\t\t\t\t\t\troughness: 0.2,\n\t\t\t\t\t\tmetalness: 0.8\n\t\t\t\t\t} ) );\n\n\t\t\t\t});\n\n\t\t\t\t// Create geometries\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.BoxGeometry( 3, 3, 3 ),\n\t\t\t\t\tnew THREE.SphereGeometry( 2, 32, 16 ),\n\t\t\t\t\tnew THREE.ConeGeometry( 2, 4, 8 ),\n\t\t\t\t\tnew THREE.CylinderGeometry( 1.5, 1.5, 4, 8 ),\n\t\t\t\t\tnew THREE.TorusGeometry( 2, 0.8, 8, 16 ),\n\t\t\t\t\tnew THREE.OctahedronGeometry( 2.5 ),\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 2.5 ),\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 1.5, 0.5, 64, 8 )\n\t\t\t\t];\n\n\t\t\t\t// Create central showcase\n\t\t\t\tconst centralGroup = new THREE.Group();\n\n\t\t\t\t// Large central torus\n\t\t\t\tconst centralTorus = new THREE.Mesh(\n\t\t\t\t\tnew THREE.TorusGeometry( 5, 1.5, 16, 32 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\troughness: 0.1,\n\t\t\t\t\t\tmetalness: 1,\n\t\t\t\t\t\temissive: 0x222222\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tcentralGroup.add( centralTorus );\n\n\t\t\t\t// Inner rotating shapes\n\t\t\t\tfor ( let i = 0; i < 6; i++ ) {\n\n\t\t\t\t\tconst angle = ( i / 6 ) * Math.PI * 2;\n\t\t\t\t\tconst radius = 3;\n\n\t\t\t\t\tconst mesh = new THREE.Mesh(\n\t\t\t\t\t\tgeometries[ i % geometries.length ],\n\t\t\t\t\t\tmaterials[ i % materials.length ]\n\t\t\t\t\t);\n\n\t\t\t\t\tmesh.position.set(\n\t\t\t\t\t\tMath.cos( angle ) * radius,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tMath.sin( angle ) * radius\n\t\t\t\t\t);\n\n\t\t\t\t\tmesh.scale.setScalar( 0.5 );\n\t\t\t\t\tcentralGroup.add( mesh );\n\t\t\t\t\tshapes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tmainGroup.add( centralGroup );\n\t\t\t\tshapes.push( centralGroup );\n\n\t\t\t\t// Create outer ring of shapes\n\t\t\t\tconst numShapes = 12;\n\t\t\t\tconst outerRadius = 15;\n\n\t\t\t\tfor ( let i = 0; i < numShapes; i++ ) {\n\n\t\t\t\t\tconst angle = ( i / numShapes ) * Math.PI * 2;\n\t\t\t\t\tconst shapesGroup = new THREE.Group();\n\n\t\t\t\t\tconst geometry = geometries[ i % geometries.length ];\n\t\t\t\t\tconst material = materials[ i % materials.length ];\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.receiveShadow = true;\n\n\t\t\t\t\tshapesGroup.add( mesh );\n\t\t\t\t\tshapesGroup.position.set(\n\t\t\t\t\t\tMath.cos( angle ) * outerRadius,\n\t\t\t\t\t\tMath.sin( i * 0.5 ) * 2,\n\t\t\t\t\t\tMath.sin( angle ) * outerRadius\n\t\t\t\t\t);\n\n\t\t\t\t\tmainGroup.add( shapesGroup );\n\t\t\t\t\tshapes.push( shapesGroup );\n\n\t\t\t\t}\n\n\t\t\t\t// Add floating particles\n\t\t\t\tconst particlesGeometry = new THREE.BufferGeometry();\n\t\t\t\tconst particlesCount = 200;\n\t\t\t\tconst positions = new Float32Array( particlesCount * 3 );\n\n\t\t\t\tfor ( let i = 0; i < particlesCount * 3; i += 3 ) {\n\n\t\t\t\t\tconst radius = 25 + Math.random() * 10;\n\t\t\t\t\tconst theta = Math.random() * Math.PI * 2;\n\t\t\t\t\tconst phi = Math.random() * Math.PI;\n\n\t\t\t\t\tpositions[ i ] = radius * Math.sin( phi ) * Math.cos( theta );\n\t\t\t\t\tpositions[ i + 1 ] = radius * Math.cos( phi );\n\t\t\t\t\tpositions[ i + 2 ] = radius * Math.sin( phi ) * Math.sin( theta );\n\n\t\t\t\t}\n\n\t\t\t\tparticlesGeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\t\t\t\tconst particlesMaterial = new THREE.PointsMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tsize: 0.5,\n\t\t\t\t\tsizeAttenuation: true\n\t\t\t\t} );\n\n\t\t\t\tconst particles = new THREE.Points( particlesGeometry, particlesMaterial );\n\t\t\t\tmainGroup.add( particles );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\t\tif ( params.animated ) {\n\n\t\t\t\t\t// Animate individual shapes\n\t\t\t\t\tmainGroup.children.forEach( ( child, index ) => {\n\n\t\t\t\t\t\tif ( child.children.length > 0 ) {\n\n\t\t\t\t\t\t\t// Central group\n\t\t\t\t\t\t\tchild.rotation.y = time * 0.5;\n\t\t\t\t\t\t\tchild.children.forEach( ( subChild, subIndex ) => {\n\n\t\t\t\t\t\t\t\tif ( subChild.geometry ) {\n\n\t\t\t\t\t\t\t\t\tsubChild.rotation.x = time * ( 1 + subIndex * 0.1 );\n\t\t\t\t\t\t\t\t\tsubChild.rotation.z = time * ( 1 - subIndex * 0.1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else if ( child.type === 'Group' ) {\n\n\t\t\t\t\t\t\t// Outer shapes\n\t\t\t\t\t\t\tchild.rotation.x = time * 0.5 + index;\n\t\t\t\t\t\t\tchild.rotation.y = time * 0.3 + index;\n\t\t\t\t\t\t\tchild.position.y = Math.sin( time + index ) * 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.autoRotate ) {\n\n\t\t\t\t\tconst radius = params.cameraDistance;\n\t\t\t\t\tcamera.position.x = Math.sin( time * 0.1 ) * radius;\n\t\t\t\t\tcamera.position.z = Math.cos( time * 0.1 ) * radius;\n\t\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\t\t\t}\n```\n\nThis example three.js webgpu - chromatic aberration"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - motion blur"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - motion blur:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, texture, uniform, output, mrt, mix, velocity, uv, screenUV } from 'three/tsl';\n\t\t\timport { motionBlur } from 'three/addons/tsl/display/MotionBlur.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet boxLeft, boxRight, model, mixer, clock;\n\t\t\tlet postProcessing;\n\t\t\tlet controls;\n\t\t\tlet stats;\n\n\t\t\tconst params = {\n\t\t\t\tspeed: 1.0\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );\n\t\t\t\tcamera.position.set( 0, 1.5, 4.5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x0487e2, 7, 25 );\n\n\t\t\t\tconst sunLight = new THREE.DirectionalLight( 0xFFE499, 5 );\n\t\t\t\tsunLight.castShadow = true;\n\t\t\t\tsunLight.shadow.camera.near = .1;\n\t\t\t\tsunLight.shadow.camera.far = 10;\n\t\t\t\tsunLight.shadow.camera.right = 2;\n\t\t\t\tsunLight.shadow.camera.left = - 2;\n\t\t\t\tsunLight.shadow.camera.top = 2;\n\t\t\t\tsunLight.shadow.camera.bottom = - 2;\n\t\t\t\tsunLight.shadow.mapSize.width = 2048;\n\t\t\t\tsunLight.shadow.mapSize.height = 2048;\n\t\t\t\tsunLight.shadow.bias = - 0.001;\n\t\t\t\tsunLight.position.set( 4, 4, 2 );\n\n\t\t\t\tconst waterAmbientLight = new THREE.HemisphereLight( 0x333366, 0x74ccf4, 5 );\n\t\t\t\tconst skyAmbientLight = new THREE.HemisphereLight( 0x74ccf4, 0, 1 );\n\n\t\t\t\tscene.add( sunLight );\n\t\t\t\tscene.add( skyAmbientLight );\n\t\t\t\tscene.add( waterAmbientLight );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// animated model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Xbot.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\n\t\t\t\t\tmodel.rotation.y = Math.PI / 2;\n\n\t\t\t\t\tmodel.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 3 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst floorColor = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tfloorColor.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorColor.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorColor.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorNormal.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorNormal.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// floor\n\n\t\t\t\tconst floorUV = uv().mul( 5 );\n\n\t\t\t\tconst floorMaterial = new THREE.MeshPhongNodeMaterial();\n\t\t\t\tfloorMaterial.colorNode = texture( floorColor, floorUV );\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 15, .001, 15 ), floorMaterial );\n\t\t\t\tfloor.receiveShadow = true;\n\n\t\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tconst walls = new THREE.Mesh( new THREE.BoxGeometry( 15, 15, 15 ), new THREE.MeshPhongNodeMaterial( { colorNode: floorMaterial.colorNode, side: THREE.BackSide } ) );\n\t\t\t\tscene.add( walls );\n\n\t\t\t\tconst map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\tmap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst geometry = new THREE.TorusGeometry( .8 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map } );\n\n\t\t\t\tboxRight = new THREE.Mesh( geometry, material );\n\t\t\t\tboxRight.position.set( 3.5, 1.5, - 4 );\n\t\t\t\tscene.add( boxRight );\n\n\t\t\t\tboxLeft = new THREE.Mesh( geometry, material );\n\t\t\t\tboxLeft.position.set( - 3.5, 1.5, - 4 );\n\t\t\t\tscene.add( boxLeft );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = 1;\n\t\t\t\tcontrols.target.set( 0, 1, 0 );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// post-processing\n\n\t\t\t\tconst blurAmount = uniform( 1 );\n\t\t\t\tconst showVelocity = uniform( 0 );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput,\n\t\t\t\t\tvelocity\n\t\t\t\t} ) );\n\n\t\t\t\tconst beauty = scenePass.getTextureNode();\n\t\t\t\tconst vel = scenePass.getTextureNode( 'velocity' ).mul( blurAmount );\n\n\t\t\t\tconst mBlur = motionBlur( beauty, vel );\n\n\t\t\t\tconst vignette = screenUV.distance( .5 ).remap( .6, 1 ).mul( 2 ).clamp().oneMinus();\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = mix( mBlur, vel, showVelocity ).mul( vignette );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.title( 'Motion Blur Settings' );\n\t\t\t\tgui.add( controls, 'autoRotate' );\n\t\t\t\tgui.add( blurAmount, 'value', 0, 3 ).name( 'blur amount' );\n\t\t\t\tgui.add( params, 'speed', 0, 2 );\n\t\t\t\tgui.add( showVelocity, 'value', 0, 1 ).name( 'show velocity' );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst delta = clock.getDelta();\n\t\t\t\tconst speed = params.speed;\n\n\t\t\t\tboxRight.rotation.y += delta * 4 * speed;\n\t\t\t\tboxLeft.scale.setScalar( 1 + Math.sin( clock.elapsedTime * 10 * speed ) * .2 );\n\n\t\t\t\tif ( model ) {\n\n\t\t\t\t\tmixer.update( delta * speed );\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - motion blur"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - post processing - Outline Pass"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - post processing - Outline Pass:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, uniform, time, oscSine } from 'three/tsl';\n\t\t\timport { outline } from 'three/addons/tsl/display/OutlineNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet postProcessing, outlinePass;\n\n\t\t\tlet selectedObjects = [];\n\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tconst obj3d = new THREE.Object3D();\n\t\t\tconst group = new THREE.Group();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 8 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 20;\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa, 0.6 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xddffdd, 2 );\n\t\t\t\tlight.position.set( 5, 5, 5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.mapSize.width = 2048;\n\t\t\t\tlight.shadow.mapSize.height = 2048;\n\t\t\t\tlight.shadow.bias = - 0.005;\n\n\t\t\t\tconst d = 10;\n\n\t\t\t\tlight.shadow.camera.left = - d;\n\t\t\t\tlight.shadow.camera.right = d;\n\t\t\t\tlight.shadow.camera.top = d;\n\t\t\t\tlight.shadow.camera.bottom = - d;\n\t\t\t\tlight.shadow.camera.far = 25;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// model\n\n\t\t\t\tconst loader = new OBJLoader();\n\t\t\t\tloader.load( 'models/obj/tree.obj', function ( object ) {\n\n\t\t\t\t\tlet scale = 1.0;\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child instanceof THREE.Mesh ) {\n\n\t\t\t\t\t\t\tchild.geometry.center();\n\t\t\t\t\t\t\tchild.geometry.computeBoundingSphere();\n\t\t\t\t\t\t\tscale = 0.2 * child.geometry.boundingSphere.radius;\n\n\t\t\t\t\t\t\tconst phongMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shininess: 5 } );\n\t\t\t\t\t\t\tchild.material = phongMaterial;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\t\t\t\t\t\t\tchild.castShadow = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tobject.position.y = 1;\n\t\t\t\t\tobject.scale.divideScalar( scale );\n\t\t\t\t\tobj3d.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\tgroup.add( obj3d );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 3, 48, 24 );\n\n\t\t\t\tfor ( let i = 0; i < 20; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 1.0, 0.3 );\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.y = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.position.z = Math.random() * 4 - 2;\n\t\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\t\tmesh.castShadow = true;\n\t\t\t\t\tmesh.scale.multiplyScalar( Math.random() * 0.3 + 0.1 );\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tconst floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 12, 12 );\n\t\t\t\tconst floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloorMesh.rotation.x -= Math.PI * 0.5;\n\t\t\t\tfloorMesh.position.y -= 1.5;\n\t\t\t\tgroup.add( floorMesh );\n\t\t\t\tfloorMesh.receiveShadow = true;\n\n\t\t\t\tconst torusGeometry = new THREE.TorusGeometry( 1, 0.3, 16, 100 );\n\t\t\t\tconst torusMaterial = new THREE.MeshPhongMaterial( { color: 0xffaaff } );\n\t\t\t\tconst torus = new THREE.Mesh( torusGeometry, torusMaterial );\n\t\t\t\ttorus.position.z = - 4;\n\t\t\t\tgroup.add( torus );\n\t\t\t\ttorus.receiveShadow = true;\n\t\t\t\ttorus.castShadow = true;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\t// outline pass\n\n\t\t\t\tconst edgeStrength = uniform( 3.0 );\n\t\t\t\tconst edgeGlow = uniform( 0.0 );\n\t\t\t\tconst edgeThickness = uniform( 1.0 );\n\t\t\t\tconst pulsePeriod = uniform( 0 );\n\t\t\t\tconst visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );\n\t\t\t\tconst hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );\n\n\t\t\t\toutlinePass = outline( scene, camera, {\n\t\t\t\t\tselectedObjects,\n\t\t\t\t\tedgeGlow,\n\t\t\t\t\tedgeThickness\n\t\t\t\t} );\n\n\t\t\t\tconst { visibleEdge, hiddenEdge } = outlinePass;\n\n\t\t\t\tconst period = time.div( pulsePeriod ).mul( 2 );\n\t\t\t\tconst osc = oscSine( period ).mul( .5 ).add( .5 ); // osc [ 0.5, 1.0 ]\n\n\t\t\t\tconst outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );\n\t\t\t\tconst outlinePulse = pulsePeriod.greaterThan( 0 ).select( outlineColor.mul( osc ), outlineColor );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = outlinePulse.add( scenePass );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI( { width: 280 } );\n\t\t\t\tgui.add( edgeStrength, 'value', 0.01, 10 ).name( 'edgeStrength' );\n\t\t\t\tgui.add( edgeGlow, 'value', 0.0, 1 ).name( 'edgeGlow' );\n\t\t\t\tgui.add( edgeThickness, 'value', 1, 4 ).name( 'edgeThickness' );\n\t\t\t\tgui.add( pulsePeriod, 'value', 0.0, 5 ).name( 'pulsePeriod' );\n\t\t\t\tgui.addColor( { color: visibleEdgeColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' ).onChange( ( value ) => {\n\n\t\t\t\t\tvisibleEdgeColor.value.set( value );\n\n\t\t\t\t} ).name( 'visibleEdgeColor' );\n\t\t\t\tgui.addColor( { color: hiddenEdgeColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' ).onChange( ( value ) => {\n\n\t\t\t\t\thiddenEdgeColor.value.set( value );\n\n\t\t\t\t} ).name( 'hiddenEdgeColor' );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\trenderer.domElement.style.touchAction = 'none';\n\t\t\t\trenderer.domElement.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\t\tif ( event.isPrimary === false ) return;\n\n\t\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\t\tcheckIntersection();\n\n\t\t\t\t}\n\n\t\t\t\tfunction addSelectedObject( object ) {\n\n\t\t\t\t\tselectedObjects = [];\n\t\t\t\t\tselectedObjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t\tfunction checkIntersection() {\n\n\t\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObject( scene, true );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tconst selectedObject = intersects[ 0 ].object;\n\t\t\t\t\t\taddSelectedObject( selectedObject );\n\t\t\t\t\t\toutlinePass.selectedObjects = selectedObjects;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// outlinePass.selectedObjects = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - Outline Pass by Prashant Sharma and Ben Houston"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing smaa"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing smaa:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass } from 'three/tsl';\n\t\t\timport { smaa } from 'three/addons/tsl/display/SMAANode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, postProcessing, stats;\n\n\t\t\tconst params = {\n\t\t\t\tenabled: true,\n\t\t\t\tautoRotate: true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 300;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 120, 120, 120 );\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.position.x = - 100;\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.position.x = 100;\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst smaaPass = smaa( scenePass );\n\n\t\t\t\tpostProcessing.outputNode = smaaPass;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst smaaFolder = gui.addFolder( 'SMAA' );\n\t\t\t\tsmaaFolder.add( params, 'enabled' ).onChange( ( value ) => {\n\t\t\t\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tpostProcessing.outputNode = smaaPass;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpostProcessing.outputNode = scenePass;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst sceneFolder = gui.addFolder( 'Scene' );\n\t\t\t\tsceneFolder.add( params, 'autoRotate' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.begin();\n\n\t\t\t\tif ( params.autoRotate === true ) {\n\n\t\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\t\tconst child = scene.children[ i ];\n\n\t\t\t\t\t\tchild.rotation.x += 0.005;\n\t\t\t\t\t\tchild.rotation.y += 0.01;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.end();\n\n\t\t\t}\n```\n\nThis example three.js - post-processing SMAA"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing sobel"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing sobel:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, renderOutput } from 'three/tsl';\n\t\t\timport { sobel } from 'three/addons/tsl/display/SobelOperatorNode.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet postProcessing;\n\n\t\t\tconst params = {\n\t\t\t\tenabled: true\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 1, 3 );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/DragonAttenuation.glb' );\n\t\t\t\tconst model = gltf.scene.children[ 1 ];\n\t\t\t\tmodel.material = new THREE.MeshStandardNodeMaterial();\n\n\t\t\t\tscene.add( model );\n\t\t\t\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\tconst environment = new RoomEnvironment();\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\t\t\t\tpmremGenerator.dispose();\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.update();\n\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputColorTransform = false;\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\n\t\t\t\tpostProcessing.outputNode = sobel( renderOutput( scenePass ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'enabled' );\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tif ( params.enabled === true ) {\n\n\t\t\t\t\tpostProcessing.render();\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js - Edge Detection with Sobel"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing manual ssaa"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing manual ssaa:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';\n\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, mesh, renderer, postProcessing;\n\t\t\tlet camera, ssaaRenderPass;\n\t\t\tlet gui, stats, timer;\n\n\t\t\tconst params = {\n\t\t\t\tsampleLevel: 3,\n\t\t\t\tcamera: 'perspective',\n\t\t\t\tclearColor: 'black',\n\t\t\t\tclearAlpha: 1.0,\n\t\t\t\tviewOffsetX: 0,\n\t\t\t\tautoRotate: true\n\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tclearGui();\n\n\t\t\tfunction clearGui() {\n\n\t\t\t\tif ( gui ) gui.destroy();\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.add( params, 'sampleLevel', {\n\t\t\t\t\t'Level 0: 1 Sample': 0,\n\t\t\t\t\t'Level 1: 2 Samples': 1,\n\t\t\t\t\t'Level 2: 4 Samples': 2,\n\t\t\t\t\t'Level 3: 8 Samples': 3,\n\t\t\t\t\t'Level 4: 16 Samples': 4,\n\t\t\t\t\t'Level 5: 32 Samples': 5\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'clearColor', [ 'black', 'white', 'blue', 'green', 'red' ] );\n\t\t\t\tgui.add( params, 'clearAlpha', 0, 1 );\n\t\t\t\tgui.add( params, 'viewOffsetX', - 100, 100 );\n\t\t\t\tgui.add( params, 'autoRotate' );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 65, width / height, 3, 10 );\n\t\t\t\tcamera.position.z = 7;\n\t\t\t\tcamera.setViewOffset( width, height, params.viewOffsetX, 0, width, height );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst light = new THREE.PointLight( 0xefffef, 500 );\n\t\t\t\tlight.position.z = 10;\n\t\t\t\tlight.position.y = - 10;\n\t\t\t\tlight.position.x = - 10;\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst light2 = new THREE.PointLight( 0xffefef, 500 );\n\t\t\t\tlight2.position.z = 10;\n\t\t\t\tlight2.position.x = - 10;\n\t\t\t\tlight2.position.y = 10;\n\t\t\t\tscene.add( light2 );\n\n\t\t\t\tconst light3 = new THREE.PointLight( 0xefefff, 500 );\n\t\t\t\tlight3.position.z = 10;\n\t\t\t\tlight3.position.x = 10;\n\t\t\t\tlight3.position.y = - 10;\n\t\t\t\tscene.add( light3 );\n\n\t\t\t\tconst light4 = new THREE.AmbientLight( 0xffffff, 0.2 );\n\t\t\t\tscene.add( light4 );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 3, 48, 24 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial();\n\n\t\t\t\tmesh = new THREE.InstancedMesh( geometry, material, 120 );\n\n\t\t\t\tconst dummy = new THREE.Mesh();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\t\t\tdummy.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tdummy.position.y = Math.random() * 4 - 2;\n\t\t\t\t\tdummy.position.z = Math.random() * 4 - 2;\n\t\t\t\t\tdummy.rotation.x = Math.random();\n\t\t\t\t\tdummy.rotation.y = Math.random();\n\t\t\t\t\tdummy.rotation.z = Math.random();\n\t\t\t\t\tdummy.scale.setScalar( Math.random() * 0.2 + 0.05 );\n\n\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\tcolor.setHSL( Math.random(), 1.0, 0.3 );\n\n\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\t\t\t\t\tmesh.setColorAt( i, color );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tssaaRenderPass = ssaaPass( scene, camera );\n\t\t\t\tconst scenePassColor = ssaaRenderPass.getTextureNode();\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.setViewOffset( width, height, params.viewOffsetX, 0, width, height );\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\tif ( params.autoRotate ) {\n\n\t\t\t\t\tconst delta = timer.getDelta();\n\n\t\t\t\t\tmesh.rotation.x += delta * 0.25;\n\t\t\t\t\tmesh.rotation.y += delta * 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tlet newColor = ssaaRenderPass.clearColor;\n\n\t\t\t\tswitch ( params.clearColor ) {\n\n\t\t\t\t\tcase 'blue': newColor = 0x0000ff; break;\n\t\t\t\t\tcase 'red': newColor = 0xff0000; break;\n\t\t\t\t\tcase 'green': newColor = 0x00ff00; break;\n\t\t\t\t\tcase 'white': newColor = 0xffffff; break;\n\t\t\t\t\tcase 'black': newColor = 0x000000; break;\n\n\t\t\t\t}\n\n\t\t\t\tssaaRenderPass.clearColor.set( newColor );\n\t\t\t\tssaaRenderPass.clearAlpha = params.clearAlpha;\n\n\t\t\t\tssaaRenderPass.sampleLevel = params.sampleLevel;\n\n\t\t\t\tcamera.view.offsetX = params.viewOffsetX;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Unbiased Manual Supersampling Anti-Aliasing (SSAA) pass by Ben Houston"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing - Screen Space Reflections (SSR)"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing - Screen Space Reflections (SSR):\n\n```javascript\nimport * as THREE from 'three';\n\t\timport { pass, mrt, output, normalView, metalness, blendColor, screenUV, color, sample, directionToColor, colorToDirection } from 'three/tsl';\n\t\timport { ssr } from 'three/addons/tsl/display/SSRNode.js';\n\t\timport { smaa } from 'three/addons/tsl/display/SMAANode.js';\n\n\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\tconst params = {\n\t\t\tmaxDistance: 0.5,\n\t\t\topacity: 1,\n\t\t\tthickness: 0.015,\n\t\t\tenabled: true\n\t\t};\n\n\t\tlet camera, scene, renderer, postProcessing, ssrPass;\n\t\tlet gui, stats, controls;\n\n\t\tinit();\n\n\t\tasync function init() {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\tcamera.position.set( 3, 2, 3 );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.backgroundNode = screenUV.distance( .5 ).remap( 0, 0.5 ).mix( color( 0x888877 ), color( 0x776666 ) );\n\n\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\t\t\n\t\t\tconst loader = new GLTFLoader();\n\t\t\tloader.setDRACOLoader( dracoLoader );\n\t\t\tloader.load( 'models/gltf/steampunk_camera.glb', function ( gltf ) {\n\n\t\t\t\tgltf.scene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.material ) {\n\n\t\t\t\t\t\t// Avoid overdrawing\n\t\t\t\t\t\tobject.material.side = THREE.FrontSide;\n\t\t\n\t\t\t\t\t}\n\t\t\n\t\t\t\t} );\n\t\t\n\t\t\t\tgltf.scene.position.y = 0.1;\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t// renderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tawait renderer.init();\n\n\t\t\tconst environment = new RoomEnvironment();\n\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\tscene.environment = pmremGenerator.fromScene( environment ).texture;\n\t\t\tscene.environmentIntensity = 1.25;\n\t\t\tpmremGenerator.dispose();\n\n\t\t\t//\n\n\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\tconst scenePass = pass( scene, camera, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter } );\n\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\toutput: output,\n\t\t\t\tnormal: directionToColor( normalView ),\n\t\t\t\tmetalness: metalness\n\t\t\t} ) );\n\n\t\t\tconst scenePassColor = scenePass.getTextureNode( 'output' );\n\t\t\tconst scenePassNormal = scenePass.getTextureNode( 'normal' );\n\t\t\tconst scenePassDepth = scenePass.getTextureNode( 'depth' );\n\t\t\tconst scenePassMetalness = scenePass.getTextureNode( 'metalness' );\n\n\t\t\t// optimization bandwidth packing the normals and reducing the texture precision if possible\n\n\t\t\tconst metalnessTexture = scenePass.getTexture( 'metalness' );\n\t\t\tmetalnessTexture.type = THREE.UnsignedByteType;\n\n\t\t\tconst normalTexture = scenePass.getTexture( 'normal' );\n\t\t\tnormalTexture.type = THREE.UnsignedByteType;\n\n\t\t\tconst customNormal = sample( ( uv ) => {\n\n\t\t\t\treturn colorToDirection( scenePassNormal.sample( uv ) );\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tssrPass = ssr( scenePassColor, scenePassDepth, customNormal, scenePassMetalness, camera );\n\t\t\tssrPass.resolutionScale = 1.0;\n\n\t\t\t// blend SSR over beauty\n\t\t\n\t\t\tconst outputNode = smaa( blendColor( scenePassColor, ssrPass ) );\n\n\t\t\tpostProcessing.outputNode = outputNode;\n\n\t\t\t//\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.enableDamping = true;\n\t\t\tcontrols.update();\n\n\t\t\t// stats\n\n\t\t\tstats = new Stats();\n\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t// GUI\n\n\t\t\tgui = new GUI();\n\t\t\tgui.add( params, 'maxDistance' ).min( 0 ).max( 1 ).onChange( updateParameters );\n\t\t\tgui.add( params, 'opacity' ).min( 0 ).max( 1 ).onChange( updateParameters );\n\t\t\tgui.add( params, 'thickness' ).min( 0 ).max( 0.05 ).onChange( updateParameters );\n\t\t\tgui.add( params, 'enabled' ).onChange( () => {\n\n\t\t\t\tif ( params.enabled === true ) {\n\n\t\t\t\t\tpostProcessing.outputNode = outputNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpostProcessing.outputNode = scenePass;\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t} );\n\t\t\n\t\t\tupdateParameters();\n\n\t\t}\n\n\t\tfunction updateParameters() {\n\n\t\t\tssrPass.maxDistance.value = params.maxDistance;\n\t\t\tssrPass.opacity.value = params.opacity;\n\t\t\tssrPass.thickness.value = params.thickness;\n\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tstats.begin();\n\n\t\t\tcontrols.update();\n\n\t\t\tpostProcessing.render();\n\n\t\t\tstats.end();\n\n\t\t}\n```\n\nThis example three.js webgpu - postprocessing - screen space reflections Steampunk Camera by dylanheyes is licensed under Creative Commons Attribution ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing traa"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing traa:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mrt, output, velocity } from 'three/tsl';\n\t\t\timport { traaPass } from 'three/addons/tsl/display/TRAAPassNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, postProcessing;\n\t\t\tlet stats;\n\t\t\tlet index = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.z = 2.5;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.position.x = - 1;\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' );\n\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.position.x = 1;\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tconst scenePass = traaPass( scene, camera );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput: output,\n\t\t\t\t\tvelocity: velocity\n\t\t\t\t} ) );\n\n\t\t\t\tpostProcessing.outputNode = scenePass;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tindex ++;\n\n\t\t\t\tif ( Math.round( index / 200 ) % 2 === 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\t\tconst child = scene.children[ i ];\n\n\t\t\t\t\t\tchild.rotation.x += 0.005;\n\t\t\t\t\t\tchild.rotation.y += 0.01;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - Temporal Reprojection Anti-Aliasing (TRAA)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - scenes transition"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - scenes transition:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\t\t\timport { uniform, pass } from 'three/tsl';\n\t\t\timport { transition } from 'three/addons/tsl/display/TransitionNode.js';\n\n\t\t\tlet renderer, postProcessing, transitionController, transitionPass;\n\n\t\t\tconst textures = [];\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst effectController = {\n\t\t\t\tanimateScene: true,\n\t\t\t\tanimateTransition: true,\n\t\t\t\ttransition: 0,\n\t\t\t\t_transition: uniform( 0 ),\n\t\t\t\tuseTexture: true,\n\t\t\t\t_useTexture: uniform( 1 ),\n\t\t\t\ttexture: 5,\n\t\t\t\tcycle: true,\n\t\t\t\tthreshold: uniform( 0.1 ),\n\t\t\t};\n\n\t\t\tfunction generateInstancedMesh( geometry, material, count ) {\n\n\t\t\t\tconst mesh = new THREE.InstancedMesh( geometry, material, count );\n\n\t\t\t\tconst dummy = new THREE.Object3D();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tdummy.position.x = Math.random() * 100 - 50;\n\t\t\t\t\tdummy.position.y = Math.random() * 60 - 30;\n\t\t\t\t\tdummy.position.z = Math.random() * 80 - 40;\n\n\t\t\t\t\tdummy.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tdummy.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tdummy.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tdummy.scale.x = Math.random() * 2 + 1;\n\n\t\t\t\t\tif ( geometry.type === 'BoxGeometry' ) {\n\n\t\t\t\t\t\tdummy.scale.y = Math.random() * 2 + 1;\n\t\t\t\t\t\tdummy.scale.z = Math.random() * 2 + 1;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdummy.scale.y = dummy.scale.x;\n\t\t\t\t\t\tdummy.scale.z = dummy.scale.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\tmesh.setMatrixAt( i, dummy.matrix );\n\t\t\t\t\tmesh.setColorAt( i, color.setScalar( 0.1 + 0.9 * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction FXScene( geometry, rotationSpeed, backgroundColor ) {\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 20;\n\n\t\t\t\t// Setup scene\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( backgroundColor );\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 1, 4 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tthis.rotationSpeed = rotationSpeed;\n\n\t\t\t\tconst color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;\n\t\t\t\tconst material = new THREE.MeshPhongNodeMaterial( { color: color, flatShading: true } );\n\t\t\t\tconst mesh = generateInstancedMesh( geometry, material, 500 );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tthis.scene = scene;\n\t\t\t\tthis.camera = camera;\n\t\t\t\tthis.mesh = mesh;\n\n\t\t\t\tthis.update = function ( delta ) {\n\n\t\t\t\t\tif ( effectController.animateScene ) {\n\n\t\t\t\t\t\tmesh.rotation.x += this.rotationSpeed.x * delta;\n\t\t\t\t\t\tmesh.rotation.y += this.rotationSpeed.y * delta;\n\t\t\t\t\t\tmesh.rotation.z += this.rotationSpeed.z * delta;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.resize = function () {\n\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst fxSceneA = new FXScene( new THREE.BoxGeometry( 2, 2, 2 ), new THREE.Vector3( 0, - 0.4, 0 ), 0xffffff );\n\t\t\tconst fxSceneB = new FXScene( new THREE.IcosahedronGeometry( 1, 1 ), new THREE.Vector3( 0, 0.2, 0.1 ), 0x000000 );\n\n\t\t\tfunction init() {\n\n\t\t\t\t// Initialize textures\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\ttextures[ i ] = loader.load( 'textures/transition/transition' + ( i + 1 ) + '.png' );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePassA = pass( fxSceneA.scene, fxSceneA.camera );\n\t\t\t\tconst scenePassB = pass( fxSceneB.scene, fxSceneB.camera );\n\n\t\t\t\ttransitionPass = transition( scenePassA, scenePassB, new THREE.TextureNode( textures[ effectController.texture ] ), effectController._transition, effectController.threshold, effectController._useTexture );\n\n\t\t\t\tpostProcessing.outputNode = transitionPass;\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( effectController, 'animateScene' ).name( 'Animate Scene' );\n\t\t\t\tgui.add( effectController, 'animateTransition' ).name( 'Animate Transition' );\n\t\t\t\ttransitionController = gui.add( effectController, 'transition', 0, 1, 0.01 ).name( 'transition' ).onChange( () => {\n\n\t\t\t\t\teffectController._transition.value = effectController.transition;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( effectController, 'useTexture' ).onChange( () => {\n\n\t\t\t\t\tconst value = effectController.useTexture ? 1 : 0;\n\t\t\t\t\teffectController._useTexture.value = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( effectController, 'texture', { Perlin: 0, Squares: 1, Cells: 2, Distort: 3, Gradient: 4, Radial: 5 } );\n\t\t\t\tgui.add( effectController, 'cycle' );\n\t\t\t\tgui.add( effectController.threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );\n\n\t\t\t}\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tfxSceneA.resize();\n\t\t\t\tfxSceneB.resize();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tnew TWEEN.Tween( effectController )\n\t\t\t\t.to( { transition: 1 }, 1500 )\n\t\t\t\t.onUpdate( function ( ) {\n\n\t\t\t\t\ttransitionController.setValue( effectController.transition );\n\n\t\t\t\t\t// Change the current alpha texture after each transition\n\t\t\t\t\tif ( effectController.cycle ) {\n\n\t\t\t\t\t\tif ( effectController.transition == 0 || effectController.transition == 1 ) {\n\n\t\t\t\t\t\t\teffectController.texture = ( effectController.texture + 1 ) % textures.length;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} )\n\t\t\t\t.repeat( Infinity )\n\t\t\t\t.delay( 2000 )\n\t\t\t\t.yoyo( true )\n\t\t\t\t.start();\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( effectController.animateTransition ) TWEEN.update();\n\n\t\t\t\tif ( textures[ effectController.texture ] ) {\n\n\t\t\t\t\tconst mixTexture = textures[ effectController.texture ];\n\t\t\t\t\ttransitionPass.mixTextureNode.value = mixTexture;\n\n\t\t\t\t}\n\n\t\t\t\tconst delta = clock.getDelta();\n\t\t\t\tfxSceneA.update( delta );\n\t\t\t\tfxSceneB.update( delta );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\t// Prevent render both scenes when it's not necessary\n\t\t\t\tif ( effectController.transition === 0 ) {\n\n\t\t\t\t\trenderer.render( fxSceneB.scene, fxSceneB.camera );\n\n\t\t\t\t} else if ( effectController.transition === 1 ) {\n\n\t\t\t\t\trenderer.render( fxSceneA.scene, fxSceneA.camera );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpostProcessing.render();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js webgpu scene transitions. Original implementation by fernandojsg - github"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - postprocessing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - postprocessing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass } from 'three/tsl';\n\t\t\timport { dotScreen } from 'three/addons/tsl/display/DotScreenNode.js';\n\t\t\timport { rgbShift } from 'three/addons/tsl/display/RGBShiftNode.js';\n\n\t\t\tlet camera, renderer, postProcessing;\n\t\t\tlet object;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 400;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x000000, 1, 1000 );\n\n\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 1, 4, 4 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 ).normalize();\n\t\t\t\t\tmesh.position.multiplyScalar( Math.random() * 400 );\n\t\t\t\t\tmesh.rotation.set( Math.random() * 2, Math.random() * 2, Math.random() * 2 );\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 50;\n\t\t\t\t\tobject.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xcccccc ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\n\t\t\t\tconst dotScreenPass = dotScreen( scenePassColor );\n\t\t\t\tdotScreenPass.scale.value = 0.3;\n\n\t\t\t\tconst rgbShiftPass = rgbShift( dotScreenPass );\n\t\t\t\trgbShiftPass.amount.value = 0.001;\n\n\t\t\t\tpostProcessing.outputNode = rgbShiftPass;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tobject.rotation.x += 0.005;\n\t\t\t\tobject.rotation.y += 0.01;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - procedural texture"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - procedural texture:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { checker, uv, uniform, convertToTexture } from 'three/tsl';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );\n\t\t\t\tcamera.position.z = 1;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// procedural to texture\n\n\t\t\t\tconst uvScale = uniform( 4 );\n\t\t\t\tconst blurAmount = uniform( .5 );\n\n\t\t\t\tconst procedural = checker( uv().mul( uvScale ) );\n\t\t\t\tconst proceduralToTexture = convertToTexture( procedural, 512, 512 ); // ( node, width, height )\n\n\t\t\t\tconst colorNode = gaussianBlur( proceduralToTexture, blurAmount, 10 );\n\n\t\t\t\t// extra\n\n\t\t\t\t//proceduralToTexture.autoUpdate = false; // update just once\n\t\t\t\t//proceduralToTexture.textureNeedsUpdate = true; // manually update\n\n\t\t\t\t// scene\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = colorNode;\n\n\t\t\t\tconst plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( uvScale, 'value', 1, 10 ).name( 'uv scale ( before rtt )' );\n\t\t\t\tgui.add( blurAmount, 'value', 0, 2 ).name( 'blur amount ( after rtt )' );\n\t\t\t\tgui.add( proceduralToTexture, 'autoUpdate' ).name( 'auto update' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.renderAsync( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - procedural texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - reflection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - reflection:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, pass, reflector, normalWorldGeometry, texture, uv, screenUV } from 'three/tsl';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet model, mixer, clock;\n\t\t\tlet postProcessing;\n\t\t\tlet controls;\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );\n\t\t\t\tcamera.position.set( 2, 2.5, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x0487e2, 7, 25 );\n\t\t\t\tscene.backgroundNode = normalWorldGeometry.y.mix( color( 0x0487e2 ), color( 0x0066ff ) );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tconst sunLight = new THREE.DirectionalLight( 0xFFE499, 5 );\n\t\t\t\tsunLight.castShadow = true;\n\t\t\t\tsunLight.shadow.camera.near = .1;\n\t\t\t\tsunLight.shadow.camera.far = 5;\n\t\t\t\tsunLight.shadow.camera.right = 2;\n\t\t\t\tsunLight.shadow.camera.left = - 2;\n\t\t\t\tsunLight.shadow.camera.top = 2;\n\t\t\t\tsunLight.shadow.camera.bottom = - 2;\n\t\t\t\tsunLight.shadow.mapSize.width = 2048;\n\t\t\t\tsunLight.shadow.mapSize.height = 2048;\n\t\t\t\tsunLight.shadow.bias = - 0.001;\n\t\t\t\tsunLight.position.set( .5, 3, .5 );\n\n\t\t\t\tconst waterAmbientLight = new THREE.HemisphereLight( 0x333366, 0x74ccf4, 5 );\n\t\t\t\tconst skyAmbientLight = new THREE.HemisphereLight( 0x74ccf4, 0, 1 );\n\n\t\t\t\tscene.add( sunLight );\n\t\t\t\tscene.add( skyAmbientLight );\n\t\t\t\tscene.add( waterAmbientLight );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// animated model\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tmodel.children[ 0 ].children[ 0 ].castShadow = true;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst floorColor = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );\n\t\t\t\tfloorColor.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorColor.wrapT = THREE.RepeatWrapping;\n\t\t\t\tfloorColor.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorNormal.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorNormal.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// floor\n\n\t\t\t\tconst floorUV = uv().mul( 15 );\n\t\t\t\tconst floorNormalOffset = texture( floorNormal, floorUV ).xy.mul( 2 ).sub( 1 ).mul( .02 );\n\n\t\t\t\tconst reflection = reflector( { resolution: 0.5 } ); // 0.5 is half of the rendering view\n\t\t\t\treflection.target.rotateX( - Math.PI / 2 );\n\t\t\t\treflection.uvNode = reflection.uvNode.add( floorNormalOffset );\n\t\t\t\tscene.add( reflection.target );\n\n\t\t\t\tconst floorMaterial = new THREE.MeshPhongNodeMaterial();\n\t\t\t\tfloorMaterial.colorNode = texture( floorColor, floorUV ).add( reflection );\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );\n\t\t\t\tfloor.receiveShadow = true;\n\n\t\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = 1;\n\t\t\t\tcontrols.target.set( 0, .5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// post-processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\t\t\t\tconst scenePassDepth = scenePass.getLinearDepthNode().remapClamp( .3, .5 );\n\n\t\t\t\tconst scenePassColorBlurred = gaussianBlur( scenePassColor );\n\t\t\t\tscenePassColorBlurred.directionNode = scenePassDepth;\n\n\t\t\t\tconst vignette = screenUV.distance( .5 ).mul( 1.35 ).clamp().oneMinus();\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = scenePassColorBlurred.mul( vignette );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( model ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - reflection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - blurred reflection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - blurred reflection:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, vec4, fract, abs, uniform, pow, color, max, length, rangeFogFactor, sub, reflector, normalWorld, hue, time, mix, positionWorld } from 'three/tsl';\n\n\t\t\timport { hashBlur } from 'three/addons/tsl/display/hashBlur.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet model, mixer, clock;\n\t\t\tlet controls;\n\t\t\tlet stats;\n\t\t\tlet gui;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );\n\t\t\t\tcamera.position.set( - 2.5, 2, 2.5 );\n\t\t\t\tcamera.lookAt( 0, .4, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = hue( normalWorld.y.mix( 0, color( 0x0066ff ) ).mul( .1 ), time );\n\n\t\t\t\tconst waterAmbientLight = new THREE.HemisphereLight( 0xffffff, 0x0066ff, 10 );\n\t\t\t\tscene.add( waterAmbientLight );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// animated model\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tmodel.children[ 0 ].children[ 0 ].castShadow = true;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst uvMap = textureLoader.load( 'textures/uv_grid_directx.jpg' );\n\t\t\t\tuvMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// uv map for debugging\n\n\t\t\t\tconst uvMaterial = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tmap: uvMap,\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tconst uvMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), uvMaterial );\n\t\t\t\tuvMesh.position.set( 0, 1, - 3 );\n\t\t\t\tscene.add( uvMesh );\n\n\t\t\t\t// circle effect\n\n\t\t\t\tconst drawCircle = Fn( ( [ pos, radius, width, power, color, timer = time.mul( .5 ) ] ) => {\n\n\t\t\t\t\t// https://www.shadertoy.com/view/3tdSRn\n\n\t\t\t\t\tconst dist1 = length( pos );\n\t\t\t\t\tdist1.assign( fract( dist1.mul( 5.0 ).sub( fract( timer ) ) ) );\n\t\t\t\t\tconst dist2 = dist1.sub( radius );\n\t\t\t\t\tconst intensity = pow( radius.div( abs( dist2 ) ), width );\n\t\t\t\t\tconst col = color.rgb.mul( intensity ).mul( power ).mul( max( sub( 0.8, abs( dist2 ) ), 0.0 ) );\n\n\t\t\t\t\treturn col;\n\n\t\t\t\t} );\n\n\t\t\t\tconst circleFadeY = positionWorld.y.mul( .7 ).oneMinus().max( 0 );\n\t\t\t\tconst animatedColor = mix( color( 0x74ccf4 ), color( 0x7f00c5 ), positionWorld.xz.distance( 0 ).div( 10 ).clamp() );\n\t\t\t\tconst animatedCircle = hue( drawCircle( positionWorld.xz.mul( .1 ), 0.5, 0.8, .01, animatedColor ).mul( circleFadeY ), time );\n\n\t\t\t\tconst floorLight = new THREE.PointLight( 0xffffff );\n\t\t\t\tfloorLight.colorNode = animatedCircle.mul( 50 );\n\t\t\t\tscene.add( floorLight );\n\n\t\t\t\t// reflection\n\n\t\t\t\tconst roughness = uniform( .9 );\n\t\t\t\tconst radius = uniform( 0.2 );\n\n\t\t\t\tconst reflection = reflector( { resolution: .5, depth: true, bounces: false } ); // 0.5 is half of the rendering view\n\t\t\t\tconst reflectionDepth = reflection.getDepthNode();\n\t\t\t\treflection.target.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( reflection.target );\n\n\t\t\t\tconst floorMaterial = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tfloorMaterial.transparent = true;\n\t\t\t\tfloorMaterial.colorNode = Fn( () => {\n\n\t\t\t\t\t// ranges adjustment\n\n\t\t\t\t\tconst radiusRange = mix( 0.01, 0.1, radius ); // range [ 0.01, 0.1 ]\n\t\t\t\t\tconst roughnessRange = mix( 0.3, 0.03, roughness ); // range [ 0.03, 0.3 ]\n\n\t\t\t\t\t// blur the reflection\n\n\t\t\t\t\tconst reflectionBlurred = hashBlur( reflection, radiusRange, {\n\t\t\t\t\t\trepeats: 40,\n\t\t\t\t\t\tmask: reflectionDepth,\n\t\t\t\t\t\tpremultipliedAlpha: true\n\t\t\t\t\t} );\n\n\t\t\t\t\t// reflection composite\n\n\t\t\t\t\tconst reflectionMask = reflectionBlurred.a.mul( reflectionDepth ).remapClamp( 0, roughnessRange );\n\t\t\t\t\tconst reflectionItensity = .1;\n\t\t\t\t\tconst reflectionMixFactor = reflectionMask.mul( roughness.mul( 2 ).min( 1 ) );\n\t\t\t\t\tconst reflectionFinal = mix( reflection.rgb, reflectionBlurred.rgb, reflectionMixFactor ).mul( reflectionItensity );\n\n\t\t\t\t\t// mix reflection with animated circle\n\n\t\t\t\t\tconst output = animatedCircle.add( reflectionFinal );\n\n\t\t\t\t\t// falloff opacity by distance like an opacity-fog\n\n\t\t\t\t\tconst opacity = rangeFogFactor( 7, 25 ).oneMinus();\n\n\t\t\t\t\t// final output\n\n\t\t\t\t\treturn vec4( output, opacity );\n\n\t\t\t\t} )();\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );\n\t\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.3;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tgui.add( roughness, 'value', 0, 1 ).name( 'roughness' );\n\t\t\t\tgui.add( radius, 'value', 0, 1 ).name( 'radius' );\n\t\t\t\tgui.add( reflection.reflector, 'resolution', .25, 1 ).name( 'resolution' );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\t//controls.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - .1;\n\t\t\t\tcontrols.target.set( 0, .5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// events\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( model ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - blurred reflection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - roughness reflection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - roughness reflection:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, vec2, vec4, texture, uv, textureBicubic, rangeFogFactor, reflector, time } from 'three/tsl';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );\n\t\t\t\tcamera.position.set( - 4, 2, 4 );\n\t\t\t\tcamera.lookAt( 0, .4, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'moonless_golf_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t} );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst uvMap = textureLoader.load( 'textures/uv_grid_directx.jpg' );\n\t\t\t\tuvMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst perlinMap = textureLoader.load( './textures/noises/perlin/rgb-256x256.png' );\n\t\t\t\tperlinMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\tperlinMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\tperlinMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// uv map for debugging\n\n\t\t\t\tconst uvMaterial = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tmap: uvMap,\n\t\t\t\t\temissiveMap: uvMap,\n\t\t\t\t\temissive: 0xffffff,\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tconst uvMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), uvMaterial );\n\t\t\t\tuvMesh.position.set( 0, 1, 0 );\n\t\t\t\tscene.add( uvMesh );\n\n\t\t\t\t// reflection\n\n\t\t\t\tconst reflection = reflector( { resolution: .5, bounces: false, generateMipmaps: true } ); // 0.5 is half of the rendering view\n\t\t\t\treflection.target.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( reflection.target );\n\n\t\t\t\tconst animatedUV = uv().mul( 10 ).add( vec2( time.mul( .1 ), 0 ) );\n\t\t\t\tconst roughness = texture( perlinMap, animatedUV ).r.mul( 2 ).saturate();\n\n\t\t\t\tconst floorMaterial = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tfloorMaterial.transparent = true;\n\t\t\t\tfloorMaterial.metalness = 1;\n\t\t\t\tfloorMaterial.roughnessNode = roughness.mul( .2 );\n\t\t\t\tfloorMaterial.colorNode = Fn( () => {\n\n\t\t\t\t\t// blur reflection using textureBicubic()\n\t\t\t\t\tconst dirtyReflection = textureBicubic( reflection, roughness.mul( .9 ) );\n\n\t\t\t\t\t// falloff opacity by distance like an opacity-fog\n\t\t\t\t\tconst opacity = rangeFogFactor( 7, 25 ).oneMinus();\n\n\t\t\t\t\treturn vec4( dirtyReflection.rgb, opacity );\n\n\t\t\t\t} )();\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );\n\t\t\t\tfloor.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 2;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.autoRotateSpeed = - .1;\n\t\t\t\tcontrols.target.set( 0, .5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// events\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - roughness reflection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - refraction"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - refraction:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { viewportSafeUV, viewportSharedTexture, screenUV, texture, uv } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet cameraControls;\n\n\t\t\tlet smallSphere;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );\n\t\t\t\tcamera.position.set( 0, 50, 160 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 5, 0 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x7b7b7b, flatShading: true } );\n\t\t\t\tsmallSphere = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( smallSphere );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\n\t\t\t\tconst floorNormal = loader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );\n\t\t\t\tfloorNormal.wrapS = THREE.RepeatWrapping;\n\t\t\t\tfloorNormal.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// refractor\n\n\t\t\t\tconst verticalNormalScale = 0.1;\n\t\t\t\tconst verticalUVOffset = texture( floorNormal, uv().mul( 5 ) ).xy.mul( 2 ).sub( 1 ).mul( verticalNormalScale );\n\n\t\t\t\tconst refractorUV = screenUV.add( verticalUVOffset );\n\t\t\t\tconst verticalRefractor = viewportSharedTexture( viewportSafeUV( refractorUV ) );\n\n\t\t\t\tconst planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );\n\n\t\t\t\tconst planeRefractor = new THREE.Mesh( planeGeo, new THREE.MeshBasicNodeMaterial( {\n\t\t\t\t\tbackdropNode: verticalRefractor\n\t\t\t\t} ) );\n\t\t\t\tplaneRefractor.material.transparent = true;\n\t\t\t\tplaneRefractor.position.y = 50;\n\t\t\t\tscene.add( planeRefractor );\n\n\t\t\t\t// walls\n\t\t\t\n\t\t\t\tconst planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneTop.position.y = 100;\n\t\t\t\tplaneTop.rotateX( Math.PI / 2 );\n\t\t\t\tscene.add( planeTop );\n\n\t\t\t\tconst planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );\n\t\t\t\tplaneBottom.rotateX( - Math.PI / 2 );\n\t\t\t\tscene.add( planeBottom );\n\n\t\t\t\tconst planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );\n\t\t\t\tplaneBack.position.z = - 50;\n\t\t\t\tplaneBack.position.y = 50;\n\t\t\t\tscene.add( planeBack );\n\n\t\t\t\tconst planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );\n\t\t\t\tplaneRight.position.x = 50;\n\t\t\t\tplaneRight.position.y = 50;\n\t\t\t\tplaneRight.rotateY( - Math.PI / 2 );\n\t\t\t\tscene.add( planeRight );\n\n\t\t\t\tconst planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );\n\t\t\t\tplaneLeft.position.x = - 50;\n\t\t\t\tplaneLeft.position.y = 50;\n\t\t\t\tplaneLeft.rotateY( Math.PI / 2 );\n\t\t\t\tscene.add( planeLeft );\n\n\t\t\t\t// lights\n\n\t\t\t\tconst mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );\n\t\t\t\tmainLight.position.y = 60;\n\t\t\t\tscene.add( mainLight );\n\n\t\t\t\tconst greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );\n\t\t\t\tgreenLight.position.set( 550, 50, 0 );\n\t\t\t\tscene.add( greenLight );\n\n\t\t\t\tconst redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );\n\t\t\t\tredLight.position.set( - 550, 50, 0 );\n\t\t\t\tscene.add( redLight );\n\n\t\t\t\tconst blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );\n\t\t\t\tblueLight.position.set( 0, 50, 550 );\n\t\t\t\tscene.add( blueLight );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( /*{ antialias: true }*/ );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcameraControls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcameraControls.target.set( 0, 50, 0 );\n\t\t\t\tcameraControls.maxDistance = 400;\n\t\t\t\tcameraControls.minDistance = 10;\n\t\t\t\tcameraControls.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = Date.now() * 0.01;\n\n\t\t\t\tsmallSphere.position.set(\n\t\t\t\t\tMath.cos( timer * 0.1 ) * 30,\n\t\t\t\t\tMath.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,\n\t\t\t\t\tMath.sin( timer * 0.1 ) * 30\n\t\t\t\t);\n\t\t\t\tsmallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;\n\t\t\t\tsmallSphere.rotation.z = timer * 0.8;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - refraction"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - RenderTargetArray and RenderTarget3D"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - RenderTargetArray and RenderTarget3D:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { vec2, uniform, screenUV, color, texture, diffuseColor, attribute, vec3, vec4 } from 'three/tsl';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { TextureHelper } from 'three/addons/helpers/TextureHelperGPU.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { unzipSync } from 'three/addons/libs/fflate.module.js';\n\n\t\t\tlet renderer, stats;\n\t\t\tlet views = [];\n\n\t\t\tclass View {\n\n\t\t\t\tconstructor( left, top, width, height ) {\n\n\t\t\t\t\tthis.left = left;\n\t\t\t\t\tthis.top = top;\n\t\t\t\t\tthis.width = width;\n\t\t\t\t\tthis.height = height;\n\n\t\t\t\t\tconst aspect = ( window.innerWidth * width ) / ( window.innerHeight * height );\n\n\t\t\t\t\t// Set up perspective camera\n\t\t\t\t\tthis.camera = new THREE.PerspectiveCamera( 50, aspect, 0.1, 100 );\n\t\t\t\t\tthis.camera.position.set( - 7, 0, 10 );\n\t\t\t\t\tthis.camera.lookAt( 0, 0, 0 );\n\t\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t\t\tthis.scene = new THREE.Scene();\n\n\n\t\t\t\t\tconst normalizedUV = screenUV.mul( vec2( 1, - 1 ) ).add( vec2( 0, 1 ) ); // Flip Y and offset\n\n\t\t\t\t\t// Calculate viewport center in normalized coordinates\n\t\t\t\t\tconst viewportCenter = vec2(\n\t\t\t\t\t\tthis.left + this.width * 0.5,\n\t\t\t\t\t\tthis.top + this.height * 0.5 // Invert Y coordinate for proper alignment\n\t\t\t\t\t);\n\n\t\t\t\t\tconst distanceEffect = normalizedUV.distance( viewportCenter ).smoothstep( 0, 0.2 );\n\n\t\t\t\t\tconst backgroundEffect = color( this.top > 0 ? 0x212121 : 0x616161 ).sub( distanceEffect.pow( 0.3 ).mul( 0.1 ) );\n\n\t\t\t\t\tthis.scene.backgroundNode = backgroundEffect;\n\n\t\t\t\t}\n\n\t\t\t\t// Method to handle viewport resize\n\t\t\t\tupdateSize( left, top, width, height ) {\n\n\t\t\t\t\tthis.left = left;\n\t\t\t\t\tthis.top = top;\n\t\t\t\t\tthis.width = width;\n\t\t\t\t\tthis.height = height;\n\n\t\t\t\t\tconst aspect = ( window.innerWidth * width ) / ( window.innerHeight * height );\n\t\t\t\t\tthis.camera.aspect = aspect;\n\t\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\t// Create views after renderer initialization\n\t\t\t\tviews = [\n\t\t\t\t\tnew View( 0.0, 0.0, 0.5, 0.5 ),\n\t\t\t\t\tnew View( 0.5, 0.0, 0.5, 0.5 ),\n\t\t\t\t\tnew View( 0.0, 0.5, 0.5, 0.5 ),\n\t\t\t\t\tnew View( 0.5, 0.5, 0.5, 0.5 )\n\t\t\t\t];\n\n\t\t\t\t// Add OrbitControls after views and renderer are created\n\t\t\t\tviews.forEach( view => {\n\n\t\t\t\t\tview.controls = new OrbitControls( view.camera, renderer.domElement );\n\t\t\t\t\tview.controls.minDistance = 1;\n\t\t\t\t\tview.controls.maxDistance = 20;\n\t\t\t\t\tview.controls.minAzimuthAngle = - Math.PI / 3;\n\t\t\t\t\tview.controls.maxAzimuthAngle = Math.PI / 3;\n\t\t\t\t\tview.controls.minPolarAngle = Math.PI / 4;\n\t\t\t\t\tview.controls.maxPolarAngle = Math.PI / 1.25;\n\t\t\t\t\tview.controls.enableDamping = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst size = {\n\t\t\t\t\twidth: 256,\n\t\t\t\t\theight: 256,\n\t\t\t\t\tdepth: 109\n\t\t\t\t};\n\n\t\t\t\tnew THREE.FileLoader()\n\t\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t\t.load( 'textures/3d/head256x256x109.zip', function ( data ) {\n\n\t\t\t\t\t\tconst zip = unzipSync( new Uint8Array( data ) );\n\t\t\t\t\t\tconst array = new Uint8Array( zip[ 'head256x256x109' ].buffer );\n\n\t\t\t\t\t\tconst map3D = new THREE.Data3DTexture( array, size.width, size.height, size.depth );\n\t\t\t\t\t\tmap3D.name = 'Data3DTexture';\n\t\t\t\t\t\tmap3D.format = THREE.RedFormat;\n\t\t\t\t\t\tmap3D.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\tmap3D.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\tmap3D.unpackAlignment = 1;\n\t\t\t\t\t\tmap3D.needsUpdate = true;\n\n\n\t\t\t\t\t\tconst depth = size.depth / 20;\n\n\t\t\t\t\t\t// 3D\n\t\t\t\t\t\tconst helper3D = new TextureHelper( map3D, 10, 10, depth );\n\t\t\t\t\t\thelper3D.material.outputNode = vec4(\n\t\t\t\t\t\t\tvec3( diffuseColor.r.mul( attribute( 'uvw' ).z.mul( diffuseColor.r ) ) ),\n\t\t\t\t\t\t\tdiffuseColor.r.mul( diffuseColor.a )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tviews[ 1 ].scene.add( helper3D );\n\n\t\t\t\t\t\tconst fbo3D = new THREE.RenderTarget3D( size.width, size.height, size.depth, {\n\t\t\t\t\t\t\tdepthBuffer: false,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfbo3D.texture.name = 'RenderTarget3D';\n\n\n\t\t\t\t\t\tconst fbo3DHelper = new TextureHelper( fbo3D.texture, 10, 10, depth );\n\t\t\t\t\t\tfbo3DHelper.material.outputNode = vec4(\n\t\t\t\t\t\t\tvec3( diffuseColor.r ),\n\t\t\t\t\t\t\tdiffuseColor.r\n\t\t\t\t\t\t);\n\t\t\t\t\t\tviews[ 3 ].scene.add( fbo3DHelper );\n\n\n\n\n\t\t\t\t\t\t// 2D Array\n\n\t\t\t\t\t\tconst mapArray = new THREE.DataArrayTexture( array, size.width, size.height, size.depth );\n\t\t\t\t\t\tmapArray.name = 'DataArrayTexture';\n\t\t\t\t\t\tmapArray.format = THREE.RedFormat;\n\t\t\t\t\t\tmapArray.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\tmapArray.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\tmapArray.unpackAlignment = 1;\n\t\t\t\t\t\tmapArray.needsUpdate = true;\n\n\t\t\t\t\t\tconst helperArray = new TextureHelper( mapArray, 10, 10, depth );\n\t\t\t\t\t\thelperArray.material.outputNode = vec4(\n\t\t\t\t\t\t\tvec3( diffuseColor.r.mul( attribute( 'uvw' ).z.div( size.depth ).mul( diffuseColor.r ) ) ),\n\t\t\t\t\t\t\tdiffuseColor.r.mul( diffuseColor.a )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tviews[ 0 ].scene.add( helperArray );\n\n\t\t\t\t\t\t// Setup render targets\n\t\t\t\t\t\tconst materialQuad = new THREE.NodeMaterial();\n\t\t\t\t\t\tconst uZCoord = uniform( 0 );\n\t\t\t\t\t\tmaterialQuad.depthTest = false;\n\t\t\t\t\t\tmaterialQuad.outputNode = vec4( texture( mapArray ).depth( uZCoord ).rgb, 1 );\n\n\t\t\t\t\t\tconst fboArray = new THREE.RenderTarget( size.width, size.height, {\n\t\t\t\t\t\t\tdepthBuffer: false,\n\t\t\t\t\t\t\tdepth: size.depth\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfboArray.texture.name = 'RenderTargetArray';\n\n\t\t\t\t\t\tconst fboArrayHelper = new TextureHelper( fboArray.texture, 10, 10, depth );\n\t\t\t\t\t\tfboArrayHelper.material.outputNode = vec4(\n\t\t\t\t\t\t\tvec3( diffuseColor.r ),\n\t\t\t\t\t\t\tdiffuseColor.r\n\t\t\t\t\t\t);\n\t\t\t\t\t\tviews[ 2 ].scene.add( fboArrayHelper );\n\n\n\t\t\t\t\t\tconst quadMesh = new THREE.QuadMesh( materialQuad );\n\n\n\n\t\t\t\t\t\t// In WebGPU we need to clear all the layers of the 3D render target before rendering to it (WebGPU limitation?)\n\t\t\t\t\t\tif ( renderer.backend.isWebGPUBackend ) {\n\n\t\t\t\t\t\t\tconst materialClear = new THREE.NodeMaterial();\n\t\t\t\t\t\t\tmaterialClear.outputNode = vec4( 0 );\n\t\t\t\t\t\t\tconst clearQuadMesh = new THREE.QuadMesh( materialClear );\n\t\t\t\t\t\t\tfor ( let i = 0; i < size.depth; i ++ ) {\n\t\t\t\n\t\t\t\t\t\t\t\trenderer.setRenderTarget( fbo3D, i );\n\t\t\t\t\t\t\t\tclearQuadMesh.render( renderer );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet j = 0;\n\n\t\t\t\t\t\tconst loop = () => {\n\n\t\t\t\t\t\t\tif ( j === size.depth ) {\n\n\t\t\t\t\t\t\t\tclearInterval( interval );\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Disable viewport and scissor for FBO rendering\n\t\t\t\t\t\t\trenderer.setViewport( 0, 0, size.width, size.height );\n\t\t\t\t\t\t\trenderer.setScissor( 0, 0, size.width, size.height );\n\t\t\t\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t\t\t\t\tuZCoord.value = j;\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( fboArray, j );\n\t\t\t\t\t\t\trenderer.clear();\n\t\t\t\t\t\t\tquadMesh.render( renderer );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( fbo3D, j );\n\t\t\t\t\t\t\trenderer.clear();\n\t\t\t\t\t\t\tquadMesh.render( renderer );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( null );\n\n\t\t\t\t\t\t\tj = ( j + 1 ) % size.depth;\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst interval = setInterval( loop, 50 );\n\n\t\t\t\t\t\tloop();\n\n\t\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\tviews.forEach( view => {\n\n\t\t\t\t\tview.updateSize(\n\t\t\t\t\t\tview.left,\n\t\t\t\t\t\tview.top,\n\t\t\t\t\t\tview.width,\n\t\t\t\t\t\tview.height\n\t\t\t\t\t);\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tviews.forEach( view => {\n\n\t\t\t\t\tview.controls.update();\n\n\t\t\t\t\tconst left = Math.floor( view.left * window.innerWidth );\n\t\t\t\t\tconst bottom = Math.floor( ( 1 - view.top - view.height ) * window.innerHeight );\n\t\t\t\t\tconst width = Math.floor( view.width * window.innerWidth );\n\t\t\t\t\tconst height = Math.floor( view.height * window.innerHeight );\n\n\t\t\t\t\trenderer.setViewport( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissor( left, bottom, width, height );\n\t\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( view.scene, view.camera );\n\n\t\t\t\t} );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js - WebGPU - RenderTargetArray and RenderTarget3D"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - rtt"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - rtt:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, uniform, saturation, hue } from 'three/tsl';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tconst mouse = new THREE.Vector2();\n\n\t\t\tlet quadMesh, renderTarget;\n\n\t\t\tlet box;\n\n\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.z = 3;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x0066FF );\n\n\t\t\t\t// textured mesh\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tconst uvTexture = loader.load( './textures/uv_grid_opengl.jpg' );\n\n\t\t\t\tconst geometryBox = new THREE.BoxGeometry();\n\t\t\t\tconst materialBox = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterialBox.colorNode = texture( uvTexture );\n\n\t\t\t\t//\n\n\t\t\t\tbox = new THREE.Mesh( geometryBox, materialBox );\n\t\t\t\tscene.add( box );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( dpr );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderTarget = new THREE.RenderTarget( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t\twindow.addEventListener( 'mousemove', onWindowMouseMove );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// FX\n\n\t\t\t\t// modulate the final color based on the mouse position\n\n\t\t\t\tconst screenFXNode = uniform( mouse );\n\n\t\t\t\tconst materialFX = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterialFX.colorNode = hue( saturation( texture( renderTarget.texture ).rgb, screenFXNode.x.oneMinus() ), screenFXNode.y );\n\n\t\t\t\tquadMesh = new THREE.QuadMesh( materialFX );\n\n\t\t\t}\n\n\t\t\tfunction onWindowMouseMove( e ) {\n\n\t\t\t\tmouse.x = e.offsetX / window.innerWidth;\n\t\t\t\tmouse.y = e.offsetY / window.innerHeight;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tbox.rotation.x += 0.01;\n\t\t\t\tbox.rotation.y += 0.02;\n\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tquadMesh.render( renderer );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - rtt"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - sandbox"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - sandbox:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { time, vec2, uv, texture, mix, checker, normalLocal, positionLocal, color, oscSine, attribute } from 'three/tsl';\n\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet box;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.z = 4;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst uvTexture = textureLoader.load( './textures/uv_grid_opengl.jpg' );\n\t\t\t\tuvTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tuvTexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\tuvTexture.name = 'uv_grid';\n\n\t\t\t\tconst textureDisplace = textureLoader.load( './textures/transition/transition1.png' );\n\t\t\t\ttextureDisplace.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttextureDisplace.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst ktxLoader = await new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupportAsync( renderer );\n\n\t\t\t\tconst ktxTexture = await ktxLoader.loadAsync( './textures/ktx2/2d_uastc.ktx2' );\n\n\t\t\t\t// box mesh\n\n\t\t\t\tconst geometryBox = new THREE.BoxGeometry();\n\t\t\t\tconst materialBox = new THREE.MeshBasicNodeMaterial();\n\n\t\t\t\t// birection speed\n\n\t\t\t\tconst timerScaleNode = time.mul( vec2( - 0.5, 0.1 ) );\n\t\t\t\tconst animateUV = uv().add( timerScaleNode );\n\n\t\t\t\tconst textureNode = texture( uvTexture, animateUV );\n\n\t\t\t\tmaterialBox.colorNode = mix( textureNode, checker( animateUV ), 0.5 );\n\n\t\t\t\t// test uv 2\n\t\t\t\t//geometryBox.setAttribute( 'uv1', geometryBox.getAttribute( 'uv' ) );\n\t\t\t\t//materialBox.colorNode = texture( uvTexture, uv( 1 ) );\n\n\t\t\t\tbox = new THREE.Mesh( geometryBox, materialBox );\n\t\t\t\tbox.position.set( 0, 1, 0 );\n\t\t\t\tscene.add( box );\n\n\t\t\t\t// displace example\n\n\t\t\t\tconst geometrySphere = new THREE.SphereGeometry( .5, 64, 64 );\n\t\t\t\tconst materialSphere = new THREE.MeshBasicNodeMaterial();\n\n\t\t\t\tconst displaceY = texture( textureDisplace ).x.mul( 0.25 );\n\n\t\t\t\tconst displace = normalLocal.mul( displaceY );\n\n\t\t\t\tmaterialSphere.colorNode = displaceY;\n\t\t\t\tmaterialSphere.positionNode = positionLocal.add( displace );\n\n\t\t\t\tconst sphere = new THREE.Mesh( geometrySphere, materialSphere );\n\t\t\t\tsphere.position.set( - 2, - 1, 0 );\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\t// data texture\n\n\t\t\t\tconst geometryPlane = new THREE.PlaneGeometry();\n\t\t\t\tconst materialPlane = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterialPlane.colorNode = texture( createDataTexture() ).add( color( 0x0000FF ) );\n\t\t\t\tmaterialPlane.transparent = true;\n\n\t\t\t\tconst plane = new THREE.Mesh( geometryPlane, materialPlane );\n\t\t\t\tplane.position.set( 0, - 1, 0 );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// compressed texture\n\n\t\t\t\tconst materialCompressed = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterialCompressed.colorNode = texture( ktxTexture );\n\t\t\t\tmaterialCompressed.emissiveNode = oscSine().mix( color( 0x663300 ), color( 0x0000FF ) );\n\t\t\t\tmaterialCompressed.alphaTestNode = oscSine();\n\t\t\t\tmaterialCompressed.transparent = true;\n\n\t\t\t\tconst geo = flipY( new THREE.PlaneGeometry() );\n\t\t\t\tconst planeCompressed = new THREE.Mesh( geo, materialCompressed );\n\t\t\t\tplaneCompressed.position.set( - 2, 1, 0 );\n\t\t\t\tscene.add( planeCompressed );\n\n\t\t\t\t// points\n\n\t\t\t\tconst points = [];\n\n\t\t\t\tfor ( let i = 0; i < 1000; i ++ ) {\n\n\t\t\t\t\tconst point = new THREE.Vector3().random().subScalar( 0.5 );\n\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometryPoints = new THREE.BufferGeometry().setFromPoints( points );\n\t\t\t\tconst materialPoints = new THREE.PointsNodeMaterial();\n\n\t\t\t\tmaterialPoints.colorNode = positionLocal.mul( 3 );\n\n\t\t\t\tconst pointCloud = new THREE.Points( geometryPoints, materialPoints );\n\t\t\t\tpointCloud.position.set( 2, - 1, 0 );\n\t\t\t\tscene.add( pointCloud );\n\n\t\t\t\t// lines\n\n\t\t\t\tconst geometryLine = new THREE.BufferGeometry().setFromPoints( [\n\t\t\t\t\tnew THREE.Vector3( - 0.5, - 0.5, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 0.5, - 0.5, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 0.5, 0.5, 0 ),\n\t\t\t\t\tnew THREE.Vector3( - 0.5, 0.5, 0 ),\n\t\t\t\t\tnew THREE.Vector3( - 0.5, - 0.5, 0 )\n\t\t\t\t] );\n\n\t\t\t\tgeometryLine.setAttribute( 'color', geometryLine.getAttribute( 'position' ) );\n\n\t\t\t\tconst materialLine = new THREE.LineBasicNodeMaterial();\n\t\t\t\tmaterialLine.colorNode = attribute( 'color' );\n\n\t\t\t\tconst line = new THREE.Line( geometryLine, materialLine );\n\t\t\t\tline.position.set( 2, 1, 0 );\n\t\t\t\tscene.add( line );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( box ) {\n\n\t\t\t\t\tbox.rotation.x += 0.01;\n\t\t\t\t\tbox.rotation.y += 0.02;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction createDataTexture() {\n\n\t\t\t\tconst color = new THREE.Color( 0xff0000 );\n\n\t\t\t\tconst width = 512;\n\t\t\t\tconst height = 512;\n\n\t\t\t\tconst size = width * height;\n\t\t\t\tconst data = new Uint8Array( 4 * size );\n\n\t\t\t\tconst r = Math.floor( color.r * 255 );\n\t\t\t\tconst g = Math.floor( color.g * 255 );\n\t\t\t\tconst b = Math.floor( color.b * 255 );\n\n\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\tconst stride = i * 4;\n\n\t\t\t\t\tdata[ stride ] = r;\n\t\t\t\t\tdata[ stride + 1 ] = g;\n\t\t\t\t\tdata[ stride + 2 ] = b;\n\t\t\t\t\tdata[ stride + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.DataTexture( data, width, height, THREE.RGBAFormat );\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Correct UVs to be compatible with `flipY=false` textures.\n\t\t\t */\n\t\t\tfunction flipY( geometry ) {\n\n\t\t\t\tconst uv = geometry.attributes.uv;\n\n\t\t\t\tfor ( let i = 0; i < uv.count; i ++ ) {\n\n\t\t\t\t\tuv.setY( i, 1 - uv.getY( i ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n```\n\nThis example three.js webgpu - sandbox"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - shadertoy"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - shadertoy:\n\n```javascript\nimport * as THREE from 'three/webgpu';\n\t\t\timport * as TSL from 'three/tsl';\n\n\t\t\timport Transpiler from 'three/addons/transpiler/Transpiler.js';\n\t\t\timport ShaderToyDecoder from 'three/addons/transpiler/ShaderToyDecoder.js';\n\t\t\timport TSLEncoder from 'three/addons/transpiler/TSLEncoder.js';\n\n\t\t\tclass ShaderToyNode extends THREE.Node {\n\n\t\t\t\tconstructor() {\n\n\t\t\t\t\tsuper( 'vec4' );\n\n\t\t\t\t\tthis.mainImage = null;\n\n\t\t\t\t}\n\n\t\t\t\ttranspile( glsl, iife = false ) {\n\n\t\t\t\t\tconst decoder = new ShaderToyDecoder();\n\n\t\t\t\t\tconst encoder = new TSLEncoder();\n\t\t\t\t\tencoder.iife = iife;\n\n\t\t\t\t\tconst jsCode = new Transpiler( decoder, encoder ).parse( glsl );\n\n\t\t\t\t\treturn jsCode;\n\n\t\t\t\t}\n\n\t\t\t\tparse( glsl ) {\n\n\t\t\t\t\tconst jsCode = this.transpile( glsl, true );\n\n\t\t\t\t\tconst { mainImage } = eval( jsCode )( TSL );\n\n\t\t\t\t\tthis.mainImage = mainImage;\n\n\t\t\t\t}\n\n\t\t\t\tasync parseAsync( glsl ) {\n\n\t\t\t\t\tconst jsCode = this.transpile( glsl );\n\n\t\t\t\t\tconst { mainImage } = await import( `data:text/javascript,${ encodeURIComponent( jsCode ) }` );\n\n\t\t\t\t\tthis.mainImage = mainImage;\n\n\t\t\t\t}\n\n\t\t\t\tsetup( builder ) {\n\n\t\t\t\t\tif ( this.mainImage === null ) {\n\n\t\t\t\t\t\tthrow new Error( 'ShaderToyNode: .parse() must be called first.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.mainImage();\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tlet renderer, camera, scene;\n\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst example1Code = document.getElementById( 'example1' ).textContent;\n\t\t\t\tconst example2Code = document.getElementById( 'example2' ).textContent;\n\n\t\t\t\tconst shaderToy1Node = new ShaderToyNode();\n\t\t\t\tshaderToy1Node.parse( example1Code );\n\n\t\t\t\tconst shaderToy2Node = new ShaderToyNode();\n\t\t\t\tshaderToy2Node.parse( example2Code );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2 );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tmaterial.colorNode = TSL.oscSine( TSL.time.mul( .3 ) ).mix( shaderToy1Node, shaderToy2Node );\n\n\t\t\t\tconst quad = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( quad );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( dpr );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.outputColorSpace = THREE.LinearSRGBColorSpace;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - shadertoy Shader created by jackdavenport and trinketMage ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - shadow map"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - shadow map:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mx_fractal_noise_vec3, positionWorld, vec4, Fn, color, vertexIndex, hash } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, clock;\n\t\t\tlet dirLight, spotLight;\n\t\t\tlet torusKnot, dirGroup;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 10, 20 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = color( 0x222244 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x222244, 50, 100 );\n\n\t\t\t\t// lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x444444, 2 ) );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xff8888, 400 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.3;\n\t\t\t\tspotLight.position.set( 8, 10, 5 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 8;\n\t\t\t\tspotLight.shadow.camera.far = 200;\n\t\t\t\tspotLight.shadow.mapSize.width = 2048;\n\t\t\t\tspotLight.shadow.mapSize.height = 2048;\n\t\t\t\tspotLight.shadow.bias = - 0.002;\n\t\t\t\tspotLight.shadow.radius = 4;\n\t\t\t\tscene.add( spotLight );\n\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0x8888ff, 3 );\n\t\t\t\tdirLight.position.set( 3, 12, 17 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 500;\n\t\t\t\tdirLight.shadow.camera.right = 17;\n\t\t\t\tdirLight.shadow.camera.left = - 17;\n\t\t\t\tdirLight.shadow.camera.top\t= 17;\n\t\t\t\tdirLight.shadow.camera.bottom = - 17;\n\t\t\t\tdirLight.shadow.mapSize.width = 2048;\n\t\t\t\tdirLight.shadow.mapSize.height = 2048;\n\t\t\t\tdirLight.shadow.radius = 4;\n\t\t\t\tdirLight.shadow.bias = - 0.0005;\n\n\t\t\t\tdirGroup = new THREE.Group();\n\t\t\t\tdirGroup.add( dirLight );\n\t\t\t\tscene.add( dirGroup );\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 25, 8, 75, 80 );\n\t\t\t\tconst material = new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolor: 0x999999,\n\t\t\t\t\tshininess: 0,\n\t\t\t\t\tspecular: 0x222222\n\t\t\t\t} );\n\n\t\t\t\tconst materialCustomShadow = material.clone();\n\t\t\t\tmaterialCustomShadow.transparent = true;\n\n\t\t\t\tconst materialColor = vec4( 1, 0, 1, .5 );\n\t\t\t\n\t\t\t\tconst discardNode = hash( vertexIndex ).greaterThan( 0.5 );\n\n\t\t\t\tmaterialCustomShadow.colorNode = Fn( () => {\n\n\t\t\t\t\tdiscardNode.discard();\n\n\t\t\t\t\treturn materialColor;\n\n\t\t\t\t} )();\n\n\n\t\t\t\tmaterialCustomShadow.castShadowNode = Fn( () => {\n\n\t\t\t\t\tdiscardNode.discard();\n\n\t\t\t\t\treturn materialColor;\n\t\t\t\n\t\t\t\t} )();\n\n\t\t\t\ttorusKnot = new THREE.Mesh( geometry, materialCustomShadow );\n\t\t\t\ttorusKnot.scale.multiplyScalar( 1 / 18 );\n\t\t\t\ttorusKnot.position.y = 3;\n\t\t\t\ttorusKnot.castShadow = true;\n\t\t\t\ttorusKnot.receiveShadow = true;\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 0.75, 0.75, 7, 32 );\n\n\t\t\t\tconst pillar1 = new THREE.Mesh( cylinderGeometry, material );\n\t\t\t\tpillar1.position.set( 8, 3.5, 8 );\n\t\t\t\tpillar1.castShadow = true;\n\n\t\t\t\tconst pillar2 = pillar1.clone();\n\t\t\t\tpillar2.position.set( 8, 3.5, - 8 );\n\t\t\t\tconst pillar3 = pillar1.clone();\n\t\t\t\tpillar3.position.set( - 8, 3.5, 8 );\n\t\t\t\tconst pillar4 = pillar1.clone();\n\t\t\t\tpillar4.position.set( - 8, 3.5, - 8 );\n\n\t\t\t\tscene.add( pillar1 );\n\t\t\t\tscene.add( pillar2 );\n\t\t\t\tscene.add( pillar3 );\n\t\t\t\tscene.add( pillar4 );\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 200, 200 );\n\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongNodeMaterial();\n\t\t\t\tplaneMaterial.color.setHex( 0x999999 );\n\t\t\t\tplaneMaterial.shininess = 0;\n\t\t\t\tplaneMaterial.specular.setHex( 0x111111 );\n\n\t\t\t\tplaneMaterial.receivedShadowPositionNode = Fn( () => {\n\n\t\t\t\t\tconst pos = positionWorld.toVar();\n\t\t\t\t\tpos.xz.addAssign( mx_fractal_noise_vec3( positionWorld.mul( 2 ) ).saturate().xz );\n\t\t\t\t\treturn pos;\n\n\t\t\t\t} )();\n\n\t\t\t\tplaneMaterial.colorNode = Fn( () => {\n\n\t\t\t\t\tconst pos = positionWorld.toVar();\n\t\t\t\t\tpos.xz.addAssign( mx_fractal_noise_vec3( positionWorld.mul( 2 ) ).saturate().xz );\n\t\t\t\t\treturn mx_fractal_noise_vec3( positionWorld.mul( 2 ) ).saturate().zzz.mul( 0.2 ).add( .5 );\n\n\t\t\t\t} )();\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.multiplyScalar( 3 );\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Mouse control\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.minDistance = 7;\n\t\t\t\tcontrols.maxDistance = 40;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\twindow.addEventListener( 'resize', resize );\n\n\t\t\t}\n\n\t\t\tfunction resize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate( time ) {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\ttorusKnot.rotation.x += 0.25 * delta;\n\t\t\t\ttorusKnot.rotation.y += 0.5 * delta;\n\t\t\t\ttorusKnot.rotation.z += 1 * delta;\n\n\t\t\t\tdirGroup.rotation.y += 0.7 * delta;\n\t\t\t\tdirLight.position.z = 17 + Math.sin( time * 0.001 ) * 5;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - webgpu shadow map"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - shadow map array tile demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - shadow map array tile demo:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mx_fractal_noise_vec3, positionWorld, Fn, color } from 'three/tsl';\n\n\t\t\timport { TileShadowNode } from 'three/addons/tsl/shadows/TileShadowNode.js';\n\t\t\timport { TileShadowNodeHelper } from 'three/addons/tsl/shadows/TileShadowNodeHelper.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\timport Stats from 'stats-gl';\n\n\t\t\tlet camera, scene, renderer, clock;\n\t\t\tlet dirLight, stats;\n\t\t\tlet torusKnot, dirGroup;\n\t\t\tlet tsmHelper;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\t// Renderer setup\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.BasicShadowMap;\n\t\t\t\t// renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.2;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\n\t\t\t\tawait renderer.init();\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 45, 60, 100 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = color( 0xCCCCFF ); // Brighter blue sky\n\t\t\t\tscene.fog = new THREE.Fog( 0xCCCCFF, 700, 1000 );\n\n\t\t\t\t// Enhanced lighting for a brighter scene\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xCCCCFF, 3 ) );\n\n\t\t\t\t// Main directional light (sun)\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0xFFFFAA, 5 );\n\t\t\t\tdirLight.position.set( 0, 80, 30 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 1;\n\t\t\t\tdirLight.shadow.camera.far = 200;\n\t\t\t\tdirLight.shadow.camera.right = 180;\n\t\t\t\tdirLight.shadow.camera.left = - 180;\n\t\t\t\tdirLight.shadow.camera.top\t= 180;\n\t\t\t\tdirLight.shadow.camera.bottom = - 160;\n\t\t\t\tdirLight.shadow.mapSize.width = 1024 * 4;\n\t\t\t\tdirLight.shadow.mapSize.height = 1024 * 4;\n\t\t\t\tdirLight.shadow.radius = 1;\n\t\t\t\tdirLight.shadow.bias = - 0.005;\n\n\t\t\t\t// Set up the tile shadow mapping\n\t\t\t\tconst tsm = new TileShadowNode( dirLight, {\n\t\t\t\t\ttilesX: 2,\n\t\t\t\t\ttilesY: 2\n\t\t\t\t} );\n\n\n\t\t\t\tdirLight.shadow.shadowNode = tsm;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\ttsmHelper = new TileShadowNodeHelper( tsm );\n\t\t\t\tscene.add( tsmHelper );\n\n\n\t\t\t\tdirGroup = new THREE.Group();\n\t\t\t\tdirGroup.add( dirLight );\n\t\t\t\tscene.add( dirGroup );\n\n\t\t\t\t// Create the ground with enhanced texture\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 1500, 1500, 2, 2 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x88AA44,\n\t\t\t\t\tshininess: 5,\n\t\t\t\t\tspecular: 0x222222\n\t\t\t\t} );\n\n\t\t\t\tplaneMaterial.colorNode = Fn( () => {\n\n\t\t\t\t\tconst noise = mx_fractal_noise_vec3( positionWorld.mul( 0.05 ) ).saturate();\n\t\t\t\t\t// Mix of greens and browns for a more natural ground\n\t\t\t\t\tconst green = color( 0.4, 0.7, 0.3 );\n\t\t\t\t\tconst brown = color( 0.6, 0.5, 0.3 );\n\t\t\t\t\treturn noise.x.mix( green, brown );\n\t\t\t\n\t\t\t\t} )();\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\n\t\t\t\n\t\t\t\t// Spread various objects across the scene\n\t\t\t\tcreateScenery();\n\n\t\t\t\t// Camera controls\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 5, 0 );\n\t\t\t\tcontrols.minDistance = 0.01;\n\t\t\t\tcontrols.maxDistance = 400;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent camera from going below ground\n\t\t\t\tcontrols.update();\n\n\n\t\t\t\tstats = new Stats( {\n\t\t\t\t\tprecision: 3,\n\t\t\t\t\thorizontal: false,\n\t\t\t\t\ttrackGPU: true\n\t\t\t\t} );\n\t\t\t\tstats.init( renderer );\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\twindow.addEventListener( 'resize', resize );\n\n\t\t\t}\n\n\t\t\tfunction createScenery() {\n\n\t\t\t\t// 1. Columns using instanced mesh\n\t\t\t\tconst columnGeometry = new THREE.CylinderGeometry( 0.8, 1, 1, 16 );\n\t\t\t\tconst columnMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xDDDDDD,\n\t\t\t\t\tshininess: 20\n\t\t\t\t} );\n\n\t\t\t\tconst columnPositions = [];\n\t\t\t\tconst columnScales = [];\n\n\t\t\t\tfor ( let x = - 100; x <= 100; x += 40 ) {\n\n\t\t\t\t\tfor ( let z = - 100; z <= 100; z += 40 ) {\n\n\t\t\t\t\t\tif ( Math.random() > 0.3 ) {\n\n\t\t\t\t\t\t\tconst height = 5 + Math.random() * 10;\n\t\t\t\t\t\t\tconst posX = x + ( Math.random() * 10 - 5 );\n\t\t\t\t\t\t\tconst posY = height / 2;\n\t\t\t\t\t\t\tconst posZ = z + ( Math.random() * 10 - 5 );\n\n\t\t\t\t\t\t\tcolumnPositions.push( posX, posY, posZ );\n\t\t\t\t\t\t\tcolumnScales.push( 1, height, 1 ); // Only scale Y to match height\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst columnCount = columnPositions.length / 3;\n\t\t\t\tconst columnInstancedMesh = new THREE.InstancedMesh(\n\t\t\t\t\tcolumnGeometry,\n\t\t\t\t\tcolumnMaterial,\n\t\t\t\t\tcolumnCount\n\t\t\t\t);\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tfor ( let i = 0; i < columnCount; i ++ ) {\n\n\t\t\t\t\tconst x = columnPositions[ i * 3 ];\n\t\t\t\t\tconst y = columnPositions[ i * 3 + 1 ];\n\t\t\t\t\tconst z = columnPositions[ i * 3 + 2 ];\n\t\t\t\t\tconst scaleY = columnScales[ i * 3 + 1 ];\n\n\t\t\t\t\tmatrix.makeScale( 1, scaleY, 1 );\n\t\t\t\t\tmatrix.setPosition( x, y, z );\n\t\t\t\t\tcolumnInstancedMesh.setMatrixAt( i, matrix );\n\n\t\t\t\t}\n\n\t\t\t\tcolumnInstancedMesh.castShadow = true;\n\t\t\t\tcolumnInstancedMesh.receiveShadow = true;\n\t\t\t\tscene.add( columnInstancedMesh );\n\n\t\t\t\t// 2. Add a central feature - the torus knot (kept as regular mesh for animation)\n\t\t\t\tconst torusKnotGeometry = new THREE.TorusKnotGeometry( 25, 8, 100, 30 );\n\t\t\t\tconst torusKnotMaterial = new THREE.MeshPhongNodeMaterial( {\n\t\t\t\t\tcolor: 0xFF6347, // Tomato color\n\t\t\t\t\tshininess: 30,\n\t\t\t\t} );\n\n\t\t\t\ttorusKnot = new THREE.Mesh( torusKnotGeometry, torusKnotMaterial );\n\t\t\t\ttorusKnot.scale.multiplyScalar( 1 / 18 );\n\t\t\t\ttorusKnot.position.x = 5;\n\t\t\t\ttorusKnot.position.y = 5;\n\t\t\t\ttorusKnot.castShadow = true;\n\t\t\t\ttorusKnot.receiveShadow = true;\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\t// 3. Cubes using instanced mesh\n\t\t\t\tconst cubeGeometry = new THREE.BoxGeometry( 3, 3, 3 );\n\t\t\t\tconst cubeMaterials = [\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0x6699CC, shininess: 20 } ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xCC6666, shininess: 20 } ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xCCCC66, shininess: 20 } )\n\t\t\t\t];\n\n\t\t\t\tconst cubeCount = 10;\n\t\t\t\tconst cubeInstances = cubeMaterials.map( material => {\n\n\t\t\t\t\treturn new THREE.InstancedMesh( cubeGeometry, material, cubeCount );\n\n\t\t\t\t} );\n\n\t\t\t\tfor ( let i = 0; i < 30; i ++ ) {\n\n\t\t\t\t\tconst materialIndex = i % 3;\n\t\t\t\t\tconst instanceIndex = Math.floor( i / 3 );\n\n\t\t\t\t\tconst x = Math.random() * 300 - 150;\n\t\t\t\t\tconst y = 1.5;\n\t\t\t\t\tconst z = Math.random() * 300 - 150;\n\t\t\t\t\tconst rotY = Math.random() * Math.PI * 2;\n\n\t\t\t\t\tmatrix.makeRotationY( rotY );\n\t\t\t\t\tmatrix.setPosition( x, y, z );\n\n\t\t\t\t\tcubeInstances[ materialIndex ].setMatrixAt( instanceIndex, matrix );\n\n\t\t\t\t}\n\n\t\t\t\tcubeInstances.forEach( instance => {\n\n\t\t\t\t\tinstance.castShadow = true;\n\t\t\t\t\tinstance.receiveShadow = true;\n\t\t\t\t\tscene.add( instance );\n\n\t\t\t\t} );\n\n\t\t\t\t// 4. Spheres using instanced mesh\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );\n\t\t\t\tconst sphereMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x88CCAA,\n\t\t\t\t\tshininess: 40\n\t\t\t\t} );\n\n\t\t\t\tconst sphereCount = 25;\n\t\t\t\tconst sphereInstancedMesh = new THREE.InstancedMesh(\n\t\t\t\t\tsphereGeometry,\n\t\t\t\t\tsphereMaterial,\n\t\t\t\t\tsphereCount\n\t\t\t\t);\n\n\t\t\t\tfor ( let i = 0; i < sphereCount; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * 180 - 90;\n\t\t\t\t\tconst y = 2;\n\t\t\t\t\tconst z = Math.random() * 180 - 90;\n\n\t\t\t\t\tmatrix.makeScale( 1, 1, 1 );\n\t\t\t\t\tmatrix.setPosition( x, y, z );\n\t\t\t\t\tsphereInstancedMesh.setMatrixAt( i, matrix );\n\n\t\t\t\t}\n\n\t\t\t\tsphereInstancedMesh.castShadow = true;\n\t\t\t\tsphereInstancedMesh.receiveShadow = true;\n\t\t\t\tscene.add( sphereInstancedMesh );\n\n\t\t\t\t// 5. Trees using instanced mesh for trunks and tops separately\n\t\t\t\tconst trunkGeometry = new THREE.CylinderGeometry( 0.5, 0.5, 2, 8 );\n\t\t\t\tconst topGeometry = new THREE.ConeGeometry( 2, 8, 8 );\n\t\t\t\tconst treeMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tvertexColors: true,\n\t\t\t\t\tshininess: 5\n\t\t\t\t} );\n\n\t\t\t\tconst treeCount = 40;\n\t\t\t\tconst totalInstanceCount = treeCount * 2;\n\n\t\t\t\tconst trunkVertexCount = trunkGeometry.attributes.position.count;\n\t\t\t\tconst trunkIndexCount = trunkGeometry.index ? trunkGeometry.index.count : 0;\n\t\t\t\tconst topVertexCount = topGeometry.attributes.position.count;\n\t\t\t\tconst topIndexCount = topGeometry.index ? topGeometry.index.count : 0;\n\n\n\t\t\t\tconst totalVertexCount = ( trunkVertexCount + topVertexCount ) * 2; // Multiple for safety\n\t\t\t\tconst totalIndexCount = ( trunkIndexCount + topIndexCount ) * 2;\n\t\t\t\tconst treeBatchedMesh = new THREE.BatchedMesh( totalInstanceCount, totalVertexCount, totalIndexCount, treeMaterial );\n\t\t\t\ttreeBatchedMesh.castShadow = true;\n\t\t\t\ttreeBatchedMesh.perObjectFrustumCulled = false;\n\t\t\t\tconst trunkGeometryId = treeBatchedMesh.addGeometry( trunkGeometry );\n\t\t\t\tconst topGeometryId = treeBatchedMesh.addGeometry( topGeometry );\n\n\t\t\t\tconst trunkColor = new THREE.Color( 0x8B4513 );\n\t\t\t\tconst topColor = new THREE.Color( 0x336633 );\n\n\n\t\t\t\tfor ( let i = 0; i < treeCount; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * 300 - 150;\n\t\t\t\t\tconst z = Math.random() * 300 - 150;\n\n\t\t\t\t\tconst trunkId = treeBatchedMesh.addInstance( trunkGeometryId );\n\t\t\t\t\tmatrix.makeScale( 1, 1, 1 );\n\t\t\t\t\tmatrix.setPosition( x, 1, z );\n\t\t\t\t\ttreeBatchedMesh.setMatrixAt( trunkId, matrix );\n\t\t\t\t\ttreeBatchedMesh.setColorAt( trunkId, trunkColor );\n\n\t\t\t\t\tconst topId = treeBatchedMesh.addInstance( topGeometryId );\n\t\t\t\t\tmatrix.makeScale( 1, 1, 1 );\n\t\t\t\t\tmatrix.setPosition( x, 6, z );\n\t\t\t\t\ttreeBatchedMesh.setMatrixAt( topId, matrix );\n\t\t\t\t\ttreeBatchedMesh.setColorAt( topId, topColor );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( treeBatchedMesh );\n\n\n\t\t\t\t// 6. Torus shapes using instanced mesh\n\t\t\t\tconst torusGeometry = new THREE.TorusGeometry( 3, 1, 16, 50 );\n\t\t\t\tconst torusMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0xFF99CC,\n\t\t\t\t\tshininess: 30\n\t\t\t\t} );\n\n\t\t\t\tconst torusCount = 15;\n\t\t\t\tconst torusInstancedMesh = new THREE.InstancedMesh(\n\t\t\t\t\ttorusGeometry,\n\t\t\t\t\ttorusMaterial,\n\t\t\t\t\ttorusCount\n\t\t\t\t);\n\n\t\t\t\tfor ( let i = 0; i < torusCount; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * 320 - 160;\n\t\t\t\t\tconst y = 2;\n\t\t\t\t\tconst z = Math.random() * 320 - 160;\n\t\t\t\t\tconst rotZ = Math.random() * Math.PI * 2;\n\n\t\t\t\t\t// Apply rotation (PI/2 on X-axis and random on Z-axis)\n\t\t\t\t\tmatrix.makeRotationX( Math.PI / 2 );\n\t\t\t\t\tconst rotMatrix = new THREE.Matrix4().makeRotationZ( rotZ );\n\t\t\t\t\tmatrix.multiply( rotMatrix );\n\t\t\t\t\tmatrix.setPosition( x, y, z );\n\n\t\t\t\t\ttorusInstancedMesh.setMatrixAt( i, matrix );\n\n\t\t\t\t}\n\n\t\t\t\ttorusInstancedMesh.castShadow = true;\n\t\t\t\ttorusInstancedMesh.receiveShadow = true;\n\t\t\t\tscene.add( torusInstancedMesh );\n\n\t\t\t}\n\n\t\t\tfunction resize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate( time ) {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\t// Rotate the central torus knot\n\t\t\t\ttorusKnot.rotation.x += 0.25 * delta;\n\t\t\t\ttorusKnot.rotation.y += 0.5 * delta;\n\t\t\t\ttorusKnot.rotation.z += 1 * delta;\n\n\t\t\t\tdirLight.position.x = Math.sin( time * 0.0001 ) * 30;\n\t\t\t\tdirLight.position.z = Math.cos( time * 0.0001 ) * 30;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\ttsmHelper.update();\n\n\t\t\t\tawait renderer.resolveTimestampsAsync();\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - tile shadow using shadow map array demonstration"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - cascaded shadow maps"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - cascaded shadow maps:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { CSMShadowNode } from 'three/addons/csm/CSMShadowNode.js';\n\t\t\timport { CSMHelper } from 'three/addons/csm/CSMHelper.js';\n\n\t\t\tlet renderer, scene, camera, orthoCamera, controls, csm, csmHelper, csmDirectionalLight;\n\n\t\t\tconst params = {\n\t\t\t\torthographic: false,\n\t\t\t\tfade: false,\n\t\t\t\tshadows: true,\n\t\t\t\tmaxFar: 1000,\n\t\t\t\tmode: 'practical',\n\t\t\t\tlightX: - 1,\n\t\t\t\tlightY: - 1,\n\t\t\t\tlightZ: - 1,\n\t\t\t\tmargin: 100,\n\t\t\t\tshadowNear: 1,\n\t\t\t\tshadowFar: 2000,\n\t\t\t\tautoUpdateHelper: true,\n\t\t\t\tupdateHelper: function () {\n\n\t\t\t\t\tcsmHelper.update();\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction updateOrthoCamera() {\n\n\t\t\t\tconst size = controls.target.distanceTo( camera.position );\n\t\t\t\tconst aspect = camera.aspect;\n\n\t\t\t\torthoCamera.left = size * aspect / - 2;\n\t\t\t\torthoCamera.right = size * aspect / 2;\n\n\t\t\t\torthoCamera.top = size / 2;\n\t\t\t\torthoCamera.bottom = size / - 2;\n\t\t\t\torthoCamera.position.copy( camera.position );\n\t\t\t\torthoCamera.rotation.copy( camera.rotation );\n\t\t\t\torthoCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( '#454e61' );\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 5000 );\n\t\t\t\torthoCamera = new THREE.OrthographicCamera();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.shadowMap.enabled = params.shadows;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcamera.position.set( 60, 60, 0 );\n\t\t\t\tcontrols.target = new THREE.Vector3( - 100, 10, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff, 1.5 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst additionalDirectionalLight = new THREE.DirectionalLight( 0x000020, 1.5 );\n\t\t\t\tadditionalDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );\n\t\t\t\tscene.add( additionalDirectionalLight );\n\n\t\t\t\tcsmDirectionalLight = new THREE.DirectionalLight( 0xffffff, 3.0 );\n\n\t\t\t\tcsmDirectionalLight.castShadow = true;\n\t\t\t\tcsmDirectionalLight.shadow.mapSize.width = 2048;\n\t\t\t\tcsmDirectionalLight.shadow.mapSize.height = 2048;\n\t\t\t\tcsmDirectionalLight.shadow.camera.near = params.shadowNear;\n\t\t\t\tcsmDirectionalLight.shadow.camera.far = params.shadowFar;\n\t\t\t\tcsmDirectionalLight.shadow.camera.top = 1000;\n\t\t\t\tcsmDirectionalLight.shadow.camera.bottom = - 1000;\n\t\t\t\tcsmDirectionalLight.shadow.camera.left = - 1000;\n\t\t\t\tcsmDirectionalLight.shadow.camera.right = 1000;\n\t\t\t\tcsmDirectionalLight.shadow.bias = - 0.001;\n\n\t\t\t\tcsm = new CSMShadowNode( csmDirectionalLight, { cascades: 4, maxFar: params.maxFar, mode: params.mode } );\n\n\t\t\t\tcsmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );\n\n\t\t\t\tcsmDirectionalLight.shadow.shadowNode = csm;\n\n\t\t\t\tscene.add( csmDirectionalLight );\n\n\t\t\t\tcsmHelper = new CSMHelper( csm );\n\t\t\t\tcsmHelper.visible = false;\n\t\t\t\tscene.add( csmHelper );\n\n\t\t\t\tconst floorMaterial = new THREE.MeshPhongMaterial( { color: '#252a34' } );\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.PlaneGeometry( 10000, 10000, 8, 8 ), floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.castShadow = true;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tconst material1 = new THREE.MeshPhongMaterial( { color: '#08d9d6' } );\n\n\t\t\t\tconst material2 = new THREE.MeshPhongMaterial( { color: '#ff2e63' } );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 10, 10, 10 );\n\n\t\t\t\tfor ( let i = 0; i < 40; i ++ ) {\n\n\t\t\t\t\tconst cube1 = new THREE.Mesh( geometry, i % 2 === 0 ? material1 : material2 );\n\t\t\t\t\tcube1.castShadow = true;\n\t\t\t\t\tcube1.receiveShadow = true;\n\t\t\t\t\tscene.add( cube1 );\n\t\t\t\t\tcube1.position.set( - i * 25, 20, 30 );\n\t\t\t\t\tcube1.scale.y = Math.random() * 2 + 6;\n\n\t\t\t\t\tconst cube2 = new THREE.Mesh( geometry, i % 2 === 0 ? material2 : material1 );\n\t\t\t\t\tcube2.castShadow = true;\n\t\t\t\t\tcube2.receiveShadow = true;\n\t\t\t\t\tscene.add( cube2 );\n\t\t\t\t\tcube2.position.set( - i * 25, 20, - 30 );\n\t\t\t\t\tcube2.scale.y = Math.random() * 2 + 6;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'orthographic' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.camera = value ? orthoCamera : camera;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\t// gui.add( params, 'fade' ).onChange( function ( value ) {\n\n\t\t\t\t// csm.fade = value;\n\t\t\t\t// csm.updateFrustums();\n\t\t\t\t// TODO: Changing \"fade\" requires toggling shadows right now\n\n\t\t\t\t// } );\n\n\t\t\t\tgui.add( params, 'shadows' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsmDirectionalLight.castShadow = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'maxFar', 1, 5000 ).step( 1 ).name( 'max shadow far' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.maxFar = value;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'mode', [ 'uniform', 'logarithmic', 'practical' ] ).name( 'frustum split mode' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.mode = value;\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightX', - 1, 1 ).name( 'light direction x' ).onChange( function () {\n\n\t\t\t\t\tcsmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightY', - 1, 1 ).name( 'light direction y' ).onChange( function () {\n\n\t\t\t\t\tcsmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'lightZ', - 1, 1 ).name( 'light direction z' ).onChange( function () {\n\n\t\t\t\t\tcsmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'margin', 0, 200 ).name( 'light margin' ).onChange( function ( value ) {\n\n\t\t\t\t\tcsm.lightMargin = value;\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'shadowNear', 1, 10000 ).name( 'shadow near' ).onChange( function ( value ) {\n\n\t\t\t\t\tfor ( let i = 0; i < csm.lights.length; i ++ ) {\n\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.near = value;\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.updateProjectionMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgui.add( params, 'shadowFar', 1, 10000 ).name( 'shadow far' ).onChange( function ( value ) {\n\n\t\t\t\t\tfor ( let i = 0; i < csm.lights.length; i ++ ) {\n\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.far = value;\n\t\t\t\t\t\tcsm.lights[ i ].shadow.camera.updateProjectionMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tconst helperFolder = gui.addFolder( 'helper' );\n\n\t\t\t\thelperFolder.add( csmHelper, 'visible' );\n\n\t\t\t\thelperFolder.add( csmHelper, 'displayFrustum' ).onChange( function () {\n\n\t\t\t\t\tcsmHelper.updateVisibility();\n\n\t\t\t\t} );\n\n\t\t\t\thelperFolder.add( csmHelper, 'displayPlanes' ).onChange( function () {\n\n\t\t\t\t\tcsmHelper.updateVisibility();\n\n\t\t\t\t} );\n\n\t\t\t\thelperFolder.add( csmHelper, 'displayShadowBounds' ).onChange( function () {\n\n\t\t\t\t\tcsmHelper.updateVisibility();\n\n\t\t\t\t} );\n\n\t\t\t\thelperFolder.add( params, 'autoUpdateHelper' ).name( 'auto update' );\n\n\t\t\t\thelperFolder.add( params, 'updateHelper' ).name( 'update' );\n\n\t\t\t\thelperFolder.open();\n\n\t\t\t\twindow.addEventListener( 'resize', function () {\n\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\tupdateOrthoCamera();\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcamera.updateMatrixWorld();\n\t\t\t\tcontrols.update();\n\n\t\t\t\tif ( params.orthographic ) {\n\n\t\t\t\t\tupdateOrthoCamera();\n\t\t\t\t\tcsm.updateFrustums();\n\n\t\t\t\t\tif ( params.autoUpdateHelper ) {\n\n\t\t\t\t\t\tcsmHelper.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( scene, orthoCamera );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( params.autoUpdateHelper ) {\n\n\t\t\t\t\t\tcsmHelper.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js webgpu - cascaded shadow maps by StrandedKitty ( original repository )"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - shadowmap + opacity"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - shadowmap + opacity:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, mix } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 40 );\n\t\t\t\tcamera.position.set( - 4, 2, 6 );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.toneMapping = THREE.AgXToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1.5;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x9e9eff );\n\n\t\t\t\t// light + shadow\n\n\t\t\t\tconst hemi = new THREE.AmbientLight( 0xffffff, .5 );\n\t\t\t\tscene.add( hemi );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0x6666ff, 10 );\n\t\t\t\tdirLight.position.set( 3, 5, 17 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 50;\n\t\t\t\tdirLight.shadow.camera.right = 5;\n\t\t\t\tdirLight.shadow.camera.left = - 5;\n\t\t\t\tdirLight.shadow.camera.top\t= 5;\n\t\t\t\tdirLight.shadow.camera.bottom = - 5;\n\t\t\t\tdirLight.shadow.mapSize.width = 2048;\n\t\t\t\tdirLight.shadow.mapSize.height = 2048;\n\t\t\t\tdirLight.shadow.radius = 4;\n\t\t\t\tdirLight.shadow.bias = - 0.0005;\n\n\t\t\t\tdirLight.shadow.autoUpdate = false;\n\t\t\t\tdirLight.shadow.needsUpdate = true;\n\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\t//\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tconst gltf = await loader.loadAsync( 'models/gltf/DragonAttenuation.glb' );\n\t\t\t\tgltf.scene.position.set( 0, 0, - .5 );\n\n\t\t\t\tconst floor = gltf.scene.children[ 0 ];\n\t\t\t\tfloor.scale.x += 4;\n\t\t\t\tfloor.scale.y += 4;\n\n\t\t\t\tconst dragon = gltf.scene.children[ 1 ];\n\t\t\t\tdragon.position.set( - 1.5, - 0.8, 1 );\n\n\t\t\t\tconst dragon2 = dragon.clone();\n\t\t\t\tdragon2.material = dragon.material.clone();\n\t\t\t\tdragon2.material.attenuationColor = new THREE.Color( 0xff0000 );\n\t\t\t\tdragon2.position.x += 4;\n\t\t\t\tgltf.scene.add( dragon2 );\n\n\t\t\t\t// shadow node\n\n\t\t\t\tconst customShadow = Fn( ( [ color, opacity = 1 ] ) => {\n\n\t\t\t\t\t//return vec4( color, opacity ); // opacity by blending\n\t\t\t\t\treturn mix( 1, color, opacity ); // opacity by color\n\n\t\t\t\t} );\n\n\t\t\t\t// apply shadow\n\n\t\t\t\tfloor.receiveShadow = true;\n\n\t\t\t\tdragon.castShadow = dragon2.castShadow = true;\n\t\t\t\tdragon.receiveShadow = dragon2.receiveShadow = true;\n\n\t\t\t\tdragon.material.castShadowNode = customShadow( dragon.material.attenuationColor );\n\t\t\t\tdragon2.material.castShadowNode = customShadow( dragon2.material.attenuationColor );\n\n\t\t\t\t//\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - shadowmap + opacity"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - progressive lightmap accumulation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - progressive lightmap accumulation:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\t\timport { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMapGPU.js';\n\n\t\t\t// ShadowMap + LightMap Res and Number of Directional Lights\n\t\t\tconst shadowMapRes = 1024, lightMapRes = 1024, lightCount = 4;\n\t\t\tlet camera, scene, renderer, controls, control, control2,\n\t\t\t\tobject = new THREE.Mesh(), lightOrigin = null, progressiveSurfacemap;\n\t\t\tconst dirLights = [], lightmapObjects = [];\n\t\t\tconst params = { 'Enable': true, 'Blur Edges': true, 'Blend Window': 200,\n\t\t\t\t\t\t\t 'Light Radius': 50, 'Ambient Weight': 0.5, 'Debug Lightmap': false };\n\t\t\tinit();\n\t\t\tcreateGUI();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// renderer\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 100, 200 );\n\t\t\t\tcamera.name = 'Camera';\n\n\t\t\t\t// scene\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x949494 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x949494, 1000, 3000 );\n\n\t\t\t\t// progressive lightmap\n\t\t\t\tprogressiveSurfacemap = new ProgressiveLightMap( renderer, lightMapRes );\n\n\t\t\t\t// directional lighting \"origin\"\n\t\t\t\tlightOrigin = new THREE.Group();\n\t\t\t\tlightOrigin.position.set( 60, 150, 100 );\n\t\t\t\tscene.add( lightOrigin );\n\n\t\t\t\t// transform gizmo\n\t\t\t\tcontrol = new TransformControls( camera, renderer.domElement );\n\t\t\t\tcontrol.addEventListener( 'dragging-changed', ( event ) => {\n\n\t\t\t\t\tcontrols.enabled = ! event.value;\n\n\t\t\t\t} );\n\t\t\t\tcontrol.attach( lightOrigin );\n\t\t\t\tscene.add( control.getHelper() );\n\n\t\t\t\t// create 8 directional lights to speed up the convergence\n\t\t\t\tfor ( let l = 0; l < lightCount; l ++ ) {\n\n\t\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, Math.PI / lightCount );\n\t\t\t\t\tdirLight.name = 'Dir. Light ' + l;\n\t\t\t\t\tdirLight.position.set( 200, 200, 200 );\n\t\t\t\t\tdirLight.castShadow = true;\n\t\t\t\t\tdirLight.shadow.camera.near = 100;\n\t\t\t\t\tdirLight.shadow.camera.far = 5000;\n\t\t\t\t\tdirLight.shadow.camera.right = 150;\n\t\t\t\t\tdirLight.shadow.camera.left = - 150;\n\t\t\t\t\tdirLight.shadow.camera.top = 150;\n\t\t\t\t\tdirLight.shadow.camera.bottom = - 150;\n\t\t\t\t\tdirLight.shadow.mapSize.width = shadowMapRes;\n\t\t\t\t\tdirLight.shadow.mapSize.height = shadowMapRes;\n\t\t\t\t\tdirLight.shadow.bias = - 0.001;\n\t\t\t\t\tlightmapObjects.push( dirLight );\n\t\t\t\t\tdirLights.push( dirLight );\n\n\t\t\t\t}\n\n\t\t\t\t// ground\n\t\t\t\tconst groundMesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 600, 600 ),\n\t\t\t\t\tnew THREE.MeshPhongMaterial( { color: 0xffffff, depthWrite: true } )\n\t\t\t\t);\n\t\t\t\tgroundMesh.position.y = - 0.1;\n\t\t\t\tgroundMesh.rotation.x = - Math.PI / 2;\n\t\t\t\tgroundMesh.name = 'Ground Mesh';\n\t\t\t\tlightmapObjects.push( groundMesh );\n\t\t\t\tscene.add( groundMesh );\n\n\t\t\t\t// model\n\t\t\t\tfunction loadModel() {\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tchild.name = 'Loaded Mesh';\n\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\t\t\t\t\t\t\tchild.material = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t\t\t// This adds the model to the lightmap\n\t\t\t\t\t\t\tlightmapObjects.push( child );\n\t\t\t\t\t\t\tprogressiveSurfacemap.addObjectsToLightMap( lightmapObjects );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tchild.layers.disableAll(); // Disable Rendering for this\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tscene.add( object );\n\t\t\t\t\tobject.scale.set( 2, 2, 2 );\n\t\t\t\t\tobject.position.set( 0, - 16, 0 );\n\t\t\t\t\tcontrol2 = new TransformControls( camera, renderer.domElement );\n\t\t\t\t\tcontrol2.addEventListener( 'dragging-changed', ( event ) => {\n\n\t\t\t\t\t\tcontrols.enabled = ! event.value;\n\n\t\t\t\t\t} );\n\t\t\t\t\tcontrol2.attach( object );\n\t\t\t\t\tscene.add( control2.getHelper() );\n\t\t\t\t\tconst lightTarget = new THREE.Group();\n\t\t\t\t\tlightTarget.position.set( 0, 20, 0 );\n\t\t\t\t\tfor ( let l = 0; l < dirLights.length; l ++ ) {\n\n\t\t\t\t\t\tdirLights[ l ].target = lightTarget;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.add( lightTarget );\n\n\t\t\t\t}\n\n\t\t\t\tconst manager = new THREE.LoadingManager( loadModel );\n\t\t\t\tconst loader = new GLTFLoader( manager );\n\t\t\t\tloader.load( 'models/gltf/ShadowmappableMesh.glb', function ( obj ) {\n\n\t\t\t\t\tobject = obj.scene.children[ 0 ];\n\n\t\t\t\t} );\n\n\t\t\t\t// controls\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\t\t\t\tcontrols.screenSpacePanning = true;\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 500;\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 1.5;\n\t\t\t\tcontrols.target.set( 0, 100, 0 );\n\t\t\t\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction createGUI() {\n\n\t\t\t\tconst gui = new GUI( { title: 'Accumulation Settings' } );\n\t\t\t\tgui.add( params, 'Enable' );\n\t\t\t\tgui.add( params, 'Blur Edges' );\n\t\t\t\tgui.add( params, 'Blend Window', 1, 500 ).step( 1 );\n\t\t\t\tgui.add( params, 'Light Radius', 0, 200 ).step( 10 );\n\t\t\t\tgui.add( params, 'Ambient Weight', 0, 1 ).step( 0.1 );\n\t\t\t\tgui.add( params, 'Debug Lightmap' ).onChange( ( value ) => progressiveSurfacemap.showDebugLightmap( value ) );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// Update the inertia on the orbit controls\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// Accumulate Surface Maps\n\t\t\t\tif ( params[ 'Enable' ] ) {\n\n\t\t\t\t\tprogressiveSurfacemap.update( camera, params[ 'Blend Window' ], params[ 'Blur Edges' ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Manually Update the Directional Lights\n\t\t\t\tfor ( let l = 0; l < dirLights.length; l ++ ) {\n\n\t\t\t\t\t// Sometimes they will be sampled from the target direction\n\t\t\t\t\t// Sometimes they will be uniformly sampled from the upper hemisphere\n\t\t\t\t\tif ( Math.random() > params[ 'Ambient Weight' ] ) {\n\n\t\t\t\t\t\tdirLights[ l ].position.set(\n\t\t\t\t\t\t\tlightOrigin.position.x + ( Math.random() * params[ 'Light Radius' ] ),\n\t\t\t\t\t\t\tlightOrigin.position.y + ( Math.random() * params[ 'Light Radius' ] ),\n\t\t\t\t\t\t\tlightOrigin.position.z + ( Math.random() * params[ 'Light Radius' ] ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Uniform Hemispherical Surface Distribution for Ambient Occlusion\n\t\t\t\t\t\tconst lambda = Math.acos( 2 * Math.random() - 1 ) - ( 3.14159 / 2.0 );\n\t\t\t\t\t\tconst phi = 2 * 3.14159 * Math.random();\n\t\t\t\t\t\tdirLights[ l ].position.set(\n\t\t\t\t\t\t\t        ( ( Math.cos( lambda ) * Math.cos( phi ) ) * 300 ) + object.position.x,\n\t\t\t\t\t\t\tMath.abs( ( Math.cos( lambda ) * Math.sin( phi ) ) * 300 ) + object.position.y + 20,\n\t\t\t\t\t\t\t          ( Math.sin( lambda ) * 300 ) + object.position.z\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Render Scene\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - Progressive Lightmaps by zalo [Inspired by evanw's Lightmap Generation ]"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - VSM Shadows example"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - VSM Shadows example:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, clock, stats;\n\t\t\tlet dirLight, spotLight;\n\t\t\tlet torusKnot, dirGroup;\n\t\t\tlet config;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitScene();\n\t\t\t\tinitMisc();\n\n\t\t\t\t// Init gui\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconfig = {\n\t\t\t\t\tspotlightRadius: 4,\n\t\t\t\t\tspotlightSamples: 8,\n\t\t\t\t\tdirlightRadius: 4,\n\t\t\t\t\tdirlightSamples: 8,\n\t\t\t\t\tanimate: true\n\t\t\t\t};\n\n\t\t\t\tconst spotlightFolder = gui.addFolder( 'Spotlight' );\n\t\t\t\tspotlightFolder.add( config, 'spotlightRadius' ).name( 'radius' ).min( 0 ).max( 25 ).onChange( function ( value ) {\n\n\t\t\t\t\tspotLight.shadow.radius = value;\n\n\t\t\t\t} );\n\n\t\t\t\tspotlightFolder.add( config, 'spotlightSamples', 1, 25, 1 ).name( 'samples' ).onChange( function ( value ) {\n\n\t\t\t\t\tspotLight.shadow.blurSamples = value;\n\n\t\t\t\t} );\n\t\t\t\tspotlightFolder.open();\n\n\t\t\t\tconst dirlightFolder = gui.addFolder( 'Directional Light' );\n\t\t\t\tdirlightFolder.add( config, 'dirlightRadius' ).name( 'radius' ).min( 0 ).max( 25 ).onChange( function ( value ) {\n\n\t\t\t\t\tdirLight.shadow.radius = value;\n\n\t\t\t\t} );\n\n\t\t\t\tdirlightFolder.add( config, 'dirlightSamples', 1, 25, 1 ).name( 'samples' ).onChange( function ( value ) {\n\n\t\t\t\t\tdirLight.shadow.blurSamples = value;\n\n\t\t\t\t} );\n\t\t\t\tdirlightFolder.open();\n\n\t\t\t\tgui.add( config, 'animate' );\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initScene() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 10, 30 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222244 );\n\t\t\t\tscene.fog = new THREE.Fog( 0x222244, 50, 100 );\n\n\t\t\t\t// Lights\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x444444 ) );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xff8888, 400 );\n\t\t\t\tspotLight.angle = Math.PI / 5;\n\t\t\t\tspotLight.penumbra = 0.3;\n\t\t\t\tspotLight.position.set( 8, 10, 5 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.camera.near = 8;\n\t\t\t\tspotLight.shadow.camera.far = 200;\n\t\t\t\tspotLight.shadow.mapSize.width = 256;\n\t\t\t\tspotLight.shadow.mapSize.height = 256;\n\t\t\t\tspotLight.shadow.bias = - 0.002;\n\t\t\t\tspotLight.shadow.radius = 4;\n\t\t\t\tscene.add( spotLight );\n\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0x8888ff, 3 );\n\t\t\t\tdirLight.position.set( 3, 12, 17 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\t\tdirLight.shadow.camera.far = 500;\n\t\t\t\tdirLight.shadow.camera.right = 17;\n\t\t\t\tdirLight.shadow.camera.left = - 17;\n\t\t\t\tdirLight.shadow.camera.top\t= 17;\n\t\t\t\tdirLight.shadow.camera.bottom = - 17;\n\t\t\t\tdirLight.shadow.mapSize.width = 512;\n\t\t\t\tdirLight.shadow.mapSize.height = 512;\n\t\t\t\tdirLight.shadow.radius = 4;\n\t\t\t\tdirLight.shadow.bias = - 0.0005;\n\n\t\t\t\tdirGroup = new THREE.Group();\n\t\t\t\tdirGroup.add( dirLight );\n\t\t\t\tscene.add( dirGroup );\n\n\t\t\t\t// Geometry\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 25, 8, 75, 20 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x999999,\n\t\t\t\t\tshininess: 0,\n\t\t\t\t\tspecular: 0x222222\n\t\t\t\t} );\n\n\t\t\t\ttorusKnot = new THREE.Mesh( geometry, material );\n\t\t\t\ttorusKnot.scale.multiplyScalar( 1 / 18 );\n\t\t\t\ttorusKnot.position.y = 3;\n\t\t\t\ttorusKnot.castShadow = true;\n\t\t\t\ttorusKnot.receiveShadow = true;\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 0.75, 0.75, 7, 32 );\n\n\t\t\t\tconst pillar1 = new THREE.Mesh( cylinderGeometry, material );\n\t\t\t\tpillar1.position.set( 8, 3.5, 8 );\n\t\t\t\tpillar1.castShadow = true;\n\t\t\t\tpillar1.receiveShadow = true;\n\n\t\t\t\tconst pillar2 = pillar1.clone();\n\t\t\t\tpillar2.position.set( 8, 3.5, - 8 );\n\t\t\t\tconst pillar3 = pillar1.clone();\n\t\t\t\tpillar3.position.set( - 8, 3.5, 8 );\n\t\t\t\tconst pillar4 = pillar1.clone();\n\t\t\t\tpillar4.position.set( - 8, 3.5, - 8 );\n\n\t\t\t\tscene.add( pillar1 );\n\t\t\t\tscene.add( pillar2 );\n\t\t\t\tscene.add( pillar3 );\n\t\t\t\tscene.add( pillar4 );\n\n\t\t\t\tconst planeGeometry = new THREE.PlaneGeometry( 200, 200 );\n\t\t\t\tconst planeMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tcolor: 0x999999,\n\t\t\t\t\tshininess: 0,\n\t\t\t\t\tspecular: 0x111111\n\t\t\t\t} );\n\n\t\t\t\tconst ground = new THREE.Mesh( planeGeometry, planeMaterial );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.scale.multiplyScalar( 3 );\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t}\n\n\t\t\tfunction initMisc() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\n\t\t\t\t// Mouse control\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate( time ) {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( config.animate === true ) {\n\n\t\t\t\t\ttorusKnot.rotation.x += 0.25 * delta;\n\t\t\t\t\ttorusKnot.rotation.y += 0.5 * delta;\n\t\t\t\t\ttorusKnot.rotation.z += 1 * delta;\n\n\t\t\t\t\tdirGroup.rotation.y += 0.7 * delta;\n\t\t\t\t\tdirLight.position.z = 17 + Math.sin( time * 0.001 ) * 5;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js - VSM Shadows example by Paul Brunt"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - skinning"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - skinning:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, screenUV } from 'three/tsl';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );\n\t\t\t\tcamera.position.set( 1, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) );\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//lights\n\n\t\t\t\tconst light = new THREE.PointLight( 0xffffff, 1, 100 );\n\t\t\t\tlight.power = 2500;\n\t\t\t\tcamera.add( light );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0x4466ff, 1 );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tconst object = gltf.scene;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t//renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.4;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - skinning"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - skinning instancing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - skinning instancing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { pass, mix, range, color, oscSine, time } from 'three/tsl';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet postProcessing;\n\n\t\t\tlet mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 40 );\n\t\t\t\tcamera.position.set( 1, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tcamera.lookAt( 0, 1, 0 );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst centerLight = new THREE.PointLight( 0xff9900, 1, 100 );\n\t\t\t\tcenterLight.position.y = 4.5;\n\t\t\t\tcenterLight.position.z = - 2;\n\t\t\t\tcenterLight.power = 400;\n\t\t\t\tscene.add( centerLight );\n\n\t\t\t\tconst cameraLight = new THREE.PointLight( 0x0099ff, 1, 100 );\n\t\t\t\tcameraLight.power = 400;\n\t\t\t\tcamera.add( cameraLight );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 1000, 1000 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, visible: true } ) );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tconst object = gltf.scene;\n\n\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tconst instanceCount = 30;\n\t\t\t\t\tconst dummy = new THREE.Object3D();\n\n\t\t\t\t\tobject.traverse( ( child ) => {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tconst oscNode = oscSine( time.mul( .1 ) );\n\n\t\t\t\t\t\t\t// random colors between instances from 0x000000 to 0xFFFFFF\n\t\t\t\t\t\t\tconst randomColors = range( new THREE.Color( 0x000000 ), new THREE.Color( 0xFFFFFF ) );\n\n\t\t\t\t\t\t\t// random [ 0, 1 ] values between instances\n\t\t\t\t\t\t\tconst randomMetalness = range( 0, 1 );\n\n\t\t\t\t\t\t\tchild.material = new THREE.MeshStandardNodeMaterial();\n\t\t\t\t\t\t\tchild.material.roughness = .1;\n\t\t\t\t\t\t\tchild.material.metalnessNode = mix( 0.0, randomMetalness, oscNode );\n\t\t\t\t\t\t\tchild.material.colorNode = mix( color( 0xFFFFFF ), randomColors, oscNode );\n\n\t\t\t\t\t\t\tchild.isInstancedMesh = true;\n\t\t\t\t\t\t\tchild.instanceMatrix = new THREE.InstancedBufferAttribute( new Float32Array( instanceCount * 16 ), 16 );\n\t\t\t\t\t\t\tchild.count = instanceCount;\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < instanceCount; i ++ ) {\n\n\t\t\t\t\t\t\t\tdummy.position.x = - 200 + ( ( i % 5 ) * 70 );\n\t\t\t\t\t\t\t\tdummy.position.y = Math.floor( i / 5 ) * - 200;\n\n\t\t\t\t\t\t\t\tdummy.updateMatrix();\n\n\t\t\t\t\t\t\t\tdummy.matrix.toArray( child.instanceMatrix.array, i * 16 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\t\t\t\tconst scenePassDepth = scenePass.getLinearDepthNode().remapClamp( .15, .3 );\n\n\t\t\t\tconst scenePassColorBlurred = gaussianBlur( scenePassColor );\n\t\t\t\tscenePassColorBlurred.directionNode = scenePassDepth;\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\tpostProcessing.outputNode = scenePassColorBlurred;\n\n\n\t\t\t\t// events\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - skinning instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - skinning points"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - skinning points:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, computeSkinning, objectWorldMatrix, instancedArray, instanceIndex, Fn, shapeCircle } from 'three/tsl';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet mixer, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 300, - 85 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x111111 );\n\t\t\t\tcamera.lookAt( 0, 0, - 85 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xffffff, 10 ) );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Michelle.glb', function ( gltf ) {\n\n\t\t\t\t\tconst object = gltf.scene;\n\t\t\t\t\tmixer = new THREE.AnimationMixer( object );\n\n\t\t\t\t\tconst action = mixer.clipAction( gltf.animations[ 0 ] );\n\t\t\t\t\taction.play();\n\n\t\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tchild.visible = false;\n\n\t\t\t\t\t\t\tconst countOfPoints = child.geometry.getAttribute( 'position' ).count;\n\n\t\t\t\t\t\t\tconst pointPositionArray = instancedArray( countOfPoints, 'vec3' ).setPBO( true );\n\t\t\t\t\t\t\tconst pointSpeedArray = instancedArray( countOfPoints, 'vec3' ).setPBO( true );\n\n\t\t\t\t\t\t\tconst pointSpeedAttribute = pointSpeedArray.toAttribute();\n\t\t\t\t\t\t\tconst skinningPosition = computeSkinning( child );\n\n\t\t\t\t\t\t\tconst materialPoints = new THREE.PointsNodeMaterial();\n\t\t\t\t\t\t\tmaterialPoints.colorNode = pointSpeedAttribute.mul( .6 ).mix( color( 0x0066ff ), color( 0xff9000 ) );\n\t\t\t\t\t\t\tmaterialPoints.opacityNode = shapeCircle();\n\t\t\t\t\t\t\tmaterialPoints.sizeNode = pointSpeedAttribute.length().exp().min( 5 ).mul( 5 ).add( 1 );\n\t\t\t\t\t\t\tmaterialPoints.sizeAttenuation = false;\n\n\t\t\t\t\t\t\tconst updateSkinningPoints = Fn( () => {\n\n\t\t\t\t\t\t\t\tconst pointPosition = pointPositionArray.element( instanceIndex );\n\t\t\t\t\t\t\t\tconst pointSpeed = pointSpeedArray.element( instanceIndex );\n\n\t\t\t\t\t\t\t\tconst skinningWorldPosition = objectWorldMatrix( child ).mul( skinningPosition );\n\n\t\t\t\t\t\t\t\tconst skinningSpeed = skinningWorldPosition.sub( pointPosition );\n\n\t\t\t\t\t\t\t\tpointSpeed.assign( skinningSpeed );\n\t\t\t\t\t\t\t\tpointPosition.assign( skinningWorldPosition );\n\n\t\t\t\t\t\t\t}, 'void' );\n\n\t\t\t\t\t\t\tmaterialPoints.positionNode = Fn( () => {\n\n\t\t\t\t\t\t\t\tupdateSkinningPoints();\n\n\t\t\t\t\t\t\t\treturn pointPositionArray.toAttribute();\n\n\t\t\t\t\t\t\t} )().compute( countOfPoints ).onInit( () => {\n\n\t\t\t\t\t\t\t\t// initialize point positions and speeds\n\n\t\t\t\t\t\t\t\trenderer.compute( updateSkinningPoints().compute( countOfPoints ) );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tconst pointCloud = new THREE.Sprite( materialPoints );\n\t\t\t\t\t\t\tpointCloud.count = countOfPoints;\n\t\t\t\t\t\t\tscene.add( pointCloud );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tobject.scale.set( 100, 100, 100 );\n\t\t\t\t\tobject.rotation.x = - Math.PI / 2;\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t//renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) mixer.update( delta );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - skinning points colors and scale of the points are based on the speed of the animation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - sky"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - sky:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { SkyMesh } from 'three/addons/objects/SkyMesh.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet sky, sun;\n\n\t\t\tinit();\n\n\t\t\tfunction initSky() {\n\n\t\t\t\t// Add Sky\n\t\t\t\tsky = new SkyMesh();\n\t\t\t\tsky.scale.setScalar( 450000 );\n\t\t\t\tscene.add( sky );\n\n\t\t\t\tsun = new THREE.Vector3();\n\n\t\t\t\t/// GUI\n\n\t\t\t\tconst effectController = {\n\t\t\t\t\tturbidity: 10,\n\t\t\t\t\trayleigh: 3,\n\t\t\t\t\tmieCoefficient: 0.005,\n\t\t\t\t\tmieDirectionalG: 0.7,\n\t\t\t\t\televation: 2,\n\t\t\t\t\tazimuth: 180,\n\t\t\t\t\texposure: renderer.toneMappingExposure\n\t\t\t\t};\n\n\t\t\t\tfunction guiChanged() {\n\n\t\t\t\t\tsky.turbidity.value = effectController.turbidity;\n\t\t\t\t\tsky.rayleigh.value = effectController.rayleigh;\n\t\t\t\t\tsky.mieCoefficient.value = effectController.mieCoefficient;\n\t\t\t\t\tsky.mieDirectionalG.value = effectController.mieDirectionalG;\n\n\t\t\t\t\tconst phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );\n\t\t\t\t\tconst theta = THREE.MathUtils.degToRad( effectController.azimuth );\n\n\t\t\t\t\tsun.setFromSphericalCoords( 1, phi, theta );\n\n\t\t\t\t\tsky.sunPosition.value.copy( sun );\n\n\t\t\t\t\trenderer.toneMappingExposure = effectController.exposure;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( effectController, 'turbidity', 0.0, 20.0, 0.1 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'rayleigh', 0.0, 4, 0.001 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'mieCoefficient', 0.0, 0.1, 0.001 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'mieDirectionalG', 0.0, 1, 0.001 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'elevation', 0, 90, 0.1 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'azimuth', - 180, 180, 0.1 ).onChange( guiChanged );\n\t\t\t\tgui.add( effectController, 'exposure', 0, 1, 0.0001 ).onChange( guiChanged );\n\n\t\t\t\tguiChanged();\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 2000000 );\n\t\t\t\tcamera.position.set( 0, 100, 2000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 0.5;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\t//controls.maxPolarAngle = Math.PI / 2;\n\t\t\t\tcontrols.enableZoom = false;\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t\tinitSky();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - sky + sun shader"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - sprites"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - sprites:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, uv, userData, fog, rangeFogFactor, color } from 'three/tsl';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet map;\n\n\t\t\tlet group;\n\n\t\t\tlet imageWidth = 1, imageHeight = 1;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, width / height, 1, 2100 );\n\t\t\t\tcamera.position.z = 1500;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fogNode = fog( color( 0x0000ff ), rangeFogFactor( 1500, 2100 ) );\n\n\t\t\t\t// create sprites\n\n\t\t\t\tconst amount = 200;\n\t\t\t\tconst radius = 500;\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tmap = textureLoader.load( 'textures/sprite1.png', ( map ) => {\n\n\t\t\t\t\timageWidth = map.image.width;\n\t\t\t\t\timageHeight = map.image.height;\n\n\t\t\t\t} );\n\n\t\t\t\tgroup = new THREE.Group();\n\n\t\t\t\tconst textureNode = texture( map );\n\n\t\t\t\tconst material = new THREE.SpriteNodeMaterial();\n\t\t\t\tmaterial.colorNode = textureNode.mul( uv() ).mul( 2 ).saturate();\n\t\t\t\tmaterial.opacityNode = textureNode.a;\n\t\t\t\tmaterial.rotationNode = userData( 'rotation', 'float' ); // get value of: sprite.userData.rotation\n\n\t\t\t\tfor ( let a = 0; a < amount; a ++ ) {\n\n\t\t\t\t\tconst x = Math.random() - 0.5;\n\t\t\t\t\tconst y = Math.random() - 0.5;\n\t\t\t\t\tconst z = Math.random() - 0.5;\n\n\t\t\t\t\tconst sprite = new THREE.Sprite( material );\n\n\t\t\t\t\tsprite.position.set( x, y, z );\n\t\t\t\t\tsprite.position.normalize();\n\t\t\t\t\tsprite.position.multiplyScalar( radius );\n\n\t\t\t\t\t// individual rotation per sprite\n\t\t\t\t\tsprite.userData.rotation = 0;\n\n\t\t\t\t\tgroup.add( sprite );\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( group );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() / 1000;\n\n\t\t\t\tfor ( let i = 0, l = group.children.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst sprite = group.children[ i ];\n\t\t\t\t\tconst scale = Math.sin( time + sprite.position.x * 0.01 ) * 0.3 + 1.0;\n\n\t\t\t\t\tsprite.userData.rotation += 0.1 * ( i / l );\n\t\t\t\t\tsprite.scale.set( scale * imageWidth, scale * imageHeight, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t\tgroup.rotation.x = time * 0.5;\n\t\t\t\tgroup.rotation.y = time * 0.75;\n\t\t\t\tgroup.rotation.z = time * 1.0;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - sprites"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - storage pbo external element"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - storage pbo external element:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { storage, If, vec3, uv, uint, float, Fn, instanceIndex, workgroupBarrier } from 'three/tsl';\n\n\t\t\tconst timestamps = {\n\t\t\t\twebgpu: document.getElementById( 'timestamps' ),\n\t\t\t\twebgl: document.getElementById( 'timestamps_webgl' )\n\t\t\t};\n\n\t\t\t// WebGPU Backend\n\t\t\tinit();\n\n\t\t\t// WebGL Backend\n\t\t\tinit( true );\n\n\t\t\tasync function init( forceWebGL = false ) {\n\n\t\t\t\tconst aspect = ( window.innerWidth / 2 ) / window.innerHeight;\n\t\t\t\tconst camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );\n\t\t\t\tcamera.position.z = 1;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\t// texture\n\n\t\t\t\tconst size = 32; // non power of two buffer size is not well supported in WebGPU\n\t\t\t\tconst barCount = 32;\n\n\t\t\t\tconst type = [ 'float', 'vec2', 'vec3', 'vec4' ];\n\n\t\t\t\tconst arrayBufferNodes = [];\n\n\t\t\t\tfor ( let i = 0; i < type.length; i ++ ) {\n\n\t\t\t\t\tconst typeSize = i + 1;\n\t\t\t\t\tconst array = new Array( size * typeSize ).fill( 0 );\n\n\t\t\t\t\tconst arrayBuffer = new THREE.StorageInstancedBufferAttribute( new Float32Array( array ), typeSize );\n\n\t\t\t\t\tarrayBufferNodes.push( storage( arrayBuffer, type[ i ], size ).setPBO( true ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst computeInitOrder = Fn( () => {\n\n\t\t\t\t\tfor ( let i = 0; i < type.length; i ++ ) {\n\n\t\t\t\t\t\tarrayBufferNodes[ i ].element( instanceIndex ).assign( instanceIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tconst computeInvertOrder = Fn( () => {\n\n\t\t\t\t\tfor ( let i = 0; i < type.length; i ++ ) {\n\n\t\t\t\t\t\tconst invertIndex = arrayBufferNodes[ i ].element( uint( size - 1 ).sub( instanceIndex ) ).toVar();\n\t\t\t\t\t\tworkgroupBarrier();\n\t\t\t\t\t\tarrayBufferNodes[ i ].element( instanceIndex ).assign( invertIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// compute\n\n\t\t\t\tconst computeInit = computeInitOrder().compute( size );\n\n\t\t\t\tconst compute = computeInvertOrder().compute( size );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );\n\n\t\t\t\tmaterial.colorNode = Fn( () => {\n\n\t\t\t\t\tconst index = uint( uv().x.mul( size ).floor() ).toVar();\n\n\t\t\t\t\tIf( index.greaterThanEqual( size ), () => {\n\n\t\t\t\t\t\tindex.assign( uint( size ).sub( 1 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst color = vec3( 0, 0, 0 ).toVar();\n\n\t\t\t\t\tIf( uv().y.greaterThan( 0.0 ), () => {\n\n\t\t\t\t\t\tconst indexValue = arrayBufferNodes[ 0 ].element( index ).toVar();\n\t\t\t\t\t\tconst value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );\n\t\t\t\n\t\t\t\t\t\tcolor.assign( vec3( value, 0, 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tIf( uv().y.greaterThan( 0.25 ), () => {\n\n\t\t\t\t\t\tconst indexValue = arrayBufferNodes[ 1 ].element( index ).toVar();\n\t\t\t\t\t\tconst value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );\n\t\t\t\n\t\t\t\t\t\tcolor.assign( vec3( 0, value, 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tIf( uv().y.greaterThan( 0.5 ), () => {\n\n\t\t\t\t\t\tconst indexValue = arrayBufferNodes[ 2 ].element( index ).toVar();\n\t\t\t\t\t\tconst value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );\n\t\t\t\n\t\t\t\t\t\tcolor.assign( vec3( 0, 0, value ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tIf( uv().y.greaterThan( 0.75 ), () => {\n\n\t\t\t\t\t\tconst indexValue = arrayBufferNodes[ 3 ].element( index ).toVar();\n\t\t\t\t\t\tconst value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );\n\t\t\t\n\t\t\t\t\t\tcolor.assign( vec3( value, value, value ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn color;\n\n\t\t\t\t} )();\n\t\t\t\n\t\t\t\t//\n\n\t\t\t\tconst plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: false, forceWebGL: forceWebGL, trackTimestamp: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth / 2, window.innerHeight );\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.domElement.style.position = 'absolute';\n\t\t\t\trenderer.domElement.style.top = '0';\n\t\t\t\trenderer.domElement.style.left = '0';\n\t\t\t\trenderer.domElement.style.width = '50%';\n\t\t\t\trenderer.domElement.style.height = '100%';\n\n\t\t\t\tif ( forceWebGL ) {\n\n\t\t\t\t\trenderer.domElement.style.left = '50%';\n\n\t\t\t\t\tscene.background = new THREE.Color( 0x212121 );\n\t\t\t\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.background = new THREE.Color( 0x313131 );\n\n\t\t\t\t}\n\n\n\t\t\t\tawait renderer.computeAsync( computeInit );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.info.autoReset = false;\n\n\t\t\t\t const stepAnimation = async function () {\n\n\t\t\t\t\trenderer.info.reset();\n\n\t\t\t\t\tawait renderer.computeAsync( compute );\n\t\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\t\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );\n\t\t\t\t\trenderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );\n\n\t\t\t\t\ttimestamps[ forceWebGL ? 'webgl' : 'webgpu' ].innerHTML = `\n\n\t\t\t\t\t\t\tCompute ${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>\n\t\t\t\t\t\t\tDraw ${renderer.info.render.drawCalls} pass in ${renderer.info.render.timestamp.toFixed( 6 )}ms`;\n\n\t\t\t\t\tsetTimeout( stepAnimation, 1000 );\n\t\t\t\n\t\t\t\t};\n\n\t\t\t\tstepAnimation();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tfunction onWindowResize() {\n\n\t\t\t\t\trenderer.setSize( window.innerWidth / 2, window.innerHeight );\n\n\t\t\t\t\tconst aspect = ( window.innerWidth / 2 ) / window.innerHeight;\n\n\t\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js This example demonstrates fetching an external element from a StorageBuffer. The left canvas uses the WebGPU Backend, while the right uses the WebGL Backend."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - struct drawIndirect"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - struct drawIndirect:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { struct, storage, wgslFn, instanceIndex, time, varyingProperty, attribute } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t}\n\n\n\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\trenderer.outputColorSpace = THREE.SRGBColorSpace;\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setClearColor( 0x000000 );\n\t\t\trenderer.setClearAlpha( 0 );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 50.0, aspect, 0.1, 10000 );\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\tscene.background = new THREE.Color( 0x00001f );\n\t\t\tcamera.position.set( 1, 1, 1 );\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\n\t\t\tlet computeDrawBuffer, computeInitDrawBuffer;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tawait renderer.init();\n\n\t\t\t\t// geometry\n\n\t\t\t\tconst vector = new THREE.Vector4();\n\n\t\t\t\tconst instances = 100000;\n\n\t\t\t\tconst positions = [];\n\t\t\t\tconst offsets = [];\n\t\t\t\tconst colors = [];\n\t\t\t\tconst orientationsStart = [];\n\t\t\t\tconst orientationsEnd = [];\n\n\t\t\t\tpositions.push( 0.025, - 0.025, 0 );\n\t\t\t\tpositions.push( - 0.025, 0.025, 0 );\n\t\t\t\tpositions.push( 0, 0, 0.025 );\n\n\t\t\t\t// instanced attributes\n\n\t\t\t\tfor ( let i = 0; i < instances; i ++ ) {\n\n\t\t\t\t\t// offsets\n\n\t\t\t\t\toffsets.push( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tcolors.push( Math.random(), Math.random(), Math.random(), Math.random() );\n\n\t\t\t\t\t// orientation start\n\n\t\t\t\t\tvector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );\n\t\t\t\t\tvector.normalize();\n\n\t\t\t\t\torientationsStart.push( vector.x, vector.y, vector.z, vector.w );\n\n\t\t\t\t\t// orientation end\n\n\t\t\t\t\tvector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );\n\t\t\t\t\tvector.normalize();\n\n\t\t\t\t\torientationsEnd.push( vector.x, vector.y, vector.z, vector.w );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.InstancedBufferGeometry();\n\t\t\t\tgeometry.instanceCount = instances;\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );\n\t\t\t\tgeometry.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientationsStart ), 4 ) );\n\t\t\t\tgeometry.setAttribute( 'orientationEnd', new THREE.InstancedBufferAttribute( new Float32Array( orientationsEnd ), 4 ) );\n\n\t\t\t\tconst drawBuffer = new THREE.IndirectStorageBufferAttribute( new Uint32Array( 5 ), 5 );\n\t\t\t\tgeometry.setIndirect( drawBuffer );\n\n\t\t\t\tconst drawBufferStruct = struct( {\n\t\t\t\t\tvertexCount: 'uint',\n\t\t\t\t\tinstanceCount: { type: 'uint', atomic: true },\n\t\t\t\t\tfirstVertex: 'uint',\n\t\t\t\t\tfirstInstance: 'uint',\n\t\t\t\t\toffset: 'uint'\n\t\t\t\t}, 'DrawBuffer' );\n\n\t\t\t\tconst writeDrawBuffer = wgslFn( `\n\t\t\t\t\tfn compute(\n\t\t\t\t\t\tindex: u32,\n\t\t\t\t\t\tdrawBuffer: ptr<storage, DrawBuffer, read_write>,\n\t\t\t\t\t\tinstances: f32,\n\t\t\t\t\t\ttime: f32,\n\t\t\t\t\t) -> void {\n\n\t\t\t\t\t\tlet instanceCount = max( instances * pow( sin( time * 0.5 ) + 1, 4.0 ), 100 );\n\n\t\t\t\t\t\tatomicStore( &drawBuffer.instanceCount, u32( instanceCount ) );\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\tcomputeDrawBuffer = writeDrawBuffer( {\n\t\t\t\t\tdrawBuffer: storage( drawBuffer, drawBufferStruct, drawBuffer.count ),\n\t\t\t\t\tinstances: instances,\n\t\t\t\t\tindex: instanceIndex,\n\t\t\t\t\ttime: time\n\t\t\t\t} ).compute( instances ); // not necessary in this case but normally one wants to run through all instances\n\n\t\t\t\tconst initDrawBuffer = wgslFn( `\n\t\t\t\t\tfn compute(\n\t\t\t\t\t\tdrawBuffer: ptr< storage, DrawBuffer, read_write >,\n\t\t\t\t\t) -> void {\n\n\t\t\t\t\t\tdrawBuffer.vertexCount = 3u;\n\t\t\t\t\t\tatomicStore(&drawBuffer.instanceCount, 0u);\n\t\t\t\t\t\tdrawBuffer.firstVertex = 0u;\n\t\t\t\t\t\tdrawBuffer.firstInstance = 0u;\n\t\t\t\t\t\tdrawBuffer.offset = 0u;\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\tcomputeInitDrawBuffer = initDrawBuffer( {\n\t\t\t\t\tdrawBuffer: storage( drawBuffer, drawBufferStruct, drawBuffer.count ),\n  \t\t\t\t} ).compute( 1 );\n\n  \t\t\t\tconst vPosition = varyingProperty( 'vec3', 'vPosition' );\n  \t\t\t\tconst vColor = varyingProperty( 'vec4', 'vColor' );\n\n  \t\t\t\tconst positionShaderParams = {\n\t\t\t\t\tposition: attribute( 'position' ),\n\t\t\t\t\toffset: attribute( 'offset' ),\n\t\t\t\t\tcolor: attribute( 'color' ),\n\t\t\t\t\torientationStart: attribute( 'orientationStart' ),\n\t\t\t\t\torientationEnd: attribute( 'orientationEnd' ),\n\t\t\t\t\ttime: time\n\t\t\t\t};\n\n\t\t\t\tconst positionShader = wgslFn( `\n\t\t\t\t\tfn main_vertex(\n\t\t\t\t\t\tposition: vec3<f32>,\n\t\t\t\t\t\toffset: vec3<f32>,\n\t\t\t\t\t\tcolor: vec4<f32>,\n\t\t\t\t\t\torientationStart: vec4<f32>,\n\t\t\t\t\t\torientationEnd: vec4<f32>,\n\t\t\t\t\t\ttime: f32\n\t\t\t\t\t) -> vec4<f32> {\n\n\t\t\t\t\t\tvar vPosition = offset * max( abs( sin( time * 0.5 ) * 2.0 + 1.0 ), 0.5 ) + position;\n\t\t\t\t\t\tvar orientation = normalize( mix( orientationStart, orientationEnd, sin( time * 0.5 ) ) );\n\t\t\t\t\t\tvar vcV = cross( orientation.xyz, vPosition );\n\t\t\t\t\t\tvPosition = vcV * ( 2.0 * orientation.w ) + ( cross( orientation.xyz, vcV ) * 2.0 + vPosition );\n\n\t\t\t\t\t\tvar vColor = color;\n\n\t\t\t\t\t\tvar outPosition = vec4f(vPosition, 1);\n\n\t\t\t\t\t\tvaryings.vPosition = vPosition;\n\t\t\t\t\t\tvaryings.vColor = vColor;\n\n\t\t\t\t\t\treturn outPosition;\n\t\t\t\t\t}\n\t\t\t\t`, [ vPosition, vColor ] );\n\n\t\t\t\tconst fragmentShaderParams = {\n\t\t\t\t\ttime: time,\n\t\t\t\t\tvPosition: vPosition,\n\t\t\t\t\tvColor: vColor\n\t\t\t\t};\n\n\t\t\t\tconst fragmentShader = wgslFn( `\n\t\t\t\t\tfn main_fragment(\n\t\t\t\t\t\ttime: f32,\n\t\t\t\t\t\tvPosition: vec3<f32>,\n\t\t\t\t\t\tvColor: vec4<f32>\n\t\t\t\t\t) -> vec4<f32> {\n\n\t\t\t\t\t\tvar color = vec4f( vColor );\n\t\t\t\t\t\tcolor.r += sin( vPosition.x * 10.0 + time ) * 0.5;\n\n\t\t\t\t\t\treturn color;\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( {\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tforceSinglePass: true,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tmaterial.positionNode = positionShader( positionShaderParams );\n\t\t\t\tmaterial.fragmentNode = fragmentShader( fragmentShaderParams );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer.setAnimationLoop( render );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\trenderer.compute( computeInitDrawBuffer );\n\t\t\t\trenderer.compute( computeDrawBuffer );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - struct drawIndirect"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - texture gradient"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - texture gradient:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { If, vec4, float, time, cos, pow, vec2, uv, texture, Fn } from 'three/tsl';\n\n\t\t\t// WebGPU Backend\n\t\t\tinit();\n\n\t\t\t// WebGL Backend\n\t\t\tinit( true );\n\n\t\t\tasync function init( forceWebGL = false ) {\n\n\t\t\t\tconst aspect = ( window.innerWidth / 2 ) / window.innerHeight;\n\t\t\t\tconst camera = new THREE.OrthographicCamera( - aspect, aspect );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tconst scene = new THREE.Scene();\n\n\t\t\t\t// texture\n\n\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial( { color: 0xffffff } );\n\n\t\t\t\t// load async brick_diffuse\n\t\t\t\tconst map = await new THREE.TextureLoader().loadAsync( 'textures/uv_grid_opengl.jpg' );\n\n\t\t\t\tmaterial.colorNode = Fn( () => {\n\n\t\t\t\t\tconst color = vec4( 1. ).toVar();\n\n\t\t\t\t\tconst vuv = uv().toVar();\n\t\t\t\t\tconst blur = pow( float( 0.0625 ).sub( cos( vuv.x.mul( 20.0 ).add( time ) ) ).mul( 0.0625 ), 2.0 );\n\n\t\t\t\t\tconst grad = vec2( blur ).toVar();\n\n\t\t\t\t\tIf( vuv.y.greaterThan( 0.5 ), () => {\n\n\t\t\t\t\t\tgrad.assign( 0 );\n\t\t\t\n\t\t\t\t\t} );\n\n\t\t\t\t\tcolor.assign(\n\t\t\t\t\t\ttexture( map, vuv.add( vec2( blur, blur ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 )\n\t\t\t\t\t\t\t.add( texture( map, vuv.add( vec2( blur, blur.negate() ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 ) )\n\t\t\t\t\t\t\t.add( texture( map, vuv.add( vec2( blur.negate(), blur ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 ) )\n\t\t\t\t\t\t\t.add( texture( map, vuv.add( vec2( blur.negate(), blur.negate() ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 ) )\n\t\t\t\t\t);\n\n\n\t\t\t\t\tIf( vuv.y.greaterThan( 0.497 ).and( vuv.y.lessThan( 0.503 ) ), () => {\n\n\t\t\t\t\t\tcolor.assign( 1 );\n\n\t\t\t\t\t} );\n\t\t\t\n\n\t\t\t\t\treturn color;\n\n\t\t\t\t} )();\n\t\t\t\n\t\t\t\t//\n\n\t\t\t\tconst box = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( box );\n\n\t\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: false, forceWebGL: forceWebGL } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth / 2, window.innerHeight );\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.domElement.style.position = 'absolute';\n\t\t\t\trenderer.domElement.style.top = '0';\n\t\t\t\trenderer.domElement.style.left = '0';\n\t\t\t\trenderer.domElement.style.width = '50%';\n\t\t\t\trenderer.domElement.style.height = '100%';\n\n\t\t\t\tif ( forceWebGL ) {\n\n\t\t\t\t\trenderer.domElement.style.left = '50%';\n\n\t\t\t\t\tscene.background = new THREE.Color( 0x212121 );\n\t\t\t\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.background = new THREE.Color( 0x313131 );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\n\t\t\t\t const animate = async function () {\n\n\t\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\t\t\t\n\t\t\t\t};\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tfunction onWindowResize() {\n\n\t\t\t\t\trenderer.setSize( window.innerWidth / 2, window.innerHeight );\n\n\t\t\t\t\tconst aspect = ( window.innerWidth / 2 ) / window.innerHeight;\n\n\t\t\t\t\tconst frustumHeight = camera.top - camera.bottom;\n\n\t\t\t\t\tcamera.left = - frustumHeight * aspect / 2;\n\t\t\t\t\tcamera.right = frustumHeight * aspect / 2;\n\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js This example demonstrate texture gradient Left canvas is using WebGPU Backend, right canvas is WebGL Backend. The bottom half of the texture benefits from the gradient to achieve better blur quality."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - 2d texture array"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - 2d texture array:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { texture, uv, time, oscTriangle } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { unzipSync } from 'three/addons/libs/fflate.module.js';\n\n\t\t\tlet camera, scene, mesh, renderer, stats;\n\n\t\t\tconst planeWidth = 50;\n\t\t\tconst planeHeight = 50;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.z = 70;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// width 256, height 256, depth 109, 8-bit, zip archived raw data\n\n\t\t\t\tnew THREE.FileLoader()\n\t\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t\t.load( 'textures/3d/head256x256x109.zip', function ( data ) {\n\n\t\t\t\t\t\tconst zip = unzipSync( new Uint8Array( data ) );\n\t\t\t\t\t\tconst array = new Uint8Array( zip[ 'head256x256x109' ].buffer );\n\n\t\t\t\t\t\tconst map = new THREE.DataArrayTexture( array, 256, 256, 109 );\n\t\t\t\t\t\tmap.format = THREE.RedFormat;\n\t\t\t\t\t\tmap.needsUpdate = true;\n\n\t\t\t\t\t\tlet coord = uv();\n\t\t\t\t\t\tcoord = coord.setY( coord.y.oneMinus() ); // flip y\n\n\t\t\t\t\t\tlet oscLayers = oscTriangle( time.mul( .5 ) ); // [ /\\/ ] triangle osc animation\n\t\t\t\t\t\toscLayers = oscLayers.add( 1 ).mul( .5 ); // convert osc range of [ -1, 1 ] to [ 0, 1 ]\n\t\t\t\t\t\toscLayers = oscLayers.mul( map.image.depth ); // scale osc range to texture depth\n\n\t\t\t\t\t\tconst material = new THREE.MeshBasicNodeMaterial();\n\t\t\t\t\t\tmaterial.colorNode = texture( map, coord ).depth( oscLayers ).r.remap( 0, 1, - .1, 1.8 ); // remap to make it more visible\n\n\t\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t} );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - 2D Texture array Scanned head data by Divine Augustine licensed under CPOL"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgl - 2D compressed texture array"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - 2D compressed texture array:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { texture, uniform, uv } from 'three/tsl';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\n\t\t\tlet camera, scene, mesh, renderer, stats, clock;\n\n\t\t\tconst depth = uniform( 0 );\n\n\t\t\tconst planeWidth = 50;\n\t\t\tconst planeHeight = 25;\n\n\t\t\tlet depthStep = 1;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );\n\t\t\t\tcamera.position.z = 70;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst ktx2Loader = new KTX2Loader();\n\t\t\t\tktx2Loader.setTranscoderPath( 'jsm/libs/basis/' );\n\t\t\t\tawait ktx2Loader.detectSupportAsync( renderer );\n\n\t\t\t\tktx2Loader.load( 'textures/spiritedaway.ktx2', function ( texturearray ) {\n\n\t\t\t\t\tconst material = new THREE.NodeMaterial();\n\n\t\t\t\t\tmaterial.colorNode = texture( texturearray, uv().flipY() ).depth( depth );\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( mesh ) {\n\n\t\t\t\t\tconst delta = clock.getDelta() * 10;\n\n\t\t\t\t\tdepthStep += delta;\n\n\t\t\t\t\tconst value = depthStep % 5;\n\n\t\t\t\t\tdepth.value = value;\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - WebGPU - 2D Compressed Texture Array Loop from the movie Spirited away by the Studio Ghibli"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - anisotropic texture filtering"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - anisotropic texture filtering:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet container, stats;\n\n\t\t\tlet camera, scene1, scene2, renderer;\n\n\t\t\tlet mouseX = 0, mouseY = 0;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst SCREEN_WIDTH = window.innerWidth;\n\t\t\t\tconst SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\trenderer.domElement.style.position = 'relative';\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 25000 );\n\t\t\t\tcamera.position.z = 1500;\n\n\t\t\t\tscene1 = new THREE.Scene();\n\t\t\t\tscene1.fog = new THREE.Fog( 0xf2f7ff, 1, 25000 );\n\n\t\t\t\tscene2 = new THREE.Scene();\n\t\t\t\tscene2.fog = new THREE.Fog( 0xf2f7ff, 1, 25000 );\n\n\t\t\t\tscene1.add( new THREE.AmbientLight( 0xeef0ff, 3 ) );\n\t\t\t\tscene2.add( new THREE.AmbientLight( 0xeef0ff, 3 ) );\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xffffff, 6 );\n\t\t\t\tlight1.position.set( 1, 1, 1 );\n\t\t\t\tscene1.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffffff, 6 );\n\t\t\t\tlight2.position.set( 1, 1, 1 );\n\t\t\t\tscene2.add( light2 );\n\n\t\t\t\t// GROUND\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst maxAnisotropy = renderer.getMaxAnisotropy();\n\n\t\t\t\tconst texture1 = textureLoader.load( 'textures/crate.gif' );\n\t\t\t\tconst material1 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture1 } );\n\n\t\t\t\ttexture1.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture1.anisotropy = renderer.getMaxAnisotropy();\n\t\t\t\ttexture1.wrapS = texture1.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture1.repeat.set( 512, 512 );\n\n\t\t\t\tconst texture2 = textureLoader.load( 'textures/crate.gif' );\n\t\t\t\tconst material2 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture2 } );\n\n\t\t\t\ttexture2.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture2.anisotropy = 1;\n\t\t\t\ttexture2.wrapS = texture2.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture2.repeat.set( 512, 512 );\n\n\t\t\t\tif ( maxAnisotropy > 0 ) {\n\n\t\t\t\t\tdocument.getElementById( 'val_left' ).innerHTML = texture1.anisotropy;\n\t\t\t\t\tdocument.getElementById( 'val_right' ).innerHTML = texture2.anisotropy;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdocument.getElementById( 'val_left' ).innerHTML = 'not supported';\n\t\t\t\t\tdocument.getElementById( 'val_right' ).innerHTML = 'not supported';\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry, material1 );\n\t\t\t\tmesh1.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh1.scale.set( 1000, 1000, 1000 );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry, material2 );\n\t\t\t\tmesh2.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh2.scale.set( 1000, 1000, 1000 );\n\n\t\t\t\tscene1.add( mesh1 );\n\t\t\t\tscene2.add( mesh2 );\n\n\t\t\t\t// STATS1\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onDocumentMouseMove );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onDocumentMouseMove( event ) {\n\n\t\t\t\tconst windowHalfX = window.innerWidth / 2;\n\t\t\t\tconst windowHalfY = window.innerHeight / 2;\n\n\t\t\t\tmouseX = ( event.clientX - windowHalfX );\n\t\t\t\tmouseY = ( event.clientY - windowHalfY );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst SCREEN_WIDTH = window.innerWidth;\n\t\t\t\tconst SCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\tcamera.position.x += ( mouseX - camera.position.x ) * .05;\n\t\t\t\tcamera.position.y = THREE.MathUtils.clamp( camera.position.y + ( - ( mouseY - 200 ) - camera.position.y ) * .05, 50, 1000 );\n\n\t\t\t\tcamera.lookAt( scene1.position );\n\t\t\t\trenderer.clear();\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( 0, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene1, camera );\n\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t\trenderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );\n\t\t\t\trenderer.render( scene2, camera );\n\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n```\n\nThis example three.js - anisotropic texture filtering example"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgl - webgpu partial texture update"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - webgpu partial texture update:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer, clock, dataTexture, diffuseMap;\n\n\t\t\tlet last = 0;\n\t\t\tconst position = new THREE.Vector2();\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.z = 2;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\tdiffuseMap = loader.load( 'textures/carbon/Carbon.png', animate );\n\t\t\t\tdiffuseMap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tdiffuseMap.minFilter = THREE.LinearFilter;\n\t\t\t\tdiffuseMap.generateMipmaps = false;\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: diffuseMap } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst width = 32;\n\t\t\t\tconst height = 32;\n\n\t\t\t\tconst data = new Uint8Array( width * height * 4 );\n\t\t\t\tdataTexture = new THREE.DataTexture( data, width, height );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\tconst elapsedTime = clock.getElapsedTime();\n\n\n\t\t\t\tawait renderer.renderAsync( scene, camera );\n\n\n\t\t\t\tif ( elapsedTime - last > 0.1 ) {\n\n\t\t\t\t\tlast = elapsedTime;\n\n\t\t\t\t\tposition.x = ( 32 * THREE.MathUtils.randInt( 1, 16 ) ) - 32;\n\t\t\t\t\tposition.y = ( 32 * THREE.MathUtils.randInt( 1, 16 ) ) - 32;\n\n\t\t\t\t\t// generate new color data\n\t\t\t\t\tupdateDataTexture( dataTexture );\n\n\t\t\t\t\t// perform copy from src to dest texture to a random position\n\n\t\t\t\t\trenderer.copyTextureToTexture( dataTexture, diffuseMap, null, position );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updateDataTexture( texture ) {\n\n\t\t\t\tconst size = texture.image.width * texture.image.height;\n\t\t\t\tconst data = texture.image.data;\n\n\t\t\t\t// generate a random color and update texture data\n\n\t\t\t\tcolor.setHex( Math.random() * 0xffffff );\n\n\t\t\t\tconst r = Math.floor( color.r * 255 );\n\t\t\t\tconst g = Math.floor( color.g * 255 );\n\t\t\t\tconst b = Math.floor( color.b * 255 );\n\n\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\tconst stride = i * 4;\n\n\t\t\t\t\tdata[ stride ] = r;\n\t\t\t\t\tdata[ stride + 1 ] = g;\n\t\t\t\t\tdata[ stride + 2 ] = b;\n\t\t\t\t\tdata[ stride + 3 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t}\n```\n\nThis example three.js - partial webgpu texture update replace parts of an existing texture with all data of another texture"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - tone mapping"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - tone mapping:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet renderer, scene, camera, controls;\n\t\t\tlet gui, guiExposure = null;\n\n\t\t\tconst params = {\n\t\t\t\texposure: 1.0,\n\t\t\t\ttoneMapping: 'Neutral',\n\t\t\t\tblurriness: 0.3,\n\t\t\t\tintensity: 1.0,\n\t\t\t};\n\n\t\t\tconst toneMappingOptions = {\n\t\t\t\tNone: THREE.NoToneMapping,\n\t\t\t\tLinear: THREE.LinearToneMapping,\n\t\t\t\tReinhard: THREE.ReinhardToneMapping,\n\t\t\t\tCineon: THREE.CineonToneMapping,\n\t\t\t\tACESFilmic: THREE.ACESFilmicToneMapping,\n\t\t\t\tAgX: THREE.AgXToneMapping,\n\t\t\t\tNeutral: THREE.NeutralToneMapping\n\t\t\t};\n\n\t\t\tinit().catch( function ( err ) {\n\n\t\t\t\tconsole.error( err );\n\n\t\t\t} );\n\n\t\t\tasync function init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer.toneMapping = toneMappingOptions[ params.toneMapping ];\n\t\t\t\trenderer.toneMappingExposure = params.exposure;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundBlurriness = params.blurriness;\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xfff3ee, 3 ); // simualte sun\n\t\t\t\tlight.position.set( 1, 0.05, 0.7 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// scene.add( new THREE.DirectionalLightHelper( light, 1, 0x000000 ) );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 10 );\n\t\t\t\tcamera.position.set( - 0.02, 0.03, 0.05 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.03;\n\t\t\t\tcontrols.maxDistance = 0.2;\n\t\t\t\tcontrols.target.set( 0, 0.03, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst rgbeLoader = new RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' );\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\t\t\t\tgltfLoader.setPath( 'models/gltf/' );\n\n\t\t\t\tconst [ texture, gltf ] = await Promise.all( [\n\t\t\t\t\trgbeLoader.loadAsync( 'venice_sunset_1k.hdr' ),\n\t\t\t\t\tgltfLoader.loadAsync( 'venice_mask.glb' ),\n\t\t\t\t] );\n\n\t\t\t\t// environment\n\n\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tscene.background = texture;\n\t\t\t\tscene.environment = texture;\n\n\t\t\t\t// model\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tgui = new GUI();\n\t\t\t\tconst toneMappingFolder = gui.addFolder( 'Tone Mapping' );\n\n\t\t\t\ttoneMappingFolder.add( params, 'toneMapping', Object.keys( toneMappingOptions ) )\n\n\t\t\t\t\t.name( 'type' )\n\t\t\t\t\t.onChange( function () {\n\n\t\t\t\t\t\tupdateGUI( toneMappingFolder );\n\n\t\t\t\t\t\trenderer.toneMapping = toneMappingOptions[ params.toneMapping ];\n\n\t\t\t\t\t} );\n\n\t\t\t\tguiExposure = toneMappingFolder.add( params, 'exposure', 0, 2 )\n\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\trenderer.toneMappingExposure = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst backgroundFolder = gui.addFolder( 'Background' );\n\n\t\t\t\tbackgroundFolder.add( params, 'blurriness', 0, 1 )\n\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\tscene.backgroundBlurriness = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tbackgroundFolder.add( params, 'intensity', 0, 1 )\n\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\tscene.backgroundIntensity = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tupdateGUI( toneMappingFolder );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction updateGUI() {\n\n\t\t\t\tif ( params.toneMapping === 'None' ) {\n\n\t\t\t\t\tguiExposure.hide();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tguiExposure.show();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - tone mapping Venice Mask by DailyArt is licensed under CC Attribution-NonCommercial Venice Sunset from HDRI Haven"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - angular slicing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - angular slicing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { If, PI2, atan, color, frontFacing, output, positionLocal, Fn, uniform, vec4 } from 'three/tsl';\n\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( - 5, 5, 12 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t// environment\n\n\t\t\t\tconst rgbeLoader = new RGBELoader();\n\t\t\t\trgbeLoader.load( './textures/equirectangular/royal_esplanade_1k.hdr', ( environmentMap ) => {\n\n\t\t\t\t\tenvironmentMap.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\tscene.background = environmentMap;\n\t\t\t\t\tscene.environment = environmentMap;\n\n\t\t\t\t} );\n\n\t\t\t\t// lights\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( '#ffffff', 4 );\n\t\t\t\tdirectionalLight.position.set( 6.25, 3, 4 );\n\t\t\t\tdirectionalLight.castShadow = true;\n\t\t\t\tdirectionalLight.shadow.mapSize.set( 2048, 2048 );\n\t\t\t\tdirectionalLight.shadow.camera.near = 0.1;\n\t\t\t\tdirectionalLight.shadow.camera.far = 30;\n\t\t\t\tdirectionalLight.shadow.camera.top = 8;\n\t\t\t\tdirectionalLight.shadow.camera.right = 8;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - 8;\n\t\t\t\tdirectionalLight.shadow.camera.left = - 8;\n\t\t\t\tdirectionalLight.shadow.normalBias = 0.05;\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// TSL functions\n\t\t\t\n\t\t\t\tconst inAngle = Fn( ( [ position, angleStart, angleArc ] ) => {\n\n\t\t\t\t\tconst angle = atan( position.y, position.x ).sub( angleStart ).mod( PI2 ).toVar();\n\t\t\t\t\treturn angle.greaterThan( 0 ).and( angle.lessThan( angleArc ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// materials\n\n\t\t\t\tconst defaultMaterial = new THREE.MeshPhysicalNodeMaterial( {\n\t\t\t\t\tmetalness: 0.5,\n\t\t\t\t\troughness: 0.25,\n\t\t\t\t\tenvMapIntensity: 0.5,\n\t\t\t\t\tcolor: '#858080'\n\t\t\t\t} );\n\n\t\t\t\tconst slicedMaterial = new THREE.MeshPhysicalNodeMaterial( {\n\t\t\t\t\tmetalness: 0.5,\n\t\t\t\t\troughness: 0.25,\n\t\t\t\t\tenvMapIntensity: 0.5,\n\t\t\t\t\tcolor: '#858080',\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\t// uniforms\n\n\t\t\t\tconst sliceStart = uniform( 1.75 );\n\t\t\t\tconst sliceArc = uniform( 1.25 );\n\t\t\t\tconst sliceColor = uniform( color( '#b62f58' ) );\n\n\t\t\t\t// debug\n\n\t\t\t\tgui.add( sliceStart, 'value', - Math.PI, Math.PI, 0.001 ).name( 'sliceStart' );\n\t\t\t\tgui.add( sliceArc, 'value', 0, Math.PI * 2, 0.001 ).name( 'sliceArc' );\n\t\t\t\tgui.addColor( { color: sliceColor.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).onChange( value => sliceColor.value.set( value ) );\n\n\t\t\t\t// output\n\n\t\t\t\tslicedMaterial.outputNode = Fn( () => {\n\n\t\t\t\t\t// discard\n\n\t\t\t\t\tinAngle( positionLocal.xy, sliceStart, sliceArc ).discard();\n\n\t\t\t\t\t// backface color\n\n\t\t\t\t\tconst finalOutput = output;\n\t\t\t\t\tIf( frontFacing.not(), () => {\n\n\t\t\t\t\t\tfinalOutput.assign( vec4( sliceColor, 1 ) );\n\t\t\t\n\t\t\t\t\t} );\n\t\t\t\n\t\t\t\t\treturn finalOutput;\n\t\t\t\n\t\t\t\t} )();\n\n\t\t\t\t// shadow\n\n\t\t\t\tslicedMaterial.castShadowNode = Fn( () => {\n\n\t\t\t\t\t// discard\n\n\t\t\t\t\tinAngle( positionLocal.xy, sliceStart, sliceArc ).discard();\n\n\t\t\t\t\treturn vec4( 0, 0, 0, 1 );\n\t\t\t\n\t\t\t\t} )();\n\n\t\t\t\t// model\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\n\t\t\t\tgltfLoader.load( './models/gltf/gears.glb', ( gltf ) => {\n\n\t\t\t\t\tconst model = gltf.scene;\n\n\t\t\t\t\tmodel.traverse( ( child ) => {\n\n\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\tif ( child.name === 'outerHull' )\n\t\t\t\t\t\t\t\tchild.material = slicedMaterial;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchild.material = defaultMaterial;\n\n\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\tchild.receiveShadow = true;\n\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tscene.add( model );\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\t// plane\n\n\t\t\t\tconst plane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10, 10, 10 ),\n\t\t\t\t\tnew THREE.MeshStandardMaterial( { color: '#aaaaaa' } )\n\t\t\t\t);\n\t\t\t\tplane.receiveShadow = true;\n\t\t\t\tplane.position.set( - 4, - 3, - 4 );\n\t\t\t\tplane.lookAt( new THREE.Vector3( 0, 0, 0 ) );\n\t\t\t\tscene.add( plane );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\t\t\t\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - angular slicing Based on Three.js Journey lesson"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - attractors particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - attractors particles:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { float, If, PI, color, cos, instanceIndex, Loop, mix, mod, sin, instancedArray, Fn, uint, uniform, uniformArray, hash, vec3, vec4 } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\n\t\t\tlet camera, scene, renderer, controls, updateCompute;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 3, 5, 8 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// ambient light\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( '#ffffff', 0.5 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\t// directional light\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( '#ffffff', 1.5 );\n\t\t\t\tdirectionalLight.position.set( 4, 2, 0 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setClearColor( '#000000' );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// attractors\n\n\t\t\t\tconst attractorsPositions = uniformArray( [\n\t\t\t\t\tnew THREE.Vector3( - 1, 0, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 1, 0, - 0.5 ),\n\t\t\t\t\tnew THREE.Vector3( 0, 0.5, 1 )\n\t\t\t\t] );\n\t\t\t\tconst attractorsRotationAxes = uniformArray( [\n\t\t\t\t\tnew THREE.Vector3( 0, 1, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 0, 1, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 1, 0, - 0.5 ).normalize()\n\t\t\t\t] );\n\t\t\t\tconst attractorsLength = uniform( attractorsPositions.array.length, 'uint' );\n\t\t\t\tconst attractors = [];\n\t\t\t\tconst helpersRingGeometry = new THREE.RingGeometry( 1, 1.02, 32, 1, 0, Math.PI * 1.5 );\n\t\t\t\tconst helpersArrowGeometry = new THREE.ConeGeometry( 0.1, 0.4, 12, 1, false );\n\t\t\t\tconst helpersMaterial = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide } );\n\n\t\t\t\tfor ( let i = 0; i < attractorsPositions.array.length; i ++ ) {\n\n\t\t\t\t\tconst attractor = {};\n\n\t\t\t\t\tattractor.position = attractorsPositions.array[ i ];\n\t\t\t\t\tattractor.orientation = attractorsRotationAxes.array[ i ];\n\t\t\t\t\tattractor.reference = new THREE.Object3D();\n\t\t\t\t\tattractor.reference.position.copy( attractor.position );\n\t\t\t\t\tattractor.reference.quaternion.setFromUnitVectors( new THREE.Vector3( 0, 1, 0 ), attractor.orientation );\n\t\t\t\t\tscene.add( attractor.reference );\n\n\t\t\t\t\tattractor.helper = new THREE.Group();\n\t\t\t\t\tattractor.helper.scale.setScalar( 0.325 );\n\t\t\t\t\tattractor.reference.add( attractor.helper );\n\n\t\t\t\t\tattractor.ring = new THREE.Mesh( helpersRingGeometry, helpersMaterial );\n\t\t\t\t\tattractor.ring.rotation.x = - Math.PI * 0.5;\n\t\t\t\t\tattractor.helper.add( attractor.ring );\n\n\t\t\t\t\tattractor.arrow = new THREE.Mesh( helpersArrowGeometry, helpersMaterial );\n\t\t\t\t\tattractor.arrow.position.x = 1;\n\t\t\t\t\tattractor.arrow.position.z = 0.2;\n\t\t\t\t\tattractor.arrow.rotation.x = Math.PI * 0.5;\n\t\t\t\t\tattractor.helper.add( attractor.arrow );\n\n\t\t\t\t\tattractor.controls = new TransformControls( camera, renderer.domElement );\n\t\t\t\t\tattractor.controls.mode = 'rotate';\n\t\t\t\t\tattractor.controls.size = 0.5;\n\t\t\t\t\tattractor.controls.attach( attractor.reference );\n\t\t\t\t\tattractor.controls.visible = true;\n\t\t\t\t\tattractor.controls.enabled = attractor.controls.visible;\n\t\t\t\t\tscene.add( attractor.controls.getHelper() );\n\n\t\t\t\t\tattractor.controls.addEventListener( 'dragging-changed', ( event ) => {\n\n\t\t\t\t\t\tcontrols.enabled = ! event.value;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tattractor.controls.addEventListener( 'change', () => {\n\n\t\t\t\t\t\tattractor.position.copy( attractor.reference.position );\n\t\t\t\t\t\tattractor.orientation.copy( new THREE.Vector3( 0, 1, 0 ).applyQuaternion( attractor.reference.quaternion ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tattractors.push( attractor );\n\n\t\t\t\t}\n\n\t\t\t\t// particles\n\n\t\t\t\tconst count = Math.pow( 2, 18 );\n\t\t\t\tconst material = new THREE.SpriteNodeMaterial( { blending: THREE.AdditiveBlending, depthWrite: false } );\n\n\t\t\t\tconst attractorMass = uniform( Number( `1e${7}` ) );\n\t\t\t\tconst particleGlobalMass = uniform( Number( `1e${4}` ) );\n\t\t\t\tconst timeScale = uniform( 1 );\n\t\t\t\tconst spinningStrength = uniform( 2.75 );\n\t\t\t\tconst maxSpeed = uniform( 8 );\n\t\t\t\tconst gravityConstant = 6.67e-11;\n\t\t\t\tconst velocityDamping = uniform( 0.1 );\n\t\t\t\tconst scale = uniform( 0.008 );\n\t\t\t\tconst boundHalfExtent = uniform( 8 );\n\t\t\t\tconst colorA = uniform( color( '#5900ff' ) );\n\t\t\t\tconst colorB = uniform( color( '#ffa575' ) );\n\n\t\t\t\tconst positionBuffer = instancedArray( count, 'vec3' );\n\t\t\t\tconst velocityBuffer = instancedArray( count, 'vec3' );\n\n\t\t\t\tconst sphericalToVec3 = Fn( ( [ phi, theta ] ) => {\n\n\t\t\t\t\tconst sinPhiRadius = sin( phi );\n\n\t\t\t\t\treturn vec3(\n\t\t\t\t\t\tsinPhiRadius.mul( sin( theta ) ),\n\t\t\t\t\t\tcos( phi ),\n\t\t\t\t\t\tsinPhiRadius.mul( cos( theta ) )\n\t\t\t\t\t);\n\n\t\t\t\t} );\n\n\t\t\t\t// init compute\n\n\t\t\t\tconst init = Fn( () => {\n\n\t\t\t\t\tconst position = positionBuffer.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocityBuffer.element( instanceIndex );\n\n\t\t\t\t\tconst basePosition = vec3(\n\t\t\t\t\t\thash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ),\n\t\t\t\t\t\thash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ),\n\t\t\t\t\t\thash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) )\n\t\t\t\t\t).sub( 0.5 ).mul( vec3( 5, 0.2, 5 ) );\n\t\t\t\t\tposition.assign( basePosition );\n\n\t\t\t\t\tconst phi = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).mul( PI ).mul( 2 );\n\t\t\t\t\tconst theta = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).mul( PI );\n\t\t\t\t\tconst baseVelocity = sphericalToVec3( phi, theta ).mul( 0.05 );\n\t\t\t\t\tvelocity.assign( baseVelocity );\n\n\t\t\t\t} );\n\n\t\t\t\tconst initCompute = init().compute( count );\n\n\t\t\t\tconst reset = () => {\n\n\t\t\t\t\trenderer.computeAsync( initCompute );\n\n\t\t\t\t};\n\n\t\t\t\treset();\n\n\t\t\t\t// update compute\n\n\t\t\t\tconst particleMassMultiplier = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).remap( 0.25, 1 ).toVar();\n\t\t\t\tconst particleMass = particleMassMultiplier.mul( particleGlobalMass ).toVar();\n\n\t\t\t\tconst update = Fn( () => {\n\n\t\t\t\t\t// const delta = timerDelta().mul( timeScale ).min( 1 / 30 ).toVar();\n\t\t\t\t\tconst delta = float( 1 / 60 ).mul( timeScale ).toVar(); // uses fixed delta to consistent result\n\t\t\t\t\tconst position = positionBuffer.element( instanceIndex );\n\t\t\t\t\tconst velocity = velocityBuffer.element( instanceIndex );\n\n\t\t\t\t\t// force\n\n\t\t\t\t\tconst force = vec3( 0 ).toVar();\n\n\t\t\t\t\tLoop( attractorsLength, ( { i } ) => {\n\n\t\t\t\t\t\tconst attractorPosition = attractorsPositions.element( i );\n\t\t\t\t\t\tconst attractorRotationAxis = attractorsRotationAxes.element( i );\n\t\t\t\t\t\tconst toAttractor = attractorPosition.sub( position );\n\t\t\t\t\t\tconst distance = toAttractor.length();\n\t\t\t\t\t\tconst direction = toAttractor.normalize();\n\n\t\t\t\t\t\t// gravity\n\t\t\t\t\t\tconst gravityStrength = attractorMass.mul( particleMass ).mul( gravityConstant ).div( distance.pow( 2 ) ).toVar();\n\t\t\t\t\t\tconst gravityForce = direction.mul( gravityStrength );\n\t\t\t\t\t\tforce.addAssign( gravityForce );\n\n\t\t\t\t\t\t// spinning\n\t\t\t\t\t\tconst spinningForce = attractorRotationAxis.mul( gravityStrength ).mul( spinningStrength );\n\t\t\t\t\t\tconst spinningVelocity = spinningForce.cross( toAttractor );\n\t\t\t\t\t\tforce.addAssign( spinningVelocity );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// velocity\n\n\t\t\t\t\tvelocity.addAssign( force.mul( delta ) );\n\t\t\t\t\tconst speed = velocity.length();\n\t\t\t\t\tIf( speed.greaterThan( maxSpeed ), () => {\n\n\t\t\t\t\t\tvelocity.assign( velocity.normalize().mul( maxSpeed ) );\n\n\t\t\t\t\t} );\n\t\t\t\t\tvelocity.mulAssign( velocityDamping.oneMinus() );\n\n\t\t\t\t\t// position\n\n\t\t\t\t\tposition.addAssign( velocity.mul( delta ) );\n\n\t\t\t\t\t// box loop\n\n\t\t\t\t\tconst halfHalfExtent = boundHalfExtent.div( 2 ).toVar();\n\t\t\t\t\tposition.assign( mod( position.add( halfHalfExtent ), boundHalfExtent ).sub( halfHalfExtent ) );\n\n\t\t\t\t} );\n\t\t\t\tupdateCompute = update().compute( count );\n\n\t\t\t\t// nodes\n\n\t\t\t\tmaterial.positionNode = positionBuffer.toAttribute();\n\n\t\t\t\tmaterial.colorNode = Fn( () => {\n\n\t\t\t\t\tconst velocity = velocityBuffer.toAttribute();\n\t\t\t\t\tconst speed = velocity.length();\n\t\t\t\t\tconst colorMix = speed.div( maxSpeed ).smoothstep( 0, 0.5 );\n\t\t\t\t\tconst finalColor = mix( colorA, colorB, colorMix );\n\n\t\t\t\t\treturn vec4( finalColor, 1 );\n\n\t\t\t\t} )();\n\n\t\t\t\tmaterial.scaleNode = particleMassMultiplier.mul( scale );\n\n\t\t\t\t// mesh\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 1, 1 );\n\t\t\t\tconst mesh = new THREE.InstancedMesh( geometry, material, count );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// debug\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( { attractorMassExponent: attractorMass.value.toString().length - 1 }, 'attractorMassExponent', 1, 10, 1 ).onChange( value => attractorMass.value = Number( `1e${value}` ) );\n\t\t\t\tgui.add( { particleGlobalMassExponent: particleGlobalMass.value.toString().length - 1 }, 'particleGlobalMassExponent', 1, 10, 1 ).onChange( value => particleGlobalMass.value = Number( `1e${value}` ) );\n\t\t\t\tgui.add( maxSpeed, 'value', 0, 10, 0.01 ).name( 'maxSpeed' );\n\t\t\t\tgui.add( velocityDamping, 'value', 0, 0.1, 0.001 ).name( 'velocityDamping' );\n\t\t\t\tgui.add( spinningStrength, 'value', 0, 10, 0.01 ).name( 'spinningStrength' );\n\t\t\t\tgui.add( scale, 'value', 0, 0.1, 0.001 ).name( 'scale' );\n\t\t\t\tgui.add( boundHalfExtent, 'value', 0, 20, 0.01 ).name( 'boundHalfExtent' );\n\t\t\t\tgui.addColor( { color: colorA.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorA' ).onChange( value => colorA.value.set( value ) );\n\t\t\t\tgui.addColor( { color: colorB.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorB' ).onChange( value => colorB.value.set( value ) );\n\t\t\t\tgui\n\t\t\t\t\t.add( { controlsMode: attractors[ 0 ].controls.mode }, 'controlsMode' )\n\t\t\t\t\t.options( [ 'translate', 'rotate', 'none' ] )\n\t\t\t\t\t.onChange( value => {\n\n\t\t\t\t\t\tfor ( const attractor of attractors ) {\n\n\t\t\t\t\t\t\tif ( value === 'none' ) {\n\n\t\t\t\t\t\t\t\tattractor.controls.visible = false;\n\t\t\t\t\t\t\t\tattractor.controls.enabled = false;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tattractor.controls.visible = true;\n\t\t\t\t\t\t\t\tattractor.controls.enabled = true;\n\t\t\t\t\t\t\t\tattractor.controls.mode = value;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui\n\t\t\t\t\t.add( { helperVisible: attractors[ 0 ].helper.visible }, 'helperVisible' )\n\t\t\t\t\t.onChange( value => {\n\n\t\t\t\t\t\tfor ( const attractor of attractors )\n\t\t\t\t\t\t\tattractor.helper.visible = value;\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.add( { reset }, 'reset' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n    \t\t\trenderer.compute( updateCompute );\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Compute Attractors Particles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - earth"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - earth:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { step, normalWorldGeometry, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls, globe, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 4.5, 2, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// sun\n\n\t\t\t\tconst sun = new THREE.DirectionalLight( '#ffffff', 2 );\n\t\t\t\tsun.position.set( 0, 0, 3 );\n\t\t\t\tscene.add( sun );\n\n\t\t\t\t// uniforms\n\n\t\t\t\tconst atmosphereDayColor = uniform( color( '#4db2ff' ) );\n\t\t\t\tconst atmosphereTwilightColor = uniform( color( '#bc490b' ) );\n\t\t\t\tconst roughnessLow = uniform( 0.25 );\n\t\t\t\tconst roughnessHigh = uniform( 0.35 );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst dayTexture = textureLoader.load( './textures/planets/earth_day_4096.jpg' );\n\t\t\t\tdayTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tdayTexture.anisotropy = 8;\n\n\t\t\t\tconst nightTexture = textureLoader.load( './textures/planets/earth_night_4096.jpg' );\n\t\t\t\tnightTexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tnightTexture.anisotropy = 8;\n\n\t\t\t\tconst bumpRoughnessCloudsTexture = textureLoader.load( './textures/planets/earth_bump_roughness_clouds_4096.jpg' );\n\t\t\t\tbumpRoughnessCloudsTexture.anisotropy = 8;\n\n\t\t\t\t// fresnel\n\n\t\t\t\tconst viewDirection = positionWorld.sub( cameraPosition ).normalize();\n\t\t\t\tconst fresnel = viewDirection.dot( normalWorldGeometry ).abs().oneMinus().toVar();\n\n\t\t\t\t// sun orientation\n\n\t\t\t\tconst sunOrientation = normalWorldGeometry.dot( normalize( sun.position ) ).toVar();\n\n\t\t\t\t// atmosphere color\n\n\t\t\t\tconst atmosphereColor = mix( atmosphereTwilightColor, atmosphereDayColor, sunOrientation.smoothstep( - 0.25, 0.75 ) );\n\n\t\t\t\t// globe\n\n\t\t\t\tconst globeMaterial = new THREE.MeshStandardNodeMaterial();\n\n\t\t\t\tconst cloudsStrength = texture( bumpRoughnessCloudsTexture, uv() ).b.smoothstep( 0.2, 1 );\n\n\t\t\t\tglobeMaterial.colorNode = mix( texture( dayTexture ), vec3( 1 ), cloudsStrength.mul( 2 ) );\n\n\t\t\t\tconst roughness = max(\n\t\t\t\t\ttexture( bumpRoughnessCloudsTexture ).g,\n\t\t\t\t\tstep( 0.01, cloudsStrength )\n\t\t\t\t);\n\t\t\t\tglobeMaterial.roughnessNode = roughness.remap( 0, 1, roughnessLow, roughnessHigh );\n\n\t\t\t\tconst night = texture( nightTexture );\n\t\t\t\tconst dayStrength = sunOrientation.smoothstep( - 0.25, 0.5 );\n\n\t\t\t\tconst atmosphereDayStrength = sunOrientation.smoothstep( - 0.5, 1 );\n\t\t\t\tconst atmosphereMix = atmosphereDayStrength.mul( fresnel.pow( 2 ) ).clamp( 0, 1 );\n\n\t\t\t\tlet finalOutput = mix( night.rgb, output.rgb, dayStrength );\n\t\t\t\tfinalOutput = mix( finalOutput, atmosphereColor, atmosphereMix );\n\n\t\t\t\tglobeMaterial.outputNode = vec4( finalOutput, output.a );\n\n\t\t\t\tconst bumpElevation = max(\n\t\t\t\t\ttexture( bumpRoughnessCloudsTexture ).r,\n\t\t\t\t\tcloudsStrength\n\t\t\t\t);\n\t\t\t\tglobeMaterial.normalNode = bumpMap( bumpElevation );\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 1, 64, 64 );\n\t\t\t\tglobe = new THREE.Mesh( sphereGeometry, globeMaterial );\n\t\t\t\tscene.add( globe );\n\n\t\t\t\t// atmosphere\n\n\t\t\t\tconst atmosphereMaterial = new THREE.MeshBasicNodeMaterial( { side: THREE.BackSide, transparent: true } );\n\t\t\t\tlet alpha = fresnel.remap( 0.73, 1, 1, 0 ).pow( 3 );\n\t\t\t\talpha = alpha.mul( sunOrientation.smoothstep( - 0.5, 1 ) );\n\t\t\t\tatmosphereMaterial.outputNode = vec4( atmosphereColor, alpha );\n\n\t\t\t\tconst atmosphere = new THREE.Mesh( sphereGeometry, atmosphereMaterial );\n\t\t\t\tatmosphere.scale.setScalar( 1.04 );\n\t\t\t\tscene.add( atmosphere );\n\n\t\t\t\t// debug\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui\n\t\t\t\t\t.addColor( { color: atmosphereDayColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' )\n\t\t\t\t\t.onChange( ( value ) => {\n\n\t\t\t\t\t\tatmosphereDayColor.value.set( value );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.name( 'atmosphereDayColor' );\n\n\t\t\t\tgui\n\t\t\t\t\t.addColor( { color: atmosphereTwilightColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' )\n\t\t\t\t\t.onChange( ( value ) => {\n\n\t\t\t\t\t\tatmosphereTwilightColor.value.set( value );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.name( 'atmosphereTwilightColor' );\n\n\t\t\t\tgui.add( roughnessLow, 'value', 0, 1, 0.001 ).name( 'roughnessLow' );\n\t\t\t\tgui.add( roughnessHigh, 'value', 0, 1, 0.001 ).name( 'roughnessHigh' );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\t\t\t\tglobe.rotation.y += delta * 0.025;\n\t\t\t\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - earth Based on Three.js Journey lesson Earth textures from Solar System Scope (resized and merged)"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - tsl editor"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - tsl editor:\n\n```javascript\nimport * as THREE from 'three/webgpu';\n\t\t\timport { vec4 } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// add the dependencies\n\n\t\t\t\tconst width = 200;\n\t\t\t\tconst height = 200;\n\n\t\t\t\tconst camera = new THREE.PerspectiveCamera( 70, width / height, 0.1, 10 );\n\t\t\t\tcamera.position.z = .72;\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tconst scene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tconst rendererDOM = document.getElementById( 'renderer' );\n\n\t\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( 200, 200 );\n\t\t\t\trendererDOM.appendChild( renderer.domElement );\n\n\t\t\t\tconst material = new THREE.NodeMaterial();\n\t\t\t\tmaterial.fragmentNode = vec4( 0, 0, 0, 1 );\n\n\t\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tlet compiling = false;\n\n\t\t\t\trenderer.setAnimationLoop( () => {\n\n\t\t\t\t\tif ( compiling ) return;\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t} );\n\n\t\t\t\t// editor\n\n\t\t\t\twindow.require.config( { paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } } );\n\n\t\t\t\trequire( [ 'vs/editor/editor.main' ], () => {\n\n\t\t\t\t\tconst options = {\n\t\t\t\t\t\tshader: 'fragment',\n\t\t\t\t\t\toutputColorSpace: THREE.SRGBColorSpace,\n\t\t\t\t\t\toutput: 'WGSL',\n\t\t\t\t\t\tpreview: true\n\t\t\t\t\t};\n\n\t\t\t\t\tlet timeout = null;\n\t\t\t\t\tlet rawShader = null;\n\n\t\t\t\t\tconst editorDOM = document.getElementById( 'source' );\n\t\t\t\t\tconst resultDOM = document.getElementById( 'result' );\n\n\t\t\t\t\tconst tslCode = `// Simple uv.x animation\n\nconst { texture, uniform, vec2, vec4, uv, oscSine, time, grayscale } = await import( 'three/tsl' );\n\nconst samplerTexture = new THREE.TextureLoader().load( './textures/uv_grid_opengl.jpg' );\nsamplerTexture.wrapS = THREE.RepeatWrapping;\nsamplerTexture.colorSpace = THREE.SRGBColorSpace;\n\nconst scaledTime = time.mul( .5 ); // .5 is speed\nconst uv0 = uv();\nconst animateUv = vec2( uv0.x.add( oscSine( scaledTime ) ), uv0.y );\n\n// label is optional\nconst myMap = texture( samplerTexture, animateUv ).rgb.label( 'myTexture' );\nconst myColor = uniform( new THREE.Color( 0x0066ff ) ).label( 'myColor' );\nconst opacity = .7;\n\nconst desaturatedMap = grayscale( myMap.rgb );\n\nconst finalColor = desaturatedMap.add( myColor );\n\noutput = vec4( finalColor, opacity );\n`;\n\n\t\t\t\t\tconst editor = window.monaco.editor.create( editorDOM, {\n\t\t\t\t\t\tvalue: tslCode,\n\t\t\t\t\t\tlanguage: 'javascript',\n\t\t\t\t\t\ttheme: 'vs-dark',\n\t\t\t\t\t\tautomaticLayout: true,\n\t\t\t\t\t\tminimap: { enabled: false }\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst result = window.monaco.editor.create( resultDOM, {\n\t\t\t\t\t\tvalue: '',\n\t\t\t\t\t\tlanguage: 'wgsl',\n\t\t\t\t\t\ttheme: 'vs-dark',\n\t\t\t\t\t\tautomaticLayout: true,\n\t\t\t\t\t\treadOnly: true,\n\t\t\t\t\t\tminimap: { enabled: false }\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst showCode = () => {\n\n\t\t\t\t\t\tresult.setValue( rawShader[ options.shader + 'Shader' ] );\n\t\t\t\t\t\tresult.revealLine( 1 );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tconst webGLRenderer = new THREE.WebGPURenderer( { forceWebGL: true } );\n\n\t\t\t\t\tconst build = async () => {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tconst AsyncFunction = async function () {}.constructor;\n\n\t\t\t\t\t\t\tconst tslCode = `let output = null;\\n${ editor.getValue() }\\nreturn { output };`;\n\t\t\t\t\t\t\tconst nodes = await ( new AsyncFunction( 'THREE', tslCode )( THREE ) );\n\n\t\t\t\t\t\t\tmesh.material.fragmentNode = nodes.output;\n\t\t\t\t\t\t\tmesh.material.needsUpdate = true;\n\n\t\t\t\t\t\t\tcompiling = true;\n\n\t\t\t\t\t\t\tif ( options.output === 'WGSL' ) {\n\n\t\t\t\t\t\t\t\trawShader = await renderer.debug.getShaderAsync( scene, camera, mesh );\n\n\n\t\t\t\t\t\t\t} else if ( options.output === 'GLSL ES 3.0' ) {\n\n\t\t\t\t\t\t\t\trawShader = await webGLRenderer.debug.getShaderAsync( scene, camera, mesh );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcompiling = false;\n\n\t\t\t\t\t\t\tshowCode();\n\n\t\t\t\t\t\t\t// extra debug info\n\n\t\t\t\t\t\t\t/*const style = 'background-color: #333; color: white; font-style: italic; border: 2px solid #777; font-size: 22px;';\n\n\t\t\t\t\t\t\tconsole.log( '%c  [ WGSL ] Vertex Shader      ', style );\n\t\t\t\t\t\t\tconsole.log( rawShader.vertexShader );\n\t\t\t\t\t\t\tconsole.log( '%c  [ WGSL ] Fragment Shader    ', style );\n\t\t\t\t\t\t\tconsole.log( rawShader.fragmentShader );/**/\n\n\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\tresult.setValue( 'Error: ' + e.message );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tbuild();\n\n\t\t\t\t\teditor.getModel().onDidChangeContent( () => {\n\n\t\t\t\t\t\tif ( timeout ) clearTimeout( timeout );\n\n\t\t\t\t\t\ttimeout = setTimeout( build, 1000 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// gui\n\n\t\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t\tgui.add( options, 'output', [ 'WGSL', 'GLSL ES 3.0' ] ).onChange( build );\n\t\t\t\t\tgui.add( options, 'shader', [ 'vertex', 'fragment' ] ).onChange( showCode );\n\n\t\t\t\t\tgui.add( options, 'outputColorSpace', [ THREE.LinearSRGBColorSpace, THREE.SRGBColorSpace ] ).onChange( ( value ) => {\n\n\t\t\t\t\t\trenderer.outputColorSpace = value;\n\n\t\t\t\t\t\tbuild();\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tgui.add( options, 'preview' ).onChange( ( value ) => {\n\n\t\t\t\t\t\trendererDOM.style.display = value ? '' : 'none';\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - galaxy"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - galaxy:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, cos, float, mix, range, sin, time, uniform, uv, vec3, vec4, PI2 } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 4, 2, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x201919 );\n\n\t\t\t\t// galaxy\n\n\t\t\t\tconst material = new THREE.SpriteNodeMaterial( {\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\tblending: THREE.AdditiveBlending\n\t\t\t\t} );\n\n\t\t\t\tconst size = uniform( 0.08 );\n\t\t\t\tmaterial.scaleNode = range( 0, 1 ).mul( size );\n\n\t\t\t\tconst radiusRatio = range( 0, 1 );\n\t\t\t\tconst radius = radiusRatio.pow( 1.5 ).mul( 5 ).toVar();\n\n\t\t\t\tconst branches = 3;\n\t\t\t\tconst branchAngle = range( 0, branches ).floor().mul( PI2.div( branches ) );\n\t\t\t\tconst angle = branchAngle.add( time.mul( radiusRatio.oneMinus() ) );\n\n\t\t\t\tconst position = vec3(\n\t\t\t\t\tcos( angle ),\n\t\t\t\t\t0,\n\t\t\t\t\tsin( angle )\n\t\t\t\t).mul( radius );\n\n\t\t\t\tconst randomOffset = range( vec3( - 1 ), vec3( 1 ) ).pow( 3 ).mul( radiusRatio ).add( 0.2 );\n\n\t\t\t\tmaterial.positionNode = position.add( randomOffset );\n\n\t\t\t\tconst colorInside = uniform( color( '#ffa575' ) );\n\t\t\t\tconst colorOutside = uniform( color( '#311599' ) );\n\t\t\t\tconst colorFinal = mix( colorInside, colorOutside, radiusRatio.oneMinus().pow( 2 ).oneMinus() );\n\t\t\t\tconst alpha = float( 0.1 ).div( uv().sub( 0.5 ).length() ).sub( 0.2 );\n\t\t\t\tmaterial.colorNode = vec4( colorFinal, alpha );\n\n\t\t\t\tconst mesh = new THREE.InstancedMesh( new THREE.PlaneGeometry( 1, 1 ), material, 20000 );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// debug\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( size, 'value', 0, 1, 0.001 ).name( 'size' );\n\n\t\t\t\tgui.addColor( { color: colorInside.value.getHex( THREE.SRGBColorSpace ) }, 'color' )\n\t\t\t\t\t.name( 'colorInside' )\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\tcolorInside.value.set( value );\n\n\t\t\t\t\t} );\n\n\t\t\t\tgui.addColor( { color: colorOutside.value.getHex( THREE.SRGBColorSpace ) }, 'color' )\n\t\t\t\t\t.name( 'colorOutside' )\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\tcolorOutside.value.set( value );\n\n\t\t\t\t\t} );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - galaxy Based on Three.js Journey lessons"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - halftone"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - halftone:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { color, mix, normalWorld, output, Fn, uniform, vec4, rotate, screenCoordinate, screenSize } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet camera, scene, renderer, controls, clock, halftoneSettings;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 6, 3, 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t// lights\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( '#ffffff', 3 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( '#ffffff', 8 );\n\t\t\t\tdirectionalLight.position.set( 4, 3, 1 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tconst lightsFolder = gui.addFolder( '\ud83d\udca1 lights' );\n\t\t\t\tlightsFolder.add( ambientLight, 'intensity', 0, 10, 0.001 ).name( 'ambientIntensity' );\n\t\t\t\tlightsFolder.add( directionalLight, 'intensity', 0, 20, 0.001 ).name( 'directionalIntensity' );\n\n\t\t\t\t// halftone settings\n\n\t\t\t\thalftoneSettings = [\n\n\t\t\t\t\t// purple shade\n\n\t\t\t\t\t{\n\t\t\t\t\t\tcount: 140,\n\t\t\t\t\t\tcolor: '#fb00ff',\n\t\t\t\t\t\tdirection: new THREE.Vector3( - 0.4, - 1, 0.5 ),\n\t\t\t\t\t\tstart: 1,\n\t\t\t\t\t\tend: 0,\n\t\t\t\t\t\tmixLow: 0,\n\t\t\t\t\t\tmixHigh: 0.5,\n\t\t\t\t\t\tradius: 0.8\n\t\t\t\t\t},\n\n\t\t\t\t\t// cyan highlight\n\n\t\t\t\t\t{\n\t\t\t\t\t\tcount: 180,\n\t\t\t\t\t\tcolor: '#94ffd1',\n\t\t\t\t\t\tdirection: new THREE.Vector3( 0.5, 0.5, - 0.2 ),\n\t\t\t\t\t\tstart: 0.55,\n\t\t\t\t\t\tend: 0.2,\n\t\t\t\t\t\tmixLow: 0.5,\n\t\t\t\t\t\tmixHigh: 1,\n\t\t\t\t\t\tradius: 0.8\n\t\t\t\t\t}\n\t\t\t\t];\n\n\t\t\t\tfor ( const index in halftoneSettings ) {\n\n\t\t\t\t\tconst settings = halftoneSettings[ index ];\n\n\t\t\t\t\t// uniforms\n\n\t\t\t\t\tconst uniforms = {};\n\n\t\t\t\t\tuniforms.count = uniform( settings.count );\n\t\t\t\t\tuniforms.color = uniform( color( settings.color ) );\n\t\t\t\t\tuniforms.direction = uniform( settings.direction );\n\t\t\t\t\tuniforms.start = uniform( settings.start );\n\t\t\t\t\tuniforms.end = uniform( settings.end );\n\t\t\t\t\tuniforms.mixLow = uniform( settings.mixLow );\n\t\t\t\t\tuniforms.mixHigh = uniform( settings.mixHigh );\n\t\t\t\t\tuniforms.radius = uniform( settings.radius );\n\n\t\t\t\t\tsettings.uniforms = uniforms;\n\n\t\t\t\t\t// debug\n\n\t\t\t\t\tconst folder = gui.addFolder( `\u26aa\ufe0f halftone ${index}` );\n\n\t\t\t\t\tfolder.addColor( { color: uniforms.color.value.getHexString( THREE.SRGBColorSpace ) }, 'color' )\n\t\t\t\t\t\t.onChange( value => uniforms.color.value.set( value ) );\n\t\t\t\t\tfolder.add( uniforms.count, 'value', 1, 200, 1 ).name( 'count' );\n\t\t\t\t\tfolder.add( uniforms.direction.value, 'x', - 1, 1, 0.01 ).listen();\n\t\t\t\t\tfolder.add( uniforms.direction.value, 'y', - 1, 1, 0.01 ).listen();\n\t\t\t\t\tfolder.add( uniforms.direction.value, 'z', - 1, 1, 0.01 ).listen();\n\t\t\t\t\tfolder.add( uniforms.start, 'value', - 1, 1, 0.01 ).name( 'start' );\n\t\t\t\t\tfolder.add( uniforms.end, 'value', - 1, 1, 0.01 ).name( 'end' );\n\t\t\t\t\tfolder.add( uniforms.mixLow, 'value', 0, 1, 0.01 ).name( 'mixLow' );\n\t\t\t\t\tfolder.add( uniforms.mixHigh, 'value', 0, 1, 0.01 ).name( 'mixHigh' );\n\t\t\t\t\tfolder.add( uniforms.radius, 'value', 0, 1, 0.01 ).name( 'radius' );\n\n\t\t\t\t}\n\n\t\t\t\t// halftone functions\n\n\t\t\t\tconst halftone = Fn( ( [ count, color, direction, start, end, radius, mixLow, mixHigh ] ) => {\n\n\t\t\t\t\t// grid pattern\n\n\t\t\t\t\tlet gridUv = screenCoordinate.xy.div( screenSize.yy ).mul( count );\n\t\t\t\t\tgridUv = rotate( gridUv, Math.PI * 0.25 ).mod( 1 );\n\n\t\t\t\t\t// orientation strength\n\n\t\t\t\t\tconst orientationStrength = normalWorld\n\t\t\t\t\t\t.dot( direction.normalize() )\n\t\t\t\t\t\t.remapClamp( end, start, 0, 1 );\n\n\t\t\t\t\t// mask\n\n\t\t\t\t\tconst mask = orientationStrength.mul( radius ).mul( 0.5 )\n\t\t\t\t\t\t.step( gridUv.sub( 0.5 ).length() )\n\t\t\t\t\t\t.mul( mix( mixLow, mixHigh, orientationStrength ) );\n\n\t\t\t\t\treturn vec4( color, mask );\n\n\t\t\t\t} );\n\n\t\t\t\tconst halftones = Fn( ( [ input ] ) => {\n\n\t\t\t\t\tconst halftonesOutput = input;\n\n\t\t\t\t\tfor ( const settings of halftoneSettings ) {\n\n\t\t\t\t\t\tconst halfToneOutput = halftone( settings.uniforms.count, settings.uniforms.color, settings.uniforms.direction, settings.uniforms.start, settings.uniforms.end, settings.uniforms.radius, settings.uniforms.mixLow, settings.uniforms.mixHigh );\n\t\t\t\t\t\thalftonesOutput.rgb.assign( mix( halftonesOutput.rgb, halfToneOutput.rgb, halfToneOutput.a ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn halftonesOutput;\n\n\t\t\t\t} );\n\n\t\t\t\t// default material\n\n\t\t\t\tconst defaultMaterial = new THREE.MeshStandardNodeMaterial( { color: '#ff622e' } );\n\t\t\t\tdefaultMaterial.outputNode = halftones( output );\n\n\t\t\t\tconst folder = gui.addFolder( '\ud83c\udfa8 default material' );\n\t\t\t\tfolder.addColor( { color: defaultMaterial.color.getHexString( THREE.SRGBColorSpace ) }, 'color' )\n\t\t\t\t\t.onChange( value => defaultMaterial.color.set( value ) );\n\n\t\t\t\t// objects\n\n\t\t\t\tconst torusKnot = new THREE.Mesh(\n\t\t\t\t\tnew THREE.TorusKnotGeometry( 0.6, 0.25, 128, 32 ),\n\t\t\t\t\tdefaultMaterial\n\t\t\t\t);\n\t\t\t\ttorusKnot.position.x = 3;\n\t\t\t\tscene.add( torusKnot );\n\n\t\t\t\tconst sphere = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 1, 64, 64 ),\n\t\t\t\t\tdefaultMaterial\n\t\t\t\t);\n\t\t\t\tsphere.position.x = - 3;\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.load(\n\t\t\t\t\t'./models/gltf/Michelle.glb',\n\t\t\t\t\t( gltf ) => {\n\n\t\t\t\t\t\tconst model = gltf.scene;\n\t\t\t\t\t\tmodel.position.y = - 2;\n\t\t\t\t\t\tmodel.scale.setScalar( 2.5 );\n\t\t\t\t\t\tmodel.traverse( ( child ) => {\n\n\t\t\t\t\t\t\tif ( child.isMesh )\n\t\t\t\t\t\t\t\tchild.material.outputNode = halftones( output );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tscene.add( model );\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setClearColor( '#000000' );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst time = clock.getElapsedTime();\n\t\t\t\thalftoneSettings[ 1 ].uniforms.direction.value.x = Math.cos( time );\n\t\t\t\thalftoneSettings[ 1 ].uniforms.direction.value.y = Math.sin( time );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js WebGPU - Halftone"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - wgsl/tsl node interoperability"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - wgsl/tsl node interoperability:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Fn, attribute, varyingProperty, time, uniform, wgslFn, texture, sampler, uv, clamp, float, vec2, vec3, fract, floor, positionGeometry, sin } from 'three/tsl';\n\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, camera, scene;\n\t\t\tconst dpr = window.devicePixelRatio;\n\n\t\t\tconst crtWidthUniform = uniform( 1608 );\n\t\t\tconst crtHeightUniform = uniform( 1608 );\n\n\t\t\tconst canvas = document.getElementById( 'c' );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tconst vUv = varyingProperty( 'vec2', 'vUv' );\n\n\t\t\t\t// In WGSL, access varying properties from the varying struct\n\t\t\t\tconst wgslVertexShader = wgslFn( `\n\t\t\t\t\tfn crtVertex(\n\t \t\t\t\t\tposition: vec3f,\n\t\t\t\t\t\tuv: vec2f\n\t\t\t\t\t) -> vec3<f32> {\n\t\t\t\t\t\tvaryings.vUv = uv;\n\t\t\t\t\t\treturn position;\n\t\t\t\t\t}\n\t\t\t\t`, [\n\t\t\t\t\tvUv\n\t\t\t\t] );\n\n\t\t\t\t// Only wgsl vertex shaders take varyings arguments when defined.\n\t\t\t\t// For a wgsl fragment shader, pass the varyingProperty node to the\n\t\t\t\t// fragment shader's constructor to access the varying value computed\n\t\t\t\t// by the vertex shader.\n\t\t\t\tconst wgslFragmentShader = wgslFn( `\n\t\t\t\t\tfn crtFragment(\n\t\t\t\t\t\tvUv: vec2f,\n\t\t\t\t\t\ttex: texture_2d<f32>,\n\t\t\t\t\t\ttexSampler: sampler,\n\t\t\t\t\t\tcrtWidth: f32,\n\t\t\t\t\t\tcrtHeight: f32,\n\t\t\t\t\t\tcellOffset: f32,\n\t\t\t\t\t\tcellSize: f32,\n\t\t\t\t\t\tborderMask: f32,\n\t\t\t\t\t\ttime: f32,\n\t\t\t\t\t\tspeed: f32,\n\t\t\t\t\t\tpulseIntensity: f32,\n\t\t\t\t\t\tpulseWidth: f32,\n\t\t\t\t\t\tpulseRate: f32\n\t\t\t\t\t) -> vec3<f32> {\n\t\t\t\t\t\t// Convert uv into map of pixels\n\t\t\t\t\t\tvar pixel = ( vUv * 0.5 + 0.5 ) * vec2<f32>(\n\t\t\t\t\t\t\tcrtWidth,\n\t\t\t\t\t\t\tcrtHeight\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Coordinate for each cell in the pixel map\n\t\t\t\t\t\tlet coord = pixel / cellSize;\n\t\t\t\t\t\t// Three color values for each cell (r, g, b)\n\t\t\t\t\t\tlet subcoord = coord * vec2f( 3.0, 1.0 );\n\t\t\t\t\t\tlet offset = vec2<f32>( 0, fract( floor( coord.x ) * cellOffset ) );\n\n\t\t\t\t\t\tlet maskCoord = floor( coord + offset ) * cellSize;\n\n\t\t\t\t\t\tvar samplePoint = maskCoord / vec2<f32>(crtWidth, crtHeight);\n\t\t\t\t\t\tsamplePoint.x += fract( time * speed / 20 );\n\n\t\t\t\t\t\tvar color = textureSample(\n\t\t\t\t\t\t\ttex,\n\t\t\t\t\t\t\ttexSampler,\n\t\t\t\t\t\t\tsamplePoint\n\t\t\t\t\t\t).xyz;\n\n\t\t\t\t\t\t// Current implementation does not give an even amount of space to each r, g, b unit of a cell\n\t\t\t\t\t\t// Fix/hack this by multiplying subCoord.x by cellSize at cellSizes below 6\n\t\t\t\t\t\tlet ind = floor( subcoord.x ) % 3;\n\n\t\t\t\t\t\tvar maskColor = vec3<f32>(\n\t\t\t\t\t\t\tf32( ind == 0.0 ),\n\t\t\t\t\t\t\tf32( ind == 1.0 ),\n\t\t\t\t\t\t\tf32( ind == 2.0 )\n\t\t\t\t\t\t) * 3.0;\n\n\t\t\t\t\t\tlet cellUV = fract( subcoord + offset ) * 2.0 - 1.0;\n\t\t\t\t\t\tvar border: vec2<f32> = 1.0 - cellUV * cellUV * borderMask;\n\n\t\t\t\t\t\tmaskColor *= vec3f( clamp( border.x, 0.0, 1.0 ) * clamp( border.y, 0.0, 1.0) );\n\n\t\t\t\t\t\tcolor *= maskColor;\n\n\t\t\t\t\t\tcolor.r *= 1.0 + pulseIntensity * sin( pixel.y / pulseWidth + time * pulseRate );\n\t\t\t\t\t\tcolor.b *= 1.0 + pulseIntensity * sin( pixel.y / pulseWidth + time * pulseRate );\n\t\t\t\t\t\tcolor.g *= 1.0 + pulseIntensity * sin( pixel.y / pulseWidth + time * pulseRate );\n\n\t\t\t\t\t\treturn color;\n\t\t\t\t\t}\n\t\t\t\t` );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst planetTexture = textureLoader.load( 'textures/planets/earth_lights_2048.png' );\n\t\t\t\tplanetTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tplanetTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// Node Uniforms:\n\t\t\t\t// Passed to WGSL Functions.\n\t\t\t\t// Manipulated directly in TSL Functions.\n\t\t\t\tconst cellOffsetUniform = uniform( 0.5 );\n\t\t\t\tconst cellSizeUniform = uniform( 6 );\n\t\t\t\tconst borderMaskUniform = uniform( 1 );\n\t\t\t\tconst pulseIntensityUniform = uniform( 0.06 );\n\t\t\t\tconst pulseWidthUniform = uniform( 60 );\n\t\t\t\tconst pulseRateUniform = uniform( 20 );\n\t\t\t\tconst wgslShaderSpeedUniform = uniform( 1.0 );\n\t\t\t\tconst tslShaderSpeedUniform = uniform( 1.0 );\n\n\t\t\t\t//\n\n\t\t\t\tconst wgslShaderMaterial = new THREE.MeshBasicNodeMaterial();\n\n\t\t\t\t// Accessed attributes correspond to a Mesh or BufferGeometry's setAttribute() calls.\n\t\t\t\twgslShaderMaterial.positionNode = wgslVertexShader( {\n\t\t\t\t\tposition: attribute( 'position' ),\n\t\t\t\t\tuv: attribute( 'uv' )\n\t\t\t\t} );\n\n\t\t\t\twgslShaderMaterial.fragmentNode = wgslFragmentShader( {\n\t\t\t\t\tvUv: vUv,\n\t\t\t\t\ttex: texture( planetTexture ),\n\t\t\t\t\ttexSampler: sampler( planetTexture ),\n\t\t\t\t\tcrtWidth: crtWidthUniform,\n\t\t\t\t\tcrtHeight: crtHeightUniform,\n\t\t\t\t\tcellOffset: cellOffsetUniform,\n\t\t\t\t\tcellSize: cellSizeUniform,\n\t\t\t\t\tborderMask: borderMaskUniform,\n\t\t\t\t\ttime: time,\n\t\t\t\t\tspeed: wgslShaderSpeedUniform,\n\t\t\t\t\tpulseIntensity: pulseIntensityUniform,\n\t\t\t\t\tpulseWidth: pulseWidthUniform,\n\t\t\t\t\tpulseRate: pulseRateUniform\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst tslVertexShader = Fn( () => {\n\n\t\t\t\t\tvUv.assign( uv() );\n\t\t\t\t\treturn positionGeometry;\n\n\t\t\t\t} );\n\n\t\t\t\tconst tslFragmentShader = Fn( () => {\n\n\t\t\t\t\tconst dimensions = vec2( crtWidthUniform, crtHeightUniform );\n\t\t\t\t\tconst translatedUV = vUv.mul( 0.5 ).add( 0.5 );\n\t\t\t\t\tconst pixel = translatedUV.mul( dimensions );\n\n\t\t\t\t\tconst coord = pixel.div( cellSizeUniform );\n\t\t\t\t\tconst subCoord = coord.mul( vec2( 3.0, 1.0 ) );\n\n\t\t\t\t\tconst cellOffset = vec2(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\tfract( floor( coord.x ).mul( cellOffsetUniform ) )\n\t\t\t\t\t);\n\n\t\t\t\t\tconst maskCoord = floor( coord.add( cellOffset ) ).mul( cellSizeUniform );\n\t\t\t\t\tconst samplePoint = maskCoord.div( dimensions );\n\t\t\t\t\tconst scaledTime = time.mul( tslShaderSpeedUniform );\n\t\t\t\t\tsamplePoint.x = samplePoint.x.add( fract( scaledTime.div( 20 ) ) );\n\t\t\t\t\tsamplePoint.y = samplePoint.y.sub( 1.5 );\n\n\t\t\t\t\tlet color = texture( planetTexture, samplePoint );\n\n\t\t\t\t\tconst ind = floor( subCoord.x ).mod( 3 );\n\n\t\t\t\t\tlet maskColor = vec3(\n\t\t\t\t\t\tind.equal( 0.0 ),\n\t\t\t\t\t\tind.equal( 1.0 ),\n\t\t\t\t\t\tind.equal( 2.0 )\n\t\t\t\t\t).mul( 3.0 );\n\n\t\t\t\t\tconst subCoordOffset = fract( subCoord.add( cellOffset ) );\n\t\t\t\t\tlet cellUV = subCoordOffset.mul( 2.0 );\n\t\t\t\t\tcellUV = cellUV.sub( 1.0 );\n\n\t\t\t\t\tconst border = float( 1.0 ).sub(\n\t\t\t\t\t\tcellUV.mul( cellUV ).mul( borderMaskUniform )\n\t\t\t\t\t);\n\n\t\t\t\t\tconst clampX = clamp( border.x, 0.0, 1.0 );\n\t\t\t\t\tconst clampY = clamp( border.y, 0.0, 1.0 );\n\t\t\t\t\tconst borderClamp = clampX.mul( clampY );\n\t\t\t\t\tmaskColor = maskColor.mul( borderClamp );\n\n\t\t\t\t\tcolor = color.mul( maskColor );\n\n\t\t\t\t\tconst pixelDampen = pixel.y.div( pulseWidthUniform );\n\t\t\t\t\tlet pulse = sin( pixelDampen.add( time.mul( pulseRateUniform ) ) );\n\t\t\t\t\tpulse = pulse.mul( pulseIntensityUniform );\n\t\t\t\t\tcolor = color.mul( float( 1.0 ).add( pulse ) );\n\n\t\t\t\t\treturn color;\n\n\t\t\t\t} );\n\n\t\t\t\tconst tslShaderMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\ttslShaderMaterial.positionNode = tslVertexShader();\n\t\t\t\ttslShaderMaterial.colorNode = tslFragmentShader();\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 1 );\n\n\t\t\t\tconst wgslQuad = new THREE.Mesh( geometry, wgslShaderMaterial );\n\t\t\t\twgslQuad.position.y += 0.5;\n\t\t\t\tscene.add( wgslQuad );\n\n\t\t\t\tconst tslQuad = new THREE.Mesh( geometry, tslShaderMaterial );\n\t\t\t\ttslQuad.position.y -= 0.5;\n\t\t\t\tscene.add( tslQuad );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, canvas: canvas } );\n\t\t\t\trenderer.setPixelRatio( dpr );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.outputColorSpace = THREE.LinearSRGBColorSpace;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( cellSizeUniform, 'value', 6, 50, 1 ).name( 'Cell Size' );\n\t\t\t\tgui.add( cellOffsetUniform, 'value', 0, 1, 0.1 ).name( 'Cell Offset' );\n\t\t\t\tgui.add( borderMaskUniform, 'value', 0, 5, 0.1 ).name( 'Border Mask' );\n\t\t\t\tgui.add( pulseIntensityUniform, 'value', 0, 0.5, 0.01 ).name( 'Pulse Intensity' );\n\t\t\t\tgui.add( pulseWidthUniform, 'value', 10, 100, 5 ).name( 'Pulse Width' );\n\t\t\t\tgui.add( wgslShaderSpeedUniform, 'value', 1, 10 ).name( 'WGSL Shader Speed' );\n\t\t\t\tgui.add( tslShaderSpeedUniform, 'value', 1, 10 ).name( 'TSL Shader Speed' );\n\n\t\t\t}\n\n\t\t\tinit();\n```\n\nThis example three.js webgpu - wgsl/tsl node interoperability CRT Shader adapted from Xor ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - procedural terrain"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - procedural terrain:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { mx_noise_float, color, cross, dot, float, transformNormalToView, positionLocal, sign, step, Fn, uniform, varying, vec2, vec3, Loop } from 'three/tsl';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tlet camera, scene, renderer, controls, drag;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( - 10, 8, - 2.2 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x201919 );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t// environment\n\n\t\t\t\tconst rgbeLoader = new RGBELoader();\n\t\t\t\trgbeLoader.load( './textures/equirectangular/pedestrian_overpass_1k.hdr', ( environmentMap ) => {\n\n\t\t\t\t\tenvironmentMap.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\tscene.background = environmentMap;\n\t\t\t\t\tscene.backgroundBlurriness = 0.5;\n\t\t\t\t\tscene.environment = environmentMap;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\t// lights\n\t\t\t\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( '#ffffff', 2 );\n\t\t\t\tdirectionalLight.position.set( 6.25, 3, 4 );\n\t\t\t\tdirectionalLight.castShadow = true;\n\t\t\t\tdirectionalLight.shadow.mapSize.set( 1024, 1024 );\n\t\t\t\tdirectionalLight.shadow.camera.near = 0.1;\n\t\t\t\tdirectionalLight.shadow.camera.far = 30;\n\t\t\t\tdirectionalLight.shadow.camera.top = 8;\n\t\t\t\tdirectionalLight.shadow.camera.right = 8;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - 8;\n\t\t\t\tdirectionalLight.shadow.camera.left = - 8;\n\t\t\t\tdirectionalLight.shadow.normalBias = 0.05;\n\t\t\t\tdirectionalLight.shadow.bias = 0;\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// terrain\n\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( {\n\t\t\t\t\tmetalness: 0,\n\t\t\t\t\troughness: 0.5,\n\t\t\t\t\tcolor: '#85d534'\n\t\t\t\t} );\n\n\t\t\t\tconst noiseIterations = uniform( 3 );\n\t\t\t\tconst positionFrequency = uniform( 0.175 );\n\t\t\t\tconst warpFrequency = uniform( 6 );\n\t\t\t\tconst warpStrength = uniform( 1 );\n\t\t\t\tconst strength = uniform( 10 );\n\t\t\t\tconst offset = uniform( vec2( 0, 0 ) );\n\t\t\t\tconst normalLookUpShift = uniform( 0.01 );\n\t\t\t\tconst colorSand = uniform( color( '#ffe894' ) );\n\t\t\t\tconst colorGrass = uniform( color( '#85d534' ) );\n\t\t\t\tconst colorSnow = uniform( color( '#ffffff' ) );\n\t\t\t\tconst colorRock = uniform( color( '#bfbd8d' ) );\n\n\t\t\t\tconst vNormal = varying( vec3() );\n\t\t\t\tconst vPosition = varying( vec3() );\n\n\t\t\t\tconst terrainElevation = Fn( ( [ position ] ) => {\n\n\t\t\t\t\tconst warpedPosition = position.add( offset ).toVar();\n\t\t\t\t\twarpedPosition.addAssign( mx_noise_float( warpedPosition.mul( positionFrequency ).mul( warpFrequency ), 1, 0 ).mul( warpStrength ) );\n\t\t\t\n\t\t\t\t\tconst elevation = float( 0 ).toVar();\n\t\t\t\t\tLoop( { type: 'float', start: float( 1 ), end: noiseIterations.toFloat(), condition: '<=' }, ( { i } ) => {\n\n\t\t\t\t\t\tconst noiseInput = warpedPosition.mul( positionFrequency ).mul( i.mul( 2 ) ).add( i.mul( 987 ) );\n\t\t\t\t\t\tconst noise = mx_noise_float( noiseInput, 1, 0 ).div( i.add( 1 ).mul( 2 ) );\n\t\t\t\t\t\televation.addAssign( noise );\n\t\t\t\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst elevationSign = sign( elevation );\n\t\t\t\t\televation.assign( elevation.abs().pow( 2 ).mul( elevationSign ).mul( strength ) );\n\n\t\t\t\t\treturn elevation;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\tmaterial.positionNode = Fn( () => {\n\n\t\t\t\t\t// neighbours positions\n\n\t\t\t\t\tconst neighbourA = positionLocal.xyz.add( vec3( normalLookUpShift, 0.0, 0.0 ) ).toVar();\n\t\t\t\t\tconst neighbourB = positionLocal.xyz.add( vec3( 0.0, 0.0, normalLookUpShift.negate() ) ).toVar();\n\n\t\t\t\t\t// elevations\n\n\t\t\t\t\tconst position = positionLocal.xyz.toVar();\n\t\t\t\t\tconst elevation = terrainElevation( positionLocal.xz );\n\t\t\t\t\tposition.y.addAssign( elevation );\n\t\t\t\n\t\t\t\t\tneighbourA.y.addAssign( terrainElevation( neighbourA.xz ) );\n\t\t\t\t\tneighbourB.y.addAssign( terrainElevation( neighbourB.xz ) );\n\n\t\t\t\t\t// compute normal\n\n\t\t\t\t\tconst toA = neighbourA.sub( position ).normalize();\n\t\t\t\t\tconst toB = neighbourB.sub( position ).normalize();\n\t\t\t\t\tvNormal.assign( cross( toA, toB ) );\n\n\t\t\t\t\t// varyings\n\n\t\t\t\t\tvPosition.assign( position.add( vec3( offset.x, 0, offset.y ) ) );\n\n\t\t\t\t\treturn position;\n\t\t\t\n\t\t\t\t} )();\n\n\t\t\t\tmaterial.normalNode = transformNormalToView( vNormal );\n\n\t\t\t\tmaterial.colorNode = Fn( () => {\n\n\t\t\t\t\tconst finalColor = colorSand.toVar();\n\n\t\t\t\t\t// grass\n\n\t\t\t\t\tconst grassMix = step( - 0.06, vPosition.y );\n\t\t\t\t\tfinalColor.assign( grassMix.mix( finalColor, colorGrass ) );\n\n\t\t\t\t\t// rock\n\n\t\t\t\t\tconst rockMix = step( 0.5, dot( vNormal, vec3( 0, 1, 0 ) ) ).oneMinus().mul( step( - 0.06, vPosition.y ) );\n\t\t\t\t\tfinalColor.assign( rockMix.mix( finalColor, colorRock ) );\n\n\t\t\t\t\t// snow\n\n\t\t\t\t\tconst snowThreshold = mx_noise_float( vPosition.xz.mul( 25 ), 1, 0 ).mul( 0.1 ).add( 0.45 );\n\t\t\t\t\tconst snowMix = step( snowThreshold, vPosition.y );\n\t\t\t\t\tfinalColor.assign( snowMix.mix( finalColor, colorSnow ) );\n\n\t\t\t\t\treturn finalColor;\n\t\t\t\n\t\t\t\t} )();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 10, 10, 500, 500 );\n\t\t\t\tgeometry.deleteAttribute( 'uv' );\n\t\t\t\tgeometry.deleteAttribute( 'normal' );\n\t\t\t\tgeometry.rotateX( - Math.PI * 0.5 );\n\n\t\t\t\tconst terrain = new THREE.Mesh( geometry, material );\n\t\t\t\tterrain.receiveShadow = true;\n\t\t\t\tterrain.castShadow = true;\n\t\t\t\tscene.add( terrain );\n\n\t\t\t\t// debug\n\n\t\t\t\tconst terrainGui = gui.addFolder( '\ud83c\udfd4\ufe0f terrain' );\n\n\t\t\t\tterrainGui.add( noiseIterations, 'value', 0, 10, 1 ).name( 'noiseIterations' );\n\t\t\t\tterrainGui.add( positionFrequency, 'value', 0, 1, 0.001 ).name( 'positionFrequency' );\n\t\t\t\tterrainGui.add( strength, 'value', 0, 20, 0.001 ).name( 'strength' );\n\t\t\t\tterrainGui.add( warpFrequency, 'value', 0, 20, 0.001 ).name( 'warpFrequency' );\n\t\t\t\tterrainGui.add( warpStrength, 'value', 0, 2, 0.001 ).name( 'warpStrength' );\n\n\t\t\t\tterrainGui.addColor( { color: colorSand.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorSand' ).onChange( value => colorSand.value.set( value ) );\n\t\t\t\tterrainGui.addColor( { color: colorGrass.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorGrass' ).onChange( value => colorGrass.value.set( value ) );\n\t\t\t\tterrainGui.addColor( { color: colorSnow.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorSnow' ).onChange( value => colorSnow.value.set( value ) );\n\t\t\t\tterrainGui.addColor( { color: colorRock.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorRock' ).onChange( value => colorRock.value.set( value ) );\n\n\t\t\t\t// water\n\t\t\t\n\t\t\t\tconst water = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10, 10, 1, 1 ),\n\t\t\t\t\tnew THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\ttransmission: 1,\n\t\t\t\t\t\troughness: 0.5,\n\t\t\t\t\t\tior: 1.333,\n\t\t\t\t\t\tcolor: '#4db2ff'\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\twater.rotation.x = - Math.PI * 0.5;\n\t\t\t\twater.position.y = - 0.1;\n\t\t\t\tscene.add( water );\n\n\t\t\t\tconst waterGui = gui.addFolder( '\ud83d\udca7 water' );\n\n\t\t\t\twaterGui.add( water.material, 'roughness', 0, 1, 0.01 );\n\t\t\t\twaterGui.add( water.material, 'ior' ).min( 1 ).max( 2 ).step( 0.001 );\n\t\t\t\twaterGui.addColor( { color: water.material.color.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'color' ).onChange( value => water.material.color.set( value ) );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxPolarAngle = Math.PI * 0.45;\n\t\t\t\tcontrols.target.y = - 0.5;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\t// drag\n\n\t\t\t\tdrag = {};\n\t\t\t\tdrag.screenCoords = new THREE.Vector2();\n\t\t\t\tdrag.prevWorldCoords = new THREE.Vector3();\n\t\t\t\tdrag.worldCoords = new THREE.Vector3();\n\t\t\t\tdrag.raycaster = new THREE.Raycaster();\n\t\t\t\tdrag.down = false;\n\t\t\t\tdrag.hover = false;\n\n\t\t\t\tdrag.object = new THREE.Mesh( new THREE.PlaneGeometry( 10, 10, 1, 1 ), new THREE.MeshBasicMaterial() );\n\t\t\t\tdrag.object.rotation.x = - Math.PI * 0.5;\n\t\t\t\tdrag.object.visible = false;\n\t\t\t\tscene.add( drag.object );\n\n\t\t\t\tdrag.getIntersect = () => {\n\n\t\t\t\t\tdrag.raycaster.setFromCamera( drag.screenCoords, camera );\n\t\t\t\t\tconst intersects = drag.raycaster.intersectObject( drag.object );\n\t\t\t\t\tif ( intersects.length )\n\t\t\t\t\t\treturn intersects[ 0 ];\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t};\n\n\t\t\t\tdrag.update = () => {\n\n\t\t\t\t\tconst intersect = drag.getIntersect();\n\n\t\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\t\tdrag.hover = true;\n\n\t\t\t\t\t\tif ( ! drag.down )\n\t\t\t\t\t\t\trenderer.domElement.style.cursor = 'grab';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdrag.hover = false;\n\t\t\t\t\t\trenderer.domElement.style.cursor = 'default';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( drag.hover && drag.down ) {\n\n\t\t\t\t\t\tdrag.worldCoords.copy( intersect.point );\n\t\t\t\t\t\tconst delta = drag.prevWorldCoords.sub( drag.worldCoords );\n\n\t\t\t\t\t\toffset.value.x += delta.x;\n\t\t\t\t\t\toffset.value.y += delta.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdrag.prevWorldCoords.copy( drag.worldCoords );\n\n\t\t\t\t};\n\n\t\t\t\twindow.addEventListener( 'pointermove', ( event ) => {\n\n\t\t\t\t\tdrag.screenCoords.x = ( event.clientX / window.innerWidth - 0.5 ) * 2;\n\t\t\t\t\tdrag.screenCoords.y = - ( event.clientY / window.innerHeight - 0.5 ) * 2;\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'pointerdown', () => {\n\n\t\t\t\t\tif ( drag.hover ) {\n\n\t\t\t\t\t\trenderer.domElement.style.cursor = 'grabbing';\n\t\t\t\t\t\tcontrols.enabled = false;\n\t\t\t\t\t\tdrag.down = true;\n\t\t\t\t\t\tdrag.object.scale.setScalar( 10 );\n\n\t\t\t\t\t\tconst intersect = drag.getIntersect();\n\t\t\t\t\t\tdrag.prevWorldCoords.copy( intersect.point );\n\t\t\t\t\t\tdrag.worldCoords.copy( intersect.point );\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'pointerup', () => {\n\n\t\t\t\t\tdrag.down = false;\n\t\t\t\t\tcontrols.enabled = true;\n\t\t\t\t\tdrag.object.scale.setScalar( 1 );\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tdrag.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - procedural terrain Based on Three.js Journey lessons"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - raging sea"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - raging sea:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { float, mx_noise_float, Loop, color, positionLocal, sin, vec2, vec3, mul, time, uniform, Fn, transformNormalToView } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 1.25, 1.25, 1.25 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// lights\n\t\t\t\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( '#ffffff', 3 );\n\t\t\t\tdirectionalLight.position.set( - 4, 2, 0 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// material\n\n\t\t\t\tconst material = new THREE.MeshStandardNodeMaterial( { color: '#271442', roughness: 0.15 } );\n\n\t\t\t\tconst emissiveColor = uniform( color( '#ff0a81' ) );\n\t\t\t\tconst emissiveLow = uniform( - 0.25 );\n\t\t\t\tconst emissiveHigh = uniform( 0.2 );\n\t\t\t\tconst emissivePower = uniform( 7 );\n\t\t\t\tconst largeWavesFrequency = uniform( vec2( 3, 1 ) );\n\t\t\t\tconst largeWavesSpeed = uniform( 1.25 );\n\t\t\t\tconst largeWavesMultiplier = uniform( 0.15 );\n\t\t\t\tconst smallWavesIterations = uniform( 3 );\n\t\t\t\tconst smallWavesFrequency = uniform( 2 );\n\t\t\t\tconst smallWavesSpeed = uniform( 0.3 );\n\t\t\t\tconst smallWavesMultiplier = uniform( 0.18 );\n\t\t\t\tconst normalComputeShift = uniform( 0.01 );\n\n\t\t\t\t// TSL functions\n\n\t\t\t\tconst wavesElevation = Fn( ( [ position ] ) => {\n\n\t\t\t\t\t// large waves\n\n\t\t\t\t\tconst elevation = mul(\n\t\t\t\t\t\tsin( position.x.mul( largeWavesFrequency.x ).add( time.mul( largeWavesSpeed ) ) ),\n\t\t\t\t\t\tsin( position.z.mul( largeWavesFrequency.y ).add( time.mul( largeWavesSpeed ) ) ),\n\t\t\t\t\t\tlargeWavesMultiplier\n\t\t\t\t\t).toVar();\n\n\t\t\t\t\tLoop( { start: float( 1 ), end: smallWavesIterations.add( 1 ) }, ( { i } ) => {\n\n\t\t\t\t\t\tconst noiseInput = vec3(\n\t\t\t\t\t\t\tposition.xz\n\t\t\t\t\t\t\t\t.add( 2 ) // avoids a-hole pattern\n\t\t\t\t\t\t\t\t.mul( smallWavesFrequency )\n\t\t\t\t\t\t\t\t.mul( i ),\n\t\t\t\t\t\t\ttime.mul( smallWavesSpeed )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst wave = mx_noise_float( noiseInput, 1, 0 )\n\t\t\t\t\t\t\t.mul( smallWavesMultiplier )\n\t\t\t\t\t\t\t.div( i )\n\t\t\t\t\t\t\t.abs();\n\n\t\t\t\t\t\televation.subAssign( wave );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn elevation;\n\n\t\t\t\t} );\n\n\t\t\t\t// position\n\n\t\t\t\tconst elevation = wavesElevation( positionLocal );\n\t\t\t\tconst position = positionLocal.add( vec3( 0, elevation, 0 ) );\n\n\t\t\t\tmaterial.positionNode = position;\n\n\t\t\t\t// normals\n\n\t\t\t\tlet positionA = positionLocal.add( vec3( normalComputeShift, 0, 0 ) );\n\t\t\t\tlet positionB = positionLocal.add( vec3( 0, 0, normalComputeShift.negate() ) );\n\n\t\t\t\tpositionA = positionA.add( vec3( 0, wavesElevation( positionA ), 0 ) );\n\t\t\t\tpositionB = positionB.add( vec3( 0, wavesElevation( positionB ), 0 ) );\n\n\t\t\t\tconst toA = positionA.sub( position ).normalize();\n\t\t\t\tconst toB = positionB.sub( position ).normalize();\n\t\t\t\tconst normal = toA.cross( toB );\n\n\t\t\t\tmaterial.normalNode = transformNormalToView( normal );\n\n\t\t\t\t// emissive\n\n\t\t\t\tconst emissive = elevation.remap( emissiveHigh, emissiveLow ).pow( emissivePower );\n\t\t\t\tmaterial.emissiveNode = emissiveColor.mul( emissive );\n\n\t\t\t\t// mesh\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2, 256, 256 );\n\t\t\t\tgeometry.rotateX( - Math.PI * 0.5 );\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// debug\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( { color: material.color.getHex( THREE.SRGBColorSpace ) }, 'color' ).name( 'color' ).onChange( value => material.color.set( value ) );\n\t\t\t\tgui.add( material, 'roughness', 0, 1, 0.001 );\n\n\t\t\t\tconst colorGui = gui.addFolder( 'emissive' );\n\t\t\t\tcolorGui.addColor( { color: emissiveColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' ).name( 'color' ).onChange( value => emissiveColor.value.set( value ) );\n\t\t\t\tcolorGui.add( emissiveLow, 'value', - 1, 0, 0.001 ).name( 'low' );\n\t\t\t\tcolorGui.add( emissiveHigh, 'value', 0, 1, 0.001 ).name( 'high' );\n\t\t\t\tcolorGui.add( emissivePower, 'value', 1, 10, 1 ).name( 'power' );\n\n\t\t\t\tconst wavesGui = gui.addFolder( 'waves' );\n\t\t\t\twavesGui.add( largeWavesSpeed, 'value', 0, 5 ).name( 'largeSpeed' );\n\t\t\t\twavesGui.add( largeWavesMultiplier, 'value', 0, 1 ).name( 'largeMultiplier' );\n\t\t\t\twavesGui.add( largeWavesFrequency.value, 'x', 0, 10 ).name( 'largeFrequencyX' );\n\t\t\t\twavesGui.add( largeWavesFrequency.value, 'y', 0, 10 ).name( 'largeFrequencyY' );\n\t\t\t\twavesGui.add( smallWavesIterations, 'value', 0, 5, 1 ).name( 'smallIterations' );\n\t\t\t\twavesGui.add( smallWavesFrequency, 'value', 0, 10 ).name( 'smallFrequency' );\n\t\t\t\twavesGui.add( smallWavesSpeed, 'value', 0, 1 ).name( 'smallSpeed' );\n\t\t\t\twavesGui.add( smallWavesMultiplier, 'value', 0, 1 ).name( 'smallMultiplier' );\n\t\t\t\twavesGui.add( normalComputeShift, 'value', 0, 0.1, 0.0001 ).name( 'normalComputeShift' );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.y = - 0.25;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\t\t\t\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - raging sea Based on Three.js Journey lesson"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - webgpu - tsl transpiler"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - webgpu - tsl transpiler:\n\n```javascript\nimport Transpiler from 'three/addons/transpiler/Transpiler.js';\n\t\t\timport GLSLDecoder from 'three/addons/transpiler/GLSLDecoder.js';\n\t\t\timport TSLEncoder from 'three/addons/transpiler/TSLEncoder.js';\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\t// editor\n\n\t\t\t\twindow.require.config( { paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } } );\n\n\t\t\t\trequire( [ 'vs/editor/editor.main' ], () => {\n\n\t\t\t\t\tlet timeout = null;\n\n\t\t\t\t\tconst editorDOM = document.getElementById( 'source' );\n\t\t\t\t\tconst resultDOM = document.getElementById( 'result' );\n\n\t\t\t\t\tconst glslCode = `// Put here your GLSL code to transpile to TSL:\n\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n`;\n\n\t\t\t\t\tconst editor = window.monaco.editor.create( editorDOM, {\n\t\t\t\t\t\tvalue: glslCode,\n\t\t\t\t\t\tlanguage: 'glsl',\n\t\t\t\t\t\ttheme: 'vs-dark',\n\t\t\t\t\t\tautomaticLayout: true,\n\t\t\t\t\t\tminimap: { enabled: false }\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst result = window.monaco.editor.create( resultDOM, {\n\t\t\t\t\t\tvalue: '',\n\t\t\t\t\t\tlanguage: 'javascript',\n\t\t\t\t\t\ttheme: 'vs-dark',\n\t\t\t\t\t\tautomaticLayout: true,\n\t\t\t\t\t\treadOnly: true,\n\t\t\t\t\t\tminimap: { enabled: false }\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst showCode = ( code ) => {\n\n\t\t\t\t\t\tresult.setValue( code );\n\t\t\t\t\t\tresult.revealLine( 1 );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tconst build = () => {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tconst glsl = editor.getValue();\n\n\t\t\t\t\t\t\tconst decoder = new GLSLDecoder();\n\t\t\t\t\t\t\tconst encoder = new TSLEncoder();\n\n\t\t\t\t\t\t\tconst transpiler = new Transpiler( decoder, encoder );\n\t\t\t\t\t\t\tconst tsl = transpiler.parse( glsl );\n\n\t\t\t\t\t\t\tshowCode( tsl );\n\n\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\tresult.setValue( 'Error: ' + e.message );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tbuild();\n\n\t\t\t\t\teditor.getModel().onDidChangeContent( () => {\n\n\t\t\t\t\t\tif ( timeout ) clearTimeout( timeout );\n\n\t\t\t\t\t\ttimeout = setTimeout( build, 1000 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - vfx flames"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - vfx flames:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { PI2, oneMinus, spherizeUV, sin, step, texture, time, Fn, uv, vec2, vec3, vec4, mix, billboarding } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 1, 1, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x201919 );\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst cellularTexture = textureLoader.load( './textures/noises/voronoi/grayscale-256x256.png' );\n\t\t\t\tconst perlinTexture = textureLoader.load( './textures/noises/perlin/rgb-256x256.png' );\n\n\t\t\t\t// gradient canvas\n\n\t\t\t\tconst gradient = {};\n\t\t\t\tgradient.element = document.createElement( 'canvas' );\n\t\t\t\tgradient.element.width = 128;\n\t\t\t\tgradient.element.height = 1;\n\t\t\t\tgradient.context = gradient.element.getContext( '2d' );\n\n\t\t\t\tgradient.colors = [\n\t\t\t\t\t'#090033',\n\t\t\t\t\t'#5f1f93',\n\t\t\t\t\t'#e02e96',\n\t\t\t\t\t'#ffbd80',\n\t\t\t\t\t'#fff0db',\n\t\t\t\t];\n\n\t\t\t\tgradient.texture = new THREE.CanvasTexture( gradient.element );\n\t\t\t\tgradient.texture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tgradient.update = () => {\n\n\t\t\t\t\tconst fillGradient = gradient.context.createLinearGradient( 0, 0, gradient.element.width, 0 );\n\n\t\t\t\t\tfor ( let i = 0; i < gradient.colors.length; i ++ ) {\n\n\t\t\t\t\t\tconst progress = i / ( gradient.colors.length - 1 );\n\t\t\t\t\t\tconst color = gradient.colors[ i ];\n\t\t\t\t\t\tfillGradient.addColorStop( progress, color );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgradient.context.fillStyle = fillGradient;\n\t\t\t\t\tgradient.context.fillRect( 0, 0, gradient.element.width, gradient.element.height );\n\n\t\t\t\t\tgradient.texture.needsUpdate = true;\n\n\t\t\t\t};\n\n\t\t\t\tgradient.update();\n\n\t\t\t\t// flame 1 material\n\n\t\t\t\tconst flame1Material = new THREE.SpriteNodeMaterial( { side: THREE.DoubleSide } );\n\n\t\t\t\tflame1Material.colorNode = Fn( () => {\n\n\t\t\t\t\t// main UV\n\t\t\t\t\tconst mainUv = uv().toVar();\n\t\t\t\t\tmainUv.assign( spherizeUV( mainUv, 10 ).mul( 0.6 ).add( 0.2 ) ); // spherize\n\t\t\t\t\tmainUv.assign( mainUv.pow( vec2( 1, 2 ) ) ); // stretch\n\t\t\t\t\tmainUv.assign( mainUv.mul( 2, 1 ).sub( vec2( 0.5, 0 ) ) ); // scale\n\n\t\t\t\t\t// gradients\n\t\t\t\t\tconst gradient1 = sin( time.mul( 10 ).sub( mainUv.y.mul( PI2 ).mul( 2 ) ) ).toVar();\n\t\t\t\t\tconst gradient2 = mainUv.y.smoothstep( 0, 1 ).toVar();\n\t\t\t\t\tmainUv.x.addAssign( gradient1.mul( gradient2 ).mul( 0.2 ) );\n\n\t\t\t\t\t// cellular noise\n\t\t\t\t\tconst cellularUv = mainUv.mul( 0.5 ).add( vec2( 0, time.negate().mul( 0.5 ) ) ).mod( 1 );\n\t\t\t\t\tconst cellularNoise = texture( cellularTexture, cellularUv, 0 ).r.oneMinus().smoothstep( 0, 0.5 ).oneMinus();\n\t\t\t\t\tcellularNoise.mulAssign( gradient2 );\n\n\t\t\t\t\t// shape\n\t\t\t\t\tconst shape = mainUv.sub( 0.5 ).mul( vec2( 3, 2 ) ).length().oneMinus().toVar();\n\t\t\t\t\tshape.assign( shape.sub( cellularNoise ) );\n\n\t\t\t\t\t// gradient color\n\t\t\t\t\tconst gradientColor = texture( gradient.texture, vec2( shape.remap( 0, 1, 0, 1 ), 0 ) );\n\n\t\t\t\t\t// output\n\t\t\t\t\tconst color = mix( gradientColor, vec3( 1 ), shape.step( 0.8 ) );\n\t\t\t\t\tconst alpha = shape.smoothstep( 0, 0.3 );\n\t\t\t\t\treturn vec4( color.rgb, alpha );\n\n\t\t\t\t} )();\n\n\t\t\t\t// flame 2 material\n\n\t\t\t\tconst flame2Material = new THREE.SpriteNodeMaterial( { side: THREE.DoubleSide } );\n\n\t\t\t\tflame2Material.colorNode = Fn( () => {\n\n\t\t\t\t\t// main UV\n\t\t\t\t\tconst mainUv = uv().toVar();\n\t\t\t\t\tmainUv.assign( spherizeUV( mainUv, 10 ).mul( 0.6 ).add( 0.2 ) ); // spherize\n\t\t\t\t\tmainUv.assign( mainUv.pow( vec2( 1, 3 ) ) ); // stretch\n\t\t\t\t\tmainUv.assign( mainUv.mul( 2, 1 ).sub( vec2( 0.5, 0 ) ) ); // scale\n\n\t\t\t\t\t// perlin noise\n\t\t\t\t\tconst perlinUv = mainUv.add( vec2( 0, time.negate().mul( 1 ) ) ).mod( 1 );\n\t\t\t\t\tconst perlinNoise = texture( perlinTexture, perlinUv, 0 ).sub( 0.5 ).mul( 1 );\n\t\t\t\t\tmainUv.x.addAssign( perlinNoise.x.mul( 0.5 ) );\n\n\t\t\t\t\t// gradients\n\t\t\t\t\tconst gradient1 = sin( time.mul( 10 ).sub( mainUv.y.mul( PI2 ).mul( 2 ) ) );\n\t\t\t\t\tconst gradient2 = mainUv.y.smoothstep( 0, 1 );\n\t\t\t\t\tconst gradient3 = oneMinus( mainUv.y ).smoothstep( 0, 0.3 );\n\t\t\t\t\tmainUv.x.addAssign( gradient1.mul( gradient2 ).mul( 0.2 ) );\n\n\t\t\t\t\t// displaced perlin noise\n\t\t\t\t\tconst displacementPerlinUv = mainUv.mul( 0.5 ).add( vec2( 0, time.negate().mul( 0.25 ) ) ).mod( 1 );\n\t\t\t\t\tconst displacementPerlinNoise = texture( perlinTexture, displacementPerlinUv, 0 ).sub( 0.5 ).mul( 1 );\n\t\t\t\t\tconst displacedPerlinUv = mainUv.add( vec2( 0, time.negate().mul( 0.5 ) ) ).add( displacementPerlinNoise ).mod( 1 );\n\t\t\t\t\tconst displacedPerlinNoise = texture( perlinTexture, displacedPerlinUv, 0 ).sub( 0.5 ).mul( 1 );\n\t\t\t\t\tmainUv.x.addAssign( displacedPerlinNoise.mul( 0.5 ) );\n\n\t\t\t\t\t// cellular noise\n\t\t\t\t\tconst cellularUv = mainUv.add( vec2( 0, time.negate().mul( 1.5 ) ) ).mod( 1 );\n\t\t\t\t\tconst cellularNoise = texture( cellularTexture, cellularUv, 0 ).r.oneMinus().smoothstep( 0.25, 1 );\n\n\t\t\t\t\t// shape\n\t\t\t\t\tconst shape = step( mainUv.sub( 0.5 ).mul( vec2( 6, 1 ) ).length(), 0.5 );\n\t\t\t\t\tshape.assign( shape.mul( cellularNoise ) );\n\t\t\t\t\tshape.mulAssign( gradient3 );\n\t\t\t\t\tshape.assign( step( 0.01, shape ) );\n\n\t\t\t\t\t// output\n\t\t\t\t\treturn vec4( vec3( 1 ), shape );\n\n\t\t\t\t} )();\n\n\t\t\t\t// billboarding - follow the camera rotation only horizontally\n\n\t\t\t\tflame1Material.vertexNode = billboarding();\n\t\t\t\tflame2Material.vertexNode = billboarding();\n\n\t\t\t\t// meshes\n\n\t\t\t\tconst flame1 = new THREE.Sprite( flame1Material );\n\t\t\t\tflame1.center.set( 0.5, 0 );\n\t\t\t\tflame1.scale.x = 0.5; // optional\n\t\t\t\tflame1.position.x = - 0.5;\n\t\t\t\tscene.add( flame1 );\n\n\t\t\t\tconst flame2 = new THREE.Sprite( flame2Material );\n\t\t\t\tflame2.center.set( 0.5, 0 );\n\t\t\t\tflame2.position.x = 0.5;\n\t\t\t\tscene.add( flame2 );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - vfx flames Inspired by @cmzw_"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - VFX Linked particles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - VFX Linked particles:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { atan, cos, float, max, min, mix, PI, PI2, sin, vec2, vec3, color, Fn, hash, hue, If, instanceIndex, Loop, mx_fractal_noise_float, mx_fractal_noise_vec3, pass, pcurve, storage, deltaTime, time, uv, uniform, step } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { Timer } from 'three/addons/misc/Timer.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport WebGPU from 'three/addons/capabilities/WebGPU.js';\n\n\t\t\tlet camera, scene, renderer, postProcessing, controls, timer, light;\n\n\t\t\tlet updateParticles, spawnParticles; // TSL compute nodes\n\t\t\tlet getInstanceColor; // TSL function\n\n\t\t\tconst screenPointer = new THREE.Vector2();\n\t\t\tconst scenePointer = new THREE.Vector3();\n\t\t\tconst raycastPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 0 );\n\t\t\tconst raycaster = new THREE.Raycaster();\n\n\t\t\tconst nbParticles = Math.pow( 2, 13 );\n\n\t\t\tconst timeScale = uniform( 1.0 );\n\t\t\tconst particleLifetime = uniform( 0.5 );\n\t\t\tconst particleSize = uniform( 1.0 );\n\t\t\tconst linksWidth = uniform( 0.005 );\n\n\t\t\tconst colorOffset = uniform( 0.0 );\n\t\t\tconst colorVariance = uniform( 2.0 );\n\t\t\tconst colorRotationSpeed = uniform( 1.0 );\n\n\t\t\tconst spawnIndex = uniform( 0 );\n\t\t\tconst nbToSpawn = uniform( 5 );\n\t\t\tconst spawnPosition = uniform( vec3( 0.0 ) );\n\t\t\tconst previousSpawnPosition = uniform( vec3( 0.0 ) );\n\n\t\t\tconst turbFrequency = uniform( 0.5 );\n\t\t\tconst turbAmplitude = uniform( 0.5 );\n\t\t\tconst turbOctaves = uniform( 2 );\n\t\t\tconst turbLacunarity = uniform( 2.0 );\n\t\t\tconst turbGain = uniform( 0.5 );\n\t\t\tconst turbFriction = uniform( 0.01 );\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tif ( WebGPU.isAvailable() === false ) {\n\n\t\t\t\t\tdocument.body.appendChild( WebGPU.getErrorMessage() );\n\n\t\t\t\t\tthrow new Error( 'No WebGPU support' );\n\n\t\t\t\t}\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 200 );\n\t\t\t\tcamera.position.set( 0, 0, 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\ttimer = new Timer();\n\t\t\t\ttimer.connect( document );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setClearColor( 0x14171a );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// TSL function\n\t\t\t\t// current color from index\n\t\t\t\tgetInstanceColor = /*#__PURE__*/ Fn( ( [ i ] ) => {\n\n\t\t\t\t\treturn hue( color( 0x0000ff ), colorOffset.add( mx_fractal_noise_float( i.toFloat().mul( .1 ), 2, 2.0, 0.5, colorVariance ) ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// Particles\n\t\t\t\t// storage buffers\n\t\t\t\tconst particlePositions = storage( new THREE.StorageInstancedBufferAttribute( nbParticles, 4 ), 'vec4', nbParticles );\n\t\t\t\tconst particleVelocities = storage( new THREE.StorageInstancedBufferAttribute( nbParticles, 4 ), 'vec4', nbParticles );\n\n\t\t\t\t// init particles buffers\n\t\t\t\trenderer.computeAsync( /*#__PURE__*/ Fn( () => {\n\n\t\t\t\t\tparticlePositions.element( instanceIndex ).xyz.assign( vec3( 10000.0 ) );\n\t\t\t\t\tparticlePositions.element( instanceIndex ).w.assign( vec3( - 1.0 ) ); // life is stored in w component; x<0 means dead\n\n\t\t\t\t} )().compute( nbParticles ) );\n\n\t\t\t\t// particles output\n\t\t\t\tconst particleQuadSize = 0.05;\n\t\t\t\tconst particleGeom = new THREE.PlaneGeometry( particleQuadSize, particleQuadSize );\n\n\t\t\t\tconst particleMaterial = new THREE.SpriteNodeMaterial();\n\t\t\t\tparticleMaterial.blending = THREE.AdditiveBlending;\n\t\t\t\tparticleMaterial.depthWrite = false;\n\t\t\t\tparticleMaterial.positionNode = particlePositions.toAttribute();\n\t\t\t\tparticleMaterial.scaleNode = vec2( particleSize );\n\t\t\t\tparticleMaterial.rotationNode = atan( particleVelocities.toAttribute().y, particleVelocities.toAttribute().x );\n\n\t\t\t\tparticleMaterial.colorNode = /*#__PURE__*/ Fn( () => {\n\n\t\t\t\t\tconst life = particlePositions.toAttribute().w;\n\t\t\t\t\tconst modLife = pcurve( life.oneMinus(), 8.0, 1.0 );\n\t\t\t\t\tconst pulse = pcurve(\n\t\t\t\t\t\tsin( hash( instanceIndex ).mul( PI2 ).add( time.mul( 0.5 ).mul( PI2 ) ) ).mul( 0.5 ).add( 0.5 ),\n\t\t\t\t\t\t0.25,\n\t\t\t\t\t\t0.25\n\t\t\t\t\t).mul( 10.0 ).add( 1.0 );\n\n\t\t\t\t\treturn getInstanceColor( instanceIndex ).mul( pulse.mul( modLife ) );\n\n\t\t\t\t} )();\n\n\t\t\t\tparticleMaterial.opacityNode = /*#__PURE__*/ Fn( () => {\n\n\t\t\t\t\tconst circle = step( uv().xy.sub( 0.5 ).length(), 0.5 );\n\t\t\t\t\tconst life = particlePositions.toAttribute().w;\n\n\t\t\t\t\treturn circle.mul( life );\n\n\t\t\t\t} )();\n\n\t\t\t\tconst particleMesh = new THREE.InstancedMesh( particleGeom, particleMaterial, nbParticles );\n\t\t\t\tparticleMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\tparticleMesh.frustumCulled = false;\n\n\t\t\t\tscene.add( particleMesh );\n\n\t\t\t\t// Links between particles\n\t\t\t\t// first, we define the indices for the links, 2 quads per particle, the indexation is fixed\n\t\t\t\tconst linksIndices = [];\n\t\t\t\tfor ( let i = 0; i < nbParticles; i ++ ) {\n\n\t\t\t\t\tconst baseIndex = i * 8;\n\t\t\t\t\tfor ( let j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\t\tconst offset = baseIndex + j * 4;\n\t\t\t\t\t\tlinksIndices.push( offset, offset + 1, offset + 2, offset, offset + 2, offset + 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// storage buffers attributes for the links\n\t\t\t\tconst nbVertices = nbParticles * 8;\n\t\t\t\tconst linksVerticesSBA = new THREE.StorageBufferAttribute( nbVertices, 4 );\n\t\t\t\tconst linksColorsSBA = new THREE.StorageBufferAttribute( nbVertices, 4 );\n\n\t\t\t\t// links output\n\t\t\t\tconst linksGeom = new THREE.BufferGeometry();\n\t\t\t\tlinksGeom.setAttribute( 'position', linksVerticesSBA );\n\t\t\t\tlinksGeom.setAttribute( 'color', linksColorsSBA );\n\t\t\t\tlinksGeom.setIndex( linksIndices );\n\n\t\t\t\tconst linksMaterial = new THREE.MeshBasicNodeMaterial();\n\t\t\t\tlinksMaterial.vertexColors = true;\n\t\t\t\tlinksMaterial.side = THREE.DoubleSide;\n\t\t\t\tlinksMaterial.transparent = true;\n\t\t\t\tlinksMaterial.depthWrite = false;\n\t\t\t\tlinksMaterial.depthTest = false;\n\t\t\t\tlinksMaterial.blending = THREE.AdditiveBlending;\n\t\t\t\tlinksMaterial.opacityNode = storage( linksColorsSBA, 'vec4', linksColorsSBA.count ).toAttribute().w;\n\n\t\t\t\tconst linksMesh = new THREE.Mesh( linksGeom, linksMaterial );\n\t\t\t\tlinksMesh.frustumCulled = false;\n\t\t\t\tscene.add( linksMesh );\n\n\t\t\t\t// compute nodes\n\t\t\t\tupdateParticles = /*#__PURE__*/ Fn( () => {\n\n\t\t\t\t\tconst position = particlePositions.element( instanceIndex ).xyz;\n\t\t\t\t\tconst life = particlePositions.element( instanceIndex ).w;\n\t\t\t\t\tconst velocity = particleVelocities.element( instanceIndex ).xyz;\n\t\t\t\t\tconst dt = deltaTime.mul( 0.1 ).mul( timeScale );\n\n\t\t\t\t\tIf( life.greaterThan( 0.0 ), () => {\n\n\t\t\t\t\t\t// first we update the particles positions and velocities\n\t\t\t\t\t\t// velocity comes from a turbulence field, and is multiplied by the particle lifetime so that it slows down over time\n\t\t\t\t\t\tconst localVel = mx_fractal_noise_vec3( position.mul( turbFrequency ), turbOctaves, turbLacunarity, turbGain, turbAmplitude ).mul( life.add( .01 ) );\n\t\t\t\t\t\tvelocity.addAssign( localVel );\n\t\t\t\t\t\tvelocity.mulAssign( turbFriction.oneMinus() );\n\t\t\t\t\t\tposition.addAssign( velocity.mul( dt ) );\n\n\t\t\t\t\t\t// then we decrease the lifetime\n\t\t\t\t\t\tlife.subAssign( dt.mul( particleLifetime.reciprocal() ) );\n\n\t\t\t\t\t\t// then we find the two closest particles and set a quad to each of them\n\t\t\t\t\t\tconst closestDist1 = float( 10000.0 ).toVar();\n\t\t\t\t\t\tconst closestPos1 = vec3( 0.0 ).toVar();\n\t\t\t\t\t\tconst closestLife1 = float( 0.0 ).toVar();\n\t\t\t\t\t\tconst closestDist2 = float( 10000.0 ).toVar();\n\t\t\t\t\t\tconst closestPos2 = vec3( 0.0 ).toVar();\n\t\t\t\t\t\tconst closestLife2 = float( 0.0 ).toVar();\n\n\t\t\t\t\t\tLoop( nbParticles, ( { i } ) => {\n\n\t\t\t\t\t\t\tconst otherPart = particlePositions.element( i );\n\n\t\t\t\t\t\t\tIf( i.notEqual( instanceIndex ).and( otherPart.w.greaterThan( 0.0 ) ), () => { // if not self and other particle is alive\n\n\t\t\t\t\t\t\t\tconst otherPosition = otherPart.xyz;\n\t\t\t\t\t\t\t\tconst dist = position.sub( otherPosition ).lengthSq();\n\t\t\t\t\t\t\t\tconst moreThanZero = dist.greaterThan( 0.0 );\n\n\t\t\t\t\t\t\t\tIf( dist.lessThan( closestDist1 ).and( moreThanZero ), () => {\n\n\t\t\t\t\t\t\t\t\tclosestDist1.assign( dist );\n\t\t\t\t\t\t\t\t\tclosestPos1.assign( otherPosition.xyz );\n\t\t\t\t\t\t\t\t\tclosestLife1.assign( otherPart.w );\n\n\t\t\t\t\t\t\t\t} ).ElseIf( dist.lessThan( closestDist2 ).and( moreThanZero ), () => {\n\n\t\t\t\t\t\t\t\t\tclosestDist2.assign( dist );\n\t\t\t\t\t\t\t\t\tclosestPos2.assign( otherPosition.xyz );\n\t\t\t\t\t\t\t\t\tclosestLife2.assign( otherPart.w );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// then we update the links correspondingly\n\t\t\t\t\t\tconst linksPositions = storage( linksVerticesSBA, 'vec4', linksVerticesSBA.count );\n\t\t\t\t\t\tconst linksColors = storage( linksColorsSBA, 'vec4', linksColorsSBA.count );\n\t\t\t\t\t\tconst firstLinkIndex = instanceIndex.mul( 8 );\n\t\t\t\t\t\tconst secondLinkIndex = firstLinkIndex.add( 4 );\n\n\t\t\t\t\t\t// positions link 1\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex ).xyz.assign( position );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex ).y.addAssign( linksWidth );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex.add( 1 ) ).xyz.assign( position );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex.add( 1 ) ).y.addAssign( linksWidth.negate() );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex.add( 2 ) ).xyz.assign( closestPos1 );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex.add( 2 ) ).y.addAssign( linksWidth.negate() );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex.add( 3 ) ).xyz.assign( closestPos1 );\n\t\t\t\t\t\tlinksPositions.element( firstLinkIndex.add( 3 ) ).y.addAssign( linksWidth );\n\n\t\t\t\t\t\t// positions link 2\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex ).xyz.assign( position );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex ).y.addAssign( linksWidth );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex.add( 1 ) ).xyz.assign( position );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex.add( 1 ) ).y.addAssign( linksWidth.negate() );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex.add( 2 ) ).xyz.assign( closestPos2 );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex.add( 2 ) ).y.addAssign( linksWidth.negate() );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex.add( 3 ) ).xyz.assign( closestPos2 );\n\t\t\t\t\t\tlinksPositions.element( secondLinkIndex.add( 3 ) ).y.addAssign( linksWidth );\n\n\t\t\t\t\t\t// colors are the same for all vertices of both quads\n\t\t\t\t\t\tconst linkColor = getInstanceColor( instanceIndex );\n\n\t\t\t\t\t\t// store the minimum lifetime of the closest particles in the w component of colors\n\t\t\t\t\t\tconst l1 = max( 0.0, min( closestLife1, life ) ).pow( 0.8 ); // pow is here to apply a slight curve to the opacity\n\t\t\t\t\t\tconst l2 = max( 0.0, min( closestLife2, life ) ).pow( 0.8 );\n\n\t\t\t\t\t\tLoop( 4, ( { i } ) => {\n\n\t\t\t\t\t\t\tlinksColors.element( firstLinkIndex.add( i ) ).xyz.assign( linkColor );\n\t\t\t\t\t\t\tlinksColors.element( firstLinkIndex.add( i ) ).w.assign( l1 );\n\t\t\t\t\t\t\tlinksColors.element( secondLinkIndex.add( i ) ).xyz.assign( linkColor );\n\t\t\t\t\t\t\tlinksColors.element( secondLinkIndex.add( i ) ).w.assign( l2 );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )().compute( nbParticles );\n\n\t\t\t\tspawnParticles = /*#__PURE__*/ Fn( () => {\n\n\t\t\t\t\tconst particleIndex = spawnIndex.add( instanceIndex ).mod( nbParticles ).toInt();\n\t\t\t\t\tconst position = particlePositions.element( particleIndex ).xyz;\n\t\t\t\t\tconst life = particlePositions.element( particleIndex ).w;\n\t\t\t\t\tconst velocity = particleVelocities.element( particleIndex ).xyz;\n\n\t\t\t\t\tlife.assign( 1.0 ); // sets it alive\n\n\t\t\t\t\t// random spherical direction\n\t\t\t\t\tconst rRange = float( 0.01 );\n\t\t\t\t\tconst rTheta = hash( particleIndex ).mul( PI2 );\n\t\t\t\t\tconst rPhi = hash( particleIndex.add( 1 ) ).mul( PI );\n\t\t\t\t\tconst rx = sin( rTheta ).mul( cos( rPhi ) );\n\t\t\t\t\tconst ry = sin( rTheta ).mul( sin( rPhi ) );\n\t\t\t\t\tconst rz = cos( rTheta );\n\t\t\t\t\tconst rDir = vec3( rx, ry, rz );\n\n\t\t\t\t\t// position is interpolated between the previous cursor position and the current one over the number of particles spawned\n\t\t\t\t\tconst pos = mix( previousSpawnPosition, spawnPosition, instanceIndex.toFloat().div( nbToSpawn.sub( 1 ).toFloat() ).clamp() );\n\t\t\t\t\tposition.assign( pos.add( rDir.mul( rRange ) ) );\n\n\t\t\t\t\t// start in that direction\n\t\t\t\t\tvelocity.assign( rDir.mul( 5.0 ) );\n\n\t\t\t\t} )().compute( nbToSpawn.value );\n\n\n\t\t\t\t// background , an inverted icosahedron\n\t\t\t\tconst backgroundGeom = new THREE.IcosahedronGeometry( 100, 5 ).applyMatrix4( new THREE.Matrix4().makeScale( - 1, 1, 1 ) );\n\t\t\t\tconst backgroundMaterial = new THREE.MeshStandardNodeMaterial();\n\t\t\t\tbackgroundMaterial.roughness = 0.4;\n\t\t\t\tbackgroundMaterial.metalness = 0.9;\n\t\t\t\tbackgroundMaterial.flatShading = true;\n\t\t\t\tbackgroundMaterial.colorNode = color( 0x0 );\n\n\t\t\t\tconst backgroundMesh = new THREE.Mesh( backgroundGeom, backgroundMaterial );\n\t\t\t\tscene.add( backgroundMesh );\n\n\t\t\t\t// light for the background\n\t\t\t\tlight = new THREE.PointLight( 0xffffff, 3000 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode( 'output' );\n\n\t\t\t\tconst bloomPass = bloom( scenePassColor, 0.75, 0.1, 0.5 );\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor.add( bloomPass );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.autoRotate = true;\n\t\t\t\tcontrols.maxDistance = 75;\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// pointer handling\n\n\t\t\t\twindow.addEventListener( 'pointermove', onPointerMove );\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( controls, 'autoRotate' ).name( 'Auto Rotate' );\n\t\t\t\tgui.add( controls, 'autoRotateSpeed', - 10.0, 10.0, 0.01 ).name( 'Auto Rotate Speed' );\n\n\t\t\t\tconst partFolder = gui.addFolder( 'Particles' );\n\t\t\t\tpartFolder.add( timeScale, 'value', 0.0, 4.0, 0.01 ).name( 'timeScale' );\n\t\t\t\tpartFolder.add( nbToSpawn, 'value', 1, 100, 1 ).name( 'Spawn rate' );\n\t\t\t\tpartFolder.add( particleSize, 'value', 0.01, 3.0, 0.01 ).name( 'Size' );\n\t\t\t\tpartFolder.add( particleLifetime, 'value', 0.01, 2.0, 0.01 ).name( 'Lifetime' );\n\t\t\t\tpartFolder.add( linksWidth, 'value', 0.001, 0.1, 0.001 ).name( 'Links width' );\n\t\t\t\tpartFolder.add( colorVariance, 'value', 0.0, 10.0, 0.01 ).name( 'Color variance' );\n\t\t\t\tpartFolder.add( colorRotationSpeed, 'value', 0.0, 5.0, 0.01 ).name( 'Color rotation speed' );\n\n\t\t\t\tconst turbFolder = gui.addFolder( 'Turbulence' );\n\t\t\t\tturbFolder.add( turbFriction, 'value', 0.0, 0.3, 0.01 ).name( 'Friction' );\n\t\t\t\tturbFolder.add( turbFrequency, 'value', 0.0, 1.0, 0.01 ).name( 'Frequency' );\n\t\t\t\tturbFolder.add( turbAmplitude, 'value', 0.0, 10.0, 0.01 ).name( 'Amplitude' );\n\t\t\t\tturbFolder.add( turbOctaves, 'value', 1, 9, 1 ).name( 'Octaves' );\n\t\t\t\tturbFolder.add( turbLacunarity, 'value', 1.0, 5.0, 0.01 ).name( 'Lacunarity' );\n\t\t\t\tturbFolder.add( turbGain, 'value', 0.0, 1.0, 0.01 ).name( 'Gain' );\n\n\t\t\t\tconst bloomFolder = gui.addFolder( 'bloom' );\n\t\t\t\tbloomFolder.add( bloomPass.threshold, 'value', 0, 2.0, 0.01 ).name( 'Threshold' );\n\t\t\t\tbloomFolder.add( bloomPass.strength, 'value', 0, 10, 0.01 ).name( 'Strength' );\n\t\t\t\tbloomFolder.add( bloomPass.radius, 'value', 0, 1, 0.01 ).name( 'Radius' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( e ) {\n\n\t\t\t\tscreenPointer.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\tscreenPointer.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t}\n\n\t\t\tfunction updatePointer() {\n\n\t\t\t\traycaster.setFromCamera( screenPointer, camera );\n\t\t\t\traycaster.ray.intersectPlane( raycastPlane, scenePointer );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\ttimer.update();\n\n\t\t\t\t// compute particles\n\t\t\t\trenderer.compute( updateParticles );\n\t\t\t\trenderer.compute( spawnParticles );\n\n\t\t\t\t// update particle index for next spawn\n\t\t\t\tspawnIndex.value = ( spawnIndex.value + nbToSpawn.value ) % nbParticles;\n\n\t\t\t\t// update raycast plane to face camera\n\t\t\t\traycastPlane.normal.applyEuler( camera.rotation );\n\t\t\t\tupdatePointer();\n\n\t\t\t\t// lerping spawn position\n\t\t\t\tpreviousSpawnPosition.value.copy( spawnPosition.value );\n\t\t\t\tspawnPosition.value.lerp( scenePointer, 0.1 );\n\n\t\t\t\t// rotating colors\n\t\t\t\tcolorOffset.value += timer.getDelta() * colorRotationSpeed.value * timeScale.value;\n\n\t\t\t\tconst elapsedTime = timer.getElapsed();\n\t\t\t\tlight.position.set(\n\t\t\t\t\tMath.sin( elapsedTime * 0.5 ) * 30,\n\t\t\t\t\tMath.cos( elapsedTime * 0.3 ) * 30,\n\t\t\t\t\tMath.sin( elapsedTime * 0.2 ) * 30,\n\t\t\t\t);\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - VFX Linked particles Based on this experiment by Christophe Choffel"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - VFX Tornado"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - VFX Tornado:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { luminance, cos, min, time, atan, uniform, pass, PI, PI2, color, positionLocal, sin, texture, Fn, uv, vec2, vec3, vec4 } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer, postProcessing, controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.set( 1, 1, 3 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// textures\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst perlinTexture = textureLoader.load( './textures/noises/perlin/rgb-256x256.png' );\n\t\t\t\tperlinTexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tperlinTexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// TSL functions\n\n\t\t\t\tconst toRadialUv = Fn( ( [ uv, multiplier, rotation, offset ] ) => {\n\n\t\t\t\t\tconst centeredUv = uv.sub( 0.5 ).toVar();\n\t\t\t\t\tconst distanceToCenter = centeredUv.length();\n\t\t\t\t\tconst angle = atan( centeredUv.y, centeredUv.x );\n\t\t\t\t\tconst radialUv = vec2( angle.add( PI ).div( PI2 ), distanceToCenter ).toVar();\n\t\t\t\t\tradialUv.mulAssign( multiplier );\n\t\t\t\t\tradialUv.x.addAssign( rotation );\n\t\t\t\t\tradialUv.y.addAssign( offset );\n\n\t\t\t\t\treturn radialUv;\n\n\t\t\t\t} );\n\n\t\t\t\tconst toSkewedUv = Fn( ( [ uv, skew ] ) => {\n\n\t\t\t\t\treturn vec2(\n\t\t\t\t\t\tuv.x.add( uv.y.mul( skew.x ) ),\n\t\t\t\t\t\tuv.y.add( uv.x.mul( skew.y ) )\n\t\t\t\t\t);\n\n\t\t\t\t} );\n\n\t\t\t\tconst twistedCylinder = Fn( ( [ position, parabolStrength, parabolOffset, parabolAmplitude, time ] ) => {\n\n\t\t\t\t\tconst angle = atan( position.z, position.x ).toVar();\n\t\t\t\t\tconst elevation = position.y;\n\n\t\t\t\t\t// parabol\n\t\t\t\t\tconst radius = parabolStrength.mul( position.y.sub( parabolOffset ) ).pow( 2 ).add( parabolAmplitude ).toVar();\n\n\t\t\t\t\t// turbulences\n\t\t\t\t\tradius.addAssign( sin( elevation.sub( time ).mul( 20 ).add( angle.mul( 2 ) ) ).mul( 0.05 ) );\n\n\t\t\t\t\tconst twistedPosition = vec3(\n\t\t\t\t\t\tcos( angle ).mul( radius ),\n\t\t\t\t\t\televation,\n\t\t\t\t\t\tsin( angle ).mul( radius )\n\t\t\t\t\t);\n\n\t\t\t\t\treturn twistedPosition;\n\n\t\t\t\t} );\n\n\t\t\t\t// uniforms\n\n\t\t\t\tconst emissiveColor = uniform( color( '#ff8b4d' ) );\n\t\t\t\tconst timeScale = uniform( 0.2 );\n\t\t\t\tconst parabolStrength = uniform( 1 );\n\t\t\t\tconst parabolOffset = uniform( 0.3 );\n\t\t\t\tconst parabolAmplitude = uniform( 0.2 );\n\n\t\t\t\t// tornado floor\n\n\t\t\t\tconst floorMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, wireframe: false } );\n\n\t\t\t\tfloorMaterial.outputNode = Fn( () => {\n\n\t\t\t\t\tconst scaledTime = time.mul( timeScale );\n\n\t\t\t\t\t// noise 1\n\t\t\t\t\tconst noise1Uv = toRadialUv(\n\t\t\t\t\t\tuv(),\n\t\t\t\t\t\tvec2( 0.5, 0.5 ),\n\t\t\t\t\t\tscaledTime,\n\t\t\t\t\t\tscaledTime\n\t\t\t\t\t);\n\t\t\t\t\tnoise1Uv.assign( toSkewedUv(\n\t\t\t\t\t\tnoise1Uv,\n\t\t\t\t\t\tvec2( - 1, 0 )\n\t\t\t\t\t) );\n\t\t\t\t\tnoise1Uv.mulAssign( vec2( 4, 1 ) );\n\t\t\t\t\tconst noise1 = texture( perlinTexture, noise1Uv, 1 ).r.remap( 0.45, 0.7 );\n\n\t\t\t\t\t// noise 2\n\t\t\t\t\tconst noise2Uv = toRadialUv(\n\t\t\t\t\t\tuv(),\n\t\t\t\t\t\tvec2( 2, 8 ),\n\t\t\t\t\t\tscaledTime.mul( 2 ),\n\t\t\t\t\t\tscaledTime.mul( 8 )\n\t\t\t\t\t);\n\t\t\t\t\tnoise2Uv.assign( toSkewedUv(\n\t\t\t\t\t\tnoise2Uv,\n\t\t\t\t\t\tvec2( - 0.25, 0 )\n\t\t\t\t\t) );\n\t\t\t\t\tnoise2Uv.mulAssign( vec2( 2, 0.25 ) );\n\t\t\t\t\tconst noise2 = texture( perlinTexture, noise2Uv, 1 ).b.remap( 0.45, 0.7 );\n\n\t\t\t\t\t// outer fade\n\t\t\t\t\tconst distanceToCenter = uv().sub( 0.5 ).toVar();\n\t\t\t\t\tconst outerFade = min(\n\t\t\t\t\t\tdistanceToCenter.length().oneMinus().smoothstep( 0.5, 0.9 ),\n\t\t\t\t\t\tdistanceToCenter.length().smoothstep( 0, 0.2 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// effect\n\t\t\t\t\tconst effect = noise1.mul( noise2 ).mul( outerFade ).toVar();\n\n\t\t\t\t\t// output\n\t\t\t\t\treturn vec4(\n\t\t\t\t\t\temissiveColor.mul( effect.step( 0.2 ) ).mul( 3 ), // Emissive\n\t\t\t\t\t\teffect.smoothstep( 0, 0.01 ) // Alpha\n\t\t\t\t\t);\n\n\t\t\t\t} )();\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI * 0.5;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// tornado cylinder geometry\n\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 1, 1, 1, 20, 20, true );\n\t\t\t\tcylinderGeometry.translate( 0, 0.5, 0 );\n\n\t\t\t\t// tornado emissive cylinder\n\n\t\t\t\tconst emissiveMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, side: THREE.DoubleSide, wireframe: false } );\n\n\t\t\t\temissiveMaterial.positionNode = twistedCylinder( positionLocal, parabolStrength, parabolOffset, parabolAmplitude.sub( 0.05 ), time.mul( timeScale ) );\n\n\t\t\t\temissiveMaterial.outputNode = Fn( () => {\n\n\t\t\t\t\tconst scaledTime = time.mul( timeScale );\n\n\t\t\t\t\t// noise 1\n\t\t\t\t\tconst noise1Uv = uv().add( vec2( scaledTime, scaledTime.negate() ) ).toVar();\n\t\t\t\t\tnoise1Uv.assign( toSkewedUv(\n\t\t\t\t\t\tnoise1Uv,\n\t\t\t\t\t\tvec2( - 1, 0 )\n\t\t\t\t\t) );\n\t\t\t\t\tnoise1Uv.mulAssign( vec2( 2, 0.25 ) );\n\t\t\t\t\tconst noise1 = texture( perlinTexture, noise1Uv, 1 ).r.remap( 0.45, 0.7 );\n\n\t\t\t\t\t// noise 2\n\t\t\t\t\tconst noise2Uv = uv().add( vec2( scaledTime.mul( 0.5 ), scaledTime.negate() ) ).toVar();\n\t\t\t\t\tnoise2Uv.assign( toSkewedUv(\n\t\t\t\t\t\tnoise2Uv,\n\t\t\t\t\t\tvec2( - 1, 0 )\n\t\t\t\t\t) );\n\t\t\t\t\tnoise2Uv.mulAssign( vec2( 5, 1 ) );\n\t\t\t\t\tconst noise2 = texture( perlinTexture, noise2Uv, 1 ).g.remap( 0.45, 0.7 );\n\n\t\t\t\t\t// outer fade\n\t\t\t\t\tconst outerFade = min(\n\t\t\t\t\t\tuv().y.smoothstep( 0, 0.1 ),\n\t\t\t\t\t\tuv().y.oneMinus().smoothstep( 0, 0.4 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// effect\n\t\t\t\t\tconst effect = noise1.mul( noise2 ).mul( outerFade );\n\n\t\t\t\t\tconst emissiveColorLuminance = luminance( emissiveColor );\n\n\t\t\t\t\t// output\n\t\t\t\t\treturn vec4(\n\t\t\t\t\t\temissiveColor.mul( 1.2 ).div( emissiveColorLuminance ), // emissive\n\t\t\t\t\t\teffect.smoothstep( 0, 0.1 ) // alpha\n\t\t\t\t\t);\n\n\t\t\t\t} )();\n\n\t\t\t\tconst emissive = new THREE.Mesh( cylinderGeometry, emissiveMaterial );\n\t\t\t\temissive.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( emissive );\n\n\t\t\t\t// tornado dark cylinder\n\n\t\t\t\tconst darkMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, side: THREE.DoubleSide, wireframe: false } );\n\n\t\t\t\tdarkMaterial.positionNode = twistedCylinder( positionLocal, parabolStrength, parabolOffset, parabolAmplitude, time.mul( timeScale ) );\n\n\t\t\t\tdarkMaterial.outputNode = Fn( () => {\n\n\t\t\t\t\tconst scaledTime = time.mul( timeScale ).add( 123.4 );\n\n\t\t\t\t\t// noise 1\n\t\t\t\t\tconst noise1Uv = uv().add( vec2( scaledTime, scaledTime.negate() ) ).toVar();\n\t\t\t\t\tnoise1Uv.assign( toSkewedUv(\n\t\t\t\t\t\tnoise1Uv,\n\t\t\t\t\t\tvec2( - 1, 0 )\n\t\t\t\t\t) );\n\t\t\t\t\tnoise1Uv.mulAssign( vec2( 2, 0.25 ) );\n\t\t\t\t\tconst noise1 = texture( perlinTexture, noise1Uv, 1 ).g.remap( 0.45, 0.7 );\n\n\t\t\t\t\t// noise 2\n\t\t\t\t\tconst noise2Uv = uv().add( vec2( scaledTime.mul( 0.5 ), scaledTime.negate() ) ).toVar();\n\t\t\t\t\tnoise2Uv.assign( toSkewedUv(\n\t\t\t\t\t\tnoise2Uv,\n\t\t\t\t\t\tvec2( - 1, 0 )\n\t\t\t\t\t) );\n\t\t\t\t\tnoise2Uv.mulAssign( vec2( 5, 1 ) );\n\t\t\t\t\tconst noise2 = texture( perlinTexture, noise2Uv, 1 ).b.remap( 0.45, 0.7 );\n\n\t\t\t\t\t// outer fade\n\t\t\t\t\tconst outerFade = min(\n\t\t\t\t\t\tuv().y.smoothstep( 0, 0.2 ),\n\t\t\t\t\t\tuv().y.oneMinus().smoothstep( 0, 0.4 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// effect\n\t\t\t\t\tconst effect = noise1.mul( noise2 ).mul( outerFade );\n\n\t\t\t\t\treturn vec4(\n\t\t\t\t\t\tvec3( 0 ),\n\t\t\t\t\t\teffect.smoothstep( 0, 0.01 )\n\t\t\t\t\t);\n\n\t\t\t\t} )();\n\n\t\t\t\tconst dark = new THREE.Mesh( cylinderGeometry, darkMaterial );\n\t\t\t\tdark.scale.set( 1, 1, 1 );\n\t\t\t\tscene.add( dark );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setClearColor( 0x201919 );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// post processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode( 'output' );\n\n\t\t\t\tconst bloomPass = bloom( scenePassColor, 1, 0.1, 1 );\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor.add( bloomPass );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.y = 0.4;\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.minDistance = 0.1;\n\t\t\t\tcontrols.maxDistance = 50;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// debug\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.addColor( { color: emissiveColor.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).onChange( value => emissiveColor.value.set( value ) ).name( 'emissiveColor' );\n\t\t\t\tgui.add( timeScale, 'value', - 1, 1, 0.01 ).name( 'timeScale' );\n\t\t\t\tgui.add( parabolStrength, 'value', 0, 2, 0.01 ).name( 'parabolStrength' );\n\t\t\t\tgui.add( parabolOffset, 'value', 0, 1, 0.01 ).name( 'parabolOffset' );\n\t\t\t\tgui.add( parabolAmplitude, 'value', 0, 2, 0.01 ).name( 'parabolAmplitude' );\n\n\t\t\t\tconst bloomGui = gui.addFolder( 'bloom' );\n\t\t\t\tbloomGui.add( bloomPass.strength, 'value', 0, 10, 0.01 ).name( 'strength' );\n\t\t\t\tbloomGui.add( bloomPass.radius, 'value', 0, 1, 0.01 ).name( 'radius' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - VFX Tornado Based on Three.js Journey lesson"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - video frames"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - video frames:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { MP4Demuxer } from 'three/addons/libs/demuxer_mp4.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .25, 10 );\n\t\t\t\tcamera.position.set( 0, 0, 1 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry();\n\n\t\t\t\tconst videoTexture = new THREE.VideoFrameTexture();\n\t\t\t\tvideoTexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// eslint-disable-next-line compat/compat\n\t\t\t\tconst decoder = new VideoDecoder( {\n\t\t\t\t\toutput( frame ) {\n\n\t\t\t\t\t\t// To avoid video decoder stalls, we should close the VideoFrame which is no longer needed. https://w3c.github.io/webcodecs/#dom-videodecoder-decode\n\t\t\t\t\t\tif ( videoTexture.image instanceof VideoFrame ) videoTexture.image.close();\n\n\t\t\t\t\t\tvideoTexture.setFrame( frame );\n\t\t\t\n\t\t\t\t\t},\n\t\t\t\t\terror( e ) {\n\n\t\t\t\t\t\tconsole.error( 'VideoDecoder:', e );\n\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tnew MP4Demuxer( './textures/sintel.mp4', {\n\t\t\t\t\tonConfig( config ) {\n\n\t\t\t\t\t\tdecoder.configure( config );\n\n\t\t\t\t\t},\n\t\t\t\t\tonChunk( chunk ) {\n\n\t\t\t\t\t\tdecoder.decode( chunk );\n\n\t\t\t\t\t},\n\t\t\t\t\tsetStatus( kind, status ) {\n\n\t\t\t\t\t\tconsole.info( 'MP4Demuxer:', kind );\n\n\t\t\t\t\t\tif ( kind === 'fetch' && status === 'Done' ) {\n\n\t\t\t\t\t\t\tdecoder.flush().then( () => {\n\n\t\t\t\t\t\t\t\tdecoder.close();\n\n\t\t\t\t\t\t\t\t// In case our VideoFrameTexture is no longer needed, we should close its backed VideoFrame, see issue #30379:\n\t\t\t\t\t\t\t\tif ( videoTexture.image instanceof VideoFrame ) videoTexture.image.close();\n\n\t\t\t\t\t\t\t\tvideoTexture.image = null;\n\n\t\t\t\t\t\t\t\tscene.remove( mesh );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: videoTexture } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - video - frames Decodes all frames from a MP4 file and renders them onto a plane as fast as possible. mp4box.js used for MP4 parsing."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - video panorama"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - video panorama:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet isUserInteracting = false,\n\t\t\t\tlon = 0, lat = 0,\n\t\t\t\tphi = 0, theta = 0,\n\t\t\t\tonPointerDownPointerX = 0,\n\t\t\t\tonPointerDownPointerY = 0,\n\t\t\t\tonPointerDownLon = 0,\n\t\t\t\tonPointerDownLat = 0;\n\n\t\t\tconst distance = .5;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .25, 10 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 5, 60, 40 );\n\t\t\t\t// invert the geometry on the x-axis so that all of the faces point inward\n\t\t\t\tgeometry.scale( - 1, 1, 1 );\n\n\t\t\t\tconst video = document.getElementById( 'video' );\n\t\t\t\tvideo.play();\n\n\t\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.addEventListener( 'pointerdown', onPointerDown );\n\t\t\t\tdocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tdocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onPointerDown( event ) {\n\n\t\t\t\tisUserInteracting = true;\n\n\t\t\t\tonPointerDownPointerX = event.clientX;\n\t\t\t\tonPointerDownPointerY = event.clientY;\n\n\t\t\t\tonPointerDownLon = lon;\n\t\t\t\tonPointerDownLat = lat;\n\n\t\t\t}\n\n\t\t\tfunction onPointerMove( event ) {\n\n\t\t\t\tif ( isUserInteracting === true ) {\n\n\t\t\t\t\tlon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;\n\t\t\t\t\tlat = ( onPointerDownPointerY - event.clientY ) * 0.1 + onPointerDownLat;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onPointerUp() {\n\n\t\t\t\tisUserInteracting = false;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tupdate();\n\n\t\t\t}\n\n\t\t\tfunction update() {\n\n\t\t\t\tlat = Math.max( - 85, Math.min( 85, lat ) );\n\t\t\t\tphi = THREE.MathUtils.degToRad( 90 - lat );\n\t\t\t\ttheta = THREE.MathUtils.degToRad( lon );\n\n\t\t\t\tcamera.position.x = distance * Math.sin( phi ) * Math.cos( theta );\n\t\t\t\tcamera.position.y = distance * Math.cos( phi );\n\t\t\t\tcamera.position.z = distance * Math.sin( phi ) * Math.sin( theta );\n\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - video panorama"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - volumetric caustics"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - volumetric caustics:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { uniform, refract, div, frameId, lightViewPosition, float, positionView, positionViewDirection, screenUV, pass, texture3D, time, screenCoordinate, normalView, texture, Fn, vec2, vec3 } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { bayer16 } from 'three/addons/tsl/math/Bayer.js';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\t\t\tlet postProcessing;\n\t\t\tlet stats;\n\t\t\tlet gltf;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tconst LAYER_VOLUMETRIC_LIGHTING = 10;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.025, 5 );\n\t\t\t\tcamera.position.set( - 0.7, 0.2, 0.2 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// Light\n\n\t\t\t\tconst spotLight = new THREE.SpotLight( 0xffffff, 1 );\n\t\t\t\tspotLight.position.set( .2, .3, .2 );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.angle = Math.PI / 6;\n\t\t\t\tspotLight.penumbra = 1;\n\t\t\t\tspotLight.decay = 2;\n\t\t\t\tspotLight.distance = 0;\n\t\t\t\tspotLight.shadow.mapType = THREE.HalfFloatType; // For HDR Caustics\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tspotLight.shadow.camera.near = .1;\n\t\t\t\tspotLight.shadow.camera.far = 1;\n\t\t\t\tspotLight.shadow.bias = - .003;\n\t\t\t\tspotLight.shadow.intensity = .95;\n\t\t\t\tspotLight.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\t// Model / Textures\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/' );\n\t\t\t\tdracoLoader.setDecoderConfig( { type: 'js' } );\n\n\t\t\t\tgltf = ( await new GLTFLoader().setDRACOLoader( dracoLoader ).loadAsync( './models/gltf/duck.glb' ) ).scene;\n\t\t\t\tgltf.scale.setScalar( .5 );\n\t\t\t\tscene.add( gltf );\n\n\t\t\t\tconst causticMap = new THREE.TextureLoader().load( './textures/opengameart/Caustic_Free.jpg' );\n\t\t\t\tcausticMap.wrapS = causticMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\tcausticMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// Material\n\n\t\t\t\tconst duck = gltf.children[ 0 ];\n\t\t\t\tduck.material = new THREE.MeshPhysicalNodeMaterial();\n\t\t\t\tduck.material.side = THREE.DoubleSide;\n\t\t\t\tduck.material.transparent = true;\n\t\t\t\tduck.material.color = new THREE.Color( 0xFFD700 );\n\t\t\t\tduck.material.transmission = 1;\n\t\t\t\tduck.material.thickness = .25;\n\t\t\t\tduck.material.ior = 1.5;\n\t\t\t\tduck.material.metalness = 0;\n\t\t\t\tduck.material.roughness = .1;\n\t\t\t\tduck.castShadow = true;\n\n\t\t\t\t// TSL Shader\n\n\t\t\t\tconst causticOcclusion = uniform( 1 );\n\n\t\t\t\tconst causticEffect = Fn( () => {\n\n\t\t\t\t\tconst refractionVector = refract( positionViewDirection.negate(), normalView, div( 1.0, duck.material.ior ) ).normalize();\n\t\t\t\t\tconst viewZ = normalView.z.pow( causticOcclusion );\n\n\t\t\t\t\tconst textureUV = refractionVector.xy.mul( .6 );\n\n\t\t\t\t\tconst causticColor = uniform( duck.material.color );\n\t\t\t\t\tconst chromaticAberrationOffset = normalView.z.pow( - .9 ).mul( .004 );\n\n\t\t\t\t\tconst causticProjection = vec3(\n\t\t\t\t\t\ttexture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x.negate(), 0 ) ) ).r,\n\t\t\t\t\t\ttexture( causticMap, textureUV.add( vec2( 0, chromaticAberrationOffset.y.negate() ) ) ).g,\n\t\t\t\t\t\ttexture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x, chromaticAberrationOffset.y ) ) ).b\n\t\t\t\t\t);\n\n\t\t\t\t\treturn causticProjection.mul( viewZ.mul( 60 ) ).add( viewZ ).mul( causticColor );\n\n\t\t\t\t} )().toVar();\n\n\t\t\t\tduck.material.castShadowNode = causticEffect;\n\n\t\t\t\tduck.material.emissiveNode = Fn( () => {\n\n\t\t\t\t\t// Custom emissive for illuminating backside of the mesh based on the caustic effect and light direction\n\n\t\t\t\t\tconst thicknessPowerNode = float( 3.0 );\n\n\t\t\t\t\tconst scatteringHalf = lightViewPosition( spotLight ).sub( positionView ).normalize();\n\t\t\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ) );\n\n\t\t\t\t\treturn causticEffect.mul( scatteringDot.add( .1 ) ).mul( .02 );\n\n\t\t\t\t} )();\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( causticOcclusion, 'value', 0, 20 ).name( 'caustic occlusion' );\n\t\t\t\tgui.addColor( duck.material, 'color' ).name( 'material color' );\n\n\t\t\t\t// Ground\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\tconst map = textureLoader.load( 'textures/hardwood2_diffuse.jpg' );\n\t\t\t\tmap.wrapS = map.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmap.repeat.set( 10, 10 );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 2, 2 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0 } );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, material );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\t// Renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t// Post-Processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\t// Layers\n\n\t\t\t\tconst volumetricLightingIntensity = uniform( .7 );\n\n\t\t\t\tconst volumetricLayer = new THREE.Layers();\n\t\t\t\tvolumetricLayer.disableAll();\n\t\t\t\tvolumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );\n\n\t\t\t\t// Volumetric Fog Area\n\n\t\t\t\tfunction createTexture3D() {\n\n\t\t\t\t\tlet i = 0;\n\n\t\t\t\t\tconst size = 128;\n\t\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\t\tconst scale = 10;\n\t\t\t\t\tconst perlin = new ImprovedNoise();\n\n\t\t\t\t\tconst repeatFactor = 5.0;\n\n\t\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\t\tconst nx = ( x / size ) * repeatFactor;\n\t\t\t\t\t\t\t\tconst ny = ( y / size ) * repeatFactor;\n\t\t\t\t\t\t\t\tconst nz = ( z / size ) * repeatFactor;\n\n\t\t\t\t\t\t\t\tconst noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );\n\n\t\t\t\t\t\t\t\tdata[ i ] = ( 128 + 128 * noiseValue );\n\n\t\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\treturn texture;\n\n\t\t\t\t}\n\n\t\t\t\tconst noiseTexture3D = createTexture3D();\n\n\t\t\t\tconst smokeAmount = uniform( 3 );\n\n\t\t\t\tconst volumetricMaterial = new THREE.VolumeNodeMaterial();\n\t\t\t\tvolumetricMaterial.steps = 20;\n\t\t\t\tvolumetricMaterial.offsetNode = bayer16( screenCoordinate.add( frameId ) ); // Add dithering to reduce banding\n\t\t\t\tvolumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {\n\n\t\t\t\t\t// Return the amount of fog based on the noise texture\n\n\t\t\t\t\tconst timeScaled = vec3( time.mul( .01 ), 0, time.mul( .03 ) );\n\n\t\t\t\t\tconst sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );\n\n\t\t\t\t\tlet density = sampleGrain( 1 );\n\t\t\t\t\tdensity = density.mul( sampleGrain( .5, 1 ) );\n\t\t\t\t\tdensity = density.mul( sampleGrain( .2, 2 ) );\n\n\t\t\t\t\treturn smokeAmount.mix( 1, density );\n\n\t\t\t\t} );\n\n\t\t\t\tconst volumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 1.5, .5, 1.5 ), volumetricMaterial );\n\t\t\t\tvolumetricMesh.receiveShadow = true;\n\t\t\t\tvolumetricMesh.position.y = .25;\n\t\t\t\tvolumetricMesh.layers.disableAll();\n\t\t\t\tvolumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\tscene.add( volumetricMesh );\n\n\t\t\t\t// Scene Pass\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst sceneDepth = scenePass.getTextureNode( 'depth' );\n\n\t\t\t\t// Material - Apply occlusion depth of volumetric lighting based on the scene depth\n\n\t\t\t\tvolumetricMaterial.depthNode = sceneDepth.sample( screenUV );\n\n\t\t\t\t// Volumetric Lighting Pass\n\n\t\t\t\tconst volumetricPass = pass( scene, camera, { depthBuffer: false } );\n\t\t\t\tvolumetricPass.setLayers( volumetricLayer );\n\t\t\t\tvolumetricPass.setResolution( .5 );\n\n\t\t\t\t// Compose and Denoise\n\n\t\t\t\tconst bloomPass = bloom( volumetricPass, 1, 1, 0 );\n\n\t\t\t\tconst scenePassColor = scenePass.add( bloomPass.mul( volumetricLightingIntensity ) );\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\n\t\t\t\t// Stats\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t// Controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.z = - .05;\n\t\t\t\tcontrols.target.y = .02;\n\t\t\t\tcontrols.maxDistance = 1;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tfor ( const mesh of gltf.children ) {\n\n\t\t\t\t\tmesh.rotation.y -= .01;\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - volumetric caustics"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - volumetric cloud"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - volumetric cloud:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { float, vec3, vec4, If, Break, Fn, smoothstep, texture3D, uniform } from 'three/tsl';\n\n\t\t\timport { RaymarchingBox } from 'three/addons/tsl/utils/Raymarching.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 1.5 );\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t// Sky\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 1;\n\t\t\t\tcanvas.height = 32;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tconst gradient = context.createLinearGradient( 0, 0, 0, 32 );\n\t\t\t\tgradient.addColorStop( 0.0, '#014a84' );\n\t\t\t\tgradient.addColorStop( 0.5, '#0561a0' );\n\t\t\t\tgradient.addColorStop( 1.0, '#437ab6' );\n\t\t\t\tcontext.fillStyle = gradient;\n\t\t\t\tcontext.fillRect( 0, 0, 1, 32 );\n\n\t\t\t\tconst skyMap = new THREE.CanvasTexture( canvas );\n\t\t\t\tskyMap.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tconst sky = new THREE.Mesh(\n\t\t\t\t\tnew THREE.SphereGeometry( 10 ),\n\t\t\t\t\tnew THREE.MeshBasicNodeMaterial( { map: skyMap, side: THREE.BackSide } )\n\t\t\t\t);\n\t\t\t\tscene.add( sky );\n\n\t\t\t\t// Texture\n\n\t\t\t\tconst size = 128;\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst scale = 0.05;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tconst d = 1.0 - vector.set( x, y, z ).subScalar( size / 2 ).divideScalar( size ).length();\n\t\t\t\t\t\t\tdata[ i ] = ( 128 + 128 * perlin.noise( x * scale / 1.5, y * scale, z * scale / 1.5 ) ) * d * d;\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// Shader\n\n\t\t\t\tconst transparentRaymarchingTexture = Fn( ( {\n\t\t\t\t\ttexture,\n\t\t\t\t\trange = float( 0.1 ),\n\t\t\t\t\tthreshold = float( 0.25 ),\n\t\t\t\t\topacity = float( 0.25 ),\n\t\t\t\t\tsteps = float( 100 )\n\t\t\t\t} ) => {\n\n\t\t\t\t\tconst finalColor = vec4( 0 ).toVar();\n\n\t\t\t\t\tRaymarchingBox( steps, ( { positionRay } ) => {\n\n\t\t\t\t\t\tconst mapValue = float( texture.sample( positionRay.add( 0.5 ) ).r ).toVar();\n\n\t\t\t\t\t\tmapValue.assign( smoothstep( threshold.sub( range ), threshold.add( range ), mapValue ).mul( opacity ) );\n\n\t\t\t\t\t\tconst shading = texture.sample( positionRay.add( vec3( - 0.01 ) ) ).r.sub( texture.sample( positionRay.add( vec3( 0.01 ) ) ).r );\n\n\t\t\t\t\t\tconst col = shading.mul( 3.0 ).add( positionRay.x.add( positionRay.y ).mul( 0.25 ) ).add( 0.2 );\n\n\t\t\t\t\t\tfinalColor.rgb.addAssign( finalColor.a.oneMinus().mul( mapValue ).mul( col ) );\n\n\t\t\t\t\t\tfinalColor.a.addAssign( finalColor.a.oneMinus().mul( mapValue ) );\n\n\t\t\t\t\t\tIf( finalColor.a.greaterThanEqual( 0.95 ), () => {\n\n\t\t\t\t\t\t\tBreak();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn finalColor;\n\n\t\t\t\t} );\n\n\t\t\t\t// Material\n\n\t\t\t\tconst baseColor = uniform( new THREE.Color( 0x798aa0 ) );\n\t\t\t\tconst range = uniform( 0.1 );\n\t\t\t\tconst threshold = uniform( 0.25 );\n\t\t\t\tconst opacity = uniform( 0.25 );\n\t\t\t\tconst steps = uniform( 100 );\n\n\t\t\t\tconst cloud3d = transparentRaymarchingTexture( {\n\t\t\t\t\ttexture: texture3D( texture, null, 0 ),\n\t\t\t\t\trange,\n\t\t\t\t\tthreshold,\n\t\t\t\t\topacity,\n\t\t\t\t\tsteps\n\t\t\t\t} );\n\n\t\t\t\tconst finalCloud = cloud3d.setRGB( cloud3d.rgb.add( baseColor ) );\n\n\t\t\t\tconst material = new THREE.NodeMaterial();\n\t\t\t\tmaterial.colorNode = finalCloud;\n\t\t\t\tmaterial.side = THREE.BackSide;\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\tmesh = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );\n\t\t\t\tgui.add( opacity, 'value', 0, 1, 0.01 ).name( 'opacity' );\n\t\t\t\tgui.add( range, 'value', 0, 1, 0.01 ).name( 'range' );\n\t\t\t\tgui.add( steps, 'value', 0, 200, 1 ).name( 'steps' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tmesh.rotation.y = - performance.now() / 7500;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - volumetric cloud"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - volumetric lighting"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - volumetric lighting:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { vec3, Fn, time, texture3D, screenUV, uniform, screenCoordinate, pass } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\t\t\timport { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';\n\n\t\t\timport { bayer16 } from 'three/addons/tsl/math/Bayer.js';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet volumetricMesh, teapot, pointLight, spotLight;\n\t\t\tlet postProcessing;\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tfunction createTexture3D() {\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\tconst size = 128;\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\tconst scale = 10;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\n\t\t\t\tconst repeatFactor = 5.0;\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tconst nx = ( x / size ) * repeatFactor;\n\t\t\t\t\t\t\tconst ny = ( y / size ) * repeatFactor;\n\t\t\t\t\t\t\tconst nz = ( z / size ) * repeatFactor;\n\n\t\t\t\t\t\t\tconst noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );\n\n\t\t\t\t\t\t\tdata[ i ] = ( 128 + 128 * noiseValue );\n\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst LAYER_VOLUMETRIC_LIGHTING = 10;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 2;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( - 8, 1, - 6 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxDistance = 40;\n\t\t\t\tcontrols.minDistance = 2;\n\n\t\t\t\t// Volumetric Fog Area\n\n\t\t\t\tconst noiseTexture3D = createTexture3D();\n\n\t\t\t\tconst smokeAmount = uniform( 2 );\n\n\t\t\t\tconst volumetricMaterial = new THREE.VolumeNodeMaterial();\n\t\t\t\tvolumetricMaterial.steps = 12;\n\t\t\t\tvolumetricMaterial.offsetNode = bayer16( screenCoordinate ); // Add dithering to reduce banding\n\t\t\t\tvolumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {\n\n\t\t\t\t\t// Return the amount of fog based on the noise texture\n\n\t\t\t\t\tconst timeScaled = vec3( time, 0, time.mul( .3 ) );\n\n\t\t\t\t\tconst sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );\n\n\t\t\t\t\tlet density = sampleGrain( .1 );\n\t\t\t\t\tdensity = density.mul( sampleGrain( .05, 1 ) );\n\t\t\t\t\tdensity = density.mul( sampleGrain( .02, 2 ) );\n\n\t\t\t\t\treturn smokeAmount.mix( 1, density );\n\n\t\t\t\t} );\n\n\t\t\t\tvolumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 20, 10, 20 ), volumetricMaterial );\n\t\t\t\tvolumetricMesh.receiveShadow = true;\n\t\t\t\tvolumetricMesh.position.y = 2;\n\t\t\t\tvolumetricMesh.layers.disableAll();\n\t\t\t\tvolumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\tscene.add( volumetricMesh );\n\n\t\t\t\t// Objects\n\n\t\t\t\tteapot = new THREE.Mesh( new TeapotGeometry( .8, 18 ), new THREE.MeshStandardMaterial( { color: 0xffffff, side: THREE.DoubleSide } ) );\n\t\t\t\tteapot.castShadow = true;\n\t\t\t\tscene.add( teapot );\n\n\t\t\t\tconst floor = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshStandardMaterial( { color: 0xffffff } ) );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.position.y = - 3;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// Lights\n\n\t\t\t\tpointLight = new THREE.PointLight( 0xf9bb50, 3, 100 );\n\t\t\t\tpointLight.castShadow = true;\n\t\t\t\tpointLight.position.set( 0, 1.4, 0 );\n\t\t\t\tpointLight.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\t//lightBase.add( new THREE.Mesh( new THREE.SphereGeometry( 0.1, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0xf9bb50 } ) ) );\n\t\t\t\tscene.add( pointLight );\n\n\t\t\t\tspotLight = new THREE.SpotLight( 0xffffff, 100 );\n\t\t\t\tspotLight.position.set( 2.5, 5, 2.5 );\n\t\t\t\tspotLight.angle = Math.PI / 6;\n\t\t\t\tspotLight.penumbra = 1;\n\t\t\t\tspotLight.decay = 2;\n\t\t\t\tspotLight.distance = 0;\n\t\t\t\tspotLight.map = new THREE.TextureLoader().setPath( 'textures/' ).load( 'colors.png' );\n\t\t\t\tspotLight.castShadow = true;\n\t\t\t\tspotLight.shadow.intensity = .98;\n\t\t\t\tspotLight.shadow.mapSize.width = 1024;\n\t\t\t\tspotLight.shadow.mapSize.height = 1024;\n\t\t\t\tspotLight.shadow.camera.near = 1;\n\t\t\t\tspotLight.shadow.camera.far = 15;\n\t\t\t\tspotLight.shadow.focus = 1;\n\t\t\t\tspotLight.shadow.bias = - .003;\n\t\t\t\tspotLight.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\t//sunLight.add( new THREE.Mesh( new THREE.SphereGeometry( 0.1, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );\n\t\t\t\tscene.add( spotLight );\n\n\t\t\t\t// Post-Processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\t// Layers\n\n\t\t\t\tconst volumetricLightingIntensity = uniform( 1 );\n\n\t\t\t\tconst volumetricLayer = new THREE.Layers();\n\t\t\t\tvolumetricLayer.disableAll();\n\t\t\t\tvolumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );\n\n\t\t\t\t// Scene Pass\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst sceneDepth = scenePass.getTextureNode( 'depth' );\n\n\t\t\t\t// Material - Apply occlusion depth of volumetric lighting based on the scene depth\n\n\t\t\t\tvolumetricMaterial.depthNode = sceneDepth.sample( screenUV );\n\n\t\t\t\t// Volumetric Lighting Pass\n\n\t\t\t\tconst volumetricPass = pass( scene, camera, { depthBuffer: false } );\n\t\t\t\tvolumetricPass.setLayers( volumetricLayer );\n\t\t\t\tvolumetricPass.setResolution( .25 );\n\n\t\t\t\t// Compose and Denoise\n\n\t\t\t\tconst denoiseStrength = uniform( .6 );\n\n\t\t\t\tconst blurredVolumetricPass = gaussianBlur( volumetricPass, denoiseStrength );\n\n\t\t\t\tconst scenePassColor = scenePass.add( blurredVolumetricPass.mul( volumetricLightingIntensity ) );\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst params = {\n\t\t\t\t\tresolution: volumetricPass.getResolution(),\n\t\t\t\t\tdenoise: true\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst rayMarching = gui.addFolder( 'Ray Marching' ).close();\n\t\t\t\trayMarching.add( params, 'resolution', .1, .5 ).onChange( ( resolution ) => {\n\n\t\t\t\t\tvolumetricPass.setResolution( resolution );\n\n\t\t\t\t} );\n\t\t\t\trayMarching.add( volumetricMaterial, 'steps', 2, 12 ).name( 'step count' );\n\t\t\t\trayMarching.add( denoiseStrength, 'value', 0, 1 ).name( 'denoise strength' );\n\t\t\t\trayMarching.add( params, 'denoise' ).onChange( ( denoise ) => {\n\n\t\t\t\t\tconst volumetric = denoise ? blurredVolumetricPass : volumetricPass;\n\n\t\t\t\t\tconst scenePassColor = scenePass.add( volumetric.mul( volumetricLightingIntensity ) );\n\n\t\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\t\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst lighting = gui.addFolder( 'Lighting / Scene' ).close();\n\t\t\t\tlighting.add( pointLight, 'intensity', 0, 6 ).name( 'light intensity' );\n\t\t\t\tlighting.add( spotLight, 'intensity', 0, 200 ).name( 'spot intensity' );\n\t\t\t\tlighting.add( volumetricLightingIntensity, 'value', 0, 2 ).name( 'fog intensity' );\n\t\t\t\tlighting.add( smokeAmount, 'value', 0, 3 ).name( 'smoke amount' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tstats.update();\n\n\t\t\t\tconst time = performance.now() * 0.001;\n\t\t\t\tconst scale = 2.4;\n\n\t\t\t\tpointLight.position.x = Math.sin( time * 0.7 ) * scale;\n\t\t\t\tpointLight.position.y = Math.cos( time * 0.5 ) * scale;\n\t\t\t\tpointLight.position.z = Math.cos( time * 0.3 ) * scale;\n\n\t\t\t\tspotLight.position.x = Math.cos( time * 0.3 ) * scale;\n\t\t\t\tspotLight.lookAt( 0, 0, 0 );\n\n\t\t\t\tteapot.rotation.y = time * 0.2;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - volumetric lighting Improve the quality/performance adjusting the parameters in the Controls"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - volumetric lighting rect area"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - volumetric lighting rect area:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { vec3, Fn, time, texture3D, screenUV, uniform, screenCoordinate, pass } from 'three/tsl';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\t\t\timport { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';\n\n\t\t\timport { bayer16 } from 'three/addons/tsl/math/Bayer.js';\n\t\t\timport { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet volumetricMesh, meshKnot;\n\t\t\tlet rectLight1, rectLight2, rectLight3;\n\t\t\tlet clock;\n\t\t\tlet postProcessing;\n\t\t\tlet stats;\n\n\t\t\tinit();\n\n\t\t\tfunction createTexture3D() {\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\tconst size = 128;\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\tconst scale = 10;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\n\t\t\t\tconst repeatFactor = 5.0;\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tconst nx = ( x / size ) * repeatFactor;\n\t\t\t\t\t\t\tconst ny = ( y / size ) * repeatFactor;\n\t\t\t\t\t\t\tconst nz = ( z / size ) * repeatFactor;\n\n\t\t\t\t\t\t\tconst noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );\n\n\t\t\t\t\t\t\tdata[ i ] = ( 128 + 128 * noiseValue );\n\n\t\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tTHREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );\n\n\t\t\t\tconst LAYER_VOLUMETRIC_LIGHTING = 10;\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 2;\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 250 );\n\t\t\t\tcamera.position.set( 0, 5, - 15 );\n\n\t\t\t\t// Volumetric Fog Area\n\n\t\t\t\tconst noiseTexture3D = createTexture3D();\n\n\t\t\t\tconst smokeAmount = uniform( 2 );\n\n\t\t\t\tconst volumetricMaterial = new THREE.VolumeNodeMaterial();\n\t\t\t\tvolumetricMaterial.steps = 12;\n\t\t\t\tvolumetricMaterial.offsetNode = bayer16( screenCoordinate ); // Add dithering to reduce banding\n\t\t\t\tvolumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {\n\n\t\t\t\t\t// Return the amount of fog based on the noise texture\n\n\t\t\t\t\tconst timeScaled = vec3( time, 0, time.mul( .3 ) );\n\n\t\t\t\t\tconst sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );\n\n\t\t\t\t\tlet density = sampleGrain( .1 );\n\t\t\t\t\tdensity = density.mul( sampleGrain( .05, 1 ) );\n\t\t\t\t\tdensity = density.mul( sampleGrain( .02, 2 ) );\n\n\t\t\t\t\treturn smokeAmount.mix( 1, density );\n\n\t\t\t\t} );\n\n\t\t\t\tvolumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 50, 40, 50 ), volumetricMaterial );\n\t\t\t\tvolumetricMesh.receiveShadow = true;\n\t\t\t\tvolumetricMesh.position.y = 20;\n\t\t\t\tvolumetricMesh.layers.disableAll();\n\t\t\t\tvolumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\tscene.add( volumetricMesh );\n\n\t\t\t\t// Objects\n\n\t\t\t\trectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );\n\t\t\t\trectLight1.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\trectLight1.position.set( - 5, 5, 5 );\n\t\t\t\tscene.add( rectLight1 );\n\n\t\t\t\trectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );\n\t\t\t\trectLight2.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\trectLight2.position.set( 0, 5, 5 );\n\t\t\t\tscene.add( rectLight2 );\n\n\t\t\t\trectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );\n\t\t\t\trectLight3.layers.enable( LAYER_VOLUMETRIC_LIGHTING );\n\t\t\t\trectLight3.position.set( 5, 5, 5 );\n\t\t\t\tscene.add( rectLight3 );\n\n\t\t\t\t//\n\n\t\t\t\tconst createRectLightMesh = ( rectLight ) => {\n\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( 4, 10 );\n\t\t\t\t\tconst frontMaterial = new THREE.MeshBasicMaterial( { color: rectLight.color, side: THREE.BackSide } );\n\t\t\t\t\tconst backMaterial = new THREE.MeshStandardMaterial( { color: 0x111111 } );\n\n\t\t\t\t\tconst backSide = new THREE.Mesh( geometry, backMaterial );\n\t\t\t\t\tbackSide.position.set( 0, 0, .08 );\n\n\t\t\t\t\tconst frontSide = new THREE.Mesh( geometry, frontMaterial );\n\t\t\t\t\tfrontSide.position.set( 0, 0, .01 );\n\n\t\t\t\t\trectLight.add( backSide );\n\t\t\t\t\trectLight.add( frontSide );\n\n\t\t\t\t};\n\n\t\t\t\tcreateRectLightMesh( rectLight1 );\n\t\t\t\tcreateRectLightMesh( rectLight2 );\n\t\t\t\tcreateRectLightMesh( rectLight3 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );\n\t\t\t\tconst matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );\n\t\t\t\tconst mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );\n\t\t\t\tscene.add( mshStdFloor );\n\n\t\t\t\tconst geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );\n\t\t\t\tconst matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );\n\t\t\t\tmeshKnot = new THREE.Mesh( geoKnot, matKnot );\n\t\t\t\tmeshKnot.position.set( 0, 5, 0 );\n\t\t\t\tscene.add( meshKnot );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 200;\n\t\t\t\tcontrols.target.copy( meshKnot.position );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t// Post-Processing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\t// Layers\n\n\t\t\t\tconst volumetricLightingIntensity = uniform( 1 );\n\n\t\t\t\tconst volumetricLayer = new THREE.Layers();\n\t\t\t\tvolumetricLayer.disableAll();\n\t\t\t\tvolumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );\n\n\t\t\t\t// Scene Pass\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst sceneDepth = scenePass.getTextureNode( 'depth' );\n\n\t\t\t\t// Material - Apply occlusion depth of volumetric lighting based on the scene depth\n\n\t\t\t\tvolumetricMaterial.depthNode = sceneDepth.sample( screenUV );\n\n\t\t\t\t// Volumetric Lighting Pass\n\n\t\t\t\tconst volumetricPass = pass( scene, camera, { depthBuffer: false } );\n\t\t\t\tvolumetricPass.setLayers( volumetricLayer );\n\t\t\t\tvolumetricPass.setResolution( .25 );\n\n\t\t\t\t// Compose and Denoise\n\n\t\t\t\tconst denoiseStrength = uniform( .6 );\n\n\t\t\t\tconst blurredVolumetricPass = gaussianBlur( volumetricPass, denoiseStrength );\n\n\t\t\t\tconst scenePassColor = scenePass.add( blurredVolumetricPass.mul( volumetricLightingIntensity ) );\n\n\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\n\t\t\t\t// GUI\n\n\t\t\t\tconst params = {\n\t\t\t\t\tresolution: volumetricPass.getResolution(),\n\t\t\t\t\tdenoise: true\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst rayMarching = gui.addFolder( 'Ray Marching' ).close();\n\t\t\t\trayMarching.add( params, 'resolution', .1, .5 ).onChange( ( resolution ) => {\n\n\t\t\t\t\tvolumetricPass.setResolution( resolution );\n\n\t\t\t\t} );\n\t\t\t\trayMarching.add( volumetricMaterial, 'steps', 2, 12 ).name( 'step count' );\n\t\t\t\trayMarching.add( denoiseStrength, 'value', 0, 1 ).name( 'denoise strength' );\n\t\t\t\trayMarching.add( params, 'denoise' ).onChange( ( denoise ) => {\n\n\t\t\t\t\tconst volumetric = denoise ? blurredVolumetricPass : volumetricPass;\n\n\t\t\t\t\tconst scenePassColor = scenePass.add( volumetric.mul( volumetricLightingIntensity ) );\n\n\t\t\t\t\tpostProcessing.outputNode = scenePassColor;\n\t\t\t\t\tpostProcessing.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst lighting = gui.addFolder( 'Lighting / Scene' ).close();\n\t\t\t\tlighting.add( volumetricLightingIntensity, 'value', 0, 2 ).name( 'fog intensity' );\n\t\t\t\tlighting.add( smokeAmount, 'value', 0, 3 ).name( 'smoke amount' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tstats.update();\n\n\t\t\t\trectLight1.rotation.y += - delta;\n\t\t\t\trectLight2.rotation.y += delta * .5;\n\t\t\t\trectLight3.rotation.y += delta;\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js webgpu - volumetric lighting rect area Improve the quality/performance adjusting the parameters in the Controls"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates webgpu - volumetric perlin"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - volumetric perlin:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { Break, If, vec3, vec4, texture3D, uniform, Fn } from 'three/tsl';\n\n\t\t\timport { RaymarchingBox } from 'three/addons/tsl/utils/Raymarching.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet renderer, scene, camera;\n\t\t\tlet mesh;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 0, 2 );\n\n\t\t\t\tnew OrbitControls( camera, renderer.domElement );\n\n\t\t\t\t// Texture\n\n\t\t\t\tconst size = 128;\n\t\t\t\tconst data = new Uint8Array( size * size * size );\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst perlin = new ImprovedNoise();\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\tfor ( let z = 0; z < size; z ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y < size; y ++ ) {\n\n\t\t\t\t\t\tfor ( let x = 0; x < size; x ++ ) {\n\n\t\t\t\t\t\t\tvector.set( x, y, z ).divideScalar( size );\n\n\t\t\t\t\t\t\tconst d = perlin.noise( vector.x * 6.5, vector.y * 6.5, vector.z * 6.5 );\n\n\t\t\t\t\t\t\tdata[ i ++ ] = d * 128 + 128;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = new THREE.Data3DTexture( data, size, size, size );\n\t\t\t\ttexture.format = THREE.RedFormat;\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\ttexture.unpackAlignment = 1;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// Shader\n\n\t\t\t\tconst opaqueRaymarchingTexture = Fn( ( { texture, steps, threshold } ) => {\n\n\t\t\t\t\tconst finalColor = vec4( 0 ).toVar();\n\n\t\t\t\t\tRaymarchingBox( steps, ( { positionRay } ) => {\n\n\t\t\t\t\t\tconst mapValue = texture.sample( positionRay.add( 0.5 ) ).r.toVar();\n\n\t\t\t\t\t\tIf( mapValue.greaterThan( threshold ), () => {\n\n\t\t\t\t\t\t\tconst p = vec3( positionRay ).add( 0.5 );\n\n\t\t\t\t\t\t\tfinalColor.rgb.assign( texture.normal( p ).mul( 0.5 ).add( positionRay.mul( 1.5 ).add( 0.25 ) ) );\n\t\t\t\t\t\t\tfinalColor.a.assign( 1 );\n\t\t\t\t\t\t\tBreak();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn finalColor;\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst threshold = uniform( 0.6 );\n\t\t\t\tconst steps = uniform( 200 );\n\n\t\t\t\tconst material = new THREE.NodeMaterial();\n\t\t\t\tmaterial.colorNode = opaqueRaymarchingTexture( {\n\t\t\t\t\ttexture: texture3D( texture, null, 0 ),\n\t\t\t\t\tsteps,\n\t\t\t\t\tthreshold\n\t\t\t\t} );\n\t\t\t\tmaterial.side = THREE.BackSide;\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\tmesh = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );\n\t\t\t\tgui.add( steps, 'value', 0, 300, 1 ).name( 'steps' );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgpu - volumetric perlin"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates - water"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - water:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { pass, mrt, output, emissive, color, screenUV } from 'three/tsl';\n\t\t\timport { bloom } from 'three/addons/tsl/display/BloomNode.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { WaterMesh } from 'three/addons/objects/Water2Mesh.js';\n\t\t\timport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\tlet scene, camera, renderer, water, postProcessing, controls;\n\n\t\t\tconst params = {\n\t\t\t\tcolor: '#ffffff',\n\t\t\t\tscale: 2,\n\t\t\t\tflowX: 0.25,\n\t\t\t\tflowY: 0.25\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.backgroundNode = screenUV.distance( .5 ).remap( 0, 0.5 ).mix( color( 0x666666 ), color( 0x111111 ) );\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );\n\t\t\t\tcamera.position.set( - 25, 10, - 25 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\t// asset loading\n\n\t\t\t\tconst dracoLoader = new DRACOLoader();\n\t\t\t\tdracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\t\tgltfLoader.setDRACOLoader( dracoLoader );\n\t\t\t\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst [ gltf, normalMap0, normalMap1 ] = await Promise.all( [\n\t\t\t\t\tgltfLoader.loadAsync( 'models/gltf/pool.glb' ),\n\t\t\t\t\ttextureLoader.loadAsync( 'textures/water/Water_1_M_Normal.jpg' ),\n\t\t\t\t\ttextureLoader.loadAsync( 'textures/water/Water_2_M_Normal.jpg' )\n\t\t\t\t] );\n\n\t\t\t\tgltf.scene.scale.setScalar( 0.1 );\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t// water\n\n\t\t\t\tnormalMap0.wrapS = normalMap0.wrapT = THREE.RepeatWrapping;\n\t\t\t\tnormalMap1.wrapS = normalMap1.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tconst waterGeometry = new THREE.PlaneGeometry( 30, 40 );\n\n\t\t\t\twater = new WaterMesh( waterGeometry, {\n\t\t\t\t\tcolor: params.color,\n\t\t\t\t\tscale: params.scale,\n\t\t\t\t\tflowDirection: new THREE.Vector2( params.flowX, params.flowY ),\n\t\t\t\t\tnormalMap0: normalMap0,\n\t\t\t\t\tnormalMap1: normalMap1\n\t\t\t\t} );\n\n\t\t\t\twater.position.set( 0, 0.2, - 2 );\n\t\t\t\twater.rotation.x = Math.PI * - 0.5;\n\t\t\t\twater.renderOrder = Infinity;\n\t\t\t\tscene.add( water );\n\n\t\t\t\t// light\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xccccccc, 0.4 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xf435ab, 3 );\n\t\t\t\tdirectionalLight.position.set( - 1, 1, 1 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGPURenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.NeutralToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\t\t\t\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tscenePass.setMRT( mrt( {\n\t\t\t\t\toutput,\n\t\t\t\t\temissive\n\t\t\t\t} ) );\n\n\t\t\t\tconst outputPass = scenePass.getTextureNode();\n\t\t\t\tconst emissivePass = scenePass.getTextureNode( 'emissive' );\n\n\t\t\t\tconst bloomPass = bloom( emissivePass );\n\n\t\t\t\tpostProcessing.outputNode = outputPass.add( bloomPass );\n\n\t\t\t\t// gui\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tconst waterNode = water.material.colorNode;\n\n\t\t\t\tgui.addColor( params, 'color' ).onChange( function ( value ) {\n\n\t\t\t\t\twaterNode.color.value.set( value );\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'scale', 1, 10 ).onChange( function ( value ) {\n\n\t\t\t\t\twaterNode.scale.value = value;\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'flowX', - 1, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\twaterNode.flowDirection.value.x = value;\n\t\t\t\t\twaterNode.flowDirection.value.normalize();\n\n\t\t\t\t} );\n\t\t\t\tgui.add( params, 'flowY', - 1, 1 ).step( 0.01 ).onChange( function ( value ) {\n\n\t\t\t\t\twaterNode.flowDirection.value.y = value;\n\t\t\t\t\twaterNode.flowDirection.value.normalize();\n\n\t\t\t\t} );\n\n\t\t\t\tgui.open();\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 50;\n\t\t\t\tcontrols.enableDamping = true;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js - water The Night Pool by syntheticplants is licensed under Creative Commons Attribution ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates vr - roller coaster"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - roller coaster:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport {\n\t\t\t\tRollerCoasterGeometry,\n\t\t\t\tRollerCoasterShadowGeometry,\n\t\t\t\tRollerCoasterLiftersGeometry,\n\t\t\t\tTreesGeometry,\n\t\t\t\tSkyGeometry\n\t\t\t} from 'three/addons/misc/RollerCoaster.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\n\t\t\tlet mesh, material, geometry;\n\n\t\t\tconst renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: false } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.xr.enabled = true;\n\t\t\trenderer.xr.setReferenceSpaceType( 'local' );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t//\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xf0f0ff );\n\n\t\t\tconst light = new THREE.HemisphereLight( 0xfff0f0, 0x60606, 3 );\n\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\tscene.add( light );\n\n\t\t\tconst train = new THREE.Object3D();\n\t\t\tscene.add( train );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 500 );\n\t\t\ttrain.add( camera );\n\n\t\t\t// environment\n\n\t\t\tgeometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );\n\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\tconst positions = geometry.attributes.position.array;\n\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\tfor ( let i = 0; i < positions.length; i += 3 ) {\n\n\t\t\t\tvertex.fromArray( positions, i );\n\n\t\t\t\tvertex.x += Math.random() * 10 - 5;\n\t\t\t\tvertex.z += Math.random() * 10 - 5;\n\n\t\t\t\tconst distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;\n\t\t\t\tvertex.y = Math.random() * Math.max( 0, distance );\n\n\t\t\t\tvertex.toArray( positions, i );\n\n\t\t\t}\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\tcolor: 0x407000\n\t\t\t} );\n\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new TreesGeometry( mesh );\n\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tside: THREE.DoubleSide, vertexColors: true\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new SkyGeometry();\n\t\t\tmaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\t//\n\n\t\t\tconst PI2 = Math.PI * 2;\n\n\t\t\tconst curve = ( function () {\n\n\t\t\t\tconst vector = new THREE.Vector3();\n\t\t\t\tconst vector2 = new THREE.Vector3();\n\n\t\t\t\treturn {\n\n\t\t\t\t\tgetPointAt: function ( t ) {\n\n\t\t\t\t\t\tt = t * PI2;\n\n\t\t\t\t\t\tconst x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;\n\t\t\t\t\t\tconst y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;\n\t\t\t\t\t\tconst z = Math.sin( t ) * Math.sin( t * 4 ) * 50;\n\n\t\t\t\t\t\treturn vector.set( x, y, z ).multiplyScalar( 2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tgetTangentAt: function ( t ) {\n\n\t\t\t\t\t\tconst delta = 0.0001;\n\t\t\t\t\t\tconst t1 = Math.max( 0, t - delta );\n\t\t\t\t\t\tconst t2 = Math.min( 1, t + delta );\n\n\t\t\t\t\t\treturn vector2.copy( this.getPointAt( t2 ) )\n\t\t\t\t\t\t\t.sub( this.getPointAt( t1 ) ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t} )();\n\n\t\t\tgeometry = new RollerCoasterGeometry( curve, 1500 );\n\t\t\tmaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\tvertexColors: true\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new RollerCoasterLiftersGeometry( curve, 100 );\n\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.y = 0.1;\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new RollerCoasterShadowGeometry( curve, 500 );\n\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: 0x305000, depthWrite: false, transparent: true\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.y = 0.1;\n\t\t\tscene.add( mesh );\n\n\t\t\tconst funfairs = [];\n\n\t\t\t//\n\n\t\t\tgeometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );\n\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\tcolor: 0xff8080\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( - 80, 10, - 70 );\n\t\t\tmesh.rotation.x = Math.PI / 2;\n\t\t\tscene.add( mesh );\n\n\t\t\tfunfairs.push( mesh );\n\n\t\t\tgeometry = new THREE.CylinderGeometry( 5, 6, 4, 10 );\n\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\tcolor: 0x8080ff\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( 50, 2, 30 );\n\t\t\tscene.add( mesh );\n\n\t\t\tfunfairs.push( mesh );\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst position = new THREE.Vector3();\n\t\t\tconst tangent = new THREE.Vector3();\n\n\t\t\tconst lookAt = new THREE.Vector3();\n\n\t\t\tlet velocity = 0;\n\t\t\tlet progress = 0;\n\n\t\t\tlet prevTime = performance.now();\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now();\n\t\t\t\tconst delta = time - prevTime;\n\n\t\t\t\tfor ( let i = 0; i < funfairs.length; i ++ ) {\n\n\t\t\t\t\tfunfairs[ i ].rotation.y = time * 0.0004;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tprogress += velocity;\n\t\t\t\tprogress = progress % 1;\n\n\t\t\t\tposition.copy( curve.getPointAt( progress ) );\n\t\t\t\tposition.y += 0.3;\n\n\t\t\t\ttrain.position.copy( position );\n\n\t\t\t\ttangent.copy( curve.getTangentAt( progress ) );\n\n\t\t\t\tvelocity -= tangent.y * 0.0000001 * delta;\n\t\t\t\tvelocity = Math.max( 0.00004, Math.min( 0.0002, velocity ) );\n\n\t\t\t\ttrain.lookAt( lookAt.copy( position ).sub( tangent ) );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tprevTime = time;\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates xr - cubes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - cubes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, raycaster, renderer;\n\n\t\t\tlet room;\n\n\t\t\tlet controller, controllerGrip;\n\t\t\tlet INTERSECTED;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x505050 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\troom = new THREE.LineSegments(\n\t\t\t\t\tnew BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0xbcbcbc } )\n\t\t\t\t);\n\t\t\t\tscene.add( room );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xa5a5a5, 0x898989, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 0.15, 0.15, 0.15 );\n\n\t\t\t\tfor ( let i = 0; i < 200; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tobject.position.y = Math.random() * 4;\n\t\t\t\t\tobject.position.z = Math.random() * 4 - 2;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\n\t\t\t\t\tobject.userData.velocity = new THREE.Vector3();\n\t\t\t\t\tobject.userData.velocity.x = Math.random() * 0.01 - 0.005;\n\t\t\t\t\tobject.userData.velocity.y = Math.random() * 0.01 - 0.005;\n\t\t\t\t\tobject.userData.velocity.z = Math.random() * 0.01 - 0.005;\n\n\t\t\t\t\troom.add( object );\n\n\t\t\t\t}\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tfunction onSelectStart() {\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller = renderer.xr.getController( 0 );\n\t\t\t\tcontroller.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tconst targetRayMode = event.data.targetRayMode;\n\n\t\t\t\t\tif ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {\n\n\t\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tcontroller.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );\n\t\t\t\tscene.add( controllerGrip );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer ) );\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\tswitch ( data.targetRayMode ) {\n\n\t\t\t\t\tcase 'tracked-pointer':\n\n\t\t\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );\n\n\t\t\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t\t\tcase 'gaze':\n\n\t\t\t\t\t\tgeometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\t\t\t\treturn new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta() * 60;\n\n\t\t\t\tif ( controller.userData.isSelecting === true ) {\n\n\t\t\t\t\tconst cube = room.children[ 0 ];\n\t\t\t\t\troom.remove( cube );\n\n\t\t\t\t\tcube.position.copy( controller.position );\n\t\t\t\t\tcube.userData.velocity.x = ( Math.random() - 0.5 ) * 0.02 * delta;\n\t\t\t\t\tcube.userData.velocity.y = ( Math.random() - 0.5 ) * 0.02 * delta;\n\t\t\t\t\tcube.userData.velocity.z = ( Math.random() * 0.01 - 0.05 ) * delta;\n\t\t\t\t\tcube.userData.velocity.applyQuaternion( controller.quaternion );\n\t\t\t\t\troom.add( cube );\n\n\t\t\t\t}\n\n\t\t\t\t// find intersections\n\n\t\t\t\traycaster.setFromXRController( controller );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( room.children, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tif ( INTERSECTED != intersects[ 0 ].object ) {\n\n\t\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\t\tINTERSECTED = intersects[ 0 ].object;\n\t\t\t\t\t\tINTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();\n\t\t\t\t\t\tINTERSECTED.material.emissive.setHex( 0xff0000 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\tINTERSECTED = undefined;\n\n\t\t\t\t}\n\n\t\t\t\t// Keep cubes inside room\n\n\t\t\t\tfor ( let i = 0; i < room.children.length; i ++ ) {\n\n\t\t\t\t\tconst cube = room.children[ i ];\n\n\t\t\t\t\tcube.userData.velocity.multiplyScalar( 1 - ( 0.001 * delta ) );\n\n\t\t\t\t\tcube.position.add( cube.userData.velocity );\n\n\t\t\t\t\tif ( cube.position.x < - 3 || cube.position.x > 3 ) {\n\n\t\t\t\t\t\tcube.position.x = THREE.MathUtils.clamp( cube.position.x, - 3, 3 );\n\t\t\t\t\t\tcube.userData.velocity.x = - cube.userData.velocity.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cube.position.y < 0 || cube.position.y > 6 ) {\n\n\t\t\t\t\t\tcube.position.y = THREE.MathUtils.clamp( cube.position.y, 0, 6 );\n\t\t\t\t\t\tcube.userData.velocity.y = - cube.userData.velocity.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cube.position.z < - 3 || cube.position.z > 3 ) {\n\n\t\t\t\t\t\tcube.position.z = THREE.MathUtils.clamp( cube.position.z, - 3, 3 );\n\t\t\t\t\t\tcube.userData.velocity.z = - cube.userData.velocity.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcube.rotation.x += cube.userData.velocity.x * 2 * delta;\n\t\t\t\t\tcube.rotation.y += cube.userData.velocity.y * 2 * delta;\n\t\t\t\t\tcube.rotation.z += cube.userData.velocity.z * 2 * delta;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - interactive cubes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgpu example that demonstrates vr - xr layers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - xr layers:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';\n\t\t\timport {\n\t\t\t\tRollerCoasterGeometry,\n\t\t\t\tRollerCoasterShadowGeometry,\n\t\t\t\tRollerCoasterLiftersGeometry,\n\t\t\t\tTreesGeometry,\n\t\t\t\tSkyGeometry\n\t\t\t} from 'three/addons/misc/RollerCoaster.js';\n\t\t\timport { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tlet room;\n\n\t\t\tlet count = 0;\n\t\t\tconst radius = 0.08;\n\t\t\tlet normal = new THREE.Vector3();\n\t\t\tconst relativeVelocity = new THREE.Vector3();\n\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst funfairs = [];\n\t\t\tconst train = new THREE.Object3D();\n\t\t\tconst rcdelta = clock.getDelta() * 0.8; // slow down simulation\n\t\t\tconst PI2 = Math.PI * 2;\n\t\t\tlet rccamera = null;\n\t\t\tlet rcscene = null;\n\n\t\t\tconst tempMatrix = new THREE.Matrix4();\n\t\t\tlet raycaster = null;\n\n\t\t\tconst curve = ( function () {\n\n\t\t\t\tconst vector = new THREE.Vector3();\n\t\t\t\tconst vector2 = new THREE.Vector3();\n\n\t\t\t\treturn {\n\n\t\t\t\t\tgetPointAt: function ( t ) {\n\n\t\t\t\t\t\tt = t * PI2;\n\n\t\t\t\t\t\tconst x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;\n\t\t\t\t\t\tconst y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;\n\t\t\t\t\t\tconst z = Math.sin( t ) * Math.sin( t * 4 ) * 50;\n\n\t\t\t\t\t\treturn vector.set( x, y, z ).multiplyScalar( 2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tgetTangentAt: function ( t ) {\n\n\t\t\t\t\t\tconst delta = 0.0001;\n\t\t\t\t\t\tconst t1 = Math.max( 0, t - delta );\n\t\t\t\t\t\tconst t2 = Math.min( 1, t + delta );\n\n\t\t\t\t\t\treturn vector2.copy( this.getPointAt( t2 ) )\n\t\t\t\t\t\t\t.sub( this.getPointAt( t1 ) ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t} )();\n\n\t\t\tlet horseCamera = null;\n\t\t\tlet horseScene = null;\n\t\t\tlet horseMixer = null;\n\t\t\tlet horseTheta = 0;\n\t\t\tlet horseMesh = null;\n\t\t\tconst horseRadius = 600;\n\n\t\t\tlet guiScene = null;\n\t\t\tlet guiCamera = null;\n\t\t\tlet guiGroup = null;\n\n\t\t\tlet rollercoasterLayer = null;\n\t\t\tlet horseLayer = null;\n\t\t\tlet guiLayer = null;\n\n\t\t\tconst parameters = {\n\t\t\t\tradius: 0.6,\n\t\t\t\ttube: 0.2,\n\t\t\t\ttubularSegments: 150,\n\t\t\t\tradialSegments: 20,\n\t\t\t\tp: 2,\n\t\t\t\tq: 3,\n\t\t\t\tthickness: 0.5\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction getIntersections( controller ) {\n\n\t\t\t\ttempMatrix.identity().extractRotation( controller.matrixWorld );\n\n\t\t\t\traycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\t\t\traycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t\t\treturn raycaster.intersectObjects( scene.children, false );\n\n\t\t\t}\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x505050 );\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\troom = new THREE.LineSegments(\n\t\t\t\t\tnew BoxLineGeometry( 6, 6, 6, 10, 10, 10 ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0x808080 } )\n\t\t\t\t);\n\t\t\t\troom.geometry.translate( 0, 3, 0 );\n\t\t\t\tscene.add( room );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( radius, 3 );\n\n\t\t\t\tfor ( let i = 0; i < 200; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tobject.position.y = Math.random() * 4;\n\t\t\t\t\tobject.position.z = Math.random() * 4 - 2;\n\n\t\t\t\t\tobject.userData.velocity = new THREE.Vector3();\n\t\t\t\t\tobject.userData.velocity.x = Math.random() * 0.01 - 0.005;\n\t\t\t\t\tobject.userData.velocity.y = Math.random() * 0.01 - 0.005;\n\t\t\t\t\tobject.userData.velocity.z = Math.random() * 0.01 - 0.005;\n\n\t\t\t\t\troom.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( render );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tfunction onSqueezeStart( ) {\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSqueezeEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectStart( event ) {\n\n\t\t\t\t\tconst controller = event.target;\n\n\t\t\t\t\tconst intersections = getIntersections( controller );\n\t\t\t\t\tlet hadSelection = false;\n\n\t\t\t\t\tfor ( let x = 0; x < intersections.length; x ++ ) {\n\n\t\t\t\t\t\tif ( intersections[ x ].object == horseLayer ) {\n\n\t\t\t\t\t\t\thorseLayer.visible = false;\n\t\t\t\t\t\t\thadSelection = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( intersections[ x ].object == rollercoasterLayer ) {\n\n\t\t\t\t\t\t\tcontroller.attach( rollercoasterLayer );\n\t\t\t\t\t\t\thadSelection = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( intersections[ x ].object == guiLayer ) {\n\n\t\t\t\t\t\t\tconst uv = intersections[ x ].uv;\n\t\t\t\t\t\t\tguiGroup.children[ 0 ].dispatchEvent( { type: 'mousedown', data: { x: uv.x, y: 1 - uv.y }, target: guiGroup } );\n\t\t\t\t\t\t\thadSelection = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.userData.isSelecting = hadSelection === false;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd( ) {\n\n\t\t\t\t\thorseLayer.visible = true;\n\t\t\t\t\tscene.attach( rollercoasterLayer );\n\t\t\t\t\tguiGroup.children[ 0 ].dispatchEvent( { type: 'mouseup', data: { x: 0, y: 0 }, target: guiGroup } );\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller1.addEventListener( 'squeezestart', onSqueezeStart );\n\t\t\t\tcontroller1.addEventListener( 'squeezeend', onSqueezeEnd );\n\t\t\t\tcontroller1.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller1.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller2.addEventListener( 'squeezestart', onSqueezeStart );\n\t\t\t\tcontroller2.addEventListener( 'squeezeend', onSqueezeEnd );\n\t\t\t\tcontroller2.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller2.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\t// The XRControllerModelFactory will automatically fetch controller models\n\t\t\t\t// that match what the user is holding as closely as possible. The models\n\t\t\t\t// should be attached to the object returned from getControllerGrip in\n\t\t\t\t// order to match the orientation of the held device.\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// set up rollercoaster\n\t\t\t\trollercoasterLayer = renderer.xr.createCylinderLayer( 1, Math.PI / 2, 2, new THREE.Vector3( 0, 1.5, - 0.5 ), new THREE.Quaternion(), 1500, 1000, renderRollercoaster );\n\t\t\t\tscene.add( rollercoasterLayer );\n\n\t\t\t\trcscene = new THREE.Scene();\n\t\t\t\trcscene.background = new THREE.Color( 0xf0f0ff );\n\n\t\t\t\tconst rclight = new THREE.HemisphereLight( 0xfff0f0, 0x606066 );\n\t\t\t\trclight.position.set( 1, 1, 1 );\n\t\t\t\trcscene.add( rclight );\n\n\t\t\t\trcscene.add( train );\n\n\t\t\t\trccamera = new THREE.PerspectiveCamera( 50, 1, 0.1, 500 );\n\t\t\t\ttrain.add( rccamera );\n\n\t\t\t\t// environment\n\n\t\t\t\tlet rcgeometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );\n\t\t\t\trcgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst positions = rcgeometry.attributes.position.array;\n\t\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < positions.length; i += 3 ) {\n\n\t\t\t\t\tvertex.fromArray( positions, i );\n\n\t\t\t\t\tvertex.x += Math.random() * 10 - 5;\n\t\t\t\t\tvertex.z += Math.random() * 10 - 5;\n\n\t\t\t\t\tconst distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;\n\t\t\t\t\tvertex.y = Math.random() * Math.max( 0, distance );\n\n\t\t\t\t\tvertex.toArray( positions, i );\n\n\t\t\t\t}\n\n\t\t\t\trcgeometry.computeVertexNormals();\n\n\t\t\t\tlet rcmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\t\tcolor: 0x407000\n\t\t\t\t} );\n\n\t\t\t\tlet rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\trcgeometry = new TreesGeometry( rcmesh );\n\t\t\t\trcmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tside: THREE.DoubleSide, vertexColors: true\n\t\t\t\t} );\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\trcgeometry = new SkyGeometry();\n\t\t\t\trcmaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\t//\n\n\t\t\t\trcgeometry = new RollerCoasterGeometry( curve, 1500 );\n\t\t\t\trcmaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tvertexColors: true\n\t\t\t\t} );\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\trcgeometry = new RollerCoasterLiftersGeometry( curve, 100 );\n\t\t\t\trcmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcmesh.position.y = 0.1;\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\trcgeometry = new RollerCoasterShadowGeometry( curve, 500 );\n\t\t\t\trcmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: 0x305000, depthWrite: false, transparent: true\n\t\t\t\t} );\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcmesh.position.y = 0.1;\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\t//\n\n\t\t\t\trcgeometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );\n\t\t\t\trcmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\t\tcolor: 0xff8080\n\t\t\t\t} );\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcmesh.position.set( - 80, 10, - 70 );\n\t\t\t\trcmesh.rotation.x = Math.PI / 2;\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\tfunfairs.push( rcmesh );\n\n\t\t\t\trcgeometry = new THREE.CylinderGeometry( 5, 6, 4, 10 );\n\t\t\t\trcmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\t\tcolor: 0x8080ff\n\t\t\t\t} );\n\t\t\t\trcmesh = new THREE.Mesh( rcgeometry, rcmaterial );\n\t\t\t\trcmesh.position.set( 50, 2, 30 );\n\t\t\t\trcscene.add( rcmesh );\n\n\t\t\t\tfunfairs.push( rcmesh );\n\n\t\t\t\t// set up horse animation\n\t\t\t\thorseLayer = renderer.xr.createQuadLayer( 1, 1, new THREE.Vector3( - 1.5, 1.5, - 1.5 ), new THREE.Quaternion(), 800, 800, renderQuad );\n\t\t\t\tscene.add( horseLayer );\n\n\t\t\t\thorseLayer.geometry = new THREE.CircleGeometry( .5, 64 );\n\n\t\t\t\thorseCamera = new THREE.PerspectiveCamera( 50, 1, 1, 10000 );\n\t\t\t\thorseCamera.position.y = 300;\n\n\t\t\t\thorseScene = new THREE.Scene();\n\t\t\t\thorseScene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\t//\n\n\t\t\t\tconst light1 = new THREE.DirectionalLight( 0xefefff, 1.5 );\n\t\t\t\tlight1.position.set( 1, 1, 1 ).normalize();\n\t\t\t\thorseScene.add( light1 );\n\n\t\t\t\tconst light2 = new THREE.DirectionalLight( 0xffefef, 1.5 );\n\t\t\t\tlight2.position.set( - 1, - 1, - 1 ).normalize();\n\t\t\t\thorseScene.add( light2 );\n\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/Horse.glb', function ( gltf ) {\n\n\t\t\t\t\thorseMesh = gltf.scene.children[ 0 ];\n\t\t\t\t\thorseMesh.scale.set( 1.5, 1.5, 1.5 );\n\t\t\t\t\thorseScene.add( horseMesh );\n\n\t\t\t\t\thorseMixer = new THREE.AnimationMixer( horseMesh );\n\n\t\t\t\t\thorseMixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();\n\n\t\t\t\t} );\n\n\t\t\t\tfunction onChange() { }\n\n\t\t\t\tfunction onThicknessChange() { }\n\n\t\t\t\t// set up ui\n\t\t\t\tguiScene = new THREE.Scene();\n\t\t\t\tguiScene.background = new THREE.Color( 0x0 );\n\n\t\t\t\tguiCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\t\tguiScene.add( guiCamera );\n\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\t\t\t\tgui.add( parameters, 'radius', 0.0, 1.0 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'tube', 0.0, 1.0 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'tubularSegments', 10, 150, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'radialSegments', 2, 20, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'p', 1, 10, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'q', 0, 10, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'thickness', 0, 1 ).onChange( onThicknessChange );\n\t\t\t\tgui.domElement.style.visibility = 'hidden';\n\n\t\t\t\tguiGroup = new InteractiveGroup( renderer, guiCamera );\n\t\t\t\tguiScene.add( guiGroup );\n\n\t\t\t\tconst mesh = new HTMLMesh( gui.domElement );\n\t\t\t\tguiGroup.add( mesh );\n\n\t\t\t\tconst bbox = new THREE.Box3().setFromObject( guiScene );\n\n\t\t\t\tguiLayer = renderer.xr.createQuadLayer( 1.2, .8, new THREE.Vector3( 1.5, 1.5, - 1.5 ), new THREE.Quaternion(), 1280, 800, renderGui );\n\t\t\t\tscene.add( guiLayer );\n\n\t\t\t\tguiCamera.left = bbox.min.x;\n\t\t\t\tguiCamera.right = bbox.max.x;\n\t\t\t\tguiCamera.top = bbox.max.y;\n\t\t\t\tguiCamera.bottom = bbox.min.y;\n\t\t\t\tguiCamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\tfunction renderGui() {\n\n\t\t\t\trenderer.render( guiScene, guiCamera );\n\n\t\t\t}\n\n\t\t\tfunction renderQuad() {\n\n\t\t\t\thorseTheta += 0.1;\n\n\t\t\t\thorseCamera.position.x = horseRadius * Math.sin( THREE.MathUtils.degToRad( horseTheta ) );\n\t\t\t\thorseCamera.position.z = horseRadius * Math.cos( THREE.MathUtils.degToRad( horseTheta ) );\n\n\t\t\t\thorseCamera.lookAt( 0, 150, 0 );\n\n\t\t\t\tif ( horseMixer ) {\n\n\t\t\t\t\tconst time = Date.now();\n\n\t\t\t\t\thorseMixer.update( ( time - prevTime ) * 0.001 );\n\n\t\t\t\t\tprevTime = time;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( horseScene, horseCamera );\n\n\t\t\t}\n\n\t\t\tconst rcposition = new THREE.Vector3();\n\t\t\tconst tangent = new THREE.Vector3();\n\n\t\t\tconst lookAt = new THREE.Vector3();\n\n\t\t\tlet rcvelocity = 0;\n\t\t\tlet progress = 0;\n\n\t\t\tlet prevTime = performance.now();\n\n\t\t\tfunction renderRollercoaster() {\n\n\t\t\t\tconst time = performance.now();\n\t\t\t\tfor ( let i = 0; i < funfairs.length; i ++ ) {\n\n\t\t\t\t\tfunfairs[ i ].rotation.y = time * 0.0004;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tprogress += rcvelocity;\n\t\t\t\tprogress = progress % 1;\n\n\t\t\t\trcposition.copy( curve.getPointAt( progress ) );\n\t\t\t\trcposition.y += 0.3;\n\n\t\t\t\ttrain.position.copy( rcposition );\n\n\t\t\t\ttangent.copy( curve.getTangentAt( progress ) );\n\n\t\t\t\trcvelocity -= tangent.y * 0.0000001 * rcdelta;\n\t\t\t\trcvelocity = Math.max( 0.00004, Math.min( 0.0002, rcvelocity ) );\n\n\t\t\t\ttrain.lookAt( lookAt.copy( rcposition ).sub( tangent ) );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.render( rcscene, rccamera );\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\tswitch ( data.targetRayMode ) {\n\n\t\t\t\t\tcase 'tracked-pointer':\n\n\t\t\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );\n\n\t\t\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t\t\tcase 'gaze':\n\n\t\t\t\t\t\tgeometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\t\t\t\treturn new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction handleController( controller ) {\n\n\t\t\t\tif ( controller.userData.isSelecting ) {\n\n\t\t\t\t\tconst object = room.children[ count ++ ];\n\n\t\t\t\t\tobject.position.copy( controller.position );\n\t\t\t\t\tobject.userData.velocity.x = ( Math.random() - 0.5 ) * 3;\n\t\t\t\t\tobject.userData.velocity.y = ( Math.random() - 0.5 ) * 3;\n\t\t\t\t\tobject.userData.velocity.z = ( Math.random() - 9 );\n\t\t\t\t\tobject.userData.velocity.applyQuaternion( controller.quaternion );\n\n\t\t\t\t\tif ( count === room.children.length ) count = 0;\n\n\t\t\t\t}\n\n\t\t\t\tconst intersections = getIntersections( controller );\n\t\t\t\tfor ( let x = 0; x < intersections.length; x ++ ) {\n\n\t\t\t\t\tif ( intersections[ x ].object == guiLayer ) {\n\n\t\t\t\t\t\tconst uv = intersections[ x ].uv;\n\t\t\t\t\t\tguiGroup.children[ 0 ].dispatchEvent( { type: 'mousemove', data: { x: uv.x, y: 1 - uv.y }, target: guiGroup } );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.xr.renderLayers( );\n\n\t\t\t\thandleController( controller1 );\n\t\t\t\thandleController( controller2 );\n\n\t\t\t\t// rotate horse\n\t\t\t\thorseLayer.rotation.y -= 0.02;\n\n\t\t\t\t//\n\t\t\t\tconst delta = clock.getDelta() * 0.8;\n\n\t\t\t\tconst range = 3 - radius;\n\n\t\t\t\tfor ( let i = 0; i < room.children.length; i ++ ) {\n\n\t\t\t\t\tconst object = room.children[ i ];\n\n\t\t\t\t\tobject.position.x += object.userData.velocity.x * delta;\n\t\t\t\t\tobject.position.y += object.userData.velocity.y * delta;\n\t\t\t\t\tobject.position.z += object.userData.velocity.z * delta;\n\n\t\t\t\t\t// keep objects inside room\n\n\t\t\t\t\tif ( object.position.x < - range || object.position.x > range ) {\n\n\t\t\t\t\t\tobject.position.x = THREE.MathUtils.clamp( object.position.x, - range, range );\n\t\t\t\t\t\tobject.userData.velocity.x = - object.userData.velocity.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.position.y < radius || object.position.y > 6 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.max( object.position.y, radius );\n\n\t\t\t\t\t\tobject.userData.velocity.x *= 0.98;\n\t\t\t\t\t\tobject.userData.velocity.y = - object.userData.velocity.y * 0.8;\n\t\t\t\t\t\tobject.userData.velocity.z *= 0.98;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.position.z < - range || object.position.z > range ) {\n\n\t\t\t\t\t\tobject.position.z = THREE.MathUtils.clamp( object.position.z, - range, range );\n\t\t\t\t\t\tobject.userData.velocity.z = - object.userData.velocity.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let j = i + 1; j < room.children.length; j ++ ) {\n\n\t\t\t\t\t\tconst object2 = room.children[ j ];\n\n\t\t\t\t\t\tnormal.copy( object.position ).sub( object2.position );\n\n\t\t\t\t\t\tconst distance = normal.length();\n\n\t\t\t\t\t\tif ( distance < 2 * radius ) {\n\n\t\t\t\t\t\t\tnormal.multiplyScalar( 0.5 * distance - radius );\n\n\t\t\t\t\t\t\tobject.position.sub( normal );\n\t\t\t\t\t\t\tobject2.position.add( normal );\n\n\t\t\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\t\t\trelativeVelocity.copy( object.userData.velocity ).sub( object2.userData.velocity );\n\n\t\t\t\t\t\t\tnormal = normal.multiplyScalar( relativeVelocity.dot( normal ) );\n\n\t\t\t\t\t\t\tobject.userData.velocity.sub( normal );\n\t\t\t\t\t\t\tobject2.userData.velocity.add( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.userData.velocity.y -= 9.8 * delta;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - xr layers"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webaudio - orientation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webaudio - orientation:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';\n\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\tlet scene, camera, renderer;\n\n\t\tconst startButton = document.getElementById( 'startButton' );\n\t\tstartButton.addEventListener( 'click', init );\n\n\t\tfunction init() {\n\n\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\toverlay.remove();\n\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t//\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\tcamera.position.set( 3, 2, 3 );\n\n\t\t\tconst reflectionCube = new THREE.CubeTextureLoader()\n\t\t\t\t.setPath( 'textures/cube/SwedishRoyalCastle/' )\n\t\t\t\t.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 2, 20 );\n\n\t\t\t//\n\n\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );\n\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\tscene.add( hemiLight );\n\n\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tdirLight.position.set( 5, 5, 0 );\n\t\t\tdirLight.castShadow = true;\n\t\t\tdirLight.shadow.camera.top = 1;\n\t\t\tdirLight.shadow.camera.bottom = - 1;\n\t\t\tdirLight.shadow.camera.left = - 1;\n\t\t\tdirLight.shadow.camera.right = 1;\n\t\t\tdirLight.shadow.camera.near = 0.1;\n\t\t\tdirLight.shadow.camera.far = 20;\n\t\t\tscene.add( dirLight );\n\n\t\t\t// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );\n\n\t\t\t//\n\n\t\t\tconst mesh = new THREE.Mesh( new THREE.PlaneGeometry( 50, 50 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\tmesh.receiveShadow = true;\n\t\t\tscene.add( mesh );\n\n\t\t\tconst grid = new THREE.GridHelper( 50, 50, 0xc1c1c1, 0xc1c1c1 );\n\t\t\tscene.add( grid );\n\n\t\t\t//\n\n\t\t\tconst listener = new THREE.AudioListener();\n\t\t\tcamera.add( listener );\n\n\t\t\tconst audioElement = document.getElementById( 'music' );\n\t\t\taudioElement.play();\n\n\t\t\tconst positionalAudio = new THREE.PositionalAudio( listener );\n\t\t\tpositionalAudio.setMediaElementSource( audioElement );\n\t\t\tpositionalAudio.setRefDistance( 1 );\n\t\t\tpositionalAudio.setDirectionalCone( 180, 230, 0.1 );\n\n\t\t\tconst helper = new PositionalAudioHelper( positionalAudio, 0.1 );\n\t\t\tpositionalAudio.add( helper );\n\n\t\t\t//\n\n\t\t\tconst gltfLoader = new GLTFLoader();\n\t\t\tgltfLoader.load( 'models/gltf/BoomBox.glb', function ( gltf ) {\n\n\t\t\t\tconst boomBox = gltf.scene;\n\t\t\t\tboomBox.position.set( 0, 0.2, 0 );\n\t\t\t\tboomBox.scale.set( 20, 20, 20 );\n\n\t\t\t\tboomBox.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\tobject.material.envMap = reflectionCube;\n\t\t\t\t\t\tobject.geometry.rotateY( - Math.PI );\n\t\t\t\t\t\tobject.castShadow = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tboomBox.add( positionalAudio );\n\t\t\t\tscene.add( boomBox );\n\t\t\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t} );\n\n\t\t\t// sound is damped behind this wall\n\n\t\t\tconst wallGeometry = new THREE.BoxGeometry( 2, 1, 0.1 );\n\t\t\tconst wallMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, transparent: true, opacity: 0.5 } );\n\n\t\t\tconst wall = new THREE.Mesh( wallGeometry, wallMaterial );\n\t\t\twall.position.set( 0, 0.5, - 0.5 );\n\t\t\tscene.add( wall );\n\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.target.set( 0, 0.1, 0 );\n\t\t\tcontrols.update();\n\t\t\tcontrols.minDistance = 0.5;\n\t\t\tcontrols.maxDistance = 10;\n\t\t\tcontrols.maxPolarAngle = 0.5 * Math.PI;\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js webaudio - orientation music by skullbeatz"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webaudio - sandbox"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webaudio - sandbox:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';\n\n\t\t\tlet camera, controls, scene, renderer, light;\n\n\t\t\tlet material1, material2, material3;\n\n\t\t\tlet analyser1, analyser2, analyser3;\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst startButton = document.getElementById( 'startButton' );\n\t\t\tstartButton.addEventListener( 'click', init );\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\t\toverlay.remove();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.set( 0, 25, 0 );\n\n\t\t\t\tconst listener = new THREE.AudioListener();\n\t\t\t\tcamera.add( listener );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.FogExp2( 0x000000, 0.0025 );\n\n\t\t\t\tlight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 0.5, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst sphere = new THREE.SphereGeometry( 20, 32, 16 );\n\n\t\t\t\tmaterial1 = new THREE.MeshPhongMaterial( { color: 0xffaa00, flatShading: true, shininess: 0 } );\n\t\t\t\tmaterial2 = new THREE.MeshPhongMaterial( { color: 0xff2200, flatShading: true, shininess: 0 } );\n\t\t\t\tmaterial3 = new THREE.MeshPhongMaterial( { color: 0x6622aa, flatShading: true, shininess: 0 } );\n\n\t\t\t\t// sound spheres\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( sphere, material1 );\n\t\t\t\tmesh1.position.set( - 250, 30, 0 );\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\tconst sound1 = new THREE.PositionalAudio( listener );\n\t\t\t\tconst songElement = document.getElementById( 'song' );\n\t\t\t\tsound1.setMediaElementSource( songElement );\n\t\t\t\tsound1.setRefDistance( 20 );\n\t\t\t\tsongElement.play();\n\t\t\t\tmesh1.add( sound1 );\n\n\t\t\t\t//\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( sphere, material2 );\n\t\t\t\tmesh2.position.set( 250, 30, 0 );\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\tconst sound2 = new THREE.PositionalAudio( listener );\n\t\t\t\tconst skullbeatzElement = document.getElementById( 'skullbeatz' );\n\t\t\t\tsound2.setMediaElementSource( skullbeatzElement );\n\t\t\t\tsound2.setRefDistance( 20 );\n\t\t\t\tskullbeatzElement.play();\n\t\t\t\tmesh2.add( sound2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst mesh3 = new THREE.Mesh( sphere, material3 );\n\t\t\t\tmesh3.position.set( 0, 30, - 250 );\n\t\t\t\tscene.add( mesh3 );\n\n\t\t\t\tconst sound3 = new THREE.PositionalAudio( listener );\n\t\t\t\tconst oscillator = listener.context.createOscillator();\n\t\t\t\toscillator.type = 'sine';\n\t\t\t\toscillator.frequency.setValueAtTime( 144, sound3.context.currentTime );\n\t\t\t\toscillator.start( 0 );\n\t\t\t\tsound3.setNodeSource( oscillator );\n\t\t\t\tsound3.setRefDistance( 20 );\n\t\t\t\tsound3.setVolume( 0.5 );\n\t\t\t\tmesh3.add( sound3 );\n\n\t\t\t\t// analysers\n\n\t\t\t\tanalyser1 = new THREE.AudioAnalyser( sound1, 32 );\n\t\t\t\tanalyser2 = new THREE.AudioAnalyser( sound2, 32 );\n\t\t\t\tanalyser3 = new THREE.AudioAnalyser( sound3, 32 );\n\n\t\t\t\t// global ambient audio\n\n\t\t\t\tconst sound4 = new THREE.Audio( listener );\n\t\t\t\tconst utopiaElement = document.getElementById( 'utopia' );\n\t\t\t\tsound4.setMediaElementSource( utopiaElement );\n\t\t\t\tsound4.setVolume( 0.5 );\n\t\t\t\tutopiaElement.play();\n\n\t\t\t\t// ground\n\n\t\t\t\tconst helper = new THREE.GridHelper( 1000, 10, 0x444444, 0x444444 );\n\t\t\t\thelper.position.y = 0.1;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\t//\n\n\t\t\t\tconst SoundControls = function () {\n\n\t\t\t\t\tthis.master = listener.getMasterVolume();\n\t\t\t\t\tthis.firstSphere = sound1.getVolume();\n\t\t\t\t\tthis.secondSphere = sound2.getVolume();\n\t\t\t\t\tthis.thirdSphere = sound3.getVolume();\n\t\t\t\t\tthis.Ambient = sound4.getVolume();\n\n\t\t\t\t};\n\n\t\t\t\tconst GeneratorControls = function () {\n\n\t\t\t\t\tthis.frequency = oscillator.frequency.value;\n\t\t\t\t\tthis.wavetype = oscillator.type;\n\n\t\t\t\t};\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tconst soundControls = new SoundControls();\n\t\t\t\tconst generatorControls = new GeneratorControls();\n\t\t\t\tconst volumeFolder = gui.addFolder( 'sound volume' );\n\t\t\t\tconst generatorFolder = gui.addFolder( 'sound generator' );\n\n\t\t\t\tvolumeFolder.add( soundControls, 'master' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\t\tlistener.setMasterVolume( soundControls.master );\n\n\t\t\t\t} );\n\t\t\t\tvolumeFolder.add( soundControls, 'firstSphere' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\t\tsound1.setVolume( soundControls.firstSphere );\n\n\t\t\t\t} );\n\t\t\t\tvolumeFolder.add( soundControls, 'secondSphere' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\t\tsound2.setVolume( soundControls.secondSphere );\n\n\t\t\t\t} );\n\n\t\t\t\tvolumeFolder.add( soundControls, 'thirdSphere' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\t\tsound3.setVolume( soundControls.thirdSphere );\n\n\t\t\t\t} );\n\t\t\t\tvolumeFolder.add( soundControls, 'Ambient' ).min( 0.0 ).max( 1.0 ).step( 0.01 ).onChange( function () {\n\n\t\t\t\t\tsound4.setVolume( soundControls.Ambient );\n\n\t\t\t\t} );\n\t\t\t\tvolumeFolder.open();\n\t\t\t\tgeneratorFolder.add( generatorControls, 'frequency' ).min( 50.0 ).max( 5000.0 ).step( 1.0 ).onChange( function () {\n\n\t\t\t\t\toscillator.frequency.setValueAtTime( generatorControls.frequency, listener.context.currentTime );\n\n\t\t\t\t} );\n\t\t\t\tgeneratorFolder.add( generatorControls, 'wavetype', [ 'sine', 'square', 'sawtooth', 'triangle' ] ).onChange( function () {\n\n\t\t\t\t\toscillator.type = generatorControls.wavetype;\n\n\t\t\t\t} );\n\n\t\t\t\tgeneratorFolder.open();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new FirstPersonControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.movementSpeed = 70;\n\t\t\t\tcontrols.lookSpeed = 0.05;\n\t\t\t\tcontrols.lookVertical = false;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tcontrols.update( delta );\n\n\t\t\t\tmaterial1.emissive.b = analyser1.getAverageFrequency() / 256;\n\t\t\t\tmaterial2.emissive.b = analyser2.getAverageFrequency() / 256;\n\t\t\t\tmaterial3.emissive.b = analyser3.getAverageFrequency() / 256;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webaudio - sandbox music by larrylarrybb , skullbeatz and congusbongus navigate with WASD / arrows / mouse"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webaudio - timing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webaudio - timing:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\tlet scene, camera, renderer, clock;\n\n\t\tconst objects = [];\n\n\t\tconst speed = 2.5;\n\t\tconst height = 3;\n\t\tconst offset = 0.5;\n\n\t\tconst startButton = document.getElementById( 'startButton' );\n\t\tstartButton.addEventListener( 'click', init );\n\n\t\tfunction init() {\n\n\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\toverlay.remove();\n\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tscene = new THREE.Scene();\n\n\t\t\tclock = new THREE.Clock();\n\n\t\t\t//\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\tcamera.position.set( 7, 3, 7 );\n\n\t\t\t// lights\n\n\t\t\tconst ambientLight = new THREE.AmbientLight( 0xcccccc );\n\t\t\tscene.add( ambientLight );\n\n\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\tdirectionalLight.position.set( 0, 5, 5 );\n\t\t\tscene.add( directionalLight );\n\n\t\t\tconst d = 5;\n\t\t\tdirectionalLight.castShadow = true;\n\t\t\tdirectionalLight.shadow.camera.left = - d;\n\t\t\tdirectionalLight.shadow.camera.right = d;\n\t\t\tdirectionalLight.shadow.camera.top = d;\n\t\t\tdirectionalLight.shadow.camera.bottom = - d;\n\n\t\t\tdirectionalLight.shadow.camera.near = 1;\n\t\t\tdirectionalLight.shadow.camera.far = 20;\n\n\t\t\tdirectionalLight.shadow.mapSize.x = 1024;\n\t\t\tdirectionalLight.shadow.mapSize.y = 1024;\n\n\t\t\t// audio\n\n\t\t\tconst audioLoader = new THREE.AudioLoader();\n\n\t\t\tconst listener = new THREE.AudioListener();\n\t\t\tcamera.add( listener );\n\n\t\t\t// floor\n\n\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 10, 10 );\n\t\t\tconst floorMaterial = new THREE.MeshLambertMaterial( { color: 0x4676b6 } );\n\n\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\tfloor.rotation.x = Math.PI * - 0.5;\n\t\t\tfloor.receiveShadow = true;\n\t\t\tscene.add( floor );\n\n\t\t\t// objects\n\n\t\t\tconst count = 5;\n\t\t\tconst radius = 3;\n\n\t\t\tconst ballGeometry = new THREE.SphereGeometry( 0.3, 32, 16 );\n\t\t\tballGeometry.translate( 0, 0.3, 0 );\n\t\t\tconst ballMaterial = new THREE.MeshLambertMaterial( { color: 0xcccccc } );\n\n\t\t\t// create objects when audio buffer is loaded\n\n\t\t\taudioLoader.load( 'sounds/ping_pong.mp3', function ( buffer ) {\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tconst s = i / count * Math.PI * 2;\n\n\t\t\t\t\tconst ball = new THREE.Mesh( ballGeometry, ballMaterial );\n\t\t\t\t\tball.castShadow = true;\n\t\t\t\t\tball.userData.down = false;\n\n\t\t\t\t\tball.position.x = radius * Math.cos( s );\n\t\t\t\t\tball.position.z = radius * Math.sin( s );\n\n\t\t\t\t\tconst audio = new THREE.PositionalAudio( listener );\n\t\t\t\t\taudio.setBuffer( buffer );\n\t\t\t\t\tball.add( audio );\n\n\t\t\t\t\tscene.add( ball );\n\t\t\t\t\tobjects.push( ball );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t//\n\n\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.minDistance = 1;\n\t\t\tcontrols.maxDistance = 25;\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\tconst ball = objects[ i ];\n\n\t\t\t\tconst previousHeight = ball.position.y;\n\t\t\t\tball.position.y = Math.abs( Math.sin( i * offset + ( time * speed ) ) * height );\n\n\t\t\t\tif ( ball.position.y < previousHeight ) {\n\n\t\t\t\t\tball.userData.down = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ball.userData.down === true ) {\n\n\t\t\t\t\t\t// ball changed direction from down to up\n\n\t\t\t\t\t\tconst audio = ball.children[ 0 ];\n\t\t\t\t\t\taudio.play(); // play audio with perfect timing when ball hits the surface\n\t\t\t\t\t\tball.userData.down = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js webaudio - timing sound effect by michorvath"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webaudio - visualizer"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webaudio - visualizer:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet scene, camera, renderer, analyser, uniforms;\n\n\t\t\tconst startButton = document.getElementById( 'startButton' );\n\t\t\tstartButton.addEventListener( 'click', init );\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst fftSize = 128;\n\n\t\t\t\t//\n\n\t\t\t\tconst overlay = document.getElementById( 'overlay' );\n\t\t\t\toverlay.remove();\n\n\t\t\t\t//\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.Camera();\n\n\t\t\t\t//\n\n\t\t\t\tconst listener = new THREE.AudioListener();\n\n\t\t\t\tconst audio = new THREE.Audio( listener );\n\t\t\t\tconst file = './sounds/376737_Skullbeatz___Bad_Cat_Maste.mp3';\n\n\t\t\t\tif ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {\n\n\t\t\t\t\tconst loader = new THREE.AudioLoader();\n\t\t\t\t\tloader.load( file, function ( buffer ) {\n\n\t\t\t\t\t\taudio.setBuffer( buffer );\n\t\t\t\t\t\taudio.play();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mediaElement = new Audio( file );\n\t\t\t\t\tmediaElement.play();\n\n\t\t\t\t\taudio.setMediaElementSource( mediaElement );\n\n\t\t\t\t}\n\n\t\t\t\tanalyser = new THREE.AudioAnalyser( audio, fftSize );\n\n\t\t\t\t//\n\n\t\t\t\tuniforms = {\n\n\t\t\t\t\ttAudioData: { value: new THREE.DataTexture( analyser.data, fftSize / 2, 1, THREE.RedFormat ) }\n\n\t\t\t\t};\n\n\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\tuniforms: uniforms,\n\t\t\t\t\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n\t\t\t\t\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent\n\n\t\t\t\t} );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( 1, 1 );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tanalyser.getFrequencyData();\n\n\t\t\t\tuniforms.tAudioData.value.needsUpdate = true;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webaudio - visualizer music by skullbeatz"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates ar - cones"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js ar - cones:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { ARButton } from 'three/addons/webxr/ARButton.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );\n\t\t\t\tlight.position.set( 0.5, 1, 0.25 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.appendChild( ARButton.createButton( renderer ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.CylinderGeometry( 0, 0.05, 0.2, 32 ).rotateX( Math.PI / 2 );\n\n\t\t\t\tfunction onSelect() {\n\n\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random() } );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.set( 0, 0, - 0.3 ).applyMatrix4( controller.matrixWorld );\n\t\t\t\t\tmesh.quaternion.setFromRotationMatrix( controller.matrixWorld );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tcontroller = renderer.xr.getController( 0 );\n\t\t\t\tcontroller.addEventListener( 'select', onSelect );\n\t\t\t\tscene.add( controller );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js ar - cones"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates ar - hit test"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js ar - hit test:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { ARButton } from 'three/addons/webxr/ARButton.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\n\t\t\tlet reticle;\n\n\t\t\tlet hitTestSource = null;\n\t\t\tlet hitTestSourceRequested = false;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );\n\t\t\t\tlight.position.set( 0.5, 1, 0.25 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.CylinderGeometry( 0.1, 0.1, 0.2, 32 ).translate( 0, 0.1, 0 );\n\n\t\t\t\tfunction onSelect() {\n\n\t\t\t\t\tif ( reticle.visible ) {\n\n\t\t\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random() } );\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\treticle.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\t\t\t\t\t\tmesh.scale.y = Math.random() * 2 + 1;\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'select', onSelect );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'select', onSelect );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\treticle = new THREE.Mesh(\n\t\t\t\t\tnew THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial()\n\t\t\t\t);\n\t\t\t\treticle.matrixAutoUpdate = false;\n\t\t\t\treticle.visible = false;\n\t\t\t\tscene.add( reticle );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate( timestamp, frame ) {\n\n\t\t\t\tif ( frame ) {\n\n\t\t\t\t\tconst referenceSpace = renderer.xr.getReferenceSpace();\n\t\t\t\t\tconst session = renderer.xr.getSession();\n\n\t\t\t\t\tif ( hitTestSourceRequested === false ) {\n\n\t\t\t\t\t\tsession.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {\n\n\t\t\t\t\t\t\tsession.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {\n\n\t\t\t\t\t\t\t\thitTestSource = source;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tsession.addEventListener( 'end', function () {\n\n\t\t\t\t\t\t\thitTestSourceRequested = false;\n\t\t\t\t\t\t\thitTestSource = null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\thitTestSourceRequested = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hitTestSource ) {\n\n\t\t\t\t\t\tconst hitTestResults = frame.getHitTestResults( hitTestSource );\n\n\t\t\t\t\t\tif ( hitTestResults.length ) {\n\n\t\t\t\t\t\t\tconst hit = hitTestResults[ 0 ];\n\n\t\t\t\t\t\t\treticle.visible = true;\n\t\t\t\t\t\t\treticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treticle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js ar - hit test"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates ar - lighting estimation"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js ar - lighting estimation:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { ARButton } from 'three/addons/webxr/ARButton.js';\n\t\t\timport { XREstimatedLight } from 'three/addons/webxr/XREstimatedLight.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller;\n\t\t\tlet defaultEnvironment;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n\t\t\t\tconst defaultLight = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );\n\t\t\t\tdefaultLight.position.set( 0.5, 1, 0.25 );\n\t\t\t\tscene.add( defaultLight );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t// Don't add the XREstimatedLight to the scene initially.\n\t\t\t\t// It doesn't have any estimated lighting values until an AR session starts.\n\n\t\t\t\tconst xrLight = new XREstimatedLight( renderer );\n\n\t\t\t\txrLight.addEventListener( 'estimationstart', () => {\n\n\t\t\t\t\t// Swap the default light out for the estimated one once we start getting some estimated values.\n\t\t\t\t\tscene.add( xrLight );\n\t\t\t\t\tscene.remove( defaultLight );\n\n\t\t\t\t\t// The estimated lighting also provides an environment cubemap, which we can apply here.\n\t\t\t\t\tif ( xrLight.environment ) {\n\n\t\t\t\t\t\tscene.environment = xrLight.environment;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\txrLight.addEventListener( 'estimationend', () => {\n\n\t\t\t\t\t// Swap the lights back when we stop receiving estimated values.\n\t\t\t\t\tscene.add( defaultLight );\n\t\t\t\t\tscene.remove( xrLight );\n\n\t\t\t\t\t// Revert back to the default environment.\n\t\t\t\t\tscene.environment = defaultEnvironment;\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tdefaultEnvironment = texture;\n\n\t\t\t\t\t\tscene.environment = defaultEnvironment;\n\n\t\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\t// In order for lighting estimation to work, 'light-estimation' must be included as either an optional or required feature.\n\t\t\t\tdocument.body.appendChild( ARButton.createButton( renderer, { optionalFeatures: [ 'light-estimation' ] } ) );\n\n\t\t\t\t//\n\n\t\t\t\tconst ballGeometry = new THREE.SphereGeometry( 0.175, 32, 32 );\n\t\t\t\tconst ballGroup = new THREE.Group();\n\t\t\t\tballGroup.position.z = - 2;\n\n\t\t\t\tconst rows = 3;\n\t\t\t\tconst cols = 3;\n\n\t\t\t\tfor ( let i = 0; i < rows; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < cols; j ++ ) {\n\n\t\t\t\t\t\tconst ballMaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\t\tcolor: 0xdddddd,\n\t\t\t\t\t\t\troughness: i / rows,\n\t\t\t\t\t\t\tmetalness: j / cols\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tconst ballMesh = new THREE.Mesh( ballGeometry, ballMaterial );\n\t\t\t\t\t\tballMesh.position.set( ( i + 0.5 - rows * 0.5 ) * 0.4, ( j + 0.5 - cols * 0.5 ) * 0.4, 0 );\n\t\t\t\t\t\tballGroup.add( ballMesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( ballGroup );\n\n\t\t\t\t//\n\n\t\t\t\tfunction onSelect() {\n\n\t\t\t\t\tballGroup.position.set( 0, 0, - 2 ).applyMatrix4( controller.matrixWorld );\n\t\t\t\t\tballGroup.quaternion.setFromRotationMatrix( controller.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tcontroller = renderer.xr.getController( 0 );\n\t\t\t\tcontroller.addEventListener( 'select', onSelect );\n\t\t\t\tscene.add( controller );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js ar - lighting estimation"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates ar - plane detection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js ar - plane detection:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { ARButton } from 'three/addons/webxr/ARButton.js';\n\t\t\timport { XRPlanes } from 'three/addons/webxr/XRPlanes.js';\n\n\t\t\t//\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.xr.enabled = true;\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tdocument.body.appendChild( ARButton.createButton( renderer, {\n\t\t\t\trequiredFeatures: [ 'plane-detection' ]\n\t\t\t} ) );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t//\n\n\t\t\tconst scene = new THREE.Scene();\n\n\t\t\tconst planes = new XRPlanes( renderer );\n\t\t\tscene.add( planes );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n\t\t\tconst light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );\n\t\t\tlight.position.set( 0.5, 1, 0.25 );\n\t\t\tscene.add( light );\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js ar - plane detection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - handinput"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - handinput:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\t\timport { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet hand1, hand2;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\t\tconst floorMaterial = new THREE.MeshStandardMaterial( { color: 0x666666 } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 2;\n\t\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\t\tlight.shadow.camera.right = 2;\n\t\t\t\tlight.shadow.camera.left = - 2;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst sessionInit = {\n\t\t\t\t\trequiredFeatures: [ 'hand-tracking' ]\n\t\t\t\t};\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer, sessionInit ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\t\t\t\tconst handModelFactory = new XRHandModelFactory();\n\n\t\t\t\t// Hand 1\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\thand1 = renderer.xr.getHand( 0 );\n\t\t\t\thand1.add( handModelFactory.createHandModel( hand1 ) );\n\n\t\t\t\tscene.add( hand1 );\n\n\t\t\t\t// Hand 2\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\thand2 = renderer.xr.getHand( 1 );\n\t\t\t\thand2.add( handModelFactory.createHandModel( hand2 ) );\n\t\t\t\tscene.add( hand2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );\n\n\t\t\t\tconst line = new THREE.Line( geometry );\n\t\t\t\tline.name = 'line';\n\t\t\t\tline.scale.z = 5;\n\n\t\t\t\tcontroller1.add( line.clone() );\n\t\t\t\tcontroller2.add( line.clone() );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - handinput"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - handinput - cubes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - handinput - cubes:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\t\timport { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet hand1, hand2;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tconst tmpVector1 = new THREE.Vector3();\n\t\t\tconst tmpVector2 = new THREE.Vector3();\n\n\t\t\tlet controls;\n\n\t\t\tlet grabbing = false;\n\t\t\tconst scaling = {\n\t\t\t\tactive: false,\n\t\t\t\tinitialDistance: 0,\n\t\t\t\tobject: null,\n\t\t\t\tinitialScale: 1\n\t\t\t};\n\n\t\t\tconst spheres = [];\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\t\tconst floorMaterial = new THREE.MeshStandardMaterial( { color: 0x666666 } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 2;\n\t\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\t\tlight.shadow.camera.right = 2;\n\t\t\t\tlight.shadow.camera.left = - 2;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst sessionInit = {\n\t\t\t\t\trequiredFeatures: [ 'hand-tracking' ]\n\t\t\t\t};\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer, sessionInit ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\t\t\t\tconst handModelFactory = new XRHandModelFactory();\n\n\t\t\t\t// Hand 1\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\thand1 = renderer.xr.getHand( 0 );\n\t\t\t\thand1.addEventListener( 'pinchstart', onPinchStartLeft );\n\t\t\t\thand1.addEventListener( 'pinchend', () => {\n\n\t\t\t\t\tscaling.active = false;\n\n\t\t\t\t} );\n\t\t\t\thand1.add( handModelFactory.createHandModel( hand1 ) );\n\n\t\t\t\tscene.add( hand1 );\n\n\t\t\t\t// Hand 2\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\thand2 = renderer.xr.getHand( 1 );\n\t\t\t\thand2.addEventListener( 'pinchstart', onPinchStartRight );\n\t\t\t\thand2.addEventListener( 'pinchend', onPinchEndRight );\n\t\t\t\thand2.add( handModelFactory.createHandModel( hand2 ) );\n\t\t\t\tscene.add( hand2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );\n\n\t\t\t\tconst line = new THREE.Line( geometry );\n\t\t\t\tline.name = 'line';\n\t\t\t\tline.scale.z = 5;\n\n\t\t\t\tcontroller1.add( line.clone() );\n\t\t\t\tcontroller2.add( line.clone() );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tconst SphereRadius = 0.05;\n\t\t\tfunction onPinchStartLeft( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tif ( grabbing ) {\n\n\t\t\t\t\tconst indexTip = controller.joints[ 'index-finger-tip' ];\n\t\t\t\t\tconst sphere = collideObject( indexTip );\n\n\t\t\t\t\tif ( sphere ) {\n\n\t\t\t\t\t\tconst sphere2 = hand2.userData.selected;\n\t\t\t\t\t\tconsole.log( 'sphere1', sphere, 'sphere2', sphere2 );\n\t\t\t\t\t\tif ( sphere === sphere2 ) {\n\n\t\t\t\t\t\t\tscaling.active = true;\n\t\t\t\t\t\t\tscaling.object = sphere;\n\t\t\t\t\t\t\tscaling.initialScale = sphere.scale.x;\n\t\t\t\t\t\t\tscaling.initialDistance = indexTip.position.distanceTo( hand2.joints[ 'index-finger-tip' ].position );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( SphereRadius, SphereRadius, SphereRadius );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: Math.random() * 0xffffff,\n\t\t\t\t\troughness: 1.0,\n\t\t\t\t\tmetalness: 0.0\n\t\t\t\t} );\n\t\t\t\tconst spawn = new THREE.Mesh( geometry, material );\n\t\t\t\tspawn.geometry.computeBoundingSphere();\n\n\t\t\t\tconst indexTip = controller.joints[ 'index-finger-tip' ];\n\t\t\t\tspawn.position.copy( indexTip.position );\n\t\t\t\tspawn.quaternion.copy( indexTip.quaternion );\n\n\t\t\t\tspheres.push( spawn );\n\n\t\t\t\tscene.add( spawn );\n\n\t\t\t}\n\n\t\t\tfunction collideObject( indexTip ) {\n\n\t\t\t\tfor ( let i = 0; i < spheres.length; i ++ ) {\n\n\t\t\t\t\tconst sphere = spheres[ i ];\n\t\t\t\t\tconst distance = indexTip.getWorldPosition( tmpVector1 ).distanceTo( sphere.getWorldPosition( tmpVector2 ) );\n\n\t\t\t\t\tif ( distance < sphere.geometry.boundingSphere.radius * sphere.scale.x ) {\n\n\t\t\t\t\t\treturn sphere;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfunction onPinchStartRight( event ) {\n\n\t\t\t\tconst controller = event.target;\n\t\t\t\tconst indexTip = controller.joints[ 'index-finger-tip' ];\n\t\t\t\tconst object = collideObject( indexTip );\n\t\t\t\tif ( object ) {\n\n\t\t\t\t\tgrabbing = true;\n\t\t\t\t\tindexTip.attach( object );\n\t\t\t\t\tcontroller.userData.selected = object;\n\t\t\t\t\tconsole.log( 'Selected', object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onPinchEndRight( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tif ( controller.userData.selected !== undefined ) {\n\n\t\t\t\t\tconst object = controller.userData.selected;\n\t\t\t\t\tobject.material.emissive.b = 0;\n\t\t\t\t\tscene.attach( object );\n\n\t\t\t\t\tcontroller.userData.selected = undefined;\n\t\t\t\t\tgrabbing = false;\n\n\t\t\t\t}\n\n\t\t\t\tscaling.active = false;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( scaling.active ) {\n\n\t\t\t\t\tconst indexTip1Pos = hand1.joints[ 'index-finger-tip' ].position;\n\t\t\t\t\tconst indexTip2Pos = hand2.joints[ 'index-finger-tip' ].position;\n\t\t\t\t\tconst distance = indexTip1Pos.distanceTo( indexTip2Pos );\n\t\t\t\t\tconst newScale = scaling.initialScale + distance / scaling.initialDistance - 1;\n\t\t\t\t\tscaling.object.scale.setScalar( newScale );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - handinput - cubes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - handinput - profiles"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - handinput - profiles:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\t\timport { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet hand1, hand2;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tconst handModels = {\n\t\t\t\tleft: null,\n\t\t\t\tright: null\n\t\t\t};\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\twindow.scene = scene;\n\t\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\t\tconst floorMaterial = new THREE.MeshStandardMaterial( { color: 0x666666 } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 2;\n\t\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\t\tlight.shadow.camera.right = 2;\n\t\t\t\tlight.shadow.camera.left = - 2;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst sessionInit = {\n\t\t\t\t\trequiredFeatures: [ 'hand-tracking' ]\n\t\t\t\t};\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer, sessionInit ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\t\t\t\tconst handModelFactory = new XRHandModelFactory();\n\n\t\t\t\t// Hand 1\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\thand1 = renderer.xr.getHand( 0 );\n\t\t\t\thand1.userData.currentHandModel = 0;\n\t\t\t\tscene.add( hand1 );\n\n\t\t\t\thandModels.left = [\n\t\t\t\t\thandModelFactory.createHandModel( hand1, 'boxes' ),\n\t\t\t\t\thandModelFactory.createHandModel( hand1, 'spheres' ),\n\t\t\t\t\thandModelFactory.createHandModel( hand1, 'mesh' )\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst model = handModels.left[ i ];\n\t\t\t\t\tmodel.visible = i == 0;\n\t\t\t\t\thand1.add( model );\n\n\t\t\t\t}\n\n\t\t\t\thand1.addEventListener( 'pinchend', function () {\n\n\t\t\t\t\thandModels.left[ this.userData.currentHandModel ].visible = false;\n\t\t\t\t\tthis.userData.currentHandModel = ( this.userData.currentHandModel + 1 ) % 3;\n\t\t\t\t\thandModels.left[ this.userData.currentHandModel ].visible = true;\n\n\t\t\t\t} );\n\n\t\t\t\t// Hand 2\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\thand2 = renderer.xr.getHand( 1 );\n\t\t\t\thand2.userData.currentHandModel = 0;\n\t\t\t\tscene.add( hand2 );\n\n\t\t\t\thandModels.right = [\n\t\t\t\t\thandModelFactory.createHandModel( hand2, 'boxes' ),\n\t\t\t\t\thandModelFactory.createHandModel( hand2, 'spheres' ),\n\t\t\t\t\thandModelFactory.createHandModel( hand2, 'mesh' )\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst model = handModels.right[ i ];\n\t\t\t\t\tmodel.visible = i == 0;\n\t\t\t\t\thand2.add( model );\n\n\t\t\t\t}\n\n\t\t\t\thand2.addEventListener( 'pinchend', function () {\n\n\t\t\t\t\thandModels.right[ this.userData.currentHandModel ].visible = false;\n\t\t\t\t\tthis.userData.currentHandModel = ( this.userData.currentHandModel + 1 ) % 3;\n\t\t\t\t\thandModels.right[ this.userData.currentHandModel ].visible = true;\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );\n\n\t\t\t\tconst line = new THREE.Line( geometry );\n\t\t\t\tline.name = 'line';\n\t\t\t\tline.scale.z = 5;\n\n\t\t\t\tcontroller1.add( line.clone() );\n\t\t\t\tcontroller2.add( line.clone() );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - handinput - profiles"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - handinput - point and click"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - handinput - point and click:\n\n```javascript\nimport * as THREE from 'three';\n\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\timport { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';\n\t\timport { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';\n\t\timport { createText } from 'three/addons/webxr/Text2D.js';\n\n\t\timport { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';\n\n\t\tclass Object3D extends Component { }\n\n\t\tObject3D.schema = {\n\t\t\tobject: { type: Types.Ref }\n\t\t};\n\n\t\tclass Button extends Component { }\n\n\t\tButton.schema = {\n\t\t\t// button states: [none, hovered, pressed]\n\t\t\tcurrState: { type: Types.String, default: 'none' },\n\t\t\tprevState: { type: Types.String, default: 'none' },\n\t\t\taction: { type: Types.Ref, default: () => { } }\n\t\t};\n\n\t\tclass ButtonSystem extends System {\n\n\t\t\texecute( /* delta, time */ ) {\n\n\t\t\t\tthis.queries.buttons.results.forEach( entity => {\n\n\t\t\t\t\tconst button = entity.getMutableComponent( Button );\n\t\t\t\t\tconst buttonMesh = entity.getComponent( Object3D ).object;\n\t\t\t\t\tif ( button.currState == 'none' ) {\n\n\t\t\t\t\t\tbuttonMesh.scale.set( 1, 1, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuttonMesh.scale.set( 1.1, 1.1, 1.1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( button.currState == 'pressed' && button.prevState != 'pressed' ) {\n\n\t\t\t\t\t\tbutton.action();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// preserve prevState, clear currState\n\t\t\t\t\t// HandRaySystem will update currState\n\t\t\t\t\tbutton.prevState = button.currState;\n\t\t\t\t\tbutton.currState = 'none';\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tButtonSystem.queries = {\n\t\t\tbuttons: {\n\t\t\t\tcomponents: [ Button ]\n\t\t\t}\n\t\t};\n\n\t\tclass Intersectable extends TagComponent { }\n\n\t\tclass HandRaySystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.handPointers = attributes.handPointers;\n\n\t\t\t}\n\n\t\t\texecute( /* delta, time */ ) {\n\n\t\t\t\tthis.handPointers.forEach( hp => {\n\n\t\t\t\t\tlet distance = null;\n\t\t\t\t\tlet intersectingEntity = null;\n\t\t\t\t\tthis.queries.intersectable.results.forEach( entity => {\n\n\t\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\t\tconst intersections = hp.intersectObject( object, false );\n\t\t\t\t\t\tif ( intersections && intersections.length > 0 ) {\n\n\t\t\t\t\t\t\tif ( distance == null || intersections[ 0 ].distance < distance ) {\n\n\t\t\t\t\t\t\t\tdistance = intersections[ 0 ].distance;\n\t\t\t\t\t\t\t\tintersectingEntity = entity;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tif ( distance ) {\n\n\t\t\t\t\t\thp.setCursor( distance );\n\t\t\t\t\t\tif ( intersectingEntity.hasComponent( Button ) ) {\n\n\t\t\t\t\t\t\tconst button = intersectingEntity.getMutableComponent( Button );\n\t\t\t\t\t\t\tif ( hp.isPinched() ) {\n\n\t\t\t\t\t\t\t\tbutton.currState = 'pressed';\n\n\t\t\t\t\t\t\t} else if ( button.currState != 'pressed' ) {\n\n\t\t\t\t\t\t\t\tbutton.currState = 'hovered';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\thp.setCursor( 1.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tHandRaySystem.queries = {\n\t\t\tintersectable: {\n\t\t\t\tcomponents: [ Intersectable ]\n\t\t\t}\n\t\t};\n\n\t\tclass Rotating extends TagComponent { }\n\n\t\tclass RotatingSystem extends System {\n\n\t\t\texecute( delta/*, time*/ ) {\n\n\t\t\t\tthis.queries.rotatingObjects.results.forEach( entity => {\n\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tobject.rotation.x += 0.4 * delta;\n\t\t\t\t\tobject.rotation.y += 0.4 * delta;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tRotatingSystem.queries = {\n\t\t\trotatingObjects: {\n\t\t\t\tcomponents: [ Rotating ]\n\t\t\t}\n\t\t};\n\n\t\tclass HandsInstructionText extends TagComponent { }\n\n\t\tclass InstructionSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.controllers = attributes.controllers;\n\n\t\t\t}\n\n\t\t\texecute( /* delta, time */ ) {\n\n\t\t\t\tlet visible = false;\n\t\t\t\tthis.controllers.forEach( controller => {\n\n\t\t\t\t\tif ( controller.visible ) {\n\n\t\t\t\t\t\tvisible = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tthis.queries.instructionTexts.results.forEach( entity => {\n\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tobject.visible = visible;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tInstructionSystem.queries = {\n\t\t\tinstructionTexts: {\n\t\t\t\tcomponents: [ HandsInstructionText ]\n\t\t\t}\n\t\t};\n\n\t\tclass OffsetFromCamera extends Component { }\n\n\t\tOffsetFromCamera.schema = {\n\t\t\tx: { type: Types.Number, default: 0 },\n\t\t\ty: { type: Types.Number, default: 0 },\n\t\t\tz: { type: Types.Number, default: 0 },\n\t\t};\n\n\t\tclass NeedCalibration extends TagComponent { }\n\n\t\tclass CalibrationSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.camera = attributes.camera;\n\t\t\t\tthis.renderer = attributes.renderer;\n\n\t\t\t}\n\n\t\t\texecute( /* delta, time */ ) {\n\n\t\t\t\tthis.queries.needCalibration.results.forEach( entity => {\n\n\t\t\t\t\tif ( this.renderer.xr.getSession() ) {\n\n\t\t\t\t\t\tconst offset = entity.getComponent( OffsetFromCamera );\n\t\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\t\tconst xrCamera = this.renderer.xr.getCamera();\n\t\t\t\t\t\tobject.position.x = xrCamera.position.x + offset.x;\n\t\t\t\t\t\tobject.position.y = xrCamera.position.y + offset.y;\n\t\t\t\t\t\tobject.position.z = xrCamera.position.z + offset.z;\n\t\t\t\t\t\tentity.removeComponent( NeedCalibration );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tCalibrationSystem.queries = {\n\t\t\tneedCalibration: {\n\t\t\t\tcomponents: [ NeedCalibration ]\n\t\t\t}\n\t\t};\n\n\t\tconst world = new World();\n\t\tconst clock = new THREE.Clock();\n\t\tlet camera, scene, renderer;\n\n\t\tinit();\n\n\t\tfunction makeButtonMesh( x, y, z, color ) {\n\n\t\t\tconst geometry = new THREE.BoxGeometry( x, y, z );\n\t\t\tconst material = new THREE.MeshPhongMaterial( { color: color } );\n\t\t\tconst buttonMesh = new THREE.Mesh( geometry, material );\n\t\t\tbuttonMesh.castShadow = true;\n\t\t\tbuttonMesh.receiveShadow = true;\n\t\t\treturn buttonMesh;\n\n\t\t}\n\n\t\tfunction init() {\n\n\t\t\tconst container = document.createElement( 'div' );\n\t\t\tdocument.body.appendChild( container );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\tcamera.position.set( 0, 1.2, 0.3 );\n\n\t\t\tscene.add( new THREE.HemisphereLight( 0xcccccc, 0x999999, 3 ) );\n\n\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\tlight.castShadow = true;\n\t\t\tlight.shadow.camera.top = 2;\n\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\tlight.shadow.camera.right = 2;\n\t\t\tlight.shadow.camera.left = - 2;\n\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\tscene.add( light );\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\trenderer.xr.enabled = true;\n\t\t\trenderer.xr.cameraAutoUpdate = false;\n\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst sessionInit = {\n\t\t\t\trequiredFeatures: [ 'hand-tracking' ]\n\t\t\t};\n\n\t\t\tdocument.body.appendChild( VRButton.createButton( renderer, sessionInit ) );\n\n\t\t\t// controllers\n\t\t\tconst controller1 = renderer.xr.getController( 0 );\n\t\t\tscene.add( controller1 );\n\n\t\t\tconst controller2 = renderer.xr.getController( 1 );\n\t\t\tscene.add( controller2 );\n\n\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t// Hand 1\n\t\t\tconst controllerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\tscene.add( controllerGrip1 );\n\n\t\t\tconst hand1 = renderer.xr.getHand( 0 );\n\t\t\thand1.add( new OculusHandModel( hand1 ) );\n\t\t\tconst handPointer1 = new OculusHandPointerModel( hand1, controller1 );\n\t\t\thand1.add( handPointer1 );\n\n\t\t\tscene.add( hand1 );\n\n\t\t\t// Hand 2\n\t\t\tconst controllerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\tscene.add( controllerGrip2 );\n\n\t\t\tconst hand2 = renderer.xr.getHand( 1 );\n\t\t\thand2.add( new OculusHandModel( hand2 ) );\n\t\t\tconst handPointer2 = new OculusHandPointerModel( hand2, controller2 );\n\t\t\thand2.add( handPointer2 );\n\t\t\tscene.add( hand2 );\n\n\t\t\t// setup objects in scene and entities\n\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\tconst floorMaterial = new THREE.MeshPhongMaterial( { color: 0x222222 } );\n\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\tfloor.receiveShadow = true;\n\t\t\tscene.add( floor );\n\n\t\t\tconst menuGeometry = new THREE.PlaneGeometry( 0.24, 0.5 );\n\t\t\tconst menuMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\topacity: 0,\n\t\t\t\ttransparent: true,\n\t\t\t} );\n\t\t\tconst menuMesh = new THREE.Mesh( menuGeometry, menuMaterial );\n\t\t\tmenuMesh.position.set( 0.4, 1, - 1 );\n\t\t\tmenuMesh.rotation.y = - Math.PI / 12;\n\t\t\tscene.add( menuMesh );\n\n\t\t\tconst orangeButton = makeButtonMesh( 0.2, 0.1, 0.01, 0xffd3b5 );\n\t\t\torangeButton.position.set( 0, 0.18, 0 );\n\t\t\tmenuMesh.add( orangeButton );\n\n\t\t\tconst pinkButton = makeButtonMesh( 0.2, 0.1, 0.01, 0xe84a5f );\n\t\t\tpinkButton.position.set( 0, 0.06, 0 );\n\t\t\tmenuMesh.add( pinkButton );\n\n\t\t\tconst resetButton = makeButtonMesh( 0.2, 0.1, 0.01, 0x355c7d );\n\t\t\tconst resetButtonText = createText( 'reset', 0.06 );\n\t\t\tresetButton.add( resetButtonText );\n\t\t\tresetButtonText.position.set( 0, 0, 0.0051 );\n\t\t\tresetButton.position.set( 0, - 0.06, 0 );\n\t\t\tmenuMesh.add( resetButton );\n\n\t\t\tconst exitButton = makeButtonMesh( 0.2, 0.1, 0.01, 0xff0000 );\n\t\t\tconst exitButtonText = createText( 'exit', 0.06 );\n\t\t\texitButton.add( exitButtonText );\n\t\t\texitButtonText.position.set( 0, 0, 0.0051 );\n\t\t\texitButton.position.set( 0, - 0.18, 0 );\n\t\t\tmenuMesh.add( exitButton );\n\n\t\t\tconst tkGeometry = new THREE.TorusKnotGeometry( 0.5, 0.2, 200, 32 );\n\t\t\tconst tkMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );\n\t\t\ttkMaterial.metalness = 0.8;\n\t\t\tconst torusKnot = new THREE.Mesh( tkGeometry, tkMaterial );\n\t\t\ttorusKnot.position.set( 0, 1, - 5 );\n\t\t\tscene.add( torusKnot );\n\n\t\t\tconst instructionText = createText( 'This is a WebXR Hands demo, please explore with hands.', 0.04 );\n\t\t\tinstructionText.position.set( 0, 1.6, - 0.6 );\n\t\t\tscene.add( instructionText );\n\n\t\t\tconst exitText = createText( 'Exiting session...', 0.04 );\n\t\t\texitText.position.set( 0, 1.5, - 0.6 );\n\t\t\texitText.visible = false;\n\t\t\tscene.add( exitText );\n\n\t\t\tworld\n\t\t\t\t.registerComponent( Object3D )\n\t\t\t\t.registerComponent( Button )\n\t\t\t\t.registerComponent( Intersectable )\n\t\t\t\t.registerComponent( Rotating )\n\t\t\t\t.registerComponent( HandsInstructionText )\n\t\t\t\t.registerComponent( OffsetFromCamera )\n\t\t\t\t.registerComponent( NeedCalibration );\n\n\t\t\tworld\n\t\t\t\t.registerSystem( RotatingSystem )\n\t\t\t\t.registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )\n\t\t\t\t.registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )\n\t\t\t\t.registerSystem( ButtonSystem )\n\t\t\t\t.registerSystem( HandRaySystem, { handPointers: [ handPointer1, handPointer2 ] } );\n\n\t\t\tconst menuEntity = world.createEntity();\n\t\t\tmenuEntity.addComponent( Intersectable );\n\t\t\tmenuEntity.addComponent( OffsetFromCamera, { x: 0.4, y: 0, z: - 1 } );\n\t\t\tmenuEntity.addComponent( NeedCalibration );\n\t\t\tmenuEntity.addComponent( Object3D, { object: menuMesh } );\n\n\t\t\tconst obEntity = world.createEntity();\n\t\t\tobEntity.addComponent( Intersectable );\n\t\t\tobEntity.addComponent( Object3D, { object: orangeButton } );\n\t\t\tconst obAction = function () {\n\n\t\t\t\ttorusKnot.material.color.setHex( 0xffd3b5 );\n\n\t\t\t};\n\n\t\t\tobEntity.addComponent( Button, { action: obAction } );\n\n\t\t\tconst pbEntity = world.createEntity();\n\t\t\tpbEntity.addComponent( Intersectable );\n\t\t\tpbEntity.addComponent( Object3D, { object: pinkButton } );\n\t\t\tconst pbAction = function () {\n\n\t\t\t\ttorusKnot.material.color.setHex( 0xe84a5f );\n\n\t\t\t};\n\n\t\t\tpbEntity.addComponent( Button, { action: pbAction } );\n\n\t\t\tconst rbEntity = world.createEntity();\n\t\t\trbEntity.addComponent( Intersectable );\n\t\t\trbEntity.addComponent( Object3D, { object: resetButton } );\n\t\t\tconst rbAction = function () {\n\n\t\t\t\ttorusKnot.material.color.setHex( 0xffffff );\n\n\t\t\t};\n\n\t\t\trbEntity.addComponent( Button, { action: rbAction } );\n\n\t\t\tconst ebEntity = world.createEntity();\n\t\t\tebEntity.addComponent( Intersectable );\n\t\t\tebEntity.addComponent( Object3D, { object: exitButton } );\n\t\t\tconst ebAction = function () {\n\n\t\t\t\texitText.visible = true;\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\texitText.visible = false; renderer.xr.getSession().end();\n\n\t\t\t\t}, 2000 );\n\n\t\t\t};\n\n\t\t\tebEntity.addComponent( Button, { action: ebAction } );\n\n\t\t\tconst tkEntity = world.createEntity();\n\t\t\ttkEntity.addComponent( Rotating );\n\t\t\ttkEntity.addComponent( Object3D, { object: torusKnot } );\n\n\t\t\tconst itEntity = world.createEntity();\n\t\t\titEntity.addComponent( HandsInstructionText );\n\t\t\titEntity.addComponent( Object3D, { object: instructionText } );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst delta = clock.getDelta();\n\t\t\tconst elapsedTime = clock.elapsedTime;\n\t\t\trenderer.xr.updateCamera( camera );\n\t\t\tworld.execute( delta, elapsedTime );\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js vr - handinput - point and click"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates ve - handinput - point and drag"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js ve - handinput - point and drag:\n\n```javascript\nimport * as THREE from 'three';\n\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\timport { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';\n\t\timport { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';\n\t\timport { createText } from 'three/addons/webxr/Text2D.js';\n\n\t\timport { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';\n\n\t\tclass Object3D extends Component { }\n\n\t\tObject3D.schema = {\n\t\t\tobject: { type: Types.Ref }\n\t\t};\n\n\t\tclass Button extends Component { }\n\n\t\tButton.schema = {\n\t\t\t// button states: [none, hovered, pressed]\n\t\t\tcurrState: { type: Types.String, default: 'none' },\n\t\t\tprevState: { type: Types.String, default: 'none' },\n\t\t\taction: { type: Types.Ref, default: () => { } }\n\t\t};\n\n\t\tclass ButtonSystem extends System {\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tthis.queries.buttons.results.forEach( entity => {\n\n\t\t\t\t\tconst button = entity.getMutableComponent( Button );\n\t\t\t\t\tconst buttonMesh = entity.getComponent( Object3D ).object;\n\t\t\t\t\tif ( button.currState == 'none' ) {\n\n\t\t\t\t\t\tbuttonMesh.scale.set( 1, 1, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuttonMesh.scale.set( 1.1, 1.1, 1.1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( button.currState == 'pressed' && button.prevState != 'pressed' ) {\n\n\t\t\t\t\t\tbutton.action();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// preserve prevState, clear currState\n\t\t\t\t\t// HandRaySystem will update currState\n\t\t\t\t\tbutton.prevState = button.currState;\n\t\t\t\t\tbutton.currState = 'none';\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tButtonSystem.queries = {\n\t\t\tbuttons: {\n\t\t\t\tcomponents: [ Button ]\n\t\t\t}\n\t\t};\n\n\t\tclass Draggable extends Component { }\n\n\t\tDraggable.schema = {\n\t\t\t// draggable states: [detached, hovered, to-be-attached, attached, to-be-detached]\n\t\t\tstate: { type: Types.String, default: 'none' },\n\t\t\toriginalParent: { type: Types.Ref, default: null },\n\t\t\tattachedPointer: { type: Types.Ref, default: null }\n\t\t};\n\n\t\tclass DraggableSystem extends System {\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tthis.queries.draggable.results.forEach( entity => {\n\n\t\t\t\t\tconst draggable = entity.getMutableComponent( Draggable );\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tif ( draggable.originalParent == null ) {\n\n\t\t\t\t\t\tdraggable.originalParent = object.parent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( draggable.state ) {\n\n\t\t\t\t\t\tcase 'to-be-attached':\n\t\t\t\t\t\t\tdraggable.attachedPointer.children[ 0 ].attach( object );\n\t\t\t\t\t\t\tdraggable.state = 'attached';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'to-be-detached':\n\t\t\t\t\t\t\tdraggable.originalParent.attach( object );\n\t\t\t\t\t\t\tdraggable.state = 'detached';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tobject.scale.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tDraggableSystem.queries = {\n\t\t\tdraggable: {\n\t\t\t\tcomponents: [ Draggable ]\n\t\t\t}\n\t\t};\n\n\t\tclass Intersectable extends TagComponent { }\n\n\t\tclass HandRaySystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.handPointers = attributes.handPointers;\n\n\t\t\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tthis.handPointers.forEach( hp => {\n\n\t\t\t\t\tlet distance = null;\n\t\t\t\t\tlet intersectingEntity = null;\n\t\t\t\t\tthis.queries.intersectable.results.forEach( entity => {\n\n\t\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\t\tconst intersections = hp.intersectObject( object, false );\n\t\t\t\t\t\tif ( intersections && intersections.length > 0 ) {\n\n\t\t\t\t\t\t\tif ( distance == null || intersections[ 0 ].distance < distance ) {\n\n\t\t\t\t\t\t\t\tdistance = intersections[ 0 ].distance;\n\t\t\t\t\t\t\t\tintersectingEntity = entity;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tif ( distance ) {\n\n\t\t\t\t\t\thp.setCursor( distance );\n\t\t\t\t\t\tif ( intersectingEntity.hasComponent( Button ) ) {\n\n\t\t\t\t\t\t\tconst button = intersectingEntity.getMutableComponent( Button );\n\t\t\t\t\t\t\tif ( hp.isPinched() ) {\n\n\t\t\t\t\t\t\t\tbutton.currState = 'pressed';\n\n\t\t\t\t\t\t\t} else if ( button.currState != 'pressed' ) {\n\n\t\t\t\t\t\t\t\tbutton.currState = 'hovered';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( intersectingEntity.hasComponent( Draggable ) ) {\n\n\t\t\t\t\t\t\tconst draggable = intersectingEntity.getMutableComponent( Draggable );\n\t\t\t\t\t\t\tconst object = intersectingEntity.getComponent( Object3D ).object;\n\t\t\t\t\t\t\tobject.scale.set( 1.1, 1.1, 1.1 );\n\t\t\t\t\t\t\tif ( hp.isPinched() ) {\n\n\t\t\t\t\t\t\t\tif ( ! hp.isAttached() && draggable.state != 'attached' ) {\n\n\t\t\t\t\t\t\t\t\tdraggable.state = 'to-be-attached';\n\t\t\t\t\t\t\t\t\tdraggable.attachedPointer = hp;\n\t\t\t\t\t\t\t\t\thp.setAttached( true );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( hp.isAttached() && draggable.state == 'attached' ) {\n\n\t\t\t\t\t\t\t\t\tconsole.log( 'hello' );\n\t\t\t\t\t\t\t\t\tdraggable.state = 'to-be-detached';\n\t\t\t\t\t\t\t\t\tdraggable.attachedPointer = null;\n\t\t\t\t\t\t\t\t\thp.setAttached( false );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\thp.setCursor( 1.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tHandRaySystem.queries = {\n\t\t\tintersectable: {\n\t\t\t\tcomponents: [ Intersectable ]\n\t\t\t}\n\t\t};\n\n\t\tclass HandsInstructionText extends TagComponent { }\n\n\t\tclass InstructionSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.controllers = attributes.controllers;\n\n\t\t\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tlet visible = false;\n\t\t\t\tthis.controllers.forEach( controller => {\n\n\t\t\t\t\tif ( controller.visible ) {\n\n\t\t\t\t\t\tvisible = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tthis.queries.instructionTexts.results.forEach( entity => {\n\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tobject.visible = visible;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tInstructionSystem.queries = {\n\t\t\tinstructionTexts: {\n\t\t\t\tcomponents: [ HandsInstructionText ]\n\t\t\t}\n\t\t};\n\n\t\tclass OffsetFromCamera extends Component { }\n\n\t\tOffsetFromCamera.schema = {\n\t\t\tx: { type: Types.Number, default: 0 },\n\t\t\ty: { type: Types.Number, default: 0 },\n\t\t\tz: { type: Types.Number, default: 0 },\n\t\t};\n\n\t\tclass NeedCalibration extends TagComponent { }\n\n\t\tclass CalibrationSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.camera = attributes.camera;\n\t\t\t\tthis.renderer = attributes.renderer;\n\n\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tthis.queries.needCalibration.results.forEach( entity => {\n\n\t\t\t\t\tif ( this.renderer.xr.getSession() ) {\n\n\t\t\t\t\t\tconst offset = entity.getComponent( OffsetFromCamera );\n\t\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\t\tconst xrCamera = this.renderer.xr.getCamera();\n\t\t\t\t\t\tobject.position.x = xrCamera.position.x + offset.x;\n\t\t\t\t\t\tobject.position.y = xrCamera.position.y + offset.y;\n\t\t\t\t\t\tobject.position.z = xrCamera.position.z + offset.z;\n\t\t\t\t\t\tentity.removeComponent( NeedCalibration );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tCalibrationSystem.queries = {\n\t\t\tneedCalibration: {\n\t\t\t\tcomponents: [ NeedCalibration ]\n\t\t\t}\n\t\t};\n\n\t\tclass Randomizable extends TagComponent { }\n\n\t\tclass RandomizerSystem extends System {\n\n\t\t\tinit( /*attributes*/ ) {\n\n\t\t\t\tthis.needRandomizing = true;\n\n\t\t\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tif ( ! this.needRandomizing ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tthis.queries.randomizable.results.forEach( entity => {\n\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\n\t\t\t\t\tobject.material.color.setHex( Math.random() * 0xffffff );\n\n\t\t\t\t\tobject.position.x = Math.random() * 2 - 1;\n\t\t\t\t\tobject.position.y = Math.random() * 2;\n\t\t\t\t\tobject.position.z = Math.random() * 2 - 1;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\t\t\t\t\tthis.needRandomizing = false;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tRandomizerSystem.queries = {\n\t\t\trandomizable: {\n\t\t\t\tcomponents: [ Randomizable ]\n\t\t\t}\n\t\t};\n\n\t\tconst world = new World();\n\t\tconst clock = new THREE.Clock();\n\t\tlet camera, scene, renderer;\n\n\t\tinit();\n\n\t\tfunction makeButtonMesh( x, y, z, color ) {\n\n\t\t\tconst geometry = new THREE.BoxGeometry( x, y, z );\n\t\t\tconst material = new THREE.MeshPhongMaterial( { color: color } );\n\t\t\tconst buttonMesh = new THREE.Mesh( geometry, material );\n\t\t\treturn buttonMesh;\n\n\t\t}\n\n\t\tfunction init() {\n\n\t\t\tconst container = document.createElement( 'div' );\n\t\t\tdocument.body.appendChild( container );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\tcamera.position.set( 0, 1.2, 0.3 );\n\n\t\t\tscene.add( new THREE.HemisphereLight( 0xcccccc, 0x999999, 3 ) );\n\n\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\tlight.castShadow = true;\n\t\t\tlight.shadow.camera.top = 2;\n\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\tlight.shadow.camera.right = 2;\n\t\t\tlight.shadow.camera.left = - 2;\n\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\tscene.add( light );\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\trenderer.xr.enabled = true;\n\t\t\trenderer.xr.cameraAutoUpdate = false;\n\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst sessionInit = {\n\t\t\t\trequiredFeatures: [ 'hand-tracking' ]\n\t\t\t};\n\n\t\t\tdocument.body.appendChild( VRButton.createButton( renderer, sessionInit ) );\n\n\t\t\t// controllers\n\t\t\tconst controller1 = renderer.xr.getController( 0 );\n\t\t\tscene.add( controller1 );\n\n\t\t\tconst controller2 = renderer.xr.getController( 1 );\n\t\t\tscene.add( controller2 );\n\n\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t// Hand 1\n\t\t\tconst controllerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\tscene.add( controllerGrip1 );\n\n\t\t\tconst hand1 = renderer.xr.getHand( 0 );\n\t\t\thand1.add( new OculusHandModel( hand1 ) );\n\t\t\tconst handPointer1 = new OculusHandPointerModel( hand1, controller1 );\n\t\t\thand1.add( handPointer1 );\n\n\t\t\tscene.add( hand1 );\n\n\t\t\t// Hand 2\n\t\t\tconst controllerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\tscene.add( controllerGrip2 );\n\n\t\t\tconst hand2 = renderer.xr.getHand( 1 );\n\t\t\thand2.add( new OculusHandModel( hand2 ) );\n\t\t\tconst handPointer2 = new OculusHandPointerModel( hand2, controller2 );\n\t\t\thand2.add( handPointer2 );\n\t\t\tscene.add( hand2 );\n\n\n\t\t\t// setup objects in scene and entities\n\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\tconst floorMaterial = new THREE.MeshPhongMaterial( { color: 0x222222 } );\n\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\tfloor.receiveShadow = true;\n\t\t\tscene.add( floor );\n\n\t\t\tconst menuGeometry = new THREE.PlaneGeometry( 0.24, 0.5 );\n\t\t\tconst menuMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\topacity: 0,\n\t\t\t\ttransparent: true,\n\t\t\t} );\n\t\t\tconst menuMesh = new THREE.Mesh( menuGeometry, menuMaterial );\n\t\t\tmenuMesh.position.set( 0.4, 1, - 1 );\n\t\t\tmenuMesh.rotation.y = - Math.PI / 12;\n\t\t\tscene.add( menuMesh );\n\n\t\t\tconst resetButton = makeButtonMesh( 0.2, 0.1, 0.01, 0x355c7d );\n\t\t\tconst resetButtonText = createText( 'reset', 0.06 );\n\t\t\tresetButton.add( resetButtonText );\n\t\t\tresetButtonText.position.set( 0, 0, 0.0051 );\n\t\t\tresetButton.position.set( 0, - 0.06, 0 );\n\t\t\tmenuMesh.add( resetButton );\n\n\t\t\tconst exitButton = makeButtonMesh( 0.2, 0.1, 0.01, 0xff0000 );\n\t\t\tconst exitButtonText = createText( 'exit', 0.06 );\n\t\t\texitButton.add( exitButtonText );\n\t\t\texitButtonText.position.set( 0, 0, 0.0051 );\n\t\t\texitButton.position.set( 0, - 0.18, 0 );\n\t\t\tmenuMesh.add( exitButton );\n\n\t\t\tconst instructionText = createText( 'This is a WebXR Hands demo, please explore with hands.', 0.04 );\n\t\t\tinstructionText.position.set( 0, 1.6, - 0.6 );\n\t\t\tscene.add( instructionText );\n\n\t\t\tconst exitText = createText( 'Exiting session...', 0.04 );\n\t\t\texitText.position.set( 0, 1.5, - 0.6 );\n\t\t\texitText.visible = false;\n\t\t\tscene.add( exitText );\n\n\t\t\tworld\n\t\t\t\t.registerComponent( Object3D )\n\t\t\t\t.registerComponent( Button )\n\t\t\t\t.registerComponent( Intersectable )\n\t\t\t\t.registerComponent( HandsInstructionText )\n\t\t\t\t.registerComponent( OffsetFromCamera )\n\t\t\t\t.registerComponent( NeedCalibration )\n\t\t\t\t.registerComponent( Randomizable )\n\t\t\t\t.registerComponent( Draggable );\n\n\t\t\tworld\n\t\t\t\t.registerSystem( RandomizerSystem )\n\t\t\t\t.registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )\n\t\t\t\t.registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )\n\t\t\t\t.registerSystem( ButtonSystem )\n\t\t\t\t.registerSystem( DraggableSystem )\n\t\t\t\t.registerSystem( HandRaySystem, { handPointers: [ handPointer1, handPointer2 ] } );\n\n\t\t\tfor ( let i = 0; i < 20; i ++ ) {\n\n\t\t\t\tconst object = new THREE.Mesh( new THREE.BoxGeometry( 0.15, 0.15, 0.15 ), new THREE.MeshLambertMaterial( { color: 0xffffff } ) );\n\t\t\t\tscene.add( object );\n\n\t\t\t\tconst entity = world.createEntity();\n\t\t\t\tentity.addComponent( Intersectable );\n\t\t\t\tentity.addComponent( Randomizable );\n\t\t\t\tentity.addComponent( Object3D, { object: object } );\n\t\t\t\tentity.addComponent( Draggable );\n\n\t\t\t}\n\n\t\t\tconst menuEntity = world.createEntity();\n\t\t\tmenuEntity.addComponent( Intersectable );\n\t\t\tmenuEntity.addComponent( OffsetFromCamera, { x: 0.4, y: 0, z: - 1 } );\n\t\t\tmenuEntity.addComponent( NeedCalibration );\n\t\t\tmenuEntity.addComponent( Object3D, { object: menuMesh } );\n\n\t\t\tconst rbEntity = world.createEntity();\n\t\t\trbEntity.addComponent( Intersectable );\n\t\t\trbEntity.addComponent( Object3D, { object: resetButton } );\n\t\t\tconst rbAction = function () {\n\n\t\t\t\tworld.getSystem( RandomizerSystem ).needRandomizing = true;\n\n\t\t\t};\n\n\t\t\trbEntity.addComponent( Button, { action: rbAction } );\n\n\t\t\tconst ebEntity = world.createEntity();\n\t\t\tebEntity.addComponent( Intersectable );\n\t\t\tebEntity.addComponent( Object3D, { object: exitButton } );\n\t\t\tconst ebAction = function () {\n\n\t\t\t\texitText.visible = true;\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\texitText.visible = false; renderer.xr.getSession().end();\n\n\t\t\t\t}, 2000 );\n\n\t\t\t};\n\n\t\t\tebEntity.addComponent( Button, { action: ebAction } );\n\n\t\t\tconst itEntity = world.createEntity();\n\t\t\titEntity.addComponent( HandsInstructionText );\n\t\t\titEntity.addComponent( Object3D, { object: instructionText } );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst delta = clock.getDelta();\n\t\t\tconst elapsedTime = clock.elapsedTime;\n\t\t\trenderer.xr.updateCamera( camera );\n\t\t\tworld.execute( delta, elapsedTime );\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js vr - handinput - point and drag"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - handinput - press button"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - handinput - press button:\n\n```javascript\nimport * as THREE from 'three';\n\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\timport { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';\n\t\timport { createText } from 'three/addons/webxr/Text2D.js';\n\n\t\timport { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';\n\n\t\tclass Object3D extends Component { }\n\n\t\tObject3D.schema = {\n\t\t\tobject: { type: Types.Ref }\n\t\t};\n\n\t\tclass Button extends Component { }\n\n\t\tButton.schema = {\n\t\t\t// button states: [resting, pressed, fully_pressed, recovering]\n\t\t\tcurrState: { type: Types.String, default: 'resting' },\n\t\t\tprevState: { type: Types.String, default: 'resting' },\n\t\t\tpressSound: { type: Types.Ref, default: null },\n\t\t\treleaseSound: { type: Types.Ref, default: null },\n\t\t\trestingY: { type: Types.Number, default: null },\n\t\t\tsurfaceY: { type: Types.Number, default: null },\n\t\t\trecoverySpeed: { type: Types.Number, default: 0.4 },\n\t\t\tfullPressDistance: { type: Types.Number, default: null },\n\t\t\taction: { type: Types.Ref, default: () => { } }\n\t\t};\n\n\t\tclass ButtonSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.renderer = attributes.renderer;\n\t\t\t\tthis.soundAdded = false;\n\n\t\t\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tlet buttonPressSound, buttonReleaseSound;\n\t\t\t\tif ( this.renderer.xr.getSession() && ! this.soundAdded ) {\n\n\t\t\t\t\tconst xrCamera = this.renderer.xr.getCamera();\n\n\t\t\t\t\tconst listener = new THREE.AudioListener();\n\t\t\t\t\txrCamera.add( listener );\n\n\t\t\t\t\t// create a global audio source\n\t\t\t\t\tbuttonPressSound = new THREE.Audio( listener );\n\t\t\t\t\tbuttonReleaseSound = new THREE.Audio( listener );\n\n\t\t\t\t\t// load a sound and set it as the Audio object's buffer\n\t\t\t\t\tconst audioLoader = new THREE.AudioLoader();\n\t\t\t\t\taudioLoader.load( 'sounds/button-press.ogg', function ( buffer ) {\n\n\t\t\t\t\t\tbuttonPressSound.setBuffer( buffer );\n\n\t\t\t\t\t} );\n\t\t\t\t\taudioLoader.load( 'sounds/button-release.ogg', function ( buffer ) {\n\n\t\t\t\t\t\tbuttonReleaseSound.setBuffer( buffer );\n\n\t\t\t\t\t} );\n\t\t\t\t\tthis.soundAdded = true;\n\n\t\t\t\t}\n\n\t\t\t\tthis.queries.buttons.results.forEach( entity => {\n\n\t\t\t\t\tconst button = entity.getMutableComponent( Button );\n\t\t\t\t\tconst buttonMesh = entity.getComponent( Object3D ).object;\n\t\t\t\t\t// populate restingY\n\t\t\t\t\tif ( button.restingY == null ) {\n\n\t\t\t\t\t\tbutton.restingY = buttonMesh.position.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( buttonPressSound ) {\n\n\t\t\t\t\t\tbutton.pressSound = buttonPressSound;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( buttonReleaseSound ) {\n\n\t\t\t\t\t\tbutton.releaseSound = buttonReleaseSound;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( button.currState == 'fully_pressed' && button.prevState != 'fully_pressed' ) {\n\n\t\t\t\t\t\tif ( button.pressSound ) button.pressSound.play();\n\t\t\t\t\t\tbutton.action();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( button.currState == 'recovering' && button.prevState != 'recovering' ) {\n\n\t\t\t\t\t\tif ( button.releaseSound ) button.releaseSound.play();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// preserve prevState, clear currState\n\t\t\t\t\t// FingerInputSystem will update currState\n\t\t\t\t\tbutton.prevState = button.currState;\n\t\t\t\t\tbutton.currState = 'resting';\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tButtonSystem.queries = {\n\t\t\tbuttons: {\n\t\t\t\tcomponents: [ Button ]\n\t\t\t}\n\t\t};\n\n\t\tclass Pressable extends TagComponent { }\n\n\t\tclass FingerInputSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.hands = attributes.hands;\n\n\t\t\t}\n\n\t\t\texecute( delta/*, time*/ ) {\n\n\t\t\t\tthis.queries.pressable.results.forEach( entity => {\n\n\t\t\t\t\tconst button = entity.getMutableComponent( Button );\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tconst pressingDistances = [];\n\t\t\t\t\tthis.hands.forEach( hand => {\n\n\t\t\t\t\t\tif ( hand && hand.intersectBoxObject( object ) ) {\n\n\t\t\t\t\t\t\tconst pressingPosition = hand.getPointerPosition();\n\t\t\t\t\t\t\tpressingDistances.push( button.surfaceY - object.worldToLocal( pressingPosition ).y );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tif ( pressingDistances.length == 0 ) { // not pressed this frame\n\n\t\t\t\t\t\tif ( object.position.y < button.restingY ) {\n\n\t\t\t\t\t\t\tobject.position.y += button.recoverySpeed * delta;\n\t\t\t\t\t\t\tbutton.currState = 'recovering';\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject.position.y = button.restingY;\n\t\t\t\t\t\t\tbutton.currState = 'resting';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbutton.currState = 'pressed';\n\t\t\t\t\t\tconst pressingDistance = Math.max( pressingDistances );\n\t\t\t\t\t\tif ( pressingDistance > 0 ) {\n\n\t\t\t\t\t\t\tobject.position.y -= pressingDistance;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( object.position.y <= button.restingY - button.fullPressDistance ) {\n\n\t\t\t\t\t\t\tbutton.currState = 'fully_pressed';\n\t\t\t\t\t\t\tobject.position.y = button.restingY - button.fullPressDistance;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tFingerInputSystem.queries = {\n\t\t\tpressable: {\n\t\t\t\tcomponents: [ Pressable ]\n\t\t\t}\n\t\t};\n\n\t\tclass Rotating extends TagComponent { }\n\n\t\tclass RotatingSystem extends System {\n\n\t\t\texecute( delta/*, time*/ ) {\n\n\t\t\t\tthis.queries.rotatingObjects.results.forEach( entity => {\n\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tobject.rotation.x += 0.4 * delta;\n\t\t\t\t\tobject.rotation.y += 0.4 * delta;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tRotatingSystem.queries = {\n\t\t\trotatingObjects: {\n\t\t\t\tcomponents: [ Rotating ]\n\t\t\t}\n\t\t};\n\n\t\tclass HandsInstructionText extends TagComponent { }\n\n\t\tclass InstructionSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.controllers = attributes.controllers;\n\n\t\t\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tlet visible = false;\n\t\t\t\tthis.controllers.forEach( controller => {\n\n\t\t\t\t\tif ( controller.visible ) {\n\n\t\t\t\t\t\tvisible = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tthis.queries.instructionTexts.results.forEach( entity => {\n\n\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\tobject.visible = visible;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tInstructionSystem.queries = {\n\t\t\tinstructionTexts: {\n\t\t\t\tcomponents: [ HandsInstructionText ]\n\t\t\t}\n\t\t};\n\n\t\tclass OffsetFromCamera extends Component { }\n\n\t\tOffsetFromCamera.schema = {\n\t\t\tx: { type: Types.Number, default: 0 },\n\t\t\ty: { type: Types.Number, default: 0 },\n\t\t\tz: { type: Types.Number, default: 0 },\n\t\t};\n\n\t\tclass NeedCalibration extends TagComponent { }\n\n\t\tclass CalibrationSystem extends System {\n\n\t\t\tinit( attributes ) {\n\n\t\t\t\tthis.camera = attributes.camera;\n\t\t\t\tthis.renderer = attributes.renderer;\n\n\t\t\t}\n\n\t\t\texecute( /*delta, time*/ ) {\n\n\t\t\t\tthis.queries.needCalibration.results.forEach( entity => {\n\n\t\t\t\t\tif ( this.renderer.xr.getSession() ) {\n\n\t\t\t\t\t\tconst offset = entity.getComponent( OffsetFromCamera );\n\t\t\t\t\t\tconst object = entity.getComponent( Object3D ).object;\n\t\t\t\t\t\tconst xrCamera = this.renderer.xr.getCamera();\n\t\t\t\t\t\tobject.position.x = xrCamera.position.x + offset.x;\n\t\t\t\t\t\tobject.position.y = xrCamera.position.y + offset.y;\n\t\t\t\t\t\tobject.position.z = xrCamera.position.z + offset.z;\n\t\t\t\t\t\tentity.removeComponent( NeedCalibration );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\tCalibrationSystem.queries = {\n\t\t\tneedCalibration: {\n\t\t\t\tcomponents: [ NeedCalibration ]\n\t\t\t}\n\t\t};\n\n\t\tconst world = new World();\n\t\tconst clock = new THREE.Clock();\n\t\tlet camera, scene, renderer;\n\n\t\tinit();\n\n\t\tfunction makeButtonMesh( x, y, z, color ) {\n\n\t\t\tconst geometry = new THREE.BoxGeometry( x, y, z );\n\t\t\tconst material = new THREE.MeshPhongMaterial( { color: color } );\n\t\t\tconst buttonMesh = new THREE.Mesh( geometry, material );\n\t\t\tbuttonMesh.castShadow = true;\n\t\t\tbuttonMesh.receiveShadow = true;\n\t\t\treturn buttonMesh;\n\n\t\t}\n\n\t\tfunction init() {\n\n\t\t\tconst container = document.createElement( 'div' );\n\t\t\tdocument.body.appendChild( container );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x444444 );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\tcamera.position.set( 0, 1.2, 0.3 );\n\n\t\t\tscene.add( new THREE.HemisphereLight( 0xcccccc, 0x999999, 3 ) );\n\n\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\tlight.castShadow = true;\n\t\t\tlight.shadow.camera.top = 2;\n\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\tlight.shadow.camera.right = 2;\n\t\t\tlight.shadow.camera.left = - 2;\n\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\tscene.add( light );\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\trenderer.xr.enabled = true;\n\t\t\trenderer.xr.cameraAutoUpdate = false;\n\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst sessionInit = {\n\t\t\t\trequiredFeatures: [ 'hand-tracking' ]\n\t\t\t};\n\n\t\t\tdocument.body.appendChild( VRButton.createButton( renderer, sessionInit ) );\n\n\t\t\t// controllers\n\t\t\tconst controller1 = renderer.xr.getController( 0 );\n\t\t\tscene.add( controller1 );\n\n\t\t\tconst controller2 = renderer.xr.getController( 1 );\n\t\t\tscene.add( controller2 );\n\n\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t// Hand 1\n\t\t\tconst controllerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\tscene.add( controllerGrip1 );\n\n\t\t\tconst hand1 = renderer.xr.getHand( 0 );\n\t\t\tconst handModel1 = new OculusHandModel( hand1 );\n\t\t\thand1.add( handModel1 );\n\t\t\tscene.add( hand1 );\n\n\t\t\t// Hand 2\n\t\t\tconst controllerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\tscene.add( controllerGrip2 );\n\n\t\t\tconst hand2 = renderer.xr.getHand( 1 );\n\t\t\tconst handModel2 = new OculusHandModel( hand2 );\n\t\t\thand2.add( handModel2 );\n\t\t\tscene.add( hand2 );\n\n\n\t\t\t// buttons\n\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\tconst floorMaterial = new THREE.MeshPhongMaterial( { color: 0x222222 } );\n\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\tfloor.receiveShadow = true;\n\t\t\tscene.add( floor );\n\n\t\t\tconst consoleGeometry = new THREE.BoxGeometry( 0.5, 0.12, 0.15 );\n\t\t\tconst consoleMaterial = new THREE.MeshPhongMaterial( { color: 0x595959 } );\n\t\t\tconst consoleMesh = new THREE.Mesh( consoleGeometry, consoleMaterial );\n\t\t\tconsoleMesh.position.set( 0, 1, - 0.3 );\n\t\t\tconsoleMesh.castShadow = true;\n\t\t\tconsoleMesh.receiveShadow = true;\n\t\t\tscene.add( consoleMesh );\n\n\t\t\tconst orangeButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xffd3b5 );\n\t\t\torangeButton.position.set( - 0.15, 0.04, 0 );\n\t\t\tconsoleMesh.add( orangeButton );\n\n\t\t\tconst pinkButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xe84a5f );\n\t\t\tpinkButton.position.set( - 0.05, 0.04, 0 );\n\t\t\tconsoleMesh.add( pinkButton );\n\n\t\t\tconst resetButton = makeButtonMesh( 0.08, 0.1, 0.08, 0x355c7d );\n\t\t\tconst resetButtonText = createText( 'reset', 0.03 );\n\t\t\tresetButton.add( resetButtonText );\n\t\t\tresetButtonText.rotation.x = - Math.PI / 2;\n\t\t\tresetButtonText.position.set( 0, 0.051, 0 );\n\t\t\tresetButton.position.set( 0.05, 0.04, 0 );\n\t\t\tconsoleMesh.add( resetButton );\n\n\t\t\tconst exitButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xff0000 );\n\t\t\tconst exitButtonText = createText( 'exit', 0.03 );\n\t\t\texitButton.add( exitButtonText );\n\t\t\texitButtonText.rotation.x = - Math.PI / 2;\n\t\t\texitButtonText.position.set( 0, 0.051, 0 );\n\t\t\texitButton.position.set( 0.15, 0.04, 0 );\n\t\t\tconsoleMesh.add( exitButton );\n\n\t\t\tconst tkGeometry = new THREE.TorusKnotGeometry( 0.5, 0.2, 200, 32 );\n\t\t\tconst tkMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );\n\t\t\ttkMaterial.metalness = 0.8;\n\t\t\tconst torusKnot = new THREE.Mesh( tkGeometry, tkMaterial );\n\t\t\ttorusKnot.position.set( 0, 1, - 5 );\n\t\t\tscene.add( torusKnot );\n\n\t\t\tconst instructionText = createText( 'This is a WebXR Hands demo, please explore with hands.', 0.04 );\n\t\t\tinstructionText.position.set( 0, 1.6, - 0.6 );\n\t\t\tscene.add( instructionText );\n\n\t\t\tconst exitText = createText( 'Exiting session...', 0.04 );\n\t\t\texitText.position.set( 0, 1.5, - 0.6 );\n\t\t\texitText.visible = false;\n\t\t\tscene.add( exitText );\n\n\t\t\tworld\n\t\t\t\t.registerComponent( Object3D )\n\t\t\t\t.registerComponent( Button )\n\t\t\t\t.registerComponent( Pressable )\n\t\t\t\t.registerComponent( Rotating )\n\t\t\t\t.registerComponent( HandsInstructionText )\n\t\t\t\t.registerComponent( OffsetFromCamera )\n\t\t\t\t.registerComponent( NeedCalibration );\n\n\t\t\tworld\n\t\t\t\t.registerSystem( RotatingSystem )\n\t\t\t\t.registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )\n\t\t\t\t.registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )\n\t\t\t\t.registerSystem( ButtonSystem, { renderer: renderer, camera: camera } )\n\t\t\t\t.registerSystem( FingerInputSystem, { hands: [ handModel1, handModel2 ] } );\n\n\t\t\tconst csEntity = world.createEntity();\n\t\t\tcsEntity.addComponent( OffsetFromCamera, { x: 0, y: - 0.4, z: - 0.3 } );\n\t\t\tcsEntity.addComponent( NeedCalibration );\n\t\t\tcsEntity.addComponent( Object3D, { object: consoleMesh } );\n\n\t\t\tconst obEntity = world.createEntity();\n\t\t\tobEntity.addComponent( Pressable );\n\t\t\tobEntity.addComponent( Object3D, { object: orangeButton } );\n\t\t\tconst obAction = function () {\n\n\t\t\t\ttorusKnot.material.color.setHex( 0xffd3b5 );\n\n\t\t\t};\n\n\t\t\tobEntity.addComponent( Button, { action: obAction, surfaceY: 0.05, fullPressDistance: 0.02 } );\n\n\t\t\tconst pbEntity = world.createEntity();\n\t\t\tpbEntity.addComponent( Pressable );\n\t\t\tpbEntity.addComponent( Object3D, { object: pinkButton } );\n\t\t\tconst pbAction = function () {\n\n\t\t\t\ttorusKnot.material.color.setHex( 0xe84a5f );\n\n\t\t\t};\n\n\t\t\tpbEntity.addComponent( Button, { action: pbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );\n\n\t\t\tconst rbEntity = world.createEntity();\n\t\t\trbEntity.addComponent( Pressable );\n\t\t\trbEntity.addComponent( Object3D, { object: resetButton } );\n\t\t\tconst rbAction = function () {\n\n\t\t\t\ttorusKnot.material.color.setHex( 0xffffff );\n\n\t\t\t};\n\n\t\t\trbEntity.addComponent( Button, { action: rbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );\n\n\t\t\tconst ebEntity = world.createEntity();\n\t\t\tebEntity.addComponent( Pressable );\n\t\t\tebEntity.addComponent( Object3D, { object: exitButton } );\n\t\t\tconst ebAction = function () {\n\n\t\t\t\texitText.visible = true;\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\texitText.visible = false; renderer.xr.getSession().end();\n\n\t\t\t\t}, 2000 );\n\n\t\t\t};\n\n\t\t\tebEntity.addComponent( Button, { action: ebAction, surfaceY: 0.05, recoverySpeed: 0.2, fullPressDistance: 0.03 } );\n\n\t\t\tconst tkEntity = world.createEntity();\n\t\t\ttkEntity.addComponent( Rotating );\n\t\t\ttkEntity.addComponent( Object3D, { object: torusKnot } );\n\n\t\t\tconst itEntity = world.createEntity();\n\t\t\titEntity.addComponent( HandsInstructionText );\n\t\t\titEntity.addComponent( Object3D, { object: instructionText } );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\tconst delta = clock.getDelta();\n\t\t\tconst elapsedTime = clock.elapsedTime;\n\t\t\trenderer.xr.updateCamera( camera );\n\t\t\tworld.execute( delta, elapsedTime );\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n```\n\nThis example three.js vr - handinput - press button"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - layers"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - layers:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';\n\t\t\timport { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\t\timport { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet video;\n\n\t\t\t// Four eye charts are rendered to demonstrate the differences in text quality.\n\t\t\t// The two charts on the top are rendered into XRQuadLayers ( substantially more legible ).\n\t\t\t// The two charts on the bottom are rendered to the eye buffer.\n\t\t\t//\n\t\t\t// The two charts on the left are rendered without mipmaps and have aliasing artifacts.\n\t\t\t// The two charts on the right are with mipmaps an don't twinkle but are blurrier.\n\t\t\t// To maximize text legibility, it's important to choose a texture size optimized for the\n\t\t\t// distance of the text. (This example intentionally uses incorrectly large textures to\n\t\t\t// demonstrate this issue.) If the optimal text size can't be determined beforehand, then\n\t\t\t// mipmaps are required to avoid aliasing.\n\t\t\t//\n\t\t\t// The background of the scene is an equirectangular layer. It uses an XRMediaBinding to\n\t\t\t// render the contents of a video element into the scene. This example uses a low resolution\n\t\t\t// video to avoid large files, but using media layers allows video that is higher resolution than normal rendering.\n\n\t\t\tlet snellenTexture;\n\t\t\tlet quadLayerPlain;\n\t\t\tlet quadLayerMips;\n\t\t\tlet guiLayer;\n\t\t\tlet guiMesh;\n\t\t\tlet errorMesh;\n\n\t\t\t// Set via GUI.\n\t\t\tconst parameters = {\n\t\t\t\teyeChartDistanceFt: 20,\n\t\t\t};\n\n\t\t\t// Data shared between the THREE.Meshes on the bottom and WebXR Layers on the top for the eye\n\t\t\t// charts. See https://en.wikipedia.org/wiki/Snellen_chart for details about the math.\n\t\t\t//\n\t\t\t// The image was designed so that each 2x2px block on the 20/20 line subtends 1 minute of\n\t\t\t// arc. That is\n\t\t\t//    tan(1/60 deg) * 6.1m * 160px/142mm = 2px\n\t\t\t// per block on line 8.\n\t\t\t//\n\t\t\t// This fidelity is beyond any modern consumer headset since it would require ~60px/deg of\n\t\t\t// resolution. The Quest has ~16ppd and the Quest 2 has ~20ppd so only lines 3 or 4 will be\n\t\t\t// legible when using layers. Without layers, you lose ~sqrt(2) in resolution due to the\n\t\t\t// extra resampling.\n\t\t\tconst snellenConfig = {\n\t\t\t\t// The texture is a power of two so that mipmaps can be generated.\n\t\t\t\ttextureSizePx: 512,\n\t\t\t\t// This is the valid part of the image.\n\t\t\t\twidthPx: 320,\n\t\t\t\theightPx: 450,\n\n\t\t\t\tx: 0,\n\t\t\t\ty: 1.5,\n\t\t\t\tz: - 6.1, // 20/20 vision @ 20ft = 6.1m\n\n\t\t\t\t// This is the size of mesh and the visible part of the quad layer.\n\t\t\t\twidthMeters: .268, // 320px image * (142mm/160px scale factor)\n\t\t\t\theightMeters: .382 // 450px image * (142mm/160px scale factor)\n\t\t\t};\n\n\t\t\tsnellenConfig.cropX = snellenConfig.widthPx / snellenConfig.textureSizePx;\n\t\t\tsnellenConfig.cropY = snellenConfig.heightPx / snellenConfig.textureSizePx;\n\n\t\t\t// The quad layer is a [-1, 1] quad but only a part of it has image data. Scale the layer so\n\t\t\t// that the part with image data is the same size as the mesh.\n\t\t\tsnellenConfig.quadWidth = .5 * snellenConfig.widthMeters / snellenConfig.cropX;\n\t\t\tsnellenConfig.quadHeight = .5 * snellenConfig.heightMeters / snellenConfig.cropY;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tconst hemLight = new THREE.HemisphereLight( 0x808080, 0x606060, 3 );\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tscene.add( hemLight, light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: false } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.setClearAlpha( 1 );\n\t\t\t\trenderer.setClearColor( new THREE.Color( 0 ), 0 );\n\t\t\t\trenderer.xr.enabled = true;\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tconst lineGeometry = new THREE.BufferGeometry().setFromPoints( [\n\t\t\t\t\tnew THREE.Vector3( 0, 0, 0 ),\n\t\t\t\t\tnew THREE.Vector3( 0, 0, - 10 )\n\t\t\t\t] );\n\t\t\t\tconst line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: 0x5555ff } ) );\n\n\t\t\t\t// The invisible dummyMesh quads and the guiMesh need to be rendered before the controller lines so that they\n\t\t\t\t// leave a hole in the depth buffer that the lines can intersect.\n\t\t\t\tline.renderOrder = 1;\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\t\t\t\tconst handModelFactory = new XRHandModelFactory().setPath( './models/fbx/' );\n\n\t\t\t\t//\n\n\t\t\t\tconst controllers = [\n\t\t\t\t\trenderer.xr.getController( 0 ),\n\t\t\t\t\trenderer.xr.getController( 1 )\n\t\t\t\t];\n\n\t\t\t\tcontrollers.forEach( ( controller, i ) => {\n\n\t\t\t\t\tconst controllerGrip = renderer.xr.getControllerGrip( i );\n\t\t\t\t\tcontrollerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );\n\t\t\t\t\tscene.add( controllerGrip );\n\n\t\t\t\t\tconst hand = renderer.xr.getHand( i );\n\t\t\t\t\thand.add( handModelFactory.createHandModel( hand ) );\n\n\t\t\t\t\tcontroller.add( line.clone() );\n\t\t\t\t\tscene.add( controller, controllerGrip, hand );\n\n\t\t\t\t} );\n\n\t\t\t\t// Eye charts\n\n\t\t\t\tconst eyeCharts = new THREE.Group();\n\t\t\t\teyeCharts.position.z = snellenConfig.z;\n\t\t\t\tscene.add( eyeCharts );\n\n\t\t\t\tsnellenTexture = new THREE.TextureLoader().load( 'textures/snellen.png' );\n\t\t\t\tsnellenTexture.repeat.x = snellenConfig.cropX;\n\t\t\t\tsnellenTexture.repeat.y = snellenConfig.cropY;\n\t\t\t\tsnellenTexture.generateMipmaps = false;\n\t\t\t\tsnellenTexture.minFilter = THREE.LinearFilter;\n\t\t\t\tconst snellenMeshPlain = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( snellenConfig.widthMeters, snellenConfig.heightMeters ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { map: snellenTexture } ) );\n\t\t\t\tsnellenMeshPlain.position.x = snellenConfig.x - snellenConfig.widthMeters;\n\t\t\t\tsnellenMeshPlain.position.y = snellenConfig.y - snellenConfig.heightMeters;\n\t\t\t\teyeCharts.add( snellenMeshPlain );\n\n\t\t\t\tsnellenTexture = new THREE.TextureLoader().load( 'textures/snellen.png' );\n\t\t\t\tsnellenTexture.repeat.x = snellenConfig.cropX;\n\t\t\t\tsnellenTexture.repeat.y = snellenConfig.cropY;\n\t\t\t\tconst snellenMeshMipMap = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( snellenConfig.widthMeters, snellenConfig.heightMeters ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { map: snellenTexture } ) );\n\t\t\t\tsnellenMeshMipMap.position.x = snellenConfig.x + snellenConfig.widthMeters;\n\t\t\t\tsnellenMeshMipMap.position.y = snellenConfig.y - snellenConfig.heightMeters;\n\t\t\t\teyeCharts.add( snellenMeshMipMap );\n\n\t\t\t\t// The layers don't participate depth testing between each other. Since the projection\n\t\t\t\t// layer is rendered last, any 3D object will incorrectly overlap layers. To avoid this,\n\t\t\t\t// invisible quads can be placed into the scene to participate in depth testing when the\n\t\t\t\t// projection layer is rendered.\n\t\t\t\tconst dummyMeshLeft = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( snellenConfig.widthMeters, snellenConfig.heightMeters ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { colorWrite: false } ) );\n\t\t\t\tdummyMeshLeft.position.x = snellenConfig.x - snellenConfig.widthMeters;\n\t\t\t\tdummyMeshLeft.position.y = snellenConfig.y + snellenConfig.heightMeters;\n\t\t\t\teyeCharts.add( dummyMeshLeft );\n\n\t\t\t\tconst dummyMeshRight = dummyMeshLeft.clone( true );\n\t\t\t\tdummyMeshRight.position.x = snellenConfig.x + snellenConfig.widthMeters;\n\t\t\t\teyeCharts.add( dummyMeshRight );\n\n\t\t\t\t// The GUI is rendered into an invisible HTMLMesh and the backing canvas's data is copied\n\t\t\t\t// into a layer as required. Hit testing and interaction is done using standard HTMLMesh\n\t\t\t\t// behavior, but since the layer is in the same place as the invisible mesh, the user\n\t\t\t\t// thinks they're directly interacting with the layer.\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\t\t\t\tgui.add( parameters, 'eyeChartDistanceFt', 1.0, 20.0 ).onChange( onChange );\n\t\t\t\tgui.domElement.style.visibility = 'hidden';\n\n\t\t\t\tfunction onChange() {\n\n\t\t\t\t\teyeCharts.position.z = - parameters.eyeChartDistanceFt * 0.3048;\n\t\t\t\t\tsnellenConfig.z = eyeCharts.position.z;\n\n\t\t\t\t\tif ( quadLayerPlain ) {\n\n\t\t\t\t\t\tquadLayerPlain.transform = new XRRigidTransform( {\n\t\t\t\t\t\t\tx: snellenConfig.x - snellenConfig.widthMeters,\n\t\t\t\t\t\t\ty: snellenConfig.y + snellenConfig.heightMeters,\n\t\t\t\t\t\t\tz: eyeCharts.position.z\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( quadLayerMips ) {\n\n\t\t\t\t\t\tquadLayerMips.transform = new XRRigidTransform( {\n\t\t\t\t\t\t\tx: snellenConfig.x + snellenConfig.widthMeters,\n\t\t\t\t\t\t\ty: snellenConfig.y + snellenConfig.heightMeters,\n\t\t\t\t\t\t\tz: eyeCharts.position.z\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tguiLayer.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst group = new InteractiveGroup();\n\t\t\t\tgroup.listenToXRControllerEvents( controllers[ 0 ] );\n\t\t\t\tgroup.listenToXRControllerEvents( controllers[ 1 ] );\n\t\t\t\tscene.add( group );\n\n\t\t\t\tguiMesh = new HTMLMesh( gui.domElement );\n\t\t\t\tguiMesh.position.set( 1.0, 1.5, - 1.0 );\n\t\t\t\tguiMesh.rotation.y = - Math.PI / 4;\n\t\t\t\tguiMesh.scale.setScalar( 2 );\n\t\t\t\tguiMesh.material.colorWrite = false;\n\t\t\t\tguiMesh.material.transparent = false;\n\t\t\t\tgroup.add( guiMesh );\n\n\t\t\t\t// Error message if layer initialization fails.\n\t\t\t\tconst errorCanvas = document.createElement( 'canvas' );\n\t\t\t\terrorCanvas.width = 400;\n\t\t\t\terrorCanvas.height = 40;\n\t\t\t\tconst errorContext = errorCanvas.getContext( '2d' );\n\t\t\t\terrorContext.fillStyle = '#FF0000';\n\t\t\t\terrorContext.fillRect( 0, 0, errorCanvas.width, errorCanvas.height );\n\t\t\t\terrorContext.fillStyle = '#000000';\n\t\t\t\terrorContext.font = '28px sans-serif';\n\t\t\t\terrorContext.fillText( 'ERROR: Layers not initialized!', 10, 30 );\n\n\t\t\t\terrorMesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 1, .1 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { map: new THREE.CanvasTexture( errorCanvas ) } )\n\t\t\t\t);\n\t\t\t\terrorMesh.position.z = - 1;\n\t\t\t\terrorMesh.position.y = 1.5;\n\t\t\t\terrorMesh.visible = false;\n\t\t\t\tscene.add( errorMesh );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t\tvideo = document.createElement( 'video' );\n\t\t\t\tvideo.loop = true;\n\t\t\t\tvideo.src = 'textures/MaryOculus.webm';\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\t\t\t//\n\n\t\t\tfunction animate( t, frame ) {\n\n\t\t\t\tconst xr = renderer.xr;\n\t\t\t\tconst session = xr.getSession();\n\t\t\t\tconst gl = renderer.getContext();\n\n\t\t\t\t// Init layers once in immersive mode and video is ready.\n\t\t\t\tconst useLayers = session &&\n\t\t\t\t\tsession.enabledFeatures !== undefined &&\n\t\t\t\t\tsession.enabledFeatures.includes( 'layers' ) &&\n\t\t\t\t\tXRMediaBinding !== undefined;\n\n\t\t\t\tif ( ! useLayers ) {\n\n\t\t\t\t\terrorMesh.visible = true;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tsession &&\n\t\t\t\t\tuseLayers &&\n\t\t\t\t\tsession.hasMediaLayer === undefined &&\n\t\t\t\t\tvideo.readyState >= 2\n\t\t\t\t) {\n\n\t\t\t\t\tsession.hasMediaLayer = true;\n\t\t\t\t\tsession.requestReferenceSpace( 'local-floor' ).then( ( refSpace ) => {\n\n\t\t\t\t\t\t// Create Quad layers for Snellen chart.\n\t\t\t\t\t\tconst glBinding = xr.getBinding();\n\t\t\t\t\t\tconst quadLayerConfig = {\n\t\t\t\t\t\t\twidth: snellenConfig.quadWidth,\n\t\t\t\t\t\t\theight: snellenConfig.quadHeight,\n\t\t\t\t\t\t\tviewPixelWidth: snellenConfig.textureSizePx,\n\t\t\t\t\t\t\tviewPixelHeight: snellenConfig.textureSizePx,\n\t\t\t\t\t\t\tisStatic: true,\n\t\t\t\t\t\t\tspace: refSpace,\n\t\t\t\t\t\t\tlayout: 'mono',\n\t\t\t\t\t\t\ttransform: new XRRigidTransform( {\n\t\t\t\t\t\t\t\tx: snellenConfig.x - snellenConfig.widthMeters,\n\t\t\t\t\t\t\t\ty: snellenConfig.y + snellenConfig.heightMeters,\n\t\t\t\t\t\t\t\tz: snellenConfig.z\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tquadLayerPlain = glBinding.createQuadLayer( quadLayerConfig );\n\n\t\t\t\t\t\tquadLayerConfig.mipLevels = 3;\n\t\t\t\t\t\tquadLayerConfig.transform = new XRRigidTransform( {\n\t\t\t\t\t\t\tx: snellenConfig.x + snellenConfig.widthMeters,\n\t\t\t\t\t\t\ty: snellenConfig.y + snellenConfig.heightMeters,\n\t\t\t\t\t\t\tz: snellenConfig.z\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tquadLayerMips = glBinding.createQuadLayer( quadLayerConfig );\n\n\t\t\t\t\t\t// Create GUI layer.\n\t\t\t\t\t\tguiLayer = glBinding.createQuadLayer( {\n\t\t\t\t\t\t\twidth: guiMesh.geometry.parameters.width,\n\t\t\t\t\t\t\theight: guiMesh.geometry.parameters.height,\n\t\t\t\t\t\t\tviewPixelWidth: guiMesh.material.map.image.width,\n\t\t\t\t\t\t\tviewPixelHeight: guiMesh.material.map.image.height,\n\t\t\t\t\t\t\tspace: refSpace,\n\t\t\t\t\t\t\ttransform: new XRRigidTransform( guiMesh.position, guiMesh.quaternion )\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Create background EQR video layer.\n\t\t\t\t\t\tconst mediaBinding = new XRMediaBinding( session );\n\t\t\t\t\t\tconst equirectLayer = mediaBinding.createEquirectLayer(\n\t\t\t\t\t\t\tvideo,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tspace: refSpace,\n\t\t\t\t\t\t\t\tlayout: 'stereo-left-right',\n\t\t\t\t\t\t\t\t// Rotate by 45 deg to avoid stereo conflict with the 3D geometry.\n\t\t\t\t\t\t\t\ttransform: new XRRigidTransform(\n\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t{ x: 0, y: .28, z: 0, w: .96 }\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\terrorMesh.visible = false;\n\n\t\t\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\t\t\tlayers: [\n\t\t\t\t\t\t\t\tequirectLayer,\n\t\t\t\t\t\t\t\tquadLayerPlain,\n\t\t\t\t\t\t\t\tquadLayerMips,\n\t\t\t\t\t\t\t\tguiLayer,\n\t\t\t\t\t\t\t\tsession.renderState.layers[ 0 ]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tvideo.play();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// Copy image to layers as required.\n\t\t\t\t// needsRedraw is set on creation or if the underlying GL resources of a layer are lost.\n\t\t\t\tif ( session && quadLayerPlain && quadLayerPlain.needsRedraw ) {\n\n\t\t\t\t\tconst glayer = xr.getBinding().getSubImage( quadLayerPlain, frame );\n\t\t\t\t\trenderer.state.bindTexture( gl.TEXTURE_2D, glayer.colorTexture );\n\t\t\t\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true );\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, 0,\n\t\t\t\t\t\t( snellenConfig.textureSizePx - snellenConfig.widthPx ) / 2,\n\t\t\t\t\t\t( snellenConfig.textureSizePx - snellenConfig.heightPx ) / 2,\n\t\t\t\t\t\tsnellenConfig.widthPx, snellenConfig.heightPx,\n\t\t\t\t\t\tgl.RGBA, gl.UNSIGNED_BYTE, snellenTexture.image );\n\n\t\t\t\t}\n\n\t\t\t\t// Same as above but also gl.generateMipmap.\n\t\t\t\tif ( session && quadLayerMips && quadLayerMips.needsRedraw ) {\n\n\t\t\t\t\tconst glayer = xr.getBinding().getSubImage( quadLayerMips, frame );\n\t\t\t\t\trenderer.state.bindTexture( gl.TEXTURE_2D, glayer.colorTexture );\n\t\t\t\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true );\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, 0,\n\t\t\t\t\t\t( snellenConfig.textureSizePx - snellenConfig.widthPx ) / 2,\n\t\t\t\t\t\t( snellenConfig.textureSizePx - snellenConfig.heightPx ) / 2,\n\t\t\t\t\t\tsnellenConfig.widthPx, snellenConfig.heightPx,\n\t\t\t\t\t\tgl.RGBA, gl.UNSIGNED_BYTE, snellenTexture.image );\n\t\t\t\t\tgl.generateMipmap( gl.TEXTURE_2D );\n\n\t\t\t\t}\n\n\t\t\t\t// Same as above, but guiLayer.needsUpdate is set when the user interacts with the GUI.\n\t\t\t\tif ( session && guiLayer && ( guiLayer.needsRedraw || guiLayer.needsUpdate ) ) {\n\n\t\t\t\t\tconst glayer = xr.getBinding().getSubImage( guiLayer, frame );\n\t\t\t\t\trenderer.state.bindTexture( gl.TEXTURE_2D, glayer.colorTexture );\n\t\t\t\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true );\n\t\t\t\t\tconst canvas = guiMesh.material.map.image;\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, 0, 0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, canvas );\n\t\t\t\t\tguiLayer.needsUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js media and projection layers This example demonstrates the use of WebXR Layers to render high quality text and video. For static content such as text, using layers increases the usable resolution of the content by avoiding the extra resampling pass that occurs during normal VR rendering. For dynamic content such as video, using layers also improves performance by only copying data when new frames are available. See the comments in the code for more information."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - panorama"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - panorama:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\n\t\t\tlet camera;\n\t\t\tlet renderer;\n\t\t\tlet scene;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\trenderer.xr.setReferenceSpaceType( 'local' );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.layers.enable( 1 );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 100, 100, 100 );\n\t\t\t\tgeometry.scale( 1, 1, - 1 );\n\n\t\t\t\tconst textures = getTexturesFromAtlasFile( 'textures/cube/sun_temple_stripe_stereo.jpg', 12 );\n\n\t\t\t\tconst materials = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tmaterials.push( new THREE.MeshBasicMaterial( { map: textures[ i ] } ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst skyBox = new THREE.Mesh( geometry, materials );\n\t\t\t\tskyBox.layers.set( 1 );\n\t\t\t\tscene.add( skyBox );\n\n\n\t\t\t\tconst materialsR = [];\n\n\t\t\t\tfor ( let i = 6; i < 12; i ++ ) {\n\n\t\t\t\t\tmaterialsR.push( new THREE.MeshBasicMaterial( { map: textures[ i ] } ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst skyBoxR = new THREE.Mesh( geometry, materialsR );\n\t\t\t\tskyBoxR.layers.set( 2 );\n\t\t\t\tscene.add( skyBoxR );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction getTexturesFromAtlasFile( atlasImgUrl, tilesNum ) {\n\n\t\t\t\tconst textures = [];\n\n\t\t\t\tfor ( let i = 0; i < tilesNum; i ++ ) {\n\n\t\t\t\t\ttextures[ i ] = new THREE.Texture();\n\n\t\t\t\t}\n\n\t\t\t\tconst loader = new THREE.ImageLoader();\n\t\t\t\tloader.load( atlasImgUrl, function ( imageObj ) {\n\n\t\t\t\t\tlet canvas, context;\n\t\t\t\t\tconst tileWidth = imageObj.height;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tcanvas = document.createElement( 'canvas' );\n\t\t\t\t\t\tcontext = canvas.getContext( '2d' );\n\t\t\t\t\t\tcanvas.height = tileWidth;\n\t\t\t\t\t\tcanvas.width = tileWidth;\n\t\t\t\t\t\tcontext.drawImage( imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth );\n\t\t\t\t\t\ttextures[ i ].colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\ttextures[ i ].image = canvas;\n\t\t\t\t\t\ttextures[ i ].needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn textures;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - panorama with depth"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - panorama with depth:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\n\t\t\tlet camera, scene, renderer, sphere, clock;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x101010 );\n\n\t\t\t\tconst light = new THREE.AmbientLight( 0xffffff, 3 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\t// Create the panoramic sphere geometry\n\t\t\t\tconst panoSphereGeo = new THREE.SphereGeometry( 6, 256, 256 );\n\n\t\t\t\t// Create the panoramic sphere material\n\t\t\t\tconst panoSphereMat = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tside: THREE.BackSide,\n\t\t\t\t\tdisplacementScale: - 4.0\n\t\t\t\t} );\n\n\t\t\t\t// Create the panoramic sphere mesh\n\t\t\t\tsphere = new THREE.Mesh( panoSphereGeo, panoSphereMat );\n\n\t\t\t\t// Load and assign the texture and depth map\n\t\t\t\tconst manager = new THREE.LoadingManager();\n\t\t\t\tconst loader = new THREE.TextureLoader( manager );\n\n\t\t\t\tloader.load( './textures/kandao3.jpg', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\tsphere.material.map = texture;\n\n\t\t\t\t} );\n\n\t\t\t\tloader.load( './textures/kandao3_depthmap.jpg', function ( depth ) {\n\n\t\t\t\t\tdepth.minFilter = THREE.NearestFilter;\n\t\t\t\t\tdepth.generateMipmaps = false;\n\t\t\t\t\tsphere.material.displacementMap = depth;\n\n\t\t\t\t} );\n\n\t\t\t\t// On load complete add the panoramic sphere to the scene\n\t\t\t\tmanager.onLoad = function () {\n\n\t\t\t\t\tscene.add( sphere );\n\n\t\t\t\t};\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\trenderer.xr.setReferenceSpaceType( 'local' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\t// If we are not presenting move the camera a little so the effect is visible\n\n\t\t\t\tif ( renderer.xr.isPresenting === false ) {\n\n\t\t\t\t\tconst time = clock.getElapsedTime();\n\n\t\t\t\t\tsphere.rotation.y += 0.001;\n\t\t\t\t\tsphere.position.x = Math.sin( time ) * 0.2;\n\t\t\t\t\tsphere.position.z = Math.cos( time ) * 0.2;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - panorama with depth Created by @juniorxsound . Panorama from krpano ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - roller coaster"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - roller coaster:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport {\n\t\t\t\tRollerCoasterGeometry,\n\t\t\t\tRollerCoasterShadowGeometry,\n\t\t\t\tRollerCoasterLiftersGeometry,\n\t\t\t\tTreesGeometry,\n\t\t\t\tSkyGeometry\n\t\t\t} from 'three/addons/misc/RollerCoaster.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\n\t\t\tlet mesh, material, geometry;\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.xr.enabled = true;\n\t\t\trenderer.xr.setReferenceSpaceType( 'local' );\n\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t//\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xf0f0ff );\n\n\t\t\tconst light = new THREE.HemisphereLight( 0xfff0f0, 0x60606, 3 );\n\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\tscene.add( light );\n\n\t\t\tconst train = new THREE.Object3D();\n\t\t\tscene.add( train );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 500 );\n\t\t\ttrain.add( camera );\n\n\t\t\t// environment\n\n\t\t\tgeometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );\n\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\tconst positions = geometry.attributes.position.array;\n\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\tfor ( let i = 0; i < positions.length; i += 3 ) {\n\n\t\t\t\tvertex.fromArray( positions, i );\n\n\t\t\t\tvertex.x += Math.random() * 10 - 5;\n\t\t\t\tvertex.z += Math.random() * 10 - 5;\n\n\t\t\t\tconst distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;\n\t\t\t\tvertex.y = Math.random() * Math.max( 0, distance );\n\n\t\t\t\tvertex.toArray( positions, i );\n\n\t\t\t}\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\tcolor: 0x407000\n\t\t\t} );\n\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new TreesGeometry( mesh );\n\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tside: THREE.DoubleSide, vertexColors: true\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new SkyGeometry();\n\t\t\tmaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\t//\n\n\t\t\tconst PI2 = Math.PI * 2;\n\n\t\t\tconst curve = ( function () {\n\n\t\t\t\tconst vector = new THREE.Vector3();\n\t\t\t\tconst vector2 = new THREE.Vector3();\n\n\t\t\t\treturn {\n\n\t\t\t\t\tgetPointAt: function ( t ) {\n\n\t\t\t\t\t\tt = t * PI2;\n\n\t\t\t\t\t\tconst x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;\n\t\t\t\t\t\tconst y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;\n\t\t\t\t\t\tconst z = Math.sin( t ) * Math.sin( t * 4 ) * 50;\n\n\t\t\t\t\t\treturn vector.set( x, y, z ).multiplyScalar( 2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tgetTangentAt: function ( t ) {\n\n\t\t\t\t\t\tconst delta = 0.0001;\n\t\t\t\t\t\tconst t1 = Math.max( 0, t - delta );\n\t\t\t\t\t\tconst t2 = Math.min( 1, t + delta );\n\n\t\t\t\t\t\treturn vector2.copy( this.getPointAt( t2 ) )\n\t\t\t\t\t\t\t.sub( this.getPointAt( t1 ) ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t} )();\n\n\t\t\tgeometry = new RollerCoasterGeometry( curve, 1500 );\n\t\t\tmaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\tvertexColors: true\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new RollerCoasterLiftersGeometry( curve, 100 );\n\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.y = 0.1;\n\t\t\tscene.add( mesh );\n\n\t\t\tgeometry = new RollerCoasterShadowGeometry( curve, 500 );\n\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: 0x305000, depthWrite: false, transparent: true\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.y = 0.1;\n\t\t\tscene.add( mesh );\n\n\t\t\tconst funfairs = [];\n\n\t\t\t//\n\n\t\t\tgeometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );\n\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\tcolor: 0xff8080\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( - 80, 10, - 70 );\n\t\t\tmesh.rotation.x = Math.PI / 2;\n\t\t\tscene.add( mesh );\n\n\t\t\tfunfairs.push( mesh );\n\n\t\t\tgeometry = new THREE.CylinderGeometry( 5, 6, 4, 10 );\n\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\tcolor: 0x8080ff\n\t\t\t} );\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.position.set( 50, 2, 30 );\n\t\t\tscene.add( mesh );\n\n\t\t\tfunfairs.push( mesh );\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst position = new THREE.Vector3();\n\t\t\tconst tangent = new THREE.Vector3();\n\n\t\t\tconst lookAt = new THREE.Vector3();\n\n\t\t\tlet velocity = 0;\n\t\t\tlet progress = 0;\n\n\t\t\tlet prevTime = performance.now();\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now();\n\t\t\t\tconst delta = time - prevTime;\n\n\t\t\t\tfor ( let i = 0; i < funfairs.length; i ++ ) {\n\n\t\t\t\t\tfunfairs[ i ].rotation.y = time * 0.0004;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tprogress += velocity;\n\t\t\t\tprogress = progress % 1;\n\n\t\t\t\tposition.copy( curve.getPointAt( progress ) );\n\t\t\t\tposition.y += 0.3;\n\n\t\t\t\ttrain.position.copy( position );\n\n\t\t\t\ttangent.copy( curve.getTangentAt( progress ) );\n\n\t\t\t\tvelocity -= tangent.y * 0.0000001 * delta;\n\t\t\t\tvelocity = Math.max( 0.00004, Math.min( 0.0002, velocity ) );\n\n\t\t\t\ttrain.lookAt( lookAt.copy( position ).sub( tangent ) );\n\n\t\t\t\t//\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tprevTime = time;\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - sandbox"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - sandbox:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { Reflector } from 'three/addons/objects/Reflector.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\n\t\t\timport { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';\n\t\t\timport { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet reflector;\n\t\t\tlet stats, statsMesh;\n\n\t\t\tconst parameters = {\n\t\t\t\tradius: 0.6,\n\t\t\t\ttube: 0.2,\n\t\t\t\ttubularSegments: 150,\n\t\t\t\tradialSegments: 20,\n\t\t\t\tp: 2,\n\t\t\t\tq: 3,\n\t\t\t\tthickness: 0.5\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'moonless_golf_1k.hdr', function ( texture ) {\n\n\t\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\tscene.background = texture;\n\t\t\t\t\t\tscene.environment = texture;\n\n\t\t\t\t\t} );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 1.5 );\n\n\t\t\t\t//\n\n\t\t\t\tconst torusGeometry = new THREE.TorusKnotGeometry( ...Object.values( parameters ) );\n\t\t\t\tconst torusMaterial = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\ttransmission: 1.0, roughness: 0, metalness: 0.25, thickness: 0.5, side: THREE.DoubleSide\n\t\t\t\t} );\n\t\t\t\tconst torus = new THREE.Mesh( torusGeometry, torusMaterial );\n\t\t\t\ttorus.name = 'torus';\n\t\t\t\ttorus.position.y = 1.5;\n\t\t\t\ttorus.position.z = - 2;\n\t\t\t\tscene.add( torus );\n\n\t\t\t\tconst cylinderGeometry = new THREE.CylinderGeometry( 1, 1, 0.1, 50 );\n\t\t\t\tconst cylinderMaterial = new THREE.MeshStandardMaterial();\n\t\t\t\tconst cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );\n\t\t\t\tcylinder.position.z = - 2;\n\t\t\t\tscene.add( cylinder );\n\n\t\t\t\t//\n\n\t\t\t\treflector = new Reflector( new THREE.PlaneGeometry( 2, 2 ), {\n\t\t\t\t\ttextureWidth: window.innerWidth,\n\t\t\t\t\ttextureHeight: window.innerHeight\n\t\t\t\t} );\n\t\t\t\treflector.position.x = 1;\n\t\t\t\treflector.position.y = 1.5;\n\t\t\t\treflector.position.z = - 3;\n\t\t\t\treflector.rotation.y = - Math.PI / 4;\n\t\t\t\tscene.add( reflector );\n\n\t\t\t\tconst frameGeometry = new THREE.BoxGeometry( 2.1, 2.1, 0.1 );\n\t\t\t\tconst frameMaterial = new THREE.MeshPhongMaterial();\n\t\t\t\tconst frame = new THREE.Mesh( frameGeometry, frameMaterial );\n\t\t\t\tframe.position.z = - 0.07;\n\t\t\t\treflector.add( frame );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.autoClear = false;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 5 ) ] );\n\n\t\t\t\tconst controller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.add( new THREE.Line( geometry ) );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tconst controller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.add( new THREE.Line( geometry ) );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tconst controllerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tconst controllerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t// GUI\n\n\t\t\t\tfunction onChange() {\n\n\t\t\t\t\ttorus.geometry.dispose();\n\t\t\t\t\ttorus.geometry = new THREE.TorusKnotGeometry( ...Object.values( parameters ) );\n\n\t\t\t\t}\n\n\t\t\t\tfunction onThicknessChange() {\n\n\t\t\t\t\ttorus.material.thickness = parameters.thickness;\n\n\t\t\t\t}\n\n\t\t\t\tconst gui = new GUI( { width: 300 } );\n\t\t\t\tgui.add( parameters, 'radius', 0.0, 1.0 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'tube', 0.0, 1.0 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'tubularSegments', 10, 150, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'radialSegments', 2, 20, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'p', 1, 10, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'q', 0, 10, 1 ).onChange( onChange );\n\t\t\t\tgui.add( parameters, 'thickness', 0, 1 ).onChange( onThicknessChange );\n\t\t\t\tgui.domElement.style.visibility = 'hidden';\n\n\t\t\t\tconst group = new InteractiveGroup();\n\t\t\t\tgroup.listenToPointerEvents( renderer, camera );\n\t\t\t\tgroup.listenToXRControllerEvents( controller1 );\n\t\t\t\tgroup.listenToXRControllerEvents( controller2 );\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst mesh = new HTMLMesh( gui.domElement );\n\t\t\t\tmesh.position.x = - 0.75;\n\t\t\t\tmesh.position.y = 1.5;\n\t\t\t\tmesh.position.z = - 0.5;\n\t\t\t\tmesh.rotation.y = Math.PI / 4;\n\t\t\t\tmesh.scale.setScalar( 2 );\n\t\t\t\tgroup.add( mesh );\n\n\n\t\t\t\t// Add stats.js\n\t\t\t\tstats = new Stats();\n\t\t\t\tstats.dom.style.width = '80px';\n\t\t\t\tstats.dom.style.height = '48px';\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tstatsMesh = new HTMLMesh( stats.dom );\n\t\t\t\tstatsMesh.position.x = - 0.75;\n\t\t\t\tstatsMesh.position.y = 2;\n\t\t\t\tstatsMesh.position.z = - 0.6;\n\t\t\t\tstatsMesh.rotation.y = Math.PI / 4;\n\t\t\t\tstatsMesh.scale.setScalar( 2.5 );\n\t\t\t\tgroup.add( statsMesh );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now() * 0.0002;\n\t\t\t\tconst torus = scene.getObjectByName( 'torus' );\n\t\t\t\ttorus.rotation.x = time * 0.4;\n\t\t\t\ttorus.rotation.y = time;\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tstats.update();\n\n\t\t\t\t// Canvas elements doesn't trigger DOM updates, so we have to update the texture\n\t\t\t\tstatsMesh.material.map.update();\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - teleport"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - teleport:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tlet camera, scene, raycaster, renderer;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tlet room, marker, floor, baseReferenceSpace;\n\n\t\t\tlet INTERSECTION;\n\t\t\tconst tempMatrix = new THREE.Matrix4();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x505050 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1, 3 );\n\n\t\t\t\troom = new THREE.LineSegments(\n\t\t\t\t\tnew BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0xbcbcbc } )\n\t\t\t\t);\n\t\t\t\tscene.add( room );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xa5a5a5, 0x898989, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tmarker = new THREE.Mesh(\n\t\t\t\t\tnew THREE.CircleGeometry( 0.25, 32 ).rotateX( - Math.PI / 2 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xbcbcbc } )\n\t\t\t\t);\n\t\t\t\tscene.add( marker );\n\n\t\t\t\tfloor = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 4.8, 4.8, 2, 2 ).rotateX( - Math.PI / 2 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0xbcbcbc, transparent: true, opacity: 0.25 } )\n\t\t\t\t);\n\t\t\t\tscene.add( floor );\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\trenderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );\n\t\t\t\trenderer.xr.enabled = true;\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tfunction onSelectStart() {\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t\tif ( INTERSECTION ) {\n\n\t\t\t\t\t\tconst offsetPosition = { x: - INTERSECTION.x, y: - INTERSECTION.y, z: - INTERSECTION.z, w: 1 };\n\t\t\t\t\t\tconst offsetRotation = new THREE.Quaternion();\n\t\t\t\t\t\tconst transform = new XRRigidTransform( offsetPosition, offsetRotation );\n\t\t\t\t\t\tconst teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace( transform );\n\n\t\t\t\t\t\trenderer.xr.setReferenceSpace( teleportSpaceOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller1.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller1.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller2.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller2.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\t// The XRControllerModelFactory will automatically fetch controller models\n\t\t\t\t// that match what the user is holding as closely as possible. The models\n\t\t\t\t// should be attached to the object returned from getControllerGrip in\n\t\t\t\t// order to match the orientation of the held device.\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\tswitch ( data.targetRayMode ) {\n\n\t\t\t\t\tcase 'tracked-pointer':\n\n\t\t\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );\n\n\t\t\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t\t\tcase 'gaze':\n\n\t\t\t\t\t\tgeometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\t\t\t\treturn new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tINTERSECTION = undefined;\n\n\t\t\t\tif ( controller1.userData.isSelecting === true ) {\n\n\t\t\t\t\ttempMatrix.identity().extractRotation( controller1.matrixWorld );\n\n\t\t\t\t\traycaster.ray.origin.setFromMatrixPosition( controller1.matrixWorld );\n\t\t\t\t\traycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObjects( [ floor ] );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tINTERSECTION = intersects[ 0 ].point;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( controller2.userData.isSelecting === true ) {\n\n\t\t\t\t\ttempMatrix.identity().extractRotation( controller2.matrixWorld );\n\n\t\t\t\t\traycaster.ray.origin.setFromMatrixPosition( controller2.matrixWorld );\n\t\t\t\t\traycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t\t\t\tconst intersects = raycaster.intersectObjects( [ floor ] );\n\n\t\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\t\tINTERSECTION = intersects[ 0 ].point;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( INTERSECTION ) marker.position.copy( INTERSECTION );\n\n\t\t\t\tmarker.visible = INTERSECTION !== undefined;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - teleport"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates vr - 360 stereo video"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js vr - 360 stereo video:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { VRButton } from 'three/addons/webxr/VRButton.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\t\t\t\tcontainer.addEventListener( 'click', function () {\n\n\t\t\t\t\tvideo.play();\n\n\t\t\t\t} );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.layers.enable( 1 ); // render left view when no stereo available\n\n\t\t\t\t// video\n\n\t\t\t\tconst video = document.getElementById( 'video' );\n\t\t\t\tvideo.play();\n\n\t\t\t\tconst texture = new THREE.VideoTexture( video );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x101010 );\n\n\t\t\t\t// left\n\n\t\t\t\tconst geometry1 = new THREE.SphereGeometry( 500, 60, 40 );\n\t\t\t\t// invert the geometry on the x-axis so that all of the faces point inward\n\t\t\t\tgeometry1.scale( - 1, 1, 1 );\n\n\t\t\t\tconst uvs1 = geometry1.attributes.uv.array;\n\n\t\t\t\tfor ( let i = 0; i < uvs1.length; i += 2 ) {\n\n\t\t\t\t\tuvs1[ i ] *= 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tconst material1 = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh1 = new THREE.Mesh( geometry1, material1 );\n\t\t\t\tmesh1.rotation.y = - Math.PI / 2;\n\t\t\t\tmesh1.layers.set( 1 ); // display in left eye only\n\t\t\t\tscene.add( mesh1 );\n\n\t\t\t\t// right\n\n\t\t\t\tconst geometry2 = new THREE.SphereGeometry( 500, 60, 40 );\n\t\t\t\tgeometry2.scale( - 1, 1, 1 );\n\n\t\t\t\tconst uvs2 = geometry2.attributes.uv.array;\n\n\t\t\t\tfor ( let i = 0; i < uvs2.length; i += 2 ) {\n\n\t\t\t\t\tuvs2[ i ] *= 0.5;\n\t\t\t\t\tuvs2[ i ] += 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tconst material2 = new THREE.MeshBasicMaterial( { map: texture } );\n\n\t\t\t\tconst mesh2 = new THREE.Mesh( geometry2, material2 );\n\t\t\t\tmesh2.rotation.y = - Math.PI / 2;\n\t\t\t\tmesh2.layers.set( 2 ); // display in right eye only\n\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\trenderer.xr.setReferenceSpaceType( 'local' );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js vr - 360 stereo video stereoscopic panoramic render by pedrofe . scene from mery project ."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - ball shooter"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - ball shooter:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tlet room, spheres, physics;\n\t\t\tconst velocity = new THREE.Vector3();\n\n\t\t\tlet count = 0;\n\n\t\t\tinit();\n\t\t\tawait initPhysics();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x505050 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 50 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\troom = new THREE.LineSegments(\n\t\t\t\t\tnew BoxLineGeometry( 6, 6, 6, 10, 10, 10 ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0x808080 } )\n\t\t\t\t);\n\t\t\t\troom.geometry.translate( 0, 3, 0 );\n\t\t\t\tscene.add( room );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbbbbbb, 0x888888, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.y = 1.6;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer, {\n\t\t\t\t\t'optionalFeatures': [ 'depth-sensing' ],\n\t\t\t\t\t'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }\n\t\t\t\t} ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tfunction onSelectStart() {\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller1.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller1.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller2.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller2.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\t// The XRControllerModelFactory will automatically fetch controller models\n\t\t\t\t// that match what the user is holding as closely as possible. The models\n\t\t\t\t// should be attached to the object returned from getControllerGrip in\n\t\t\t\t// order to match the orientation of the held device.\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\tswitch ( data.targetRayMode ) {\n\n\t\t\t\t\tcase 'tracked-pointer':\n\n\t\t\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );\n\n\t\t\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t\t\tcase 'gaze':\n\n\t\t\t\t\t\tgeometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\t\t\t\treturn new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function initPhysics() {\n\n\t\t\t\tphysics = await RapierPhysics();\n\n\t\t\t\t{\n\n\t\t\t\t\t// Floor\n\n\t\t\t\t\tconst geometry = new THREE.BoxGeometry( 6, 2, 6 );\n\t\t\t\t\tconst material = new THREE.MeshNormalMaterial( { visible: false } );\n\n\t\t\t\t\tconst floor = new THREE.Mesh( geometry, material );\n\t\t\t\t\tfloor.position.y = - 1;\n\t\t\t\t\tfloor.userData.physics = { mass: 0 };\n\t\t\t\t\tscene.add( floor );\n\n\t\t\t\t\t// Walls\n\n\t\t\t\t\tconst wallPX = new THREE.Mesh( geometry, material );\n\t\t\t\t\twallPX.position.set( 4, 3, 0 );\n\t\t\t\t\twallPX.rotation.z = Math.PI / 2;\n\t\t\t\t\twallPX.userData.physics = { mass: 0 };\n\t\t\t\t\tscene.add( wallPX );\n\n\t\t\t\t\tconst wallNX = new THREE.Mesh( geometry, material );\n\t\t\t\t\twallNX.position.set( - 4, 3, 0 );\n\t\t\t\t\twallNX.rotation.z = Math.PI / 2;\n\t\t\t\t\twallNX.userData.physics = { mass: 0 };\n\t\t\t\t\tscene.add( wallNX );\n\n\t\t\t\t\tconst wallPZ = new THREE.Mesh( geometry, material );\n\t\t\t\t\twallPZ.position.set( 0, 3, 4 );\n\t\t\t\t\twallPZ.rotation.x = Math.PI / 2;\n\t\t\t\t\twallPZ.userData.physics = { mass: 0 };\n\t\t\t\t\tscene.add( wallPZ );\n\n\t\t\t\t\tconst wallNZ = new THREE.Mesh( geometry, material );\n\t\t\t\t\twallNZ.position.set( 0, 3, - 4 );\n\t\t\t\t\twallNZ.rotation.x = Math.PI / 2;\n\t\t\t\t\twallNZ.userData.physics = { mass: 0 };\n\t\t\t\t\tscene.add( wallNZ );\n\n\t\t\t\t}\n\n\t\t\t\t// Spheres\n\n\t\t\t\tconst geometry = new THREE.IcosahedronGeometry( 0.08, 3 );\n\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\tspheres = new THREE.InstancedMesh( geometry, material, 800 );\n\t\t\t\tspheres.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tspheres.userData.physics = { mass: 1, restitution: 1.1 };\n\t\t\t\tscene.add( spheres );\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tfor ( let i = 0; i < spheres.count; i ++ ) {\n\n\t\t\t\t\tconst x = Math.random() * 4 - 2;\n\t\t\t\t\tconst y = Math.random() * 4;\n\t\t\t\t\tconst z = Math.random() * 4 - 2;\n\n\t\t\t\t\tmatrix.setPosition( x, y, z );\n\t\t\t\t\tspheres.setMatrixAt( i, matrix );\n\t\t\t\t\tspheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction handleController( controller ) {\n\n\t\t\t\tif ( controller.userData.isSelecting ) {\n\n\t\t\t\t\tphysics.setMeshPosition( spheres, controller.position, count );\n\n\t\t\t\t\tvelocity.x = ( Math.random() - 0.5 ) * 2;\n\t\t\t\t\tvelocity.y = ( Math.random() - 0.5 ) * 2;\n\t\t\t\t\tvelocity.z = ( Math.random() - 9 );\n\t\t\t\t\tvelocity.applyQuaternion( controller.quaternion );\n\n\t\t\t\t\tphysics.setMeshVelocity( spheres, velocity, count );\n\n\t\t\t\t\tif ( ++ count === spheres.count ) count = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\thandleController( controller1 );\n\t\t\t\thandleController( controller2 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - ball shooter"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - controls - transform"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - controls - transform:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2, line;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tlet raycaster;\n\n\t\t\tlet controls, group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x808080 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 0 );\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 6, 6 );\n\t\t\t\tconst floorMaterial = new THREE.ShadowMaterial( { opacity: 0.25, blending: THREE.CustomBlending, transparent: false } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 3;\n\t\t\t\tlight.shadow.camera.bottom = - 3;\n\t\t\t\tlight.shadow.camera.right = 3;\n\t\t\t\tlight.shadow.camera.left = - 3;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.BoxGeometry( 0.2, 0.2, 0.2 ),\n\t\t\t\t\tnew THREE.ConeGeometry( 0.2, 0.4, 64 ),\n\t\t\t\t\tnew THREE.CylinderGeometry( 0.2, 0.2, 0.2, 64 ),\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 0.2, 8 ),\n\t\t\t\t\tnew THREE.TorusGeometry( 0.2, 0.04, 64, 32 )\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\t\tconst geometry = geometries[ Math.floor( Math.random() * geometries.length ) ];\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: Math.random() * 0xffffff,\n\t\t\t\t\t\troughness: 0.7,\n\t\t\t\t\t\tmetalness: 0.0\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tobject.position.x = Math.random() - 0.5;\n\t\t\t\t\tobject.position.y = Math.random() * 2 + 0.5;\n\t\t\t\t\tobject.position.z = Math.random() - 2.5;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.setScalar( Math.random() + 0.5 );\n\n\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\tobject.receiveShadow = true;\n\n\t\t\t\t\tgroup.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'select', onSelect );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onControllerEvent );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onControllerEvent );\n\t\t\t\tcontroller1.addEventListener( 'move', onControllerEvent );\n\t\t\t\tcontroller1.userData.active = false;\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'select', onSelect );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onControllerEvent );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onControllerEvent );\n\t\t\t\tcontroller2.addEventListener( 'move', onControllerEvent );\n\t\t\t\tcontroller2.userData.active = true;\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );\n\n\t\t\t\tline = new THREE.Line( geometry );\n\t\t\t\tline.name = 'line';\n\t\t\t\tline.scale.z = 5;\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new TransformControls( camera, renderer.domElement );\n\t\t\t\tcontrols.attach( group.children[ 0 ] );\n\t\t\t\tscene.add( controls.getHelper() );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onSelect( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tcontroller1.userData.active = false;\n\t\t\t\tcontroller2.userData.active = false;\n\n\t\t\t\tif ( controller === controller1 ) {\n\n\t\t\t\t\tcontroller1.userData.active = true;\n\t\t\t\t\tcontroller1.add( line );\n\n\t\t\t\t}\n\n\t\t\t\tif ( controller === controller2 ) {\n\n\t\t\t\t\tcontroller2.userData.active = true;\n\t\t\t\t\tcontroller2.add( line );\n\n\t\t\t\t}\n\n\t\t\t\traycaster.setFromXRController( controller );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( group.children );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tcontrols.attach( intersects[ 0 ].object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onControllerEvent( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tif ( controller.userData.active === false ) return;\n\n\t\t\t\tcontrols.getRaycaster().setFromXRController( controller );\n\n\t\t\t\tswitch ( event.type ) {\n\n\t\t\t\t\tcase 'selectstart':\n\t\t\t\t\t\tcontrols.pointerDown( null );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'selectend':\n\t\t\t\t\t\tcontrols.pointerUp( null );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'move':\n\t\t\t\t\t\tcontrols.pointerHover( null );\n\t\t\t\t\t\tcontrols.pointerMove( null );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - controls - transform"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - cubes"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - cubes:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, raycaster, renderer;\n\n\t\t\tlet room;\n\n\t\t\tlet controller, controllerGrip;\n\t\t\tlet INTERSECTED;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x505050 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\t\t\t\tscene.add( camera );\n\n\t\t\t\troom = new THREE.LineSegments(\n\t\t\t\t\tnew BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),\n\t\t\t\t\tnew THREE.LineBasicMaterial( { color: 0xbcbcbc } )\n\t\t\t\t);\n\t\t\t\tscene.add( room );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xa5a5a5, 0x898989, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 1, 1, 1 ).normalize();\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 0.15, 0.15, 0.15 );\n\n\t\t\t\tfor ( let i = 0; i < 200; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tobject.position.y = Math.random() * 4;\n\t\t\t\t\tobject.position.z = Math.random() * 4 - 2;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.z = Math.random() + 0.5;\n\n\t\t\t\t\tobject.userData.velocity = new THREE.Vector3();\n\t\t\t\t\tobject.userData.velocity.x = Math.random() * 0.01 - 0.005;\n\t\t\t\t\tobject.userData.velocity.y = Math.random() * 0.01 - 0.005;\n\t\t\t\t\tobject.userData.velocity.z = Math.random() * 0.01 - 0.005;\n\n\t\t\t\t\troom.add( object );\n\n\t\t\t\t}\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tfunction onSelectStart() {\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller = renderer.xr.getController( 0 );\n\t\t\t\tcontroller.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller.addEventListener( 'connected', function ( event ) {\n\n\t\t\t\t\tthis.add( buildController( event.data ) );\n\n\t\t\t\t} );\n\t\t\t\tcontroller.addEventListener( 'disconnected', function () {\n\n\t\t\t\t\tthis.remove( this.children[ 0 ] );\n\n\t\t\t\t} );\n\t\t\t\tscene.add( controller );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );\n\t\t\t\tscene.add( controllerGrip );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer, {\n\t\t\t\t\t'optionalFeatures': [ 'depth-sensing' ],\n\t\t\t\t\t'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tlet geometry, material;\n\n\t\t\t\tswitch ( data.targetRayMode ) {\n\n\t\t\t\t\tcase 'tracked-pointer':\n\n\t\t\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );\n\n\t\t\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t\t\tcase 'gaze':\n\n\t\t\t\t\t\tgeometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\t\t\t\treturn new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta() * 60;\n\n\t\t\t\tif ( controller.userData.isSelecting === true ) {\n\n\t\t\t\t\tconst cube = room.children[ 0 ];\n\t\t\t\t\troom.remove( cube );\n\n\t\t\t\t\tcube.position.copy( controller.position );\n\t\t\t\t\tcube.userData.velocity.x = ( Math.random() - 0.5 ) * 0.02 * delta;\n\t\t\t\t\tcube.userData.velocity.y = ( Math.random() - 0.5 ) * 0.02 * delta;\n\t\t\t\t\tcube.userData.velocity.z = ( Math.random() * 0.01 - 0.05 ) * delta;\n\t\t\t\t\tcube.userData.velocity.applyQuaternion( controller.quaternion );\n\t\t\t\t\troom.add( cube );\n\n\t\t\t\t}\n\n\t\t\t\t// find intersections\n\n\t\t\t\traycaster.setFromXRController( controller );\n\n\t\t\t\tconst intersects = raycaster.intersectObjects( room.children, false );\n\n\t\t\t\tif ( intersects.length > 0 ) {\n\n\t\t\t\t\tif ( INTERSECTED != intersects[ 0 ].object ) {\n\n\t\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\t\tINTERSECTED = intersects[ 0 ].object;\n\t\t\t\t\t\tINTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();\n\t\t\t\t\t\tINTERSECTED.material.emissive.setHex( 0xff0000 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );\n\n\t\t\t\t\tINTERSECTED = undefined;\n\n\t\t\t\t}\n\n\t\t\t\t// Keep cubes inside room\n\n\t\t\t\tfor ( let i = 0; i < room.children.length; i ++ ) {\n\n\t\t\t\t\tconst cube = room.children[ i ];\n\n\t\t\t\t\tcube.userData.velocity.multiplyScalar( 1 - ( 0.001 * delta ) );\n\n\t\t\t\t\tcube.position.add( cube.userData.velocity );\n\n\t\t\t\t\tif ( cube.position.x < - 3 || cube.position.x > 3 ) {\n\n\t\t\t\t\t\tcube.position.x = THREE.MathUtils.clamp( cube.position.x, - 3, 3 );\n\t\t\t\t\t\tcube.userData.velocity.x = - cube.userData.velocity.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cube.position.y < 0 || cube.position.y > 6 ) {\n\n\t\t\t\t\t\tcube.position.y = THREE.MathUtils.clamp( cube.position.y, 0, 6 );\n\t\t\t\t\t\tcube.userData.velocity.y = - cube.userData.velocity.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cube.position.z < - 3 || cube.position.z > 3 ) {\n\n\t\t\t\t\t\tcube.position.z = THREE.MathUtils.clamp( cube.position.z, - 3, 3 );\n\t\t\t\t\t\tcube.userData.velocity.z = - cube.userData.velocity.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcube.rotation.x += cube.userData.velocity.x * 2 * delta;\n\t\t\t\t\tcube.rotation.y += cube.userData.velocity.y * 2 * delta;\n\t\t\t\t\tcube.rotation.z += cube.userData.velocity.z * 2 * delta;\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - interactive cubes"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - dragging"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - dragging:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tlet raycaster;\n\n\t\t\tconst intersected = [];\n\n\t\t\tlet controls, group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x808080 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 6, 6 );\n\t\t\t\tconst floorMaterial = new THREE.ShadowMaterial( { opacity: 0.25, blending: THREE.CustomBlending, transparent: false } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 3;\n\t\t\t\tlight.shadow.camera.bottom = - 3;\n\t\t\t\tlight.shadow.camera.right = 3;\n\t\t\t\tlight.shadow.camera.left = - 3;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.BoxGeometry( 0.2, 0.2, 0.2 ),\n\t\t\t\t\tnew THREE.ConeGeometry( 0.2, 0.2, 64 ),\n\t\t\t\t\tnew THREE.CylinderGeometry( 0.2, 0.2, 0.2, 64 ),\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 0.2, 8 ),\n\t\t\t\t\tnew THREE.TorusGeometry( 0.2, 0.04, 64, 32 )\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tconst geometry = geometries[ Math.floor( Math.random() * geometries.length ) ];\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: Math.random() * 0xffffff,\n\t\t\t\t\t\troughness: 0.7,\n\t\t\t\t\t\tmetalness: 0.0\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tobject.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tobject.position.y = Math.random() * 2;\n\t\t\t\t\tobject.position.z = Math.random() * 4 - 2;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.setScalar( Math.random() + 0.5 );\n\n\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\tobject.receiveShadow = true;\n\n\t\t\t\t\tgroup.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer, {\n\t\t\t\t\t'optionalFeatures': [ 'depth-sensing' ],\n\t\t\t\t\t'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }\n\t\t\t\t} ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );\n\n\t\t\t\tconst line = new THREE.Line( geometry );\n\t\t\t\tline.name = 'line';\n\t\t\t\tline.scale.z = 5;\n\n\t\t\t\tcontroller1.add( line.clone() );\n\t\t\t\tcontroller2.add( line.clone() );\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onSelectStart( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tconst intersections = getIntersections( controller );\n\n\t\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\t\tconst intersection = intersections[ 0 ];\n\n\t\t\t\t\tconst object = intersection.object;\n\t\t\t\t\tobject.material.emissive.b = 1;\n\t\t\t\t\tcontroller.attach( object );\n\n\t\t\t\t\tcontroller.userData.selected = object;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller.userData.targetRayMode = event.data.targetRayMode;\n\n\t\t\t}\n\n\t\t\tfunction onSelectEnd( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tif ( controller.userData.selected !== undefined ) {\n\n\t\t\t\t\tconst object = controller.userData.selected;\n\t\t\t\t\tobject.material.emissive.b = 0;\n\t\t\t\t\tgroup.attach( object );\n\n\t\t\t\t\tcontroller.userData.selected = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getIntersections( controller ) {\n\n\t\t\t\tcontroller.updateMatrixWorld();\n\n\t\t\t\traycaster.setFromXRController( controller );\n\n\t\t\t\treturn raycaster.intersectObjects( group.children, false );\n\n\t\t\t}\n\n\t\t\tfunction intersectObjects( controller ) {\n\n\t\t\t\t// Do not highlight in mobile-ar\n\n\t\t\t\tif ( controller.userData.targetRayMode === 'screen' ) return;\n\n\t\t\t\t// Do not highlight when already selected\n\n\t\t\t\tif ( controller.userData.selected !== undefined ) return;\n\n\t\t\t\tconst line = controller.getObjectByName( 'line' );\n\t\t\t\tconst intersections = getIntersections( controller );\n\n\t\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\t\tconst intersection = intersections[ 0 ];\n\n\t\t\t\t\tconst object = intersection.object;\n\t\t\t\t\tobject.material.emissive.r = 1;\n\t\t\t\t\tintersected.push( object );\n\n\t\t\t\t\tline.scale.z = intersection.distance;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tline.scale.z = 5;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction cleanIntersected() {\n\n\t\t\t\twhile ( intersected.length ) {\n\n\t\t\t\t\tconst object = intersected.pop();\n\t\t\t\t\tobject.material.emissive.r = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcleanIntersected();\n\n\t\t\t\tintersectObjects( controller1 );\n\t\t\t\tintersectObjects( controller2 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - dragging"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - dragging with custom depth shader"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - dragging with custom depth shader:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\t\t\tlet isDepthSupplied = false;\n\n\t\t\tlet raycaster;\n\n\t\t\tconst intersected = [];\n\t\t\tconst tempMatrix = new THREE.Matrix4();\n\n\t\t\tlet controls, group;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x808080 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 6, 6 );\n\t\t\t\tconst floorMaterial = new THREE.ShadowMaterial( { opacity: 0.25, blending: THREE.CustomBlending, transparent: false } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 3;\n\t\t\t\tlight.shadow.camera.bottom = - 3;\n\t\t\t\tlight.shadow.camera.right = 3;\n\t\t\t\tlight.shadow.camera.left = - 3;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst geometries = [\n\t\t\t\t\tnew THREE.BoxGeometry( 0.2, 0.2, 0.2 ),\n\t\t\t\t\tnew THREE.ConeGeometry( 0.2, 0.2, 64 ),\n\t\t\t\t\tnew THREE.CylinderGeometry( 0.2, 0.2, 0.2, 64 ),\n\t\t\t\t\tnew THREE.IcosahedronGeometry( 0.2, 8 ),\n\t\t\t\t\tnew THREE.TorusGeometry( 0.2, 0.04, 64, 32 )\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tconst geometry = geometries[ Math.floor( Math.random() * geometries.length ) ];\n\t\t\t\t\tconst material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\t\tvertexShader: /* glsl */`\n\t\t\t\t\t\t\tvarying vec3 vNormal;\n\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\tvNormal = normalize(normalMatrix * normal);\n\t\t\t\t\t\t\t\tvUv = uv;\n\t\t\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t`,\n\n\t\t\t\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t\t\t\tuniform vec3 diffuseColor;\n\t\t\t\t\t\t\tuniform float roughness;\n\t\t\t\t\t\t\tuniform float metalness;\n\t\t\t\t\t\t\tuniform float emissive;\n\t\t\t\t\t\t\tvarying vec3 vNormal;\n\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\tuniform sampler2DArray depthColor;\n\t\t\t\t\t\t\tuniform float depthWidth;\n\t\t\t\t\t\t\tuniform float depthHeight;\n\t\t\t\t\t\t\t#define saturate( a ) clamp( a, 0.0, 1.0 )\n\t\t\t\t\t\t\tfloat Depth_GetCameraDepthInMeters(const sampler2DArray depthTexture,\n\t\t\t\t\t\t\t\tconst vec2 depthUv, int arrayIndex) {\n\t\t\t\t\t\t\t\treturn texture(depthColor, vec3(depthUv.x, depthUv.y, arrayIndex)).r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfloat Depth_GetOcclusion(const sampler2DArray depthTexture, const vec2 depthUv, float assetDepthM, int arrayIndex) {\n\t\t\t\t\t\t\t\tfloat depthMm = Depth_GetCameraDepthInMeters(depthTexture, depthUv, arrayIndex);\n\t\t\t\t\t\t\t\tconst float kDepthTolerancePerM = 0.001;\n\t\t\t\t\t\t\t\treturn clamp(1.0 -\n\t\t\t\t\t\t\t\t\t0.5 * (depthMm - assetDepthM) /\n\t\t\t\t\t\t\t\t\t\t(kDepthTolerancePerM * assetDepthM) +\n\t\t\t\t\t\t\t\t\t0.5, 0.0, 1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfloat Depth_GetBlurredOcclusionAroundUV(const sampler2DArray depthTexture, const vec2 uv, float assetDepthM, int arrayIndex) {\n\t\t\t\t\t\t\t\t// Kernel used:\n\t\t\t\t\t\t\t\t// 0   4   7   4   0\n\t\t\t\t\t\t\t\t// 4   16  26  16  4\n\t\t\t\t\t\t\t\t// 7   26  41  26  7\n\t\t\t\t\t\t\t\t// 4   16  26  16  4\n\t\t\t\t\t\t\t\t// 0   4   7   4   0\n\t\t\t\t\t\t\t\tconst float kKernelTotalWeights = 269.0;\n\t\t\t\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\t\t\t\tconst float kOcclusionBlurAmount = 0.0005;\n\t\t\t\t\t\t\t\tvec2 blurriness =\n\t\t\t\t\t\t\t\tvec2(kOcclusionBlurAmount, kOcclusionBlurAmount /** u_DepthAspectRatio*/);\n\t\t\t\t\t\t\t\tfloat current = 0.0;\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-1.0, -2.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+1.0, -2.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-1.0, +2.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+1.0, +2.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-2.0, +1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+2.0, +1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-2.0, -1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+2.0, -1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tsum += current * 4.0;\n\t\t\t\t\t\t\t\tcurrent = 0.0;\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-2.0, -0.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+2.0, +0.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+0.0, +2.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-0.0, -2.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tsum += current * 7.0;\n\t\t\t\t\t\t\t\tcurrent = 0.0;\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-1.0, -1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+1.0, -1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-1.0, +1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+1.0, +1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tsum += current * 16.0;\n\t\t\t\t\t\t\t\tcurrent = 0.0;\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+0.0, +1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-0.0, -1.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(-1.0, -0.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tcurrent += Depth_GetOcclusion(\n\t\t\t\t\t\t\t\tdepthTexture, uv + vec2(+1.0, +0.0) * blurriness, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\tsum += current * 26.0;\n\t\t\t\t\t\t\t\tsum += Depth_GetOcclusion(depthTexture, uv, assetDepthM, arrayIndex) * 41.0;\n\t\t\t\t\t\t\t\treturn sum / kKernelTotalWeights;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\tvec3 normal = normalize(vNormal);\n\t\t\t\t\t\t\t\tvec3 diffuse = diffuseColor;\n\t\t\t\t\t\t\t\tfloat specularIntensity = pow(max(dot(normal, normalize(vec3(0, 0, 1))), 0.0), 64.0);\n\t\t\t\t\t\t\t\tvec3 specular = vec3(specularIntensity) * mix(vec3(0.04), diffuse, metalness);\n\t\t\t\t\t\t\t\tgl_FragColor = vec4(diffuse * (1.0 - specular) + specular, 1.0) * (1.0 + emissive);\n\n\t\t\t\t\t\t\t\tif (depthWidth > 0.0) {\n\t\t\t\t\t\t\t\t\tint arrayIndex = 0;\n\t\t\t\t\t\t\t\t\tvec2 depthUv;\n\t\t\t\t\t\t\t\t\tif (gl_FragCoord.x>=depthWidth) {\n\t\t\t\t\t\t\t\t\t\tarrayIndex = 1;\n\t\t\t\t\t\t\t\t\t\tdepthUv = vec2((gl_FragCoord.x-depthWidth)/depthWidth, gl_FragCoord.y/depthHeight);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdepthUv = vec2(gl_FragCoord.x/depthWidth, gl_FragCoord.y/depthHeight);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfloat assetDepthM = gl_FragCoord.z;\n\n\t\t\t\t\t\t\t\t\tfloat occlusion = Depth_GetBlurredOcclusionAroundUV(depthColor, depthUv, assetDepthM, arrayIndex);\n\t\t\t\t\t\t\t\t\tfloat depthMm = Depth_GetCameraDepthInMeters(depthColor, depthUv, arrayIndex);\n\n\t\t\t\t\t\t\t\t\tfloat absDistance = abs(assetDepthM - depthMm);\n\t\t\t\t\t\t\t\t\tfloat v = 0.0025;\n\t\t\t\t\t\t\t\t\tabsDistance = saturate(v - absDistance) / v;\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += vec3(absDistance * 2.0, absDistance * 2.0, absDistance * 12.0);\n\t\t\t\t\t\t\t\t\tgl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 0.0, 0.0), occlusion * 0.7);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`,\n\n\t\t\t\t\t\tuniforms: {\n\n\t\t\t\t\t\t\tdiffuseColor: { value: new THREE.Color( Math.random() * 0xffffff ) },\n\t\t\t\t\t\t\troughness: { value: 0.7 },\n\t\t\t\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\t\t\t\temissive: { value: 0.0 },\n\t\t\t\t\t\t\tdepthWidth: { value: 0.0 },\n\t\t\t\t\t\t\tdepthHeight: { value: 0.0 },\n\t\t\t\t\t\t\tdepthColor: { value: new THREE.Texture() }\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tobject.position.x = Math.random() * 4 - 2;\n\t\t\t\t\tobject.position.y = Math.random() * 2;\n\t\t\t\t\tobject.position.z = Math.random() * 4 - 2;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.setScalar( Math.random() + 0.5 );\n\n\t\t\t\t\tgroup.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer, {\n\t\t\t\t\t'optionalFeatures': [ 'depth-sensing' ],\n\t\t\t\t\t'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }\n\t\t\t\t} ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );\n\n\t\t\t\tconst line = new THREE.Line( geometry );\n\t\t\t\tline.name = 'line';\n\t\t\t\tline.scale.z = 5;\n\n\t\t\t\tcontroller1.add( line.clone() );\n\t\t\t\tcontroller2.add( line.clone() );\n\n\t\t\t\traycaster = new THREE.Raycaster();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction onSelectStart( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tconst intersections = getIntersections( controller );\n\n\t\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\t\tconst intersection = intersections[ 0 ];\n\n\t\t\t\t\tconst object = intersection.object;\n\t\t\t\t\tobject.material.uniforms.emissive.value = 1;\n\t\t\t\t\tcontroller.attach( object );\n\n\t\t\t\t\tcontroller.userData.selected = object;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller.userData.targetRayMode = event.data.targetRayMode;\n\n\t\t\t}\n\n\t\t\tfunction onSelectEnd( event ) {\n\n\t\t\t\tconst controller = event.target;\n\n\t\t\t\tif ( controller.userData.selected !== undefined ) {\n\n\t\t\t\t\tconst object = controller.userData.selected;\n\t\t\t\t\tobject.material.uniforms.emissive.value = 0;\n\t\t\t\t\tgroup.attach( object );\n\n\t\t\t\t\tcontroller.userData.selected = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getIntersections( controller ) {\n\n\t\t\t\tcontroller.updateMatrixWorld();\n\n\t\t\t\ttempMatrix.identity().extractRotation( controller.matrixWorld );\n\n\t\t\t\traycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\t\t\traycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t\t\treturn raycaster.intersectObjects( group.children, false );\n\n\t\t\t}\n\n\t\t\tfunction intersectObjects( controller ) {\n\n\t\t\t\t// Do not highlight in mobile-ar\n\n\t\t\t\tif ( controller.userData.targetRayMode === 'screen' ) return;\n\n\t\t\t\t// Do not highlight when already selected\n\n\t\t\t\tif ( controller.userData.selected !== undefined ) return;\n\n\t\t\t\tconst line = controller.getObjectByName( 'line' );\n\t\t\t\tconst intersections = getIntersections( controller );\n\n\t\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\t\tconst intersection = intersections[ 0 ];\n\n\t\t\t\t\tconst object = intersection.object;\n\t\t\t\t\tobject.material.uniforms.emissive.value = 1;\n\t\t\t\t\tintersected.push( object );\n\n\t\t\t\t\tline.scale.z = intersection.distance;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tline.scale.z = 5;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction cleanIntersected() {\n\n\t\t\t\twhile ( intersected.length ) {\n\n\t\t\t\t\tconst object = intersected.pop();\n\t\t\t\t\tobject.material.uniforms.emissive.value = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.setAnimationLoop( render );\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tif ( renderer.xr.hasDepthSensing() && ! isDepthSupplied ) {\n\n\t\t\t\t\tgroup.children.forEach( child => {\n\n\t\t\t\t\t\tchild.material.uniforms.depthColor.value = renderer.xr.getDepthTexture();\n\t\t\t\t\t\tchild.material.uniforms.depthWidth.value = 1680;\n\t\t\t\t\t\tchild.material.uniforms.depthHeight.value = 1760;\n\n\t\t\t\t\t\tisDepthSupplied = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! renderer.xr.hasDepthSensing() && isDepthSupplied ) {\n\n\t\t\t\t\tgroup.children.forEach( child => {\n\n\t\t\t\t\t\tchild.material.uniforms.depthWidth.value = 0;\n\t\t\t\t\t\tchild.material.uniforms.depthHeight.value = 0;\n\n\t\t\t\t\t\tisDepthSupplied = false;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tcleanIntersected();\n\n\t\t\t\tintersectObjects( controller1 );\n\t\t\t\tintersectObjects( controller2 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - dragging"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - haptics"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - haptics:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\t\t\timport { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet listener;\n\t\t\tlet controller1, controller2;\n\t\t\tlet controllerGrip1, controllerGrip2;\n\n\t\t\tconst box = new THREE.Box3();\n\n\t\t\tlet controls, group;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x808080 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tlistener = new THREE.AudioListener();\n\t\t\t\tcamera.add( listener );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst floorGeometry = new THREE.PlaneGeometry( 4, 4 );\n\t\t\t\tconst floorMaterial = new THREE.ShadowMaterial( { opacity: 0.25, blending: THREE.CustomBlending, transparent: false } );\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tfloor.rotation.x = - Math.PI / 2;\n\t\t\t\tfloor.receiveShadow = true;\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0xbcbcbc, 0xa5a5a5, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.top = 2;\n\t\t\t\tlight.shadow.camera.bottom = - 2;\n\t\t\t\tlight.shadow.camera.right = 2;\n\t\t\t\tlight.shadow.camera.left = - 2;\n\t\t\t\tlight.shadow.mapSize.set( 4096, 4096 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tgroup.position.z = - 0.5;\n\t\t\t\tscene.add( group );\n\t\t\t\tconst BOXES = 10;\n\n\t\t\t\tfor ( let i = 0; i < BOXES; i ++ ) {\n\n\t\t\t\t\tconst intensity = ( i + 1 ) / BOXES;\n\t\t\t\t\tconst w = 0.1;\n\t\t\t\t\tconst h = 0.05 * i + 0.5;\n\t\t\t\t\tconst geometry = new THREE.BoxGeometry( w, h, w );\n\t\t\t\t\tgeometry.translate( 0, h / 2, 0 );\n\t\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\t\tcolor: new THREE.Color( intensity, 0.1, 0.1 ),\n\t\t\t\t\t\troughness: 0.7,\n\t\t\t\t\t\tmetalness: 0.0\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, material );\n\t\t\t\t\tobject.position.x = ( i - 5 ) * ( w + 0.05 );\n\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\tobject.receiveShadow = true;\n\t\t\t\t\tobject.userData = {\n\t\t\t\t\t\tindex: i + 1,\n\t\t\t\t\t\tintensity: intensity\n\t\t\t\t\t};\n\n\t\t\t\t\tgroup.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\tconst controllerModelFactory = new XRControllerModelFactory();\n\n\t\t\t\tcontrollerGrip1 = renderer.xr.getControllerGrip( 0 );\n\t\t\t\tcontrollerGrip1.addEventListener( 'connected', controllerConnected );\n\t\t\t\tcontrollerGrip1.addEventListener( 'disconnected', controllerDisconnected );\n\t\t\t\tcontrollerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );\n\t\t\t\tscene.add( controllerGrip1 );\n\n\t\t\t\tcontrollerGrip2 = renderer.xr.getControllerGrip( 1 );\n\t\t\t\tcontrollerGrip2.addEventListener( 'connected', controllerConnected );\n\t\t\t\tcontrollerGrip2.addEventListener( 'disconnected', controllerDisconnected );\n\t\t\t\tcontrollerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );\n\t\t\t\tscene.add( controllerGrip2 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction controllerConnected( event ) {\n\n\t\t\t\tconst oscillator = listener.context.createOscillator();\n\t\t\t\toscillator.type = 'sine';\n\t\t\t\toscillator.start()\n\n\t\t\t\tconst audio = new THREE.PositionalAudio( listener );\n\t\t\t\taudio.setNodeSource( oscillator );\n\t\t\t\taudio.setRefDistance( 20 );\n\t\t\t\taudio.setVolume( 0 );\n\n\t\t\t\tthis.userData.gamepad = event.data.gamepad;\n\t\t\t\tthis.userData.colliding = false;\n\t\t\t\tthis.userData.audio = audio;\n\n\t\t\t\tthis.add( audio );\n\n\t\t\t}\n\n\t\t\tfunction controllerDisconnected( event ) {\n\n\t\t\t\tconst audio = this.userData.audio;\n\t\t\t\taudio.source.stop();\n\t\t\t\t\n\t\t\t\tthis.remove( audio );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\n\t\t\tfunction handleCollisions( controller ) {\n\n\t\t\t\tfor ( let i = 0; i < group.children.length; i ++ ) {\n\n\t\t\t\t\tgroup.children[ i ].collided = false;\n\n\t\t\t\t}\n\n\t\t\t\thandleController( controllerGrip1 );\n\t\t\t\thandleController( controllerGrip2 );\n\n\t\t\t\tfor ( let i = 0; i < group.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = group.children[ i ];\n\t\t\t\t\tif ( ! child.collided ) {\n\n\t\t\t\t\t\t// reset uncollided boxes\n\t\t\t\t\t\tchild.material.emissive.b = 0;\n\t\t\t\t\t\tchild.scale.setScalar( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// minor pentatonic scale, so whichever notes is stricken would be more pleasant\n\t\t\tconst musicScale = [ 0, 3, 5, 7, 10 ];\n\n\t\t\tfunction handleController( controller ) {\n\n\t\t\t\tcontroller.userData.colliding = false;\n\n\t\t\t\tconst audio = controller.userData.audio;\n\t\t\t\tconst gamepad = controller.userData.gamepad;\n\n\t\t\t\tif ( audio === undefined || gamepad === undefined ) return;\n\n\t\t\t\tconst oscillator = audio.source;\n\t\t\t\tconst supportHaptic = 'hapticActuators' in gamepad && gamepad.hapticActuators != null && gamepad.hapticActuators.length > 0;\n\n\t\t\t\tconst sphere = {\n\t\t\t\t\tradius: 0.03,\n\t\t\t\t\tcenter: controller.position\n\t\t\t\t};\n\n\t\t\t\tfor ( let i = 0; i < group.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = group.children[ i ];\n\t\t\t\t\tbox.setFromObject( child );\n\n\t\t\t\t\tif ( box.intersectsSphere( sphere ) ) {\n\n\t\t\t\t\t\tchild.material.emissive.b = 1;\n\t\t\t\t\t\tconst intensity = child.userData.index / group.children.length;\n\t\t\t\t\t\tchild.scale.setScalar( 1 + Math.random() * 0.1 * intensity );\n\n\t\t\t\t\t\tif ( supportHaptic ) {\n\n\t\t\t\t\t\t\tgamepad.hapticActuators[ 0 ].pulse( intensity, 100 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst musicInterval = musicScale[ child.userData.index % musicScale.length ] + 12 * Math.floor( child.userData.index / musicScale.length );\n\t\t\t\t\t\toscillator.frequency.value = 110 * Math.pow( 2, musicInterval / 12 );\n\t\t\t\t\t\tcontroller.userData.colliding = true;\n\t\t\t\t\t\tgroup.children[ i ].collided = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( controller.userData.colliding ) {\n\n\t\t\t\t\taudio.setVolume( 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taudio.setVolume( 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\thandleCollisions();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - haptics"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - paint"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - paint:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TubePainter } from 'three/addons/misc/TubePainter.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\n\t\t\tconst cursor = new THREE.Vector3();\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 50 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst grid = new THREE.GridHelper( 4, 1, 0x111111, 0x111111 );\n\t\t\t\tscene.add( grid );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x888877, 0x777788, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 1.5 );\n\t\t\t\tlight.position.set( 0, 4, 0 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\tconst painter1 = new TubePainter();\n\t\t\t\tscene.add( painter1.mesh );\n\n\t\t\t\tconst painter2 = new TubePainter();\n\t\t\t\tscene.add( painter2.mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tfunction onSelectStart() {\n\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\t\tconst pivot = this.getObjectByName( 'pivot' );\n\t\t\t\t\tcursor.setFromMatrixPosition( pivot.matrixWorld );\n\n\t\t\t\t\tconst painter = this.userData.painter;\n\t\t\t\t\tpainter.moveTo( cursor );\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSqueezeStart() {\n\n\t\t\t\t\tthis.userData.isSqueezing = true;\n\t\t\t\t\tthis.userData.positionAtSqueezeStart = this.position.y;\n\t\t\t\t\tthis.userData.scaleAtSqueezeStart = this.scale.x;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSqueezeEnd() {\n\n\t\t\t\t\tthis.userData.isSqueezing = false;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller1.addEventListener( 'squeezestart', onSqueezeStart );\n\t\t\t\tcontroller1.addEventListener( 'squeezeend', onSqueezeEnd );\n\t\t\t\tcontroller1.userData.painter = painter1;\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller2.addEventListener( 'squeezestart', onSqueezeStart );\n\t\t\t\tcontroller2.addEventListener( 'squeezeend', onSqueezeEnd );\n\t\t\t\tcontroller2.userData.painter = painter2;\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst pivot = new THREE.Mesh( new THREE.IcosahedronGeometry( 0.01, 3 ) );\n\t\t\t\tpivot.name = 'pivot';\n\t\t\t\tpivot.position.z = - 0.05;\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tgroup.add( pivot );\n\n\t\t\t\tcontroller1.add( group.clone() );\n\t\t\t\tcontroller2.add( group.clone() );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction handleController( controller ) {\n\n\t\t\t\tcontroller.updateMatrixWorld( true );\n\n\t\t\t\tconst userData = controller.userData;\n\t\t\t\tconst painter = userData.painter;\n\n\t\t\t\tconst pivot = controller.getObjectByName( 'pivot' );\n\n\t\t\t\tif ( userData.isSqueezing === true ) {\n\n\t\t\t\t\tconst delta = ( controller.position.y - userData.positionAtSqueezeStart ) * 5;\n\t\t\t\t\tconst scale = Math.max( 0.1, userData.scaleAtSqueezeStart + delta );\n\n\t\t\t\t\tpivot.scale.setScalar( scale );\n\t\t\t\t\tpainter.setSize( scale );\n\n\t\t\t\t}\n\n\t\t\t\tcursor.setFromMatrixPosition( pivot.matrixWorld );\n\n\t\t\t\tif ( userData.isSelecting === true ) {\n\n\t\t\t\t\tpainter.lineTo( cursor );\n\t\t\t\t\tpainter.update();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\thandleController( controller1 );\n\t\t\t\thandleController( controller2 );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - paint"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webxr example that demonstrates xr - sculpt"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js xr - sculpt:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';\n\t\t\timport { XRButton } from 'three/addons/webxr/XRButton.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controller1, controller2;\n\n\t\t\tlet controls, blob;\n\n\t\t\tlet points = [];\n\n\t\t\tinit();\n\t\t\tinitBlob();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x222222 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 50 );\n\t\t\t\tcamera.position.set( 0, 1.6, 3 );\n\n\t\t\t\tcontrols = new OrbitControls( camera, container );\n\t\t\t\tcontrols.target.set( 0, 1.6, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst grid = new THREE.GridHelper( 4, 1, 0x111111, 0x111111 );\n\t\t\t\tscene.add( grid );\n\n\t\t\t\tscene.add( new THREE.HemisphereLight( 0x888877, 0x777788, 3 ) );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 0, 6, 0 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.xr.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tdocument.body.appendChild( XRButton.createButton( renderer ) );\n\n\t\t\t\t// controllers\n\n\t\t\t\tfunction onSelectStart() {\n\n\t\t\t\t\tthis.userData.isSelecting = true;\n\n\t\t\t\t}\n\n\t\t\t\tfunction onSelectEnd() {\n\n\t\t\t\t\tthis.userData.isSelecting = false;\n\n\t\t\t\t}\n\n\t\t\t\tcontroller1 = renderer.xr.getController( 0 );\n\t\t\t\tcontroller1.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller1.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller1.userData.id = 0;\n\t\t\t\tscene.add( controller1 );\n\n\t\t\t\tcontroller2 = renderer.xr.getController( 1 );\n\t\t\t\tcontroller2.addEventListener( 'selectstart', onSelectStart );\n\t\t\t\tcontroller2.addEventListener( 'selectend', onSelectEnd );\n\t\t\t\tcontroller2.userData.id = 1;\n\t\t\t\tscene.add( controller2 );\n\n\t\t\t\t//\n\n\t\t\t\tconst pivot = new THREE.Mesh( new THREE.IcosahedronGeometry( 0.01, 3 ) );\n\t\t\t\tpivot.name = 'pivot';\n\t\t\t\tpivot.position.z = - 0.05;\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tgroup.add( pivot );\n\n\t\t\t\tcontroller1.add( group.clone() );\n\t\t\t\tcontroller2.add( group.clone() );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initBlob() {\n\n\t\t\t\t/*\n\t\t\t\tconst path = 'textures/cube/SwedishRoyalCastle/';\n\t\t\t\tconst format = '.jpg';\n\t\t\t\tconst urls = [\n\t\t\t\t\tpath + 'px' + format, path + 'nx' + format,\n\t\t\t\t\tpath + 'py' + format, path + 'ny' + format,\n\t\t\t\t\tpath + 'pz' + format, path + 'nz' + format\n\t\t\t\t];\n\n\t\t\t\tconst reflectionCube = new THREE.CubeTextureLoader().load( urls );\n\t\t\t\t*/\n\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t// envMap: reflectionCube,\n\t\t\t\t\troughness: 0.9,\n\t\t\t\t\tmetalness: 0.0,\n\t\t\t\t\ttransparent: true\n\t\t\t\t} );\n\n\t\t\t\tblob = new MarchingCubes( 64, material, false, false, 500000 );\n\t\t\t\tblob.position.y = 1;\n\t\t\t\tscene.add( blob );\n\n\t\t\t\tinitPoints();\n\n\t\t\t}\n\n\t\t\tfunction initPoints() {\n\n\t\t\t\tpoints = [\n\t\t\t\t\t{ position: new THREE.Vector3(), strength: 0.04, subtract: 10 },\n\t\t\t\t\t{ position: new THREE.Vector3(), strength: - 0.08, subtract: 10 }\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction transformPoint( vector ) {\n\n\t\t\t\tvector.x = ( vector.x + 1.0 ) / 2.0;\n\t\t\t\tvector.y = ( vector.y / 2.0 );\n\t\t\t\tvector.z = ( vector.z + 1.0 ) / 2.0;\n\n\t\t\t}\n\n\t\t\tfunction handleController( controller ) {\n\n\t\t\t\tconst pivot = controller.getObjectByName( 'pivot' );\n\n\t\t\t\tif ( pivot ) {\n\n\t\t\t\t\tconst id = controller.userData.id;\n\t\t\t\t\tconst matrix = pivot.matrixWorld;\n\n\t\t\t\t\tpoints[ id ].position.setFromMatrixPosition( matrix );\n\t\t\t\t\ttransformPoint( points[ id ].position );\n\n\t\t\t\t\tif ( controller.userData.isSelecting ) {\n\n\t\t\t\t\t\tconst strength = points[ id ].strength / 2;\n\n\t\t\t\t\t\tconst vector = new THREE.Vector3().setFromMatrixPosition( matrix );\n\n\t\t\t\t\t\ttransformPoint( vector );\n\n\t\t\t\t\t\tpoints.push( { position: vector, strength: strength, subtract: 10 } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updateBlob() {\n\n\t\t\t\tblob.reset();\n\n\t\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\t\tconst point = points[ i ];\n\t\t\t\t\tconst position = point.position;\n\n\t\t\t\t\tblob.addBall( position.x, position.y, position.z, point.strength, point.subtract );\n\n\t\t\t\t}\n\n\t\t\t\tblob.update();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\thandleController( controller1 );\n\t\t\t\thandleController( controller2 );\n\n\t\t\t\tupdateBlob();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js xr - sculpt"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js games example that demonstrates - misc - octree collisions"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - misc - octree collisions:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\t\t\timport { Octree } from 'three/addons/math/Octree.js';\n\t\t\timport { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';\n\n\t\t\timport { Capsule } from 'three/addons/math/Capsule.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x88ccee );\n\t\t\tscene.fog = new THREE.Fog( 0x88ccee, 0, 50 );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\tcamera.rotation.order = 'YXZ';\n\n\t\t\tconst fillLight1 = new THREE.HemisphereLight( 0x8dc1de, 0x00668d, 1.5 );\n\t\t\tfillLight1.position.set( 2, 1, 1 );\n\t\t\tscene.add( fillLight1 );\n\n\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\tdirectionalLight.position.set( - 5, 25, - 1 );\n\t\t\tdirectionalLight.castShadow = true;\n\t\t\tdirectionalLight.shadow.camera.near = 0.01;\n\t\t\tdirectionalLight.shadow.camera.far = 500;\n\t\t\tdirectionalLight.shadow.camera.right = 30;\n\t\t\tdirectionalLight.shadow.camera.left = - 30;\n\t\t\tdirectionalLight.shadow.camera.top\t= 30;\n\t\t\tdirectionalLight.shadow.camera.bottom = - 30;\n\t\t\tdirectionalLight.shadow.mapSize.width = 1024;\n\t\t\tdirectionalLight.shadow.mapSize.height = 1024;\n\t\t\tdirectionalLight.shadow.radius = 4;\n\t\t\tdirectionalLight.shadow.bias = - 0.00006;\n\t\t\tscene.add( directionalLight );\n\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tconst stats = new Stats();\n\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\tstats.domElement.style.top = '0px';\n\t\t\tcontainer.appendChild( stats.domElement );\n\n\t\t\tconst GRAVITY = 30;\n\n\t\t\tconst NUM_SPHERES = 100;\n\t\t\tconst SPHERE_RADIUS = 0.2;\n\n\t\t\tconst STEPS_PER_FRAME = 5;\n\n\t\t\tconst sphereGeometry = new THREE.IcosahedronGeometry( SPHERE_RADIUS, 5 );\n\t\t\tconst sphereMaterial = new THREE.MeshLambertMaterial( { color: 0xdede8d } );\n\n\t\t\tconst spheres = [];\n\t\t\tlet sphereIdx = 0;\n\n\t\t\tfor ( let i = 0; i < NUM_SPHERES; i ++ ) {\n\n\t\t\t\tconst sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );\n\t\t\t\tsphere.castShadow = true;\n\t\t\t\tsphere.receiveShadow = true;\n\n\t\t\t\tscene.add( sphere );\n\n\t\t\t\tspheres.push( {\n\t\t\t\t\tmesh: sphere,\n\t\t\t\t\tcollider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ),\n\t\t\t\t\tvelocity: new THREE.Vector3()\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worldOctree = new Octree();\n\n\t\t\tconst playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );\n\n\t\t\tconst playerVelocity = new THREE.Vector3();\n\t\t\tconst playerDirection = new THREE.Vector3();\n\n\t\t\tlet playerOnFloor = false;\n\t\t\tlet mouseTime = 0;\n\n\t\t\tconst keyStates = {};\n\n\t\t\tconst vector1 = new THREE.Vector3();\n\t\t\tconst vector2 = new THREE.Vector3();\n\t\t\tconst vector3 = new THREE.Vector3();\n\n\t\t\tdocument.addEventListener( 'keydown', ( event ) => {\n\n\t\t\t\tkeyStates[ event.code ] = true;\n\n\t\t\t} );\n\n\t\t\tdocument.addEventListener( 'keyup', ( event ) => {\n\n\t\t\t\tkeyStates[ event.code ] = false;\n\n\t\t\t} );\n\n\t\t\tcontainer.addEventListener( 'mousedown', () => {\n\n\t\t\t\tdocument.body.requestPointerLock();\n\n\t\t\t\tmouseTime = performance.now();\n\n\t\t\t} );\n\n\t\t\tdocument.addEventListener( 'mouseup', () => {\n\n\t\t\t\tif ( document.pointerLockElement !== null ) throwBall();\n\n\t\t\t} );\n\n\t\t\tdocument.body.addEventListener( 'mousemove', ( event ) => {\n\n\t\t\t\tif ( document.pointerLockElement === document.body ) {\n\n\t\t\t\t\tcamera.rotation.y -= event.movementX / 500;\n\t\t\t\t\tcamera.rotation.x -= event.movementY / 500;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction throwBall() {\n\n\t\t\t\tconst sphere = spheres[ sphereIdx ];\n\n\t\t\t\tcamera.getWorldDirection( playerDirection );\n\n\t\t\t\tsphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );\n\n\t\t\t\t// throw the ball with more force if we hold the button longer, and if we move forward\n\n\t\t\t\tconst impulse = 15 + 30 * ( 1 - Math.exp( ( mouseTime - performance.now() ) * 0.001 ) );\n\n\t\t\t\tsphere.velocity.copy( playerDirection ).multiplyScalar( impulse );\n\t\t\t\tsphere.velocity.addScaledVector( playerVelocity, 2 );\n\n\t\t\t\tsphereIdx = ( sphereIdx + 1 ) % spheres.length;\n\n\t\t\t}\n\n\t\t\tfunction playerCollisions() {\n\n\t\t\t\tconst result = worldOctree.capsuleIntersect( playerCollider );\n\n\t\t\t\tplayerOnFloor = false;\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tplayerOnFloor = result.normal.y > 0;\n\n\t\t\t\t\tif ( ! playerOnFloor ) {\n\n\t\t\t\t\t\tplayerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( result.depth >= 1e-10 ) {\n\n\t\t\t\t\t\tplayerCollider.translate( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updatePlayer( deltaTime ) {\n\n\t\t\t\tlet damping = Math.exp( - 4 * deltaTime ) - 1;\n\n\t\t\t\tif ( ! playerOnFloor ) {\n\n\t\t\t\t\tplayerVelocity.y -= GRAVITY * deltaTime;\n\n\t\t\t\t\t// small air resistance\n\t\t\t\t\tdamping *= 0.1;\n\n\t\t\t\t}\n\n\t\t\t\tplayerVelocity.addScaledVector( playerVelocity, damping );\n\n\t\t\t\tconst deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );\n\t\t\t\tplayerCollider.translate( deltaPosition );\n\n\t\t\t\tplayerCollisions();\n\n\t\t\t\tcamera.position.copy( playerCollider.end );\n\n\t\t\t}\n\n\t\t\tfunction playerSphereCollision( sphere ) {\n\n\t\t\t\tconst center = vector1.addVectors( playerCollider.start, playerCollider.end ).multiplyScalar( 0.5 );\n\n\t\t\t\tconst sphere_center = sphere.collider.center;\n\n\t\t\t\tconst r = playerCollider.radius + sphere.collider.radius;\n\t\t\t\tconst r2 = r * r;\n\n\t\t\t\t// approximation: player = 3 spheres\n\n\t\t\t\tfor ( const point of [ playerCollider.start, playerCollider.end, center ] ) {\n\n\t\t\t\t\tconst d2 = point.distanceToSquared( sphere_center );\n\n\t\t\t\t\tif ( d2 < r2 ) {\n\n\t\t\t\t\t\tconst normal = vector1.subVectors( point, sphere_center ).normalize();\n\t\t\t\t\t\tconst v1 = vector2.copy( normal ).multiplyScalar( normal.dot( playerVelocity ) );\n\t\t\t\t\t\tconst v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );\n\n\t\t\t\t\t\tplayerVelocity.add( v2 ).sub( v1 );\n\t\t\t\t\t\tsphere.velocity.add( v1 ).sub( v2 );\n\n\t\t\t\t\t\tconst d = ( r - Math.sqrt( d2 ) ) / 2;\n\t\t\t\t\t\tsphere_center.addScaledVector( normal, - d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction spheresCollisions() {\n\n\t\t\t\tfor ( let i = 0, length = spheres.length; i < length; i ++ ) {\n\n\t\t\t\t\tconst s1 = spheres[ i ];\n\n\t\t\t\t\tfor ( let j = i + 1; j < length; j ++ ) {\n\n\t\t\t\t\t\tconst s2 = spheres[ j ];\n\n\t\t\t\t\t\tconst d2 = s1.collider.center.distanceToSquared( s2.collider.center );\n\t\t\t\t\t\tconst r = s1.collider.radius + s2.collider.radius;\n\t\t\t\t\t\tconst r2 = r * r;\n\n\t\t\t\t\t\tif ( d2 < r2 ) {\n\n\t\t\t\t\t\t\tconst normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();\n\t\t\t\t\t\t\tconst v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );\n\t\t\t\t\t\t\tconst v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );\n\n\t\t\t\t\t\t\ts1.velocity.add( v2 ).sub( v1 );\n\t\t\t\t\t\t\ts2.velocity.add( v1 ).sub( v2 );\n\n\t\t\t\t\t\t\tconst d = ( r - Math.sqrt( d2 ) ) / 2;\n\n\t\t\t\t\t\t\ts1.collider.center.addScaledVector( normal, d );\n\t\t\t\t\t\t\ts2.collider.center.addScaledVector( normal, - d );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updateSpheres( deltaTime ) {\n\n\t\t\t\tspheres.forEach( sphere => {\n\n\t\t\t\t\tsphere.collider.center.addScaledVector( sphere.velocity, deltaTime );\n\n\t\t\t\t\tconst result = worldOctree.sphereIntersect( sphere.collider );\n\n\t\t\t\t\tif ( result ) {\n\n\t\t\t\t\t\tsphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );\n\t\t\t\t\t\tsphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsphere.velocity.y -= GRAVITY * deltaTime;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst damping = Math.exp( - 1.5 * deltaTime ) - 1;\n\t\t\t\t\tsphere.velocity.addScaledVector( sphere.velocity, damping );\n\n\t\t\t\t\tplayerSphereCollision( sphere );\n\n\t\t\t\t} );\n\n\t\t\t\tspheresCollisions();\n\n\t\t\t\tfor ( const sphere of spheres ) {\n\n\t\t\t\t\tsphere.mesh.position.copy( sphere.collider.center );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getForwardVector() {\n\n\t\t\t\tcamera.getWorldDirection( playerDirection );\n\t\t\t\tplayerDirection.y = 0;\n\t\t\t\tplayerDirection.normalize();\n\n\t\t\t\treturn playerDirection;\n\n\t\t\t}\n\n\t\t\tfunction getSideVector() {\n\n\t\t\t\tcamera.getWorldDirection( playerDirection );\n\t\t\t\tplayerDirection.y = 0;\n\t\t\t\tplayerDirection.normalize();\n\t\t\t\tplayerDirection.cross( camera.up );\n\n\t\t\t\treturn playerDirection;\n\n\t\t\t}\n\n\t\t\tfunction controls( deltaTime ) {\n\n\t\t\t\t// gives a bit of air control\n\t\t\t\tconst speedDelta = deltaTime * ( playerOnFloor ? 25 : 8 );\n\n\t\t\t\tif ( keyStates[ 'KeyW' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( keyStates[ 'KeyS' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( keyStates[ 'KeyA' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( keyStates[ 'KeyD' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( playerOnFloor ) {\n\n\t\t\t\t\tif ( keyStates[ 'Space' ] ) {\n\n\t\t\t\t\t\tplayerVelocity.y = 15;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst loader = new GLTFLoader().setPath( './models/gltf/' );\n\n\t\t\tloader.load( 'collision-world.glb', ( gltf ) => {\n\n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\tworldOctree.fromGraphNode( gltf.scene );\n\n\t\t\t\tgltf.scene.traverse( child => {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\tchild.receiveShadow = true;\n\n\t\t\t\t\t\tif ( child.material.map ) {\n\n\t\t\t\t\t\t\tchild.material.map.anisotropy = 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tconst helper = new OctreeHelper( worldOctree );\n\t\t\t\thelper.visible = false;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\tconst gui = new GUI( { width: 200 } );\n\t\t\t\tgui.add( { debug: false }, 'debug' )\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\thelper.visible = value;\n\n\t\t\t\t\t} );\n\t\t\t\n\t\t\t} );\n\n\t\t\tfunction teleportPlayerIfOob() {\n\n\t\t\t\tif ( camera.position.y <= - 25 ) {\n\n\t\t\t\t\tplayerCollider.start.set( 0, 0.35, 0 );\n\t\t\t\t\tplayerCollider.end.set( 0, 1, 0 );\n\t\t\t\t\tplayerCollider.radius = 0.35;\n\t\t\t\t\tcamera.position.copy( playerCollider.end );\n\t\t\t\t\tcamera.rotation.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;\n\n\t\t\t\t// we look for collisions in substeps to mitigate the risk of\n\t\t\t\t// an object traversing another too quickly for detection.\n\n\t\t\t\tfor ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {\n\n\t\t\t\t\tcontrols( deltaTime );\n\n\t\t\t\t\tupdatePlayer( deltaTime );\n\n\t\t\t\t\tupdateSpheres( deltaTime );\n\n\t\t\t\t\tteleportPlayerIfOob();\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example Octree threejs demo - basic collisions with static triangle mesh MOUSE to look around and to throw balls WASD to move and SPACE to jump"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates Convex object breaking example"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Convex object breaking example:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\timport { ConvexObjectBreaker } from 'three/addons/misc/ConvexObjectBreaker.js';\n\t\timport { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';\n\n\t\t// - Global variables -\n\n\t\t// Graphics variables\n\t\tlet container, stats;\n\t\tlet camera, controls, scene, renderer;\n\t\tlet textureLoader;\n\t\tconst clock = new THREE.Clock();\n\n\t\tconst mouseCoords = new THREE.Vector2();\n\t\tconst raycaster = new THREE.Raycaster();\n\t\tconst ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );\n\n\t\t// Physics variables\n\t\tconst gravityConstant = 7.8;\n\t\tlet collisionConfiguration;\n\t\tlet dispatcher;\n\t\tlet broadphase;\n\t\tlet solver;\n\t\tlet physicsWorld;\n\t\tconst margin = 0.05;\n\n\t\tconst convexBreaker = new ConvexObjectBreaker();\n\n\t\t// Rigid bodies include all movable objects\n\t\tconst rigidBodies = [];\n\n\t\tconst pos = new THREE.Vector3();\n\t\tconst quat = new THREE.Quaternion();\n\t\tlet transformAux1;\n\t\tlet tempBtVec3_1;\n\n\t\tconst objectsToRemove = [];\n\n\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\tobjectsToRemove[ i ] = null;\n\n\t\t}\n\n\t\tlet numObjectsToRemove = 0;\n\n\t\tconst impactPoint = new THREE.Vector3();\n\t\tconst impactNormal = new THREE.Vector3();\n\n\t\t// - Main code -\n\n\t\tAmmo().then( function ( AmmoLib ) {\n\n\t\t\tAmmo = AmmoLib;\n\n\t\t\tinit();\n\n\t\t} );\n\n\n\t\t// - Functions -\n\n\t\tfunction init() {\n\n\t\t\tinitGraphics();\n\n\t\t\tinitPhysics();\n\n\t\t\tcreateObjects();\n\n\t\t\tinitInput();\n\n\t\t}\n\n\t\tfunction initGraphics() {\n\n\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\tcamera.position.set( - 14, 8, 16 );\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\tcontrols.update();\n\n\t\t\ttextureLoader = new THREE.TextureLoader();\n\n\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\tscene.add( ambientLight );\n\n\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tlight.position.set( - 10, 18, 5 );\n\t\t\tlight.castShadow = true;\n\t\t\tconst d = 14;\n\t\t\tlight.shadow.camera.left = - d;\n\t\t\tlight.shadow.camera.right = d;\n\t\t\tlight.shadow.camera.top = d;\n\t\t\tlight.shadow.camera.bottom = - d;\n\n\t\t\tlight.shadow.camera.near = 2;\n\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\tlight.shadow.mapSize.x = 1024;\n\t\t\tlight.shadow.mapSize.y = 1024;\n\n\t\t\tscene.add( light );\n\n\t\t\tstats = new Stats();\n\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\tstats.domElement.style.top = '0px';\n\t\t\tcontainer.appendChild( stats.domElement );\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction initPhysics() {\n\n\t\t\t// Physics configuration\n\n\t\t\tcollisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n\t\t\tdispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );\n\t\t\tbroadphase = new Ammo.btDbvtBroadphase();\n\t\t\tsolver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\tphysicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );\n\t\t\tphysicsWorld.setGravity( new Ammo.btVector3( 0, - gravityConstant, 0 ) );\n\n\t\t\ttransformAux1 = new Ammo.btTransform();\n\t\t\ttempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );\n\n\t\t}\n\n\t\tfunction createObject( mass, halfExtents, pos, quat, material ) {\n\n\t\t\tconst object = new THREE.Mesh( new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 ), material );\n\t\t\tobject.position.copy( pos );\n\t\t\tobject.quaternion.copy( quat );\n\t\t\tconvexBreaker.prepareBreakableObject( object, mass, new THREE.Vector3(), new THREE.Vector3(), true );\n\t\t\tcreateDebrisFromBreakableObject( object );\n\n\t\t}\n\n\t\tfunction createObjects() {\n\n\t\t\t// Ground\n\t\t\tpos.set( 0, - 0.5, 0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tconst ground = createParalellepipedWithPhysics( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );\n\t\t\tground.receiveShadow = true;\n\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.repeat.set( 40, 40 );\n\t\t\t\tground.material.map = texture;\n\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t\t// Tower 1\n\t\t\tconst towerMass = 1000;\n\t\t\tconst towerHalfExtents = new THREE.Vector3( 2, 5, 2 );\n\t\t\tpos.set( - 8, 5, 0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tcreateObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03014 ) );\n\n\t\t\t// Tower 2\n\t\t\tpos.set( 8, 5, 0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tcreateObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03214 ) );\n\n\t\t\t//Bridge\n\t\t\tconst bridgeMass = 100;\n\t\t\tconst bridgeHalfExtents = new THREE.Vector3( 7, 0.2, 1.5 );\n\t\t\tpos.set( 0, 10.2, 0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tcreateObject( bridgeMass, bridgeHalfExtents, pos, quat, createMaterial( 0xB3B865 ) );\n\n\t\t\t// Stones\n\t\t\tconst stoneMass = 120;\n\t\t\tconst stoneHalfExtents = new THREE.Vector3( 1, 2, 0.15 );\n\t\t\tconst numStones = 8;\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tfor ( let i = 0; i < numStones; i ++ ) {\n\n\t\t\t\tpos.set( 0, 2, 15 * ( 0.5 - i / ( numStones + 1 ) ) );\n\n\t\t\t\tcreateObject( stoneMass, stoneHalfExtents, pos, quat, createMaterial( 0xB0B0B0 ) );\n\n\t\t\t}\n\n\t\t\t// Mountain\n\t\t\tconst mountainMass = 860;\n\t\t\tconst mountainHalfExtents = new THREE.Vector3( 4, 5, 4 );\n\t\t\tpos.set( 5, mountainHalfExtents.y * 0.5, - 7 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tconst mountainPoints = [];\n\t\t\tmountainPoints.push( new THREE.Vector3( mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z ) );\n\t\t\tmountainPoints.push( new THREE.Vector3( - mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z ) );\n\t\t\tmountainPoints.push( new THREE.Vector3( mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z ) );\n\t\t\tmountainPoints.push( new THREE.Vector3( - mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z ) );\n\t\t\tmountainPoints.push( new THREE.Vector3( 0, mountainHalfExtents.y, 0 ) );\n\t\t\tconst mountain = new THREE.Mesh( new ConvexGeometry( mountainPoints ), createMaterial( 0xB03814 ) );\n\t\t\tmountain.position.copy( pos );\n\t\t\tmountain.quaternion.copy( quat );\n\t\t\tconvexBreaker.prepareBreakableObject( mountain, mountainMass, new THREE.Vector3(), new THREE.Vector3(), true );\n\t\t\tcreateDebrisFromBreakableObject( mountain );\n\n\t\t}\n\n\t\tfunction createParalellepipedWithPhysics( sx, sy, sz, mass, pos, quat, material ) {\n\n\t\t\tconst object = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );\n\t\t\tconst shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );\n\t\t\tshape.setMargin( margin );\n\n\t\t\tcreateRigidBody( object, shape, mass, pos, quat );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction createDebrisFromBreakableObject( object ) {\n\n\t\t\tobject.castShadow = true;\n\t\t\tobject.receiveShadow = true;\n\n\t\t\tconst shape = createConvexHullPhysicsShape( object.geometry.attributes.position.array );\n\t\t\tshape.setMargin( margin );\n\n\t\t\tconst body = createRigidBody( object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity );\n\n\t\t\t// Set pointer back to the three object only in the debris objects\n\t\t\tconst btVecUserData = new Ammo.btVector3( 0, 0, 0 );\n\t\t\tbtVecUserData.threeObject = object;\n\t\t\tbody.setUserPointer( btVecUserData );\n\n\t\t}\n\n\t\tfunction removeDebris( object ) {\n\n\t\t\tscene.remove( object );\n\n\t\t\tphysicsWorld.removeRigidBody( object.userData.physicsBody );\n\n\t\t}\n\n\t\tfunction createConvexHullPhysicsShape( coords ) {\n\n\t\t\tconst shape = new Ammo.btConvexHullShape();\n\n\t\t\tfor ( let i = 0, il = coords.length; i < il; i += 3 ) {\n\n\t\t\t\ttempBtVec3_1.setValue( coords[ i ], coords[ i + 1 ], coords[ i + 2 ] );\n\t\t\t\tconst lastOne = ( i >= ( il - 3 ) );\n\t\t\t\tshape.addPoint( tempBtVec3_1, lastOne );\n\n\t\t\t}\n\n\t\t\treturn shape;\n\n\t\t}\n\n\t\tfunction createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) {\n\n\t\t\tif ( pos ) {\n\n\t\t\t\tobject.position.copy( pos );\n\n\t\t\t} else {\n\n\t\t\t\tpos = object.position;\n\n\t\t\t}\n\n\t\t\tif ( quat ) {\n\n\t\t\t\tobject.quaternion.copy( quat );\n\n\t\t\t} else {\n\n\t\t\t\tquat = object.quaternion;\n\n\t\t\t}\n\n\t\t\tconst transform = new Ammo.btTransform();\n\t\t\ttransform.setIdentity();\n\t\t\ttransform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\t\t\ttransform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );\n\t\t\tconst motionState = new Ammo.btDefaultMotionState( transform );\n\n\t\t\tconst localInertia = new Ammo.btVector3( 0, 0, 0 );\n\t\t\tphysicsShape.calculateLocalInertia( mass, localInertia );\n\n\t\t\tconst rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );\n\t\t\tconst body = new Ammo.btRigidBody( rbInfo );\n\n\t\t\tbody.setFriction( 0.5 );\n\n\t\t\tif ( vel ) {\n\n\t\t\t\tbody.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );\n\n\t\t\t}\n\n\t\t\tif ( angVel ) {\n\n\t\t\t\tbody.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );\n\n\t\t\t}\n\n\t\t\tobject.userData.physicsBody = body;\n\t\t\tobject.userData.collided = false;\n\n\t\t\tscene.add( object );\n\n\t\t\tif ( mass > 0 ) {\n\n\t\t\t\trigidBodies.push( object );\n\n\t\t\t\t// Disable deactivation\n\t\t\t\tbody.setActivationState( 4 );\n\n\t\t\t}\n\n\t\t\tphysicsWorld.addRigidBody( body );\n\n\t\t\treturn body;\n\n\t\t}\n\n\t\tfunction createRandomColor() {\n\n\t\t\treturn Math.floor( Math.random() * ( 1 << 24 ) );\n\n\t\t}\n\n\t\tfunction createMaterial( color ) {\n\n\t\t\tcolor = color || createRandomColor();\n\t\t\treturn new THREE.MeshPhongMaterial( { color: color } );\n\n\t\t}\n\n\t\tfunction initInput() {\n\n\t\t\twindow.addEventListener( 'pointerdown', function ( event ) {\n\n\t\t\t\tmouseCoords.set(\n\t\t\t\t\t( event.clientX / window.innerWidth ) * 2 - 1,\n\t\t\t\t\t- ( event.clientY / window.innerHeight ) * 2 + 1\n\t\t\t\t);\n\n\t\t\t\traycaster.setFromCamera( mouseCoords, camera );\n\n\t\t\t\t// Creates a ball and throws it\n\t\t\t\tconst ballMass = 35;\n\t\t\t\tconst ballRadius = 0.4;\n\n\t\t\t\tconst ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 14, 10 ), ballMaterial );\n\t\t\t\tball.castShadow = true;\n\t\t\t\tball.receiveShadow = true;\n\t\t\t\tconst ballShape = new Ammo.btSphereShape( ballRadius );\n\t\t\t\tballShape.setMargin( margin );\n\t\t\t\tpos.copy( raycaster.ray.direction );\n\t\t\t\tpos.add( raycaster.ray.origin );\n\t\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\t\tconst ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );\n\n\t\t\t\tpos.copy( raycaster.ray.direction );\n\t\t\t\tpos.multiplyScalar( 24 );\n\t\t\t\tballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\trender();\n\t\t\tstats.update();\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\tconst deltaTime = clock.getDelta();\n\n\t\t\tupdatePhysics( deltaTime );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n\n\t\tfunction updatePhysics( deltaTime ) {\n\n\t\t\t// Step world\n\t\t\tphysicsWorld.stepSimulation( deltaTime, 10 );\n\n\t\t\t// Update rigid bodies\n\t\t\tfor ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {\n\n\t\t\t\tconst objThree = rigidBodies[ i ];\n\t\t\t\tconst objPhys = objThree.userData.physicsBody;\n\t\t\t\tconst ms = objPhys.getMotionState();\n\n\t\t\t\tif ( ms ) {\n\n\t\t\t\t\tms.getWorldTransform( transformAux1 );\n\t\t\t\t\tconst p = transformAux1.getOrigin();\n\t\t\t\t\tconst q = transformAux1.getRotation();\n\t\t\t\t\tobjThree.position.set( p.x(), p.y(), p.z() );\n\t\t\t\t\tobjThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );\n\n\t\t\t\t\tobjThree.userData.collided = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {\n\n\t\t\t\tconst contactManifold = dispatcher.getManifoldByIndexInternal( i );\n\t\t\t\tconst rb0 = Ammo.castObject( contactManifold.getBody0(), Ammo.btRigidBody );\n\t\t\t\tconst rb1 = Ammo.castObject( contactManifold.getBody1(), Ammo.btRigidBody );\n\n\t\t\t\tconst threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;\n\t\t\t\tconst threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;\n\n\t\t\t\tif ( ! threeObject0 && ! threeObject1 ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst userData0 = threeObject0 ? threeObject0.userData : null;\n\t\t\t\tconst userData1 = threeObject1 ? threeObject1.userData : null;\n\n\t\t\t\tconst breakable0 = userData0 ? userData0.breakable : false;\n\t\t\t\tconst breakable1 = userData1 ? userData1.breakable : false;\n\n\t\t\t\tconst collided0 = userData0 ? userData0.collided : false;\n\t\t\t\tconst collided1 = userData1 ? userData1.collided : false;\n\n\t\t\t\tif ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tlet contact = false;\n\t\t\t\tlet maxImpulse = 0;\n\t\t\t\tfor ( let j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {\n\n\t\t\t\t\tconst contactPoint = contactManifold.getContactPoint( j );\n\n\t\t\t\t\tif ( contactPoint.getDistance() < 0 ) {\n\n\t\t\t\t\t\tcontact = true;\n\t\t\t\t\t\tconst impulse = contactPoint.getAppliedImpulse();\n\n\t\t\t\t\t\tif ( impulse > maxImpulse ) {\n\n\t\t\t\t\t\t\tmaxImpulse = impulse;\n\t\t\t\t\t\t\tconst pos = contactPoint.get_m_positionWorldOnB();\n\t\t\t\t\t\t\tconst normal = contactPoint.get_m_normalWorldOnB();\n\t\t\t\t\t\t\timpactPoint.set( pos.x(), pos.y(), pos.z() );\n\t\t\t\t\t\t\timpactNormal.set( normal.x(), normal.y(), normal.z() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// If no point has contact, abort\n\t\t\t\tif ( ! contact ) continue;\n\n\t\t\t\t// Subdivision\n\n\t\t\t\tconst fractureImpulse = 250;\n\n\t\t\t\tif ( breakable0 && ! collided0 && maxImpulse > fractureImpulse ) {\n\n\t\t\t\t\tconst debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal, 1, 2, 1.5 );\n\n\t\t\t\t\tconst numObjects = debris.length;\n\t\t\t\t\tfor ( let j = 0; j < numObjects; j ++ ) {\n\n\t\t\t\t\t\tconst vel = rb0.getLinearVelocity();\n\t\t\t\t\t\tconst angVel = rb0.getAngularVelocity();\n\t\t\t\t\t\tconst fragment = debris[ j ];\n\t\t\t\t\t\tfragment.userData.velocity.set( vel.x(), vel.y(), vel.z() );\n\t\t\t\t\t\tfragment.userData.angularVelocity.set( angVel.x(), angVel.y(), angVel.z() );\n\n\t\t\t\t\t\tcreateDebrisFromBreakableObject( fragment );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjectsToRemove[ numObjectsToRemove ++ ] = threeObject0;\n\t\t\t\t\tuserData0.collided = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( breakable1 && ! collided1 && maxImpulse > fractureImpulse ) {\n\n\t\t\t\t\tconst debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal, 1, 2, 1.5 );\n\n\t\t\t\t\tconst numObjects = debris.length;\n\t\t\t\t\tfor ( let j = 0; j < numObjects; j ++ ) {\n\n\t\t\t\t\t\tconst vel = rb1.getLinearVelocity();\n\t\t\t\t\t\tconst angVel = rb1.getAngularVelocity();\n\t\t\t\t\t\tconst fragment = debris[ j ];\n\t\t\t\t\t\tfragment.userData.velocity.set( vel.x(), vel.y(), vel.z() );\n\t\t\t\t\t\tfragment.userData.angularVelocity.set( angVel.x(), angVel.y(), angVel.z() );\n\n\t\t\t\t\t\tcreateDebrisFromBreakableObject( fragment );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjectsToRemove[ numObjectsToRemove ++ ] = threeObject1;\n\t\t\t\t\tuserData1.collided = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < numObjectsToRemove; i ++ ) {\n\n\t\t\t\tremoveDebris( objectsToRemove[ i ] );\n\n\t\t\t}\n\n\t\t\tnumObjectsToRemove = 0;\n\n\t\t}\n```\n\nThis example Physics threejs demo with convex objects breaking in real time Press mouse to throw balls and move the camera."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates Ammo.js softbody cloth demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Ammo.js softbody cloth demo:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\t// Graphics variables\n\t\t\tlet container, stats;\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet textureLoader;\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\t// Physics variables\n\t\t\tconst gravityConstant = - 9.8;\n\t\t\tlet physicsWorld;\n\t\t\tconst rigidBodies = [];\n\t\t\tconst margin = 0.05;\n\t\t\tlet hinge;\n\t\t\tlet cloth;\n\t\t\tlet transformAux1;\n\n\t\t\tlet armMovement = 0;\n\n\t\t\tAmmo().then( function ( AmmoLib ) {\n\n\t\t\t\tAmmo = AmmoLib;\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitGraphics();\n\n\t\t\t\tinitPhysics();\n\n\t\t\t\tcreateObjects();\n\n\t\t\t\tinitInput();\n\n\t\t\t}\n\n\t\t\tfunction initGraphics() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera.position.set( - 12, 7, 4 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\ttextureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( - 7, 10, 15 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tconst d = 10;\n\t\t\t\tlight.shadow.camera.left = - d;\n\t\t\t\tlight.shadow.camera.right = d;\n\t\t\t\tlight.shadow.camera.top = d;\n\t\t\t\tlight.shadow.camera.bottom = - d;\n\n\t\t\t\tlight.shadow.camera.near = 2;\n\t\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\t\tlight.shadow.mapSize.x = 1024;\n\t\t\t\tlight.shadow.mapSize.y = 1024;\n\n\t\t\t\tlight.shadow.bias = - 0.003;\n\t\t\t\tscene.add( light );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\t\tstats.domElement.style.top = '0px';\n\t\t\t\tcontainer.appendChild( stats.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initPhysics() {\n\n\t\t\t\t// Physics configuration\n\n\t\t\t\tconst collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();\n\t\t\t\tconst dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );\n\t\t\t\tconst broadphase = new Ammo.btDbvtBroadphase();\n\t\t\t\tconst solver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\t\tconst softBodySolver = new Ammo.btDefaultSoftBodySolver();\n\t\t\t\tphysicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver );\n\t\t\t\tphysicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );\n\t\t\t\tphysicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );\n\n\t\t\t\ttransformAux1 = new Ammo.btTransform();\n\n\t\t\t}\n\n\t\t\tfunction createObjects() {\n\n\t\t\t\tconst pos = new THREE.Vector3();\n\t\t\t\tconst quat = new THREE.Quaternion();\n\n\t\t\t\t// Ground\n\t\t\t\tpos.set( 0, - 0.5, 0 );\n\t\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\t\tconst ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( 40, 40 );\n\t\t\t\t\tground.material.map = texture;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t} );\n\n\t\t\t\t// Wall\n\t\t\t\tconst brickMass = 0.5;\n\t\t\t\tconst brickLength = 1.2;\n\t\t\t\tconst brickDepth = 0.6;\n\t\t\t\tconst brickHeight = brickLength * 0.5;\n\t\t\t\tconst numBricksLength = 6;\n\t\t\t\tconst numBricksHeight = 8;\n\t\t\t\tconst z0 = - numBricksLength * brickLength * 0.5;\n\t\t\t\tpos.set( 0, brickHeight * 0.5, z0 );\n\t\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\t\tfor ( let j = 0; j < numBricksHeight; j ++ ) {\n\n\t\t\t\t\tconst oddRow = ( j % 2 ) == 1;\n\n\t\t\t\t\tpos.z = z0;\n\n\t\t\t\t\tif ( oddRow ) {\n\n\t\t\t\t\t\tpos.z -= 0.25 * brickLength;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nRow = oddRow ? numBricksLength + 1 : numBricksLength;\n\n\t\t\t\t\tfor ( let i = 0; i < nRow; i ++ ) {\n\n\t\t\t\t\t\tlet brickLengthCurrent = brickLength;\n\t\t\t\t\t\tlet brickMassCurrent = brickMass;\n\n\t\t\t\t\t\tif ( oddRow && ( i == 0 || i == nRow - 1 ) ) {\n\n\t\t\t\t\t\t\tbrickLengthCurrent *= 0.5;\n\t\t\t\t\t\t\tbrickMassCurrent *= 0.5;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst brick = createParalellepiped( brickDepth, brickHeight, brickLengthCurrent, brickMassCurrent, pos, quat, createMaterial() );\n\t\t\t\t\t\tbrick.castShadow = true;\n\t\t\t\t\t\tbrick.receiveShadow = true;\n\n\t\t\t\t\t\tif ( oddRow && ( i == 0 || i == nRow - 2 ) ) {\n\n\t\t\t\t\t\t\tpos.z += 0.75 * brickLength;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpos.z += brickLength;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpos.y += brickHeight;\n\n\t\t\t\t}\n\n\t\t\t\t// The cloth\n\t\t\t\t// Cloth graphic object\n\t\t\t\tconst clothWidth = 4;\n\t\t\t\tconst clothHeight = 3;\n\t\t\t\tconst clothNumSegmentsZ = clothWidth * 5;\n\t\t\t\tconst clothNumSegmentsY = clothHeight * 5;\n\t\t\t\tconst clothPos = new THREE.Vector3( - 3, 3, 2 );\n\n\t\t\t\tconst clothGeometry = new THREE.PlaneGeometry( clothWidth, clothHeight, clothNumSegmentsZ, clothNumSegmentsY );\n\t\t\t\tclothGeometry.rotateY( Math.PI * 0.5 );\n\t\t\t\tclothGeometry.translate( clothPos.x, clothPos.y + clothHeight * 0.5, clothPos.z - clothWidth * 0.5 );\n\n\t\t\t\tconst clothMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, side: THREE.DoubleSide } );\n\t\t\t\tcloth = new THREE.Mesh( clothGeometry, clothMaterial );\n\t\t\t\tcloth.castShadow = true;\n\t\t\t\tcloth.receiveShadow = true;\n\t\t\t\tscene.add( cloth );\n\t\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( clothNumSegmentsZ, clothNumSegmentsY );\n\t\t\t\t\tcloth.material.map = texture;\n\t\t\t\t\tcloth.material.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\t// Cloth physic object\n\t\t\t\tconst softBodyHelpers = new Ammo.btSoftBodyHelpers();\n\t\t\t\tconst clothCorner00 = new Ammo.btVector3( clothPos.x, clothPos.y + clothHeight, clothPos.z );\n\t\t\t\tconst clothCorner01 = new Ammo.btVector3( clothPos.x, clothPos.y + clothHeight, clothPos.z - clothWidth );\n\t\t\t\tconst clothCorner10 = new Ammo.btVector3( clothPos.x, clothPos.y, clothPos.z );\n\t\t\t\tconst clothCorner11 = new Ammo.btVector3( clothPos.x, clothPos.y, clothPos.z - clothWidth );\n\t\t\t\tconst clothSoftBody = softBodyHelpers.CreatePatch( physicsWorld.getWorldInfo(), clothCorner00, clothCorner01, clothCorner10, clothCorner11, clothNumSegmentsZ + 1, clothNumSegmentsY + 1, 0, true );\n\t\t\t\tconst sbConfig = clothSoftBody.get_m_cfg();\n\t\t\t\tsbConfig.set_viterations( 10 );\n\t\t\t\tsbConfig.set_piterations( 10 );\n\n\t\t\t\tclothSoftBody.setTotalMass( 0.9, false );\n\t\t\t\tAmmo.castObject( clothSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( margin * 3 );\n\t\t\t\tphysicsWorld.addSoftBody( clothSoftBody, 1, - 1 );\n\t\t\t\tcloth.userData.physicsBody = clothSoftBody;\n\t\t\t\t// Disable deactivation\n\t\t\t\tclothSoftBody.setActivationState( 4 );\n\n\t\t\t\t// The base\n\t\t\t\tconst armMass = 2;\n\t\t\t\tconst armLength = 3 + clothWidth;\n\t\t\t\tconst pylonHeight = clothPos.y + clothHeight;\n\t\t\t\tconst baseMaterial = new THREE.MeshPhongMaterial( { color: 0x606060 } );\n\t\t\t\tpos.set( clothPos.x, 0.1, clothPos.z - armLength );\n\t\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\t\tconst base = createParalellepiped( 1, 0.2, 1, 0, pos, quat, baseMaterial );\n\t\t\t\tbase.castShadow = true;\n\t\t\t\tbase.receiveShadow = true;\n\t\t\t\tpos.set( clothPos.x, 0.5 * pylonHeight, clothPos.z - armLength );\n\t\t\t\tconst pylon = createParalellepiped( 0.4, pylonHeight, 0.4, 0, pos, quat, baseMaterial );\n\t\t\t\tpylon.castShadow = true;\n\t\t\t\tpylon.receiveShadow = true;\n\t\t\t\tpos.set( clothPos.x, pylonHeight + 0.2, clothPos.z - 0.5 * armLength );\n\t\t\t\tconst arm = createParalellepiped( 0.4, 0.4, armLength + 0.4, armMass, pos, quat, baseMaterial );\n\t\t\t\tarm.castShadow = true;\n\t\t\t\tarm.receiveShadow = true;\n\n\t\t\t\t// Glue the cloth to the arm\n\t\t\t\tconst influence = 0.5;\n\t\t\t\tclothSoftBody.appendAnchor( 0, arm.userData.physicsBody, false, influence );\n\t\t\t\tclothSoftBody.appendAnchor( clothNumSegmentsZ, arm.userData.physicsBody, false, influence );\n\n\t\t\t\t// Hinge constraint to move the arm\n\t\t\t\tconst pivotA = new Ammo.btVector3( 0, pylonHeight * 0.5, 0 );\n\t\t\t\tconst pivotB = new Ammo.btVector3( 0, - 0.2, - armLength * 0.5 );\n\t\t\t\tconst axis = new Ammo.btVector3( 0, 1, 0 );\n\t\t\t\thinge = new Ammo.btHingeConstraint( pylon.userData.physicsBody, arm.userData.physicsBody, pivotA, pivotB, axis, axis, true );\n\t\t\t\tphysicsWorld.addConstraint( hinge, true );\n\n\t\t\t}\n\n\t\t\tfunction createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {\n\n\t\t\t\tconst threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );\n\t\t\t\tconst shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );\n\t\t\t\tshape.setMargin( margin );\n\n\t\t\t\tcreateRigidBody( threeObject, shape, mass, pos, quat );\n\n\t\t\t\treturn threeObject;\n\n\t\t\t}\n\n\t\t\tfunction createRigidBody( threeObject, physicsShape, mass, pos, quat ) {\n\n\t\t\t\tthreeObject.position.copy( pos );\n\t\t\t\tthreeObject.quaternion.copy( quat );\n\n\t\t\t\tconst transform = new Ammo.btTransform();\n\t\t\t\ttransform.setIdentity();\n\t\t\t\ttransform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\t\t\t\ttransform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );\n\t\t\t\tconst motionState = new Ammo.btDefaultMotionState( transform );\n\n\t\t\t\tconst localInertia = new Ammo.btVector3( 0, 0, 0 );\n\t\t\t\tphysicsShape.calculateLocalInertia( mass, localInertia );\n\n\t\t\t\tconst rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );\n\t\t\t\tconst body = new Ammo.btRigidBody( rbInfo );\n\n\t\t\t\tthreeObject.userData.physicsBody = body;\n\n\t\t\t\tscene.add( threeObject );\n\n\t\t\t\tif ( mass > 0 ) {\n\n\t\t\t\t\trigidBodies.push( threeObject );\n\n\t\t\t\t\t// Disable deactivation\n\t\t\t\t\tbody.setActivationState( 4 );\n\n\t\t\t\t}\n\n\t\t\t\tphysicsWorld.addRigidBody( body );\n\n\t\t\t}\n\n\t\t\tfunction createRandomColor() {\n\n\t\t\t\treturn Math.floor( Math.random() * ( 1 << 24 ) );\n\n\t\t\t}\n\n\t\t\tfunction createMaterial() {\n\n\t\t\t\treturn new THREE.MeshPhongMaterial( { color: createRandomColor() } );\n\n\t\t\t}\n\n\t\t\tfunction initInput() {\n\n\t\t\t\twindow.addEventListener( 'keydown', function ( event ) {\n\n\t\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\t\t// Q\n\t\t\t\t\t\tcase 81:\n\t\t\t\t\t\t\tarmMovement = 1;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// A\n\t\t\t\t\t\tcase 65:\n\t\t\t\t\t\t\tarmMovement = - 1;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'keyup', function () {\n\n\t\t\t\t\tarmMovement = 0;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst deltaTime = clock.getDelta();\n\n\t\t\t\tupdatePhysics( deltaTime );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction updatePhysics( deltaTime ) {\n\n\t\t\t\t// Hinge control\n\t\t\t\thinge.enableAngularMotor( true, 0.8 * armMovement, 50 );\n\n\t\t\t\t// Step world\n\t\t\t\tphysicsWorld.stepSimulation( deltaTime, 10 );\n\n\t\t\t\t// Update cloth\n\t\t\t\tconst softBody = cloth.userData.physicsBody;\n\t\t\t\tconst clothPositions = cloth.geometry.attributes.position.array;\n\t\t\t\tconst numVerts = clothPositions.length / 3;\n\t\t\t\tconst nodes = softBody.get_m_nodes();\n\t\t\t\tlet indexFloat = 0;\n\n\t\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\t\tconst node = nodes.at( i );\n\t\t\t\t\tconst nodePos = node.get_m_x();\n\t\t\t\t\tclothPositions[ indexFloat ++ ] = nodePos.x();\n\t\t\t\t\tclothPositions[ indexFloat ++ ] = nodePos.y();\n\t\t\t\t\tclothPositions[ indexFloat ++ ] = nodePos.z();\n\n\t\t\t\t}\n\n\t\t\t\tcloth.geometry.computeVertexNormals();\n\t\t\t\tcloth.geometry.attributes.position.needsUpdate = true;\n\t\t\t\tcloth.geometry.attributes.normal.needsUpdate = true;\n\n\t\t\t\t// Update rigid bodies\n\t\t\t\tfor ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst objThree = rigidBodies[ i ];\n\t\t\t\t\tconst objPhys = objThree.userData.physicsBody;\n\t\t\t\t\tconst ms = objPhys.getMotionState();\n\t\t\t\t\tif ( ms ) {\n\n\t\t\t\t\t\tms.getWorldTransform( transformAux1 );\n\t\t\t\t\t\tconst p = transformAux1.getOrigin();\n\t\t\t\t\t\tconst q = transformAux1.getRotation();\n\t\t\t\t\t\tobjThree.position.set( p.x(), p.y(), p.z() );\n\t\t\t\t\t\tobjThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example Ammo.js physics soft body cloth demo Press Q or A to move the arm."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - ammo.js instancing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - ammo.js instancing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { AmmoPhysics } from 'three/addons/physics/AmmoPhysics.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet physics, position;\n\n\t\t\tlet boxes, spheres;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tphysics = await AmmoPhysics();\n\t\t\t\tposition = new THREE.Vector3();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( - 1, 1.5, 2 );\n\t\t\t\tcamera.lookAt( 0, 0.5, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight();\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 5, 5, 5 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.zoom = 2;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst shadowPlane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10, 10 ),\n\t\t\t\t\tnew THREE.ShadowMaterial( {\n\t\t\t\t\t\tcolor: 0x444444\n\t\t\t\t\t} ),\n\t\t\t\t);\n\t\t\t\tshadowPlane.rotation.x = - Math.PI / 2;\n\t\t\t\tshadowPlane.receiveShadow = true;\n\t\t\t\tscene.add( shadowPlane );\n\n\t\t\t\tconst floorCollider = new THREE.Mesh(\n\t\t\t\t\tnew THREE.BoxGeometry( 10, 5, 10 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x666666 } )\n\t\t\t\t);\n\t\t\t\tfloorCollider.position.y = - 2.5;\n\t\t\t\tfloorCollider.userData.physics = { mass: 0 };\n\t\t\t\tfloorCollider.visible = false;\n\t\t\t\tscene.add( floorCollider );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\t// Boxes\n\n\t\t\t\tconst geometryBox = new THREE.BoxGeometry( 0.075, 0.075, 0.075 );\n\t\t\t\tboxes = new THREE.InstancedMesh( geometryBox, material, 400 );\n\t\t\t\tboxes.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tboxes.castShadow = true;\n\t\t\t\tboxes.receiveShadow = true;\n\t\t\t\tboxes.userData.physics = { mass: 1 };\n\t\t\t\tscene.add( boxes );\n\n\t\t\t\tfor ( let i = 0; i < boxes.count; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );\n\t\t\t\t\tboxes.setMatrixAt( i, matrix );\n\t\t\t\t\tboxes.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Spheres\n\n\t\t\t\tconst geometrySphere = new THREE.IcosahedronGeometry( 0.05, 4 );\n\t\t\t\tspheres = new THREE.InstancedMesh( geometrySphere, material, 400 );\n\t\t\t\tspheres.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tspheres.castShadow = true;\n\t\t\t\tspheres.receiveShadow = true;\n\t\t\t\tspheres.userData.physics = { mass: 1 };\n\t\t\t\tscene.add( spheres );\n\n\t\t\t\tfor ( let i = 0; i < spheres.count; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );\n\t\t\t\t\tspheres.setMatrixAt( i, matrix );\n\t\t\t\t\tspheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.y = 0.5;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tsetInterval( () => {\n\n\t\t\t\t\tlet index = Math.floor( Math.random() * boxes.count );\n\n\t\t\t\t\tposition.set( 0, Math.random() + 1, 0 );\n\t\t\t\t\tphysics.setMeshPosition( boxes, position, index );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tindex = Math.floor( Math.random() * spheres.count );\n\n\t\t\t\t\tposition.set( 0, Math.random() + 1, 0 );\n\t\t\t\t\tphysics.setMeshPosition( spheres, position, index );\n\n\t\t\t\t}, 1000 / 60 );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - ammo.js instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates Amjs softbody rope demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Amjs softbody rope demo:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t// Graphics variables\n\t\tlet container, stats;\n\t\tlet camera, controls, scene, renderer;\n\t\tlet textureLoader;\n\t\tconst clock = new THREE.Clock();\n\n\t\t// Physics variables\n\t\tconst gravityConstant = - 9.8;\n\t\tlet collisionConfiguration;\n\t\tlet dispatcher;\n\t\tlet broadphase;\n\t\tlet solver;\n\t\tlet softBodySolver;\n\t\tlet physicsWorld;\n\t\tconst rigidBodies = [];\n\t\tconst margin = 0.05;\n\t\tlet hinge;\n\t\tlet rope;\n\t\tlet transformAux1;\n\n\t\tlet armMovement = 0;\n\n\t\tAmmo().then( function ( AmmoLib ) {\n\n\t\t\tAmmo = AmmoLib;\n\n\t\t\tinit();\n\n\t\t} );\n\n\t\tfunction init() {\n\n\t\t\tinitGraphics();\n\n\t\t\tinitPhysics();\n\n\t\t\tcreateObjects();\n\n\t\t\tinitInput();\n\n\t\t}\n\n\t\tfunction initGraphics() {\n\n\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );\n\n\t\t\tscene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\tcamera.position.set( - 7, 5, 8 );\n\n\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\tcontrols.update();\n\n\t\t\ttextureLoader = new THREE.TextureLoader();\n\n\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\tscene.add( ambientLight );\n\n\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\tlight.position.set( - 10, 10, 5 );\n\t\t\tlight.castShadow = true;\n\t\t\tconst d = 10;\n\t\t\tlight.shadow.camera.left = - d;\n\t\t\tlight.shadow.camera.right = d;\n\t\t\tlight.shadow.camera.top = d;\n\t\t\tlight.shadow.camera.bottom = - d;\n\n\t\t\tlight.shadow.camera.near = 2;\n\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\tlight.shadow.mapSize.x = 1024;\n\t\t\tlight.shadow.mapSize.y = 1024;\n\n\t\t\tscene.add( light );\n\n\t\t\tstats = new Stats();\n\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\tstats.domElement.style.top = '0px';\n\t\t\tcontainer.appendChild( stats.domElement );\n\n\t\t\t//\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t}\n\n\t\tfunction initPhysics() {\n\n\t\t\t// Physics configuration\n\n\t\t\tcollisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();\n\t\t\tdispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );\n\t\t\tbroadphase = new Ammo.btDbvtBroadphase();\n\t\t\tsolver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\tsoftBodySolver = new Ammo.btDefaultSoftBodySolver();\n\t\t\tphysicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver );\n\t\t\tphysicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );\n\t\t\tphysicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );\n\n\t\t\ttransformAux1 = new Ammo.btTransform();\n\n\t\t}\n\n\t\tfunction createObjects() {\n\n\t\t\tconst pos = new THREE.Vector3();\n\t\t\tconst quat = new THREE.Quaternion();\n\n\t\t\t// Ground\n\t\t\tpos.set( 0, - 0.5, 0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tconst ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );\n\t\t\tground.castShadow = true;\n\t\t\tground.receiveShadow = true;\n\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\ttexture.repeat.set( 40, 40 );\n\t\t\t\tground.material.map = texture;\n\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t} );\n\n\n\t\t\t// Ball\n\t\t\tconst ballMass = 1.2;\n\t\t\tconst ballRadius = 0.6;\n\n\t\t\tconst ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 20, 20 ), new THREE.MeshPhongMaterial( { color: 0x202020 } ) );\n\t\t\tball.castShadow = true;\n\t\t\tball.receiveShadow = true;\n\t\t\tconst ballShape = new Ammo.btSphereShape( ballRadius );\n\t\t\tballShape.setMargin( margin );\n\t\t\tpos.set( - 3, 2, 0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tcreateRigidBody( ball, ballShape, ballMass, pos, quat );\n\t\t\tball.userData.physicsBody.setFriction( 0.5 );\n\n\t\t\t// Wall\n\t\t\tconst brickMass = 0.5;\n\t\t\tconst brickLength = 1.2;\n\t\t\tconst brickDepth = 0.6;\n\t\t\tconst brickHeight = brickLength * 0.5;\n\t\t\tconst numBricksLength = 6;\n\t\t\tconst numBricksHeight = 8;\n\t\t\tconst z0 = - numBricksLength * brickLength * 0.5;\n\t\t\tpos.set( 0, brickHeight * 0.5, z0 );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\n\t\t\tfor ( let j = 0; j < numBricksHeight; j ++ ) {\n\n\t\t\t\tconst oddRow = ( j % 2 ) == 1;\n\n\t\t\t\tpos.z = z0;\n\n\t\t\t\tif ( oddRow ) {\n\n\t\t\t\t\tpos.z -= 0.25 * brickLength;\n\n\t\t\t\t}\n\n\t\t\t\tconst nRow = oddRow ? numBricksLength + 1 : numBricksLength;\n\n\t\t\t\tfor ( let i = 0; i < nRow; i ++ ) {\n\n\t\t\t\t\tlet brickLengthCurrent = brickLength;\n\t\t\t\t\tlet brickMassCurrent = brickMass;\n\t\t\t\t\tif ( oddRow && ( i == 0 || i == nRow - 1 ) ) {\n\n\t\t\t\t\t\tbrickLengthCurrent *= 0.5;\n\t\t\t\t\t\tbrickMassCurrent *= 0.5;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst brick = createParalellepiped( brickDepth, brickHeight, brickLengthCurrent, brickMassCurrent, pos, quat, createMaterial() );\n\t\t\t\t\tbrick.castShadow = true;\n\t\t\t\t\tbrick.receiveShadow = true;\n\n\t\t\t\t\tif ( oddRow && ( i == 0 || i == nRow - 2 ) ) {\n\n\t\t\t\t\t\tpos.z += 0.75 * brickLength;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpos.z += brickLength;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tpos.y += brickHeight;\n\n\t\t\t}\n\n\t\t\t// The rope\n\t\t\t// Rope graphic object\n\t\t\tconst ropeNumSegments = 10;\n\t\t\tconst ropeLength = 4;\n\t\t\tconst ropeMass = 3;\n\t\t\tconst ropePos = ball.position.clone();\n\t\t\tropePos.y += ballRadius;\n\n\t\t\tconst segmentLength = ropeLength / ropeNumSegments;\n\t\t\tconst ropeGeometry = new THREE.BufferGeometry();\n\t\t\tconst ropeMaterial = new THREE.LineBasicMaterial( { color: 0x000000 } );\n\t\t\tconst ropePositions = [];\n\t\t\tconst ropeIndices = [];\n\n\t\t\tfor ( let i = 0; i < ropeNumSegments + 1; i ++ ) {\n\n\t\t\t\tropePositions.push( ropePos.x, ropePos.y + i * segmentLength, ropePos.z );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < ropeNumSegments; i ++ ) {\n\n\t\t\t\tropeIndices.push( i, i + 1 );\n\n\t\t\t}\n\n\t\t\tropeGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( ropeIndices ), 1 ) );\n\t\t\tropeGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ropePositions ), 3 ) );\n\t\t\tropeGeometry.computeBoundingSphere();\n\t\t\trope = new THREE.LineSegments( ropeGeometry, ropeMaterial );\n\t\t\trope.castShadow = true;\n\t\t\trope.receiveShadow = true;\n\t\t\tscene.add( rope );\n\n\t\t\t// Rope physic object\n\t\t\tconst softBodyHelpers = new Ammo.btSoftBodyHelpers();\n\t\t\tconst ropeStart = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );\n\t\t\tconst ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y + ropeLength, ropePos.z );\n\t\t\tconst ropeSoftBody = softBodyHelpers.CreateRope( physicsWorld.getWorldInfo(), ropeStart, ropeEnd, ropeNumSegments - 1, 0 );\n\t\t\tconst sbConfig = ropeSoftBody.get_m_cfg();\n\t\t\tsbConfig.set_viterations( 10 );\n\t\t\tsbConfig.set_piterations( 10 );\n\t\t\tropeSoftBody.setTotalMass( ropeMass, false );\n\t\t\tAmmo.castObject( ropeSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( margin * 3 );\n\t\t\tphysicsWorld.addSoftBody( ropeSoftBody, 1, - 1 );\n\t\t\trope.userData.physicsBody = ropeSoftBody;\n\t\t\t// Disable deactivation\n\t\t\tropeSoftBody.setActivationState( 4 );\n\n\t\t\t// The base\n\t\t\tconst armMass = 2;\n\t\t\tconst armLength = 3;\n\t\t\tconst pylonHeight = ropePos.y + ropeLength;\n\t\t\tconst baseMaterial = new THREE.MeshPhongMaterial( { color: 0x606060 } );\n\t\t\tpos.set( ropePos.x, 0.1, ropePos.z - armLength );\n\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\tconst base = createParalellepiped( 1, 0.2, 1, 0, pos, quat, baseMaterial );\n\t\t\tbase.castShadow = true;\n\t\t\tbase.receiveShadow = true;\n\t\t\tpos.set( ropePos.x, 0.5 * pylonHeight, ropePos.z - armLength );\n\t\t\tconst pylon = createParalellepiped( 0.4, pylonHeight, 0.4, 0, pos, quat, baseMaterial );\n\t\t\tpylon.castShadow = true;\n\t\t\tpylon.receiveShadow = true;\n\t\t\tpos.set( ropePos.x, pylonHeight + 0.2, ropePos.z - 0.5 * armLength );\n\t\t\tconst arm = createParalellepiped( 0.4, 0.4, armLength + 0.4, armMass, pos, quat, baseMaterial );\n\t\t\tarm.castShadow = true;\n\t\t\tarm.receiveShadow = true;\n\n\t\t\t// Glue the rope extremes to the ball and the arm\n\t\t\tconst influence = 1;\n\t\t\tropeSoftBody.appendAnchor( 0, ball.userData.physicsBody, true, influence );\n\t\t\tropeSoftBody.appendAnchor( ropeNumSegments, arm.userData.physicsBody, true, influence );\n\n\t\t\t// Hinge constraint to move the arm\n\t\t\tconst pivotA = new Ammo.btVector3( 0, pylonHeight * 0.5, 0 );\n\t\t\tconst pivotB = new Ammo.btVector3( 0, - 0.2, - armLength * 0.5 );\n\t\t\tconst axis = new Ammo.btVector3( 0, 1, 0 );\n\t\t\thinge = new Ammo.btHingeConstraint( pylon.userData.physicsBody, arm.userData.physicsBody, pivotA, pivotB, axis, axis, true );\n\t\t\tphysicsWorld.addConstraint( hinge, true );\n\n\n\t\t}\n\n\t\tfunction createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {\n\n\t\t\tconst threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );\n\t\t\tconst shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );\n\t\t\tshape.setMargin( margin );\n\n\t\t\tcreateRigidBody( threeObject, shape, mass, pos, quat );\n\n\t\t\treturn threeObject;\n\n\t\t}\n\n\t\tfunction createRigidBody( threeObject, physicsShape, mass, pos, quat ) {\n\n\t\t\tthreeObject.position.copy( pos );\n\t\t\tthreeObject.quaternion.copy( quat );\n\n\t\t\tconst transform = new Ammo.btTransform();\n\t\t\ttransform.setIdentity();\n\t\t\ttransform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\t\t\ttransform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );\n\t\t\tconst motionState = new Ammo.btDefaultMotionState( transform );\n\n\t\t\tconst localInertia = new Ammo.btVector3( 0, 0, 0 );\n\t\t\tphysicsShape.calculateLocalInertia( mass, localInertia );\n\n\t\t\tconst rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );\n\t\t\tconst body = new Ammo.btRigidBody( rbInfo );\n\n\t\t\tthreeObject.userData.physicsBody = body;\n\n\t\t\tscene.add( threeObject );\n\n\t\t\tif ( mass > 0 ) {\n\n\t\t\t\trigidBodies.push( threeObject );\n\n\t\t\t\t// Disable deactivation\n\t\t\t\tbody.setActivationState( 4 );\n\n\t\t\t}\n\n\t\t\tphysicsWorld.addRigidBody( body );\n\n\t\t}\n\n\t\tfunction createRandomColor() {\n\n\t\t\treturn Math.floor( Math.random() * ( 1 << 24 ) );\n\n\t\t}\n\n\t\tfunction createMaterial() {\n\n\t\t\treturn new THREE.MeshPhongMaterial( { color: createRandomColor() } );\n\n\t\t}\n\n\t\tfunction initInput() {\n\n\t\t\twindow.addEventListener( 'keydown', function ( event ) {\n\n\t\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\t\t// Q\n\t\t\t\t\tcase 81:\n\t\t\t\t\t\tarmMovement = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// A\n\t\t\t\t\tcase 65:\n\t\t\t\t\t\tarmMovement = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\twindow.addEventListener( 'keyup', function () {\n\n\t\t\t\tarmMovement = 0;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction onWindowResize() {\n\n\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t\tfunction animate() {\n\n\t\t\trender();\n\t\t\tstats.update();\n\n\t\t}\n\n\t\tfunction render() {\n\n\t\t\tconst deltaTime = clock.getDelta();\n\n\t\t\tupdatePhysics( deltaTime );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t}\n\n\t\tfunction updatePhysics( deltaTime ) {\n\n\t\t\t// Hinge control\n\t\t\thinge.enableAngularMotor( true, 1.5 * armMovement, 50 );\n\n\t\t\t// Step world\n\t\t\tphysicsWorld.stepSimulation( deltaTime, 10 );\n\n\t\t\t// Update rope\n\t\t\tconst softBody = rope.userData.physicsBody;\n\t\t\tconst ropePositions = rope.geometry.attributes.position.array;\n\t\t\tconst numVerts = ropePositions.length / 3;\n\t\t\tconst nodes = softBody.get_m_nodes();\n\t\t\tlet indexFloat = 0;\n\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst node = nodes.at( i );\n\t\t\t\tconst nodePos = node.get_m_x();\n\t\t\t\tropePositions[ indexFloat ++ ] = nodePos.x();\n\t\t\t\tropePositions[ indexFloat ++ ] = nodePos.y();\n\t\t\t\tropePositions[ indexFloat ++ ] = nodePos.z();\n\n\t\t\t}\n\n\t\t\trope.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t// Update rigid bodies\n\t\t\tfor ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {\n\n\t\t\t\tconst objThree = rigidBodies[ i ];\n\t\t\t\tconst objPhys = objThree.userData.physicsBody;\n\t\t\t\tconst ms = objPhys.getMotionState();\n\t\t\t\tif ( ms ) {\n\n\t\t\t\t\tms.getWorldTransform( transformAux1 );\n\t\t\t\t\tconst p = transformAux1.getOrigin();\n\t\t\t\t\tconst q = transformAux1.getRotation();\n\t\t\t\t\tobjThree.position.set( p.x(), p.y(), p.z() );\n\t\t\t\t\tobjThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n```\n\nThis example Ammo.js physics soft body rope demo Press Q or A to move the arm."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates Ammo.js terrain heightfield demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Ammo.js terrain heightfield demo:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\t// Heightfield parameters\n\t\t\tconst terrainWidthExtents = 100;\n\t\t\tconst terrainDepthExtents = 100;\n\t\t\tconst terrainWidth = 128;\n\t\t\tconst terrainDepth = 128;\n\t\t\tconst terrainHalfWidth = terrainWidth / 2;\n\t\t\tconst terrainHalfDepth = terrainDepth / 2;\n\t\t\tconst terrainMaxHeight = 8;\n\t\t\tconst terrainMinHeight = - 2;\n\n\t\t\t// Graphics variables\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet terrainMesh;\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\t// Physics variables\n\t\t\tlet collisionConfiguration;\n\t\t\tlet dispatcher;\n\t\t\tlet broadphase;\n\t\t\tlet solver;\n\t\t\tlet physicsWorld;\n\t\t\tconst dynamicObjects = [];\n\t\t\tlet transformAux1;\n\n\t\t\tlet heightData = null;\n\t\t\tlet ammoHeightData = null;\n\n\t\t\tlet time = 0;\n\t\t\tconst objectTimePeriod = 3;\n\t\t\tlet timeNextSpawn = time + objectTimePeriod;\n\t\t\tconst maxNumObjects = 30;\n\n\t\t\tAmmo().then( function ( AmmoLib ) {\n\n\t\t\t\tAmmo = AmmoLib;\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\theightData = generateHeight( terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight );\n\n\t\t\t\tinitGraphics();\n\n\t\t\t\tinitPhysics();\n\n\t\t\t}\n\n\t\t\tfunction initGraphics() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\t\tstats.domElement.style.top = '0px';\n\t\t\t\tcontainer.appendChild( stats.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera.position.y = heightData[ terrainHalfWidth + terrainHalfDepth * terrainWidth ] * ( terrainMaxHeight - terrainMinHeight ) + 5;\n\n\t\t\t\tcamera.position.z = terrainDepthExtents / 2;\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( terrainWidthExtents, terrainDepthExtents, terrainWidth - 1, terrainDepth - 1 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst vertices = geometry.attributes.position.array;\n\n\t\t\t\tfor ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {\n\n\t\t\t\t\t// j + 1 because it is the y component that we modify\n\t\t\t\t\tvertices[ j + 1 ] = heightData[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\tconst groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );\n\t\t\t\tterrainMesh = new THREE.Mesh( geometry, groundMaterial );\n\t\t\t\tterrainMesh.receiveShadow = true;\n\t\t\t\tterrainMesh.castShadow = true;\n\n\t\t\t\tscene.add( terrainMesh );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( terrainWidth - 1, terrainDepth - 1 );\n\t\t\t\t\tgroundMaterial.map = texture;\n\t\t\t\t\tgroundMaterial.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 100, 100, 50 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tconst dLight = 200;\n\t\t\t\tconst sLight = dLight * 0.25;\n\t\t\t\tlight.shadow.camera.left = - sLight;\n\t\t\t\tlight.shadow.camera.right = sLight;\n\t\t\t\tlight.shadow.camera.top = sLight;\n\t\t\t\tlight.shadow.camera.bottom = - sLight;\n\n\t\t\t\tlight.shadow.camera.near = dLight / 30;\n\t\t\t\tlight.shadow.camera.far = dLight;\n\n\t\t\t\tlight.shadow.mapSize.x = 1024 * 2;\n\t\t\t\tlight.shadow.mapSize.y = 1024 * 2;\n\n\t\t\t\tscene.add( light );\n\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction initPhysics() {\n\n\t\t\t\t// Physics configuration\n\n\t\t\t\tcollisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n\t\t\t\tdispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );\n\t\t\t\tbroadphase = new Ammo.btDbvtBroadphase();\n\t\t\t\tsolver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\t\tphysicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );\n\t\t\t\tphysicsWorld.setGravity( new Ammo.btVector3( 0, - 6, 0 ) );\n\n\t\t\t\t// Create the terrain body\n\n\t\t\t\tconst groundShape = createTerrainShape();\n\t\t\t\tconst groundTransform = new Ammo.btTransform();\n\t\t\t\tgroundTransform.setIdentity();\n\t\t\t\t// Shifts the terrain, since bullet re-centers it on its bounding box.\n\t\t\t\tgroundTransform.setOrigin( new Ammo.btVector3( 0, ( terrainMaxHeight + terrainMinHeight ) / 2, 0 ) );\n\t\t\t\tconst groundMass = 0;\n\t\t\t\tconst groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );\n\t\t\t\tconst groundMotionState = new Ammo.btDefaultMotionState( groundTransform );\n\t\t\t\tconst groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );\n\t\t\t\tphysicsWorld.addRigidBody( groundBody );\n\n\t\t\t\ttransformAux1 = new Ammo.btTransform();\n\n\t\t\t}\n\n\t\t\tfunction generateHeight( width, depth, minHeight, maxHeight ) {\n\n\t\t\t\t// Generates the height data (a sinus wave)\n\n\t\t\t\tconst size = width * depth;\n\t\t\t\tconst data = new Float32Array( size );\n\n\t\t\t\tconst hRange = maxHeight - minHeight;\n\t\t\t\tconst w2 = width / 2;\n\t\t\t\tconst d2 = depth / 2;\n\t\t\t\tconst phaseMult = 12;\n\n\t\t\t\tlet p = 0;\n\n\t\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < width; i ++ ) {\n\n\t\t\t\t\t\tconst radius = Math.sqrt(\n\t\t\t\t\t\t\tMath.pow( ( i - w2 ) / w2, 2.0 ) +\n\t\t\t\t\t\t\t\tMath.pow( ( j - d2 ) / d2, 2.0 ) );\n\n\t\t\t\t\t\tconst height = ( Math.sin( radius * phaseMult ) + 1 ) * 0.5 * hRange + minHeight;\n\n\t\t\t\t\t\tdata[ p ] = height;\n\n\t\t\t\t\t\tp ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction createTerrainShape() {\n\n\t\t\t\t// This parameter is not really used, since we are using PHY_FLOAT height data type and hence it is ignored\n\t\t\t\tconst heightScale = 1;\n\n\t\t\t\t// Up axis = 0 for X, 1 for Y, 2 for Z. Normally 1 = Y is used.\n\t\t\t\tconst upAxis = 1;\n\n\t\t\t\t// hdt, height data type. \"PHY_FLOAT\" is used. Possible values are \"PHY_FLOAT\", \"PHY_UCHAR\", \"PHY_SHORT\"\n\t\t\t\tconst hdt = 'PHY_FLOAT';\n\n\t\t\t\t// Set this to your needs (inverts the triangles)\n\t\t\t\tconst flipQuadEdges = false;\n\n\t\t\t\t// Creates height data buffer in Ammo heap\n\t\t\t\tammoHeightData = Ammo._malloc( 4 * terrainWidth * terrainDepth );\n\n\t\t\t\t// Copy the javascript height data array to the Ammo one.\n\t\t\t\tlet p = 0;\n\t\t\t\tlet p2 = 0;\n\n\t\t\t\tfor ( let j = 0; j < terrainDepth; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < terrainWidth; i ++ ) {\n\n\t\t\t\t\t\t// write 32-bit float data to memory\n\t\t\t\t\t\tAmmo.HEAPF32[ ammoHeightData + p2 >> 2 ] = heightData[ p ];\n\n\t\t\t\t\t\tp ++;\n\n\t\t\t\t\t\t// 4 bytes/float\n\t\t\t\t\t\tp2 += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Creates the heightfield physics shape\n\t\t\t\tconst heightFieldShape = new Ammo.btHeightfieldTerrainShape(\n\t\t\t\t\tterrainWidth,\n\t\t\t\t\tterrainDepth,\n\t\t\t\t\tammoHeightData,\n\t\t\t\t\theightScale,\n\t\t\t\t\tterrainMinHeight,\n\t\t\t\t\tterrainMaxHeight,\n\t\t\t\t\tupAxis,\n\t\t\t\t\thdt,\n\t\t\t\t\tflipQuadEdges\n\t\t\t\t);\n\n\t\t\t\t// Set horizontal scale\n\t\t\t\tconst scaleX = terrainWidthExtents / ( terrainWidth - 1 );\n\t\t\t\tconst scaleZ = terrainDepthExtents / ( terrainDepth - 1 );\n\t\t\t\theightFieldShape.setLocalScaling( new Ammo.btVector3( scaleX, 1, scaleZ ) );\n\n\t\t\t\theightFieldShape.setMargin( 0.05 );\n\n\t\t\t\treturn heightFieldShape;\n\n\t\t\t}\n\n\t\t\tfunction generateObject() {\n\n\t\t\t\tconst numTypes = 4;\n\t\t\t\tconst objectType = Math.ceil( Math.random() * numTypes );\n\n\t\t\t\tlet threeObject = null;\n\t\t\t\tlet shape = null;\n\n\t\t\t\tconst objectSize = 3;\n\t\t\t\tconst margin = 0.05;\n\n\t\t\t\tlet radius, height;\n\n\t\t\t\tswitch ( objectType ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t// Sphere\n\t\t\t\t\t\tradius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.SphereGeometry( radius, 20, 20 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btSphereShape( radius );\n\t\t\t\t\t\tshape.setMargin( margin );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t// Box\n\t\t\t\t\t\tconst sx = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tconst sy = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tconst sz = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );\n\t\t\t\t\t\tshape.setMargin( margin );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t// Cylinder\n\t\t\t\t\t\tradius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\theight = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.CylinderGeometry( radius, radius, height, 20, 1 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btCylinderShape( new Ammo.btVector3( radius, height * 0.5, radius ) );\n\t\t\t\t\t\tshape.setMargin( margin );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Cone\n\t\t\t\t\t\tradius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\theight = 2 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.ConeGeometry( radius, height, 20, 2 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btConeShape( radius, height );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tthreeObject.position.set( ( Math.random() - 0.5 ) * terrainWidth * 0.6, terrainMaxHeight + objectSize + 2, ( Math.random() - 0.5 ) * terrainDepth * 0.6 );\n\n\t\t\t\tconst mass = objectSize * 5;\n\t\t\t\tconst localInertia = new Ammo.btVector3( 0, 0, 0 );\n\t\t\t\tshape.calculateLocalInertia( mass, localInertia );\n\t\t\t\tconst transform = new Ammo.btTransform();\n\t\t\t\ttransform.setIdentity();\n\t\t\t\tconst pos = threeObject.position;\n\t\t\t\ttransform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\t\t\t\tconst motionState = new Ammo.btDefaultMotionState( transform );\n\t\t\t\tconst rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, shape, localInertia );\n\t\t\t\tconst body = new Ammo.btRigidBody( rbInfo );\n\n\t\t\t\tthreeObject.userData.physicsBody = body;\n\n\t\t\t\tthreeObject.receiveShadow = true;\n\t\t\t\tthreeObject.castShadow = true;\n\n\t\t\t\tscene.add( threeObject );\n\t\t\t\tdynamicObjects.push( threeObject );\n\n\t\t\t\tphysicsWorld.addRigidBody( body );\n\n\n\n\t\t\t}\n\n\t\t\tfunction createObjectMaterial() {\n\n\t\t\t\tconst c = Math.floor( Math.random() * ( 1 << 24 ) );\n\t\t\t\treturn new THREE.MeshPhongMaterial( { color: c } );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst deltaTime = clock.getDelta();\n\n\t\t\t\tif ( dynamicObjects.length < maxNumObjects && time > timeNextSpawn ) {\n\n\t\t\t\t\tgenerateObject();\n\t\t\t\t\ttimeNextSpawn = time + objectTimePeriod;\n\n\t\t\t\t}\n\n\t\t\t\tupdatePhysics( deltaTime );\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\ttime += deltaTime;\n\n\t\t\t}\n\n\t\t\tfunction updatePhysics( deltaTime ) {\n\n\t\t\t\tphysicsWorld.stepSimulation( deltaTime, 10 );\n\n\t\t\t\t// Update objects\n\t\t\t\tfor ( let i = 0, il = dynamicObjects.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst objThree = dynamicObjects[ i ];\n\t\t\t\t\tconst objPhys = objThree.userData.physicsBody;\n\t\t\t\t\tconst ms = objPhys.getMotionState();\n\t\t\t\t\tif ( ms ) {\n\n\t\t\t\t\t\tms.getWorldTransform( transformAux1 );\n\t\t\t\t\t\tconst p = transformAux1.getOrigin();\n\t\t\t\t\t\tconst q = transformAux1.getRotation();\n\t\t\t\t\t\tobjThree.position.set( p.x(), p.y(), p.z() );\n\t\t\t\t\t\tobjThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example Ammo.js physics terrain heightfield demo"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates Ammo.js softbody volume demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Ammo.js softbody volume demo:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n\n\t\t\t// Graphics variables\n\t\t\tlet container, stats;\n\t\t\tlet camera, controls, scene, renderer;\n\t\t\tlet textureLoader;\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tlet clickRequest = false;\n\t\t\tconst mouseCoords = new THREE.Vector2();\n\t\t\tconst raycaster = new THREE.Raycaster();\n\t\t\tconst ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );\n\t\t\tconst pos = new THREE.Vector3();\n\t\t\tconst quat = new THREE.Quaternion();\n\n\t\t\t// Physics variables\n\t\t\tconst gravityConstant = - 9.8;\n\t\t\tlet physicsWorld;\n\t\t\tconst rigidBodies = [];\n\t\t\tconst softBodies = [];\n\t\t\tconst margin = 0.05;\n\t\t\tlet transformAux1;\n\t\t\tlet softBodyHelpers;\n\n\t\t\tAmmo().then( function ( AmmoLib ) {\n\n\t\t\t\tAmmo = AmmoLib;\n\n\t\t\t\tinit();\n\n\t\t\t} );\n\n\t\t\tfunction init() {\n\n\t\t\t\tinitGraphics();\n\n\t\t\t\tinitPhysics();\n\n\t\t\t\tcreateObjects();\n\n\t\t\t\tinitInput();\n\n\t\t\t}\n\n\t\t\tfunction initGraphics() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera.position.set( - 7, 5, 8 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\ttextureLoader = new THREE.TextureLoader();\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( - 10, 10, 5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tconst d = 20;\n\t\t\t\tlight.shadow.camera.left = - d;\n\t\t\t\tlight.shadow.camera.right = d;\n\t\t\t\tlight.shadow.camera.top = d;\n\t\t\t\tlight.shadow.camera.bottom = - d;\n\n\t\t\t\tlight.shadow.camera.near = 2;\n\t\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\t\tlight.shadow.mapSize.x = 1024;\n\t\t\t\tlight.shadow.mapSize.y = 1024;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\t\tstats.domElement.style.top = '0px';\n\t\t\t\tcontainer.appendChild( stats.domElement );\n\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction initPhysics() {\n\n\t\t\t\t// Physics configuration\n\n\t\t\t\tconst collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();\n\t\t\t\tconst dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );\n\t\t\t\tconst broadphase = new Ammo.btDbvtBroadphase();\n\t\t\t\tconst solver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\t\tconst softBodySolver = new Ammo.btDefaultSoftBodySolver();\n\t\t\t\tphysicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver );\n\t\t\t\tphysicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );\n\t\t\t\tphysicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );\n\n\t\t\t\ttransformAux1 = new Ammo.btTransform();\n\t\t\t\tsoftBodyHelpers = new Ammo.btSoftBodyHelpers();\n\n\t\t\t}\n\n\t\t\tfunction createObjects() {\n\n\t\t\t\t// Ground\n\t\t\t\tpos.set( 0, - 0.5, 0 );\n\t\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\t\tconst ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );\n\t\t\t\tground.castShadow = true;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( 40, 40 );\n\t\t\t\t\tground.material.map = texture;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\t// Create soft volumes\n\t\t\t\tconst volumeMass = 15;\n\n\t\t\t\tconst sphereGeometry = new THREE.SphereGeometry( 1.5, 40, 25 );\n\t\t\t\tsphereGeometry.translate( 5, 5, 0 );\n\t\t\t\tcreateSoftVolume( sphereGeometry, volumeMass, 250 );\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 1, 1, 5, 4, 4, 20 );\n\t\t\t\tboxGeometry.translate( - 2, 5, 0 );\n\t\t\t\tcreateSoftVolume( boxGeometry, volumeMass, 120 );\n\n\t\t\t\t// Ramp\n\t\t\t\tpos.set( 3, 1, 0 );\n\t\t\t\tquat.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), 30 * Math.PI / 180 );\n\t\t\t\tconst obstacle = createParalellepiped( 10, 1, 4, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0x606060 } ) );\n\t\t\t\tobstacle.castShadow = true;\n\t\t\t\tobstacle.receiveShadow = true;\n\n\t\t\t}\n\n\t\t\tfunction processGeometry( bufGeometry ) {\n\n\t\t\t\t// Ony consider the position values when merging the vertices\n\t\t\t\tconst posOnlyBufGeometry = new THREE.BufferGeometry();\n\t\t\t\tposOnlyBufGeometry.setAttribute( 'position', bufGeometry.getAttribute( 'position' ) );\n\t\t\t\tposOnlyBufGeometry.setIndex( bufGeometry.getIndex() );\n\n\t\t\t\t// Merge the vertices so the triangle soup is converted to indexed triangles\n\t\t\t\tconst indexedBufferGeom = BufferGeometryUtils.mergeVertices( posOnlyBufGeometry );\n\n\t\t\t\t// Create index arrays mapping the indexed vertices to bufGeometry vertices\n\t\t\t\tmapIndices( bufGeometry, indexedBufferGeom );\n\n\t\t\t}\n\n\t\t\tfunction isEqual( x1, y1, z1, x2, y2, z2 ) {\n\n\t\t\t\tconst delta = 0.000001;\n\t\t\t\treturn Math.abs( x2 - x1 ) < delta &&\n\t\t\t\t\t\tMath.abs( y2 - y1 ) < delta &&\n\t\t\t\t\t\tMath.abs( z2 - z1 ) < delta;\n\n\t\t\t}\n\n\t\t\tfunction mapIndices( bufGeometry, indexedBufferGeom ) {\n\n\t\t\t\t// Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry\n\n\t\t\t\tconst vertices = bufGeometry.attributes.position.array;\n\t\t\t\tconst idxVertices = indexedBufferGeom.attributes.position.array;\n\t\t\t\tconst indices = indexedBufferGeom.index.array;\n\n\t\t\t\tconst numIdxVertices = idxVertices.length / 3;\n\t\t\t\tconst numVertices = vertices.length / 3;\n\n\t\t\t\tbufGeometry.ammoVertices = idxVertices;\n\t\t\t\tbufGeometry.ammoIndices = indices;\n\t\t\t\tbufGeometry.ammoIndexAssociation = [];\n\n\t\t\t\tfor ( let i = 0; i < numIdxVertices; i ++ ) {\n\n\t\t\t\t\tconst association = [];\n\t\t\t\t\tbufGeometry.ammoIndexAssociation.push( association );\n\n\t\t\t\t\tconst i3 = i * 3;\n\n\t\t\t\t\tfor ( let j = 0; j < numVertices; j ++ ) {\n\n\t\t\t\t\t\tconst j3 = j * 3;\n\t\t\t\t\t\tif ( isEqual( idxVertices[ i3 ], idxVertices[ i3 + 1 ], idxVertices[ i3 + 2 ],\n\t\t\t\t\t\t\tvertices[ j3 ], vertices[ j3 + 1 ], vertices[ j3 + 2 ] ) ) {\n\n\t\t\t\t\t\t\tassociation.push( j3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createSoftVolume( bufferGeom, mass, pressure ) {\n\n\t\t\t\tprocessGeometry( bufferGeom );\n\n\t\t\t\tconst volume = new THREE.Mesh( bufferGeom, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );\n\t\t\t\tvolume.castShadow = true;\n\t\t\t\tvolume.receiveShadow = true;\n\t\t\t\tvolume.frustumCulled = false;\n\t\t\t\tscene.add( volume );\n\n\t\t\t\ttextureLoader.load( 'textures/colors.png', function ( texture ) {\n\n\t\t\t\t\tvolume.material.map = texture;\n\t\t\t\t\tvolume.material.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\t// Volume physic object\n\n\t\t\t\tconst volumeSoftBody = softBodyHelpers.CreateFromTriMesh(\n\t\t\t\t\tphysicsWorld.getWorldInfo(),\n\t\t\t\t\tbufferGeom.ammoVertices,\n\t\t\t\t\tbufferGeom.ammoIndices,\n\t\t\t\t\tbufferGeom.ammoIndices.length / 3,\n\t\t\t\t\ttrue );\n\n\t\t\t\tconst sbConfig = volumeSoftBody.get_m_cfg();\n\t\t\t\tsbConfig.set_viterations( 40 );\n\t\t\t\tsbConfig.set_piterations( 40 );\n\n\t\t\t\t// Soft-soft and soft-rigid collisions\n\t\t\t\tsbConfig.set_collisions( 0x11 );\n\n\t\t\t\t// Friction\n\t\t\t\tsbConfig.set_kDF( 0.1 );\n\t\t\t\t// Damping\n\t\t\t\tsbConfig.set_kDP( 0.01 );\n\t\t\t\t// Pressure\n\t\t\t\tsbConfig.set_kPR( pressure );\n\t\t\t\t// Stiffness\n\t\t\t\tvolumeSoftBody.get_m_materials().at( 0 ).set_m_kLST( 0.9 );\n\t\t\t\tvolumeSoftBody.get_m_materials().at( 0 ).set_m_kAST( 0.9 );\n\n\t\t\t\tvolumeSoftBody.setTotalMass( mass, false );\n\t\t\t\tAmmo.castObject( volumeSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( margin );\n\t\t\t\tphysicsWorld.addSoftBody( volumeSoftBody, 1, - 1 );\n\t\t\t\tvolume.userData.physicsBody = volumeSoftBody;\n\t\t\t\t// Disable deactivation\n\t\t\t\tvolumeSoftBody.setActivationState( 4 );\n\n\t\t\t\tsoftBodies.push( volume );\n\n\t\t\t}\n\n\t\t\tfunction createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {\n\n\t\t\t\tconst threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );\n\t\t\t\tconst shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );\n\t\t\t\tshape.setMargin( margin );\n\n\t\t\t\tcreateRigidBody( threeObject, shape, mass, pos, quat );\n\n\t\t\t\treturn threeObject;\n\n\t\t\t}\n\n\t\t\tfunction createRigidBody( threeObject, physicsShape, mass, pos, quat ) {\n\n\t\t\t\tthreeObject.position.copy( pos );\n\t\t\t\tthreeObject.quaternion.copy( quat );\n\n\t\t\t\tconst transform = new Ammo.btTransform();\n\t\t\t\ttransform.setIdentity();\n\t\t\t\ttransform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\t\t\t\ttransform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );\n\t\t\t\tconst motionState = new Ammo.btDefaultMotionState( transform );\n\n\t\t\t\tconst localInertia = new Ammo.btVector3( 0, 0, 0 );\n\t\t\t\tphysicsShape.calculateLocalInertia( mass, localInertia );\n\n\t\t\t\tconst rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );\n\t\t\t\tconst body = new Ammo.btRigidBody( rbInfo );\n\n\t\t\t\tthreeObject.userData.physicsBody = body;\n\n\t\t\t\tscene.add( threeObject );\n\n\t\t\t\tif ( mass > 0 ) {\n\n\t\t\t\t\trigidBodies.push( threeObject );\n\n\t\t\t\t\t// Disable deactivation\n\t\t\t\t\tbody.setActivationState( 4 );\n\n\t\t\t\t}\n\n\t\t\t\tphysicsWorld.addRigidBody( body );\n\n\t\t\t\treturn body;\n\n\t\t\t}\n\n\t\t\tfunction initInput() {\n\n\t\t\t\twindow.addEventListener( 'pointerdown', function ( event ) {\n\n\t\t\t\t\tif ( ! clickRequest ) {\n\n\t\t\t\t\t\tmouseCoords.set(\n\t\t\t\t\t\t\t( event.clientX / window.innerWidth ) * 2 - 1,\n\t\t\t\t\t\t\t- ( event.clientY / window.innerHeight ) * 2 + 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tclickRequest = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction processClick() {\n\n\t\t\t\tif ( clickRequest ) {\n\n\t\t\t\t\traycaster.setFromCamera( mouseCoords, camera );\n\n\t\t\t\t\t// Creates a ball\n\t\t\t\t\tconst ballMass = 3;\n\t\t\t\t\tconst ballRadius = 0.4;\n\n\t\t\t\t\tconst ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 18, 16 ), ballMaterial );\n\t\t\t\t\tball.castShadow = true;\n\t\t\t\t\tball.receiveShadow = true;\n\t\t\t\t\tconst ballShape = new Ammo.btSphereShape( ballRadius );\n\t\t\t\t\tballShape.setMargin( margin );\n\t\t\t\t\tpos.copy( raycaster.ray.direction );\n\t\t\t\t\tpos.add( raycaster.ray.origin );\n\t\t\t\t\tquat.set( 0, 0, 0, 1 );\n\t\t\t\t\tconst ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );\n\t\t\t\t\tballBody.setFriction( 0.5 );\n\n\t\t\t\t\tpos.copy( raycaster.ray.direction );\n\t\t\t\t\tpos.multiplyScalar( 14 );\n\t\t\t\t\tballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );\n\n\t\t\t\t\tclickRequest = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst deltaTime = clock.getDelta();\n\n\t\t\t\tupdatePhysics( deltaTime );\n\n\t\t\t\tprocessClick();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction updatePhysics( deltaTime ) {\n\n\t\t\t\t// Step world\n\t\t\t\tphysicsWorld.stepSimulation( deltaTime, 10 );\n\n\t\t\t\t// Update soft volumes\n\t\t\t\tfor ( let i = 0, il = softBodies.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst volume = softBodies[ i ];\n\t\t\t\t\tconst geometry = volume.geometry;\n\t\t\t\t\tconst softBody = volume.userData.physicsBody;\n\t\t\t\t\tconst volumePositions = geometry.attributes.position.array;\n\t\t\t\t\tconst volumeNormals = geometry.attributes.normal.array;\n\t\t\t\t\tconst association = geometry.ammoIndexAssociation;\n\t\t\t\t\tconst numVerts = association.length;\n\t\t\t\t\tconst nodes = softBody.get_m_nodes();\n\t\t\t\t\tfor ( let j = 0; j < numVerts; j ++ ) {\n\n\t\t\t\t\t\tconst node = nodes.at( j );\n\t\t\t\t\t\tconst nodePos = node.get_m_x();\n\t\t\t\t\t\tconst x = nodePos.x();\n\t\t\t\t\t\tconst y = nodePos.y();\n\t\t\t\t\t\tconst z = nodePos.z();\n\t\t\t\t\t\tconst nodeNormal = node.get_m_n();\n\t\t\t\t\t\tconst nx = nodeNormal.x();\n\t\t\t\t\t\tconst ny = nodeNormal.y();\n\t\t\t\t\t\tconst nz = nodeNormal.z();\n\n\t\t\t\t\t\tconst assocVertex = association[ j ];\n\n\t\t\t\t\t\tfor ( let k = 0, kl = assocVertex.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tlet indexVertex = assocVertex[ k ];\n\t\t\t\t\t\t\tvolumePositions[ indexVertex ] = x;\n\t\t\t\t\t\t\tvolumeNormals[ indexVertex ] = nx;\n\t\t\t\t\t\t\tindexVertex ++;\n\t\t\t\t\t\t\tvolumePositions[ indexVertex ] = y;\n\t\t\t\t\t\t\tvolumeNormals[ indexVertex ] = ny;\n\t\t\t\t\t\t\tindexVertex ++;\n\t\t\t\t\t\t\tvolumePositions[ indexVertex ] = z;\n\t\t\t\t\t\t\tvolumeNormals[ indexVertex ] = nz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.attributes.position.needsUpdate = true;\n\t\t\t\t\tgeometry.attributes.normal.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\t// Update rigid bodies\n\t\t\t\tfor ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst objThree = rigidBodies[ i ];\n\t\t\t\t\tconst objPhys = objThree.userData.physicsBody;\n\t\t\t\t\tconst ms = objPhys.getMotionState();\n\t\t\t\t\tif ( ms ) {\n\n\t\t\t\t\t\tms.getWorldTransform( transformAux1 );\n\t\t\t\t\t\tconst p = transformAux1.getOrigin();\n\t\t\t\t\t\tconst q = transformAux1.getRotation();\n\t\t\t\t\t\tobjThree.position.set( p.x(), p.y(), p.z() );\n\t\t\t\t\t\tobjThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example Ammo.js physics soft body volume demo Click to throw a ball"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - jolt instancing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - jolt instancing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { JoltPhysics } from 'three/addons/physics/JoltPhysics.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet physics, position;\n\n\t\t\tlet boxes, spheres;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tphysics = await JoltPhysics();\n\t\t\t\tposition = new THREE.Vector3();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( - 1, 1.5, 2 );\n\t\t\t\tcamera.lookAt( 0, 0.5, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight();\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 5, 5, 5 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.zoom = 2;\n\t\t\t\tdirLight.shadow.bias = - 0.001;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst shadowPlane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10, 10 ),\n\t\t\t\t\tnew THREE.ShadowMaterial( {\n\t\t\t\t\t\tcolor: 0x444444\n\t\t\t\t\t} ),\n\t\t\t\t);\n\t\t\t\tshadowPlane.rotation.x = - Math.PI / 2;\n\t\t\t\tshadowPlane.receiveShadow = true;\n\t\t\t\tscene.add( shadowPlane );\n\n\t\t\t\tconst floorCollider = new THREE.Mesh(\n\t\t\t\t\tnew THREE.BoxGeometry( 10, 5, 10 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x666666 } )\n\t\t\t\t);\n\t\t\t\tfloorCollider.position.y = - 2.5;\n\t\t\t\tfloorCollider.userData.physics = { mass: 0 };\n\t\t\t\tfloorCollider.visible = false;\n\t\t\t\tscene.add( floorCollider );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\t// Boxes\n\n\t\t\t\tconst geometryBox = new THREE.BoxGeometry( 0.075, 0.075, 0.075 );\n\t\t\t\tboxes = new THREE.InstancedMesh( geometryBox, material, 400 );\n\t\t\t\tboxes.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tboxes.castShadow = true;\n\t\t\t\tboxes.receiveShadow = true;\n\t\t\t\tboxes.userData.physics = { mass: 1 };\n\t\t\t\tscene.add( boxes );\n\n\t\t\t\tfor ( let i = 0; i < boxes.count; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );\n\t\t\t\t\tboxes.setMatrixAt( i, matrix );\n\t\t\t\t\tboxes.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Spheres\n\n\t\t\t\tconst geometrySphere = new THREE.IcosahedronGeometry( 0.05, 4 );\n\t\t\t\tspheres = new THREE.InstancedMesh( geometrySphere, material, 400 );\n\t\t\t\tspheres.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tspheres.castShadow = true;\n\t\t\t\tspheres.receiveShadow = true;\n\t\t\t\tspheres.userData.physics = { mass: 1 };\n\t\t\t\tscene.add( spheres );\n\n\t\t\t\tfor ( let i = 0; i < spheres.count; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );\n\t\t\t\t\tspheres.setMatrixAt( i, matrix );\n\t\t\t\t\tspheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.y = 0.5;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tsetInterval( () => {\n\n\t\t\t\t\tlet index = Math.floor( Math.random() * boxes.count );\n\n\t\t\t\t\tposition.set( 0, Math.random() + 1, 0 );\n\t\t\t\t\tphysics.setMeshPosition( boxes, position, index );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tindex = Math.floor( Math.random() * spheres.count );\n\n\t\t\t\t\tposition.set( 0, Math.random() + 1, 0 );\n\t\t\t\t\tphysics.setMeshPosition( spheres, position, index );\n\n\t\t\t\t}, 1000 / 60 );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - jolt instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - rapier3d basic"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - rapier3d basic:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\t\t\timport { RapierHelper } from 'three/addons/helpers/RapierHelper.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats, controls;\n\t\t\tlet physics, physicsHelper;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 3, 10 );\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0x555555, 0xFFFFFF );\n\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 4 );\n\n\t\t\t\tlight.position.set( 0, 12.5, 12.5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.radius = 3;\n\t\t\t\tlight.shadow.blurSamples = 8;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\n\t\t\t\tconst size = 10;\n\t\t\t\tlight.shadow.camera.left = - size;\n\t\t\t\tlight.shadow.camera.bottom = - size;\n\t\t\t\tlight.shadow.camera.right = size;\n\t\t\t\tlight.shadow.camera.top = size;\n\t\t\t\tlight.shadow.camera.near = 1;\n\t\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.target = new THREE.Vector3( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 10, 0.5, 10 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xFFFFFF } );\n\n\t\t\t\tconst floor = new THREE.Mesh( geometry, material );\n\t\t\t\tfloor.receiveShadow = true;\n\n\t\t\t\tfloor.position.y = - 0.25;\n\t\t\t\tfloor.userData.physics = { mass: 0 };\n\n\t\t\t\tscene.add( floor );\n\n\t\t\t\tnew THREE.TextureLoader().load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( 20, 20 );\n\t\t\t\t\tfloor.material.map = texture;\n\t\t\t\t\tfloor.material.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tinitPhysics();\n\n\t\t\t\tonWindowResize();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tasync function initPhysics() {\n\n\t\t\t\t//Initialize physics engine using the script in the jsm/physics folder\n\t\t\t\tphysics = await RapierPhysics();\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t\taddBody( );\n\n\t\t\t\t//Optionally display collider outlines\n\t\t\t\tphysicsHelper = new RapierHelper( physics.world );\n\t\t\t\tscene.add( physicsHelper );\n\n\t\t\t\tsetInterval( addBody, 1000 );\n\n\t\t\t}\n\n\t\t\tfunction addBody( ) {\n\n\t\t\t\tconst geometry = ( Math.random() > 0.5 ) ? new THREE.SphereGeometry( 0.5 ) : new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: Math.floor( Math.random() * 0xFFFFFF ) } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\n\t\t\t\tmesh.position.set( Math.random() * 2 - 1, Math.random() * 3 + 6, Math.random() * 2 - 1 );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//parameter 2 - mass, parameter 3 - restitution ( how bouncy )\n\t\t\t\tphysics.addMesh( mesh, 1, 0.5 );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize( ) {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tfor ( const object of scene.children ) {\n\n\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\tif ( object.position.y < - 10 ) {\n\n\t\t\t\t\t\t\tscene.remove( object );\n\t\t\t\t\t\t\tphysics.removeMesh( object );\n\n\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( physicsHelper ) physicsHelper.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - rapier basic"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - rapier3d instancing"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - rapier3d instancing:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet physics, position;\n\n\t\t\tlet boxes, spheres;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tphysics = await RapierPhysics();\n\t\t\t\tposition = new THREE.Vector3();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( - 1, 1.5, 2 );\n\t\t\t\tcamera.lookAt( 0, 0.5, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0x666666 );\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight();\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 5, 5, 5 );\n\t\t\t\tdirLight.castShadow = true;\n\t\t\t\tdirLight.shadow.camera.zoom = 2;\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst shadowPlane = new THREE.Mesh(\n\t\t\t\t\tnew THREE.PlaneGeometry( 10, 10 ),\n\t\t\t\t\tnew THREE.ShadowMaterial( {\n\t\t\t\t\t\tcolor: 0x444444\n\t\t\t\t\t} ),\n\t\t\t\t);\n\t\t\t\tshadowPlane.rotation.x = - Math.PI / 2;\n\t\t\t\tshadowPlane.receiveShadow = true;\n\t\t\t\tscene.add( shadowPlane );\n\n\t\t\t\tconst floorCollider = new THREE.Mesh(\n\t\t\t\t\tnew THREE.BoxGeometry( 10, 5, 10 ),\n\t\t\t\t\tnew THREE.MeshBasicMaterial( { color: 0x666666 } )\n\t\t\t\t);\n\t\t\t\tfloorCollider.position.y = - 2.5;\n\t\t\t\tfloorCollider.userData.physics = { mass: 0 };\n\t\t\t\tfloorCollider.visible = false;\n\t\t\t\tscene.add( floorCollider );\n\n\t\t\t\t//\n\n\t\t\t\tconst material = new THREE.MeshLambertMaterial();\n\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\t// Boxes\n\n\t\t\t\tconst geometryBox = new THREE.BoxGeometry( 0.075, 0.075, 0.075 );\n\t\t\t\tboxes = new THREE.InstancedMesh( geometryBox, material, 400 );\n\t\t\t\tboxes.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tboxes.castShadow = true;\n\t\t\t\tboxes.receiveShadow = true;\n\t\t\t\tboxes.userData.physics = { mass: 1 };\n\t\t\t\tscene.add( boxes );\n\n\t\t\t\tfor ( let i = 0; i < boxes.count; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );\n\t\t\t\t\tboxes.setMatrixAt( i, matrix );\n\t\t\t\t\tboxes.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Spheres\n\n\t\t\t\tconst geometrySphere = new THREE.IcosahedronGeometry( 0.05, 4 );\n\t\t\t\tspheres = new THREE.InstancedMesh( geometrySphere, material, 400 );\n\t\t\t\tspheres.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame\n\t\t\t\tspheres.castShadow = true;\n\t\t\t\tspheres.receiveShadow = true;\n\t\t\t\tspheres.userData.physics = { mass: 1 };\n\t\t\t\tscene.add( spheres );\n\n\t\t\t\tfor ( let i = 0; i < spheres.count; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );\n\t\t\t\t\tspheres.setMatrixAt( i, matrix );\n\t\t\t\t\tspheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n\n\t\t\t\t}\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.y = 0.5;\n\t\t\t\tcontrols.update();\n\n\t\t\t\tsetInterval( () => {\n\n\t\t\t\t\tlet index = Math.floor( Math.random() * boxes.count );\n\n\t\t\t\t\tposition.set( 0, Math.random() + 1, 0 );\n\t\t\t\t\tphysics.setMeshPosition( boxes, position, index );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tindex = Math.floor( Math.random() * spheres.count );\n\n\t\t\t\t\tposition.set( 0, Math.random() + 1, 0 );\n\t\t\t\t\tphysics.setMeshPosition( spheres, position, index );\n\n\t\t\t\t}, 1000 / 60 );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - rapier instancing"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - rapier3d joints"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - rapier3d joints:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\t\t\timport { RapierHelper } from 'three/addons/helpers/RapierHelper.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet physics, pivot, physicsHelper;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 3, 10 );\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0x555555, 0xFFFFFF );\n\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 4 );\n\n\t\t\t\tlight.position.set( 0, 12.5, 12.5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.radius = 3;\n\t\t\t\tlight.shadow.blurSamples = 8;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\n\t\t\t\tconst size = 10;\n\t\t\t\tlight.shadow.camera.left = - size;\n\t\t\t\tlight.shadow.camera.bottom = - size;\n\t\t\t\tlight.shadow.camera.right = size;\n\t\t\t\tlight.shadow.camera.top = size;\n\t\t\t\tlight.shadow.camera.near = 1;\n\t\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\t\tscene.add( light );\n\t\t\t\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target = new THREE.Vector3( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//Create pivot point\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.5 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xFF0000 } );\n\t\t\t\n\t\t\t\tpivot = new THREE.Mesh( geometry, material );\n\n\t\t\t\tpivot.position.y = 6;\n\t\t\t\tpivot.userData.physics = { mass: 0 };\n\n\t\t\t\tscene.add( pivot );\n\t\t\t\n\t\t\t\tinitPhysics();\n\t\t\t\n\t\t\t\tonWindowResize();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tasync function initPhysics() {\n\n\t\t\t\t//Initialize physics engine using the script in the jsm/physics folder\n\t\t\t\tphysics = await RapierPhysics();\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t\t//Optionally display collider outlines\n\t\t\t\tphysicsHelper = new RapierHelper( physics.world );\n\t\t\t\tscene.add( physicsHelper );\n\n\t\t\t\tconst link1 = addLink( pivot, 0 );\n\t\t\t\tconst link2 = addLink( link1, 2 );\n\t\t\t\taddLink( link2, 4 );\n\n\t\t\t}\n\n\t\t\t//link - the mesh that the new link will be attached to\n\t\t\t//x    - used to position the new link\n\t\t\tfunction addLink( link, x ) {\n\n\t\t\t\tconst geometry = new THREE.CapsuleGeometry( 0.25, 1.8 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xCCCC00 } );\n\t\t\t\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.rotateZ( Math.PI * 0.5 );\n\n\t\t\t\tmesh.position.set( x + 0.9, 5.8, 0 );\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tphysics.addMesh( mesh, 1, 0.5 );\n\n\t\t\t\tconst jointParams = physics.RAPIER.JointData.spherical(\n\t\t\t\t\t( link == pivot ) ? new physics.RAPIER.Vector3( 0, - 0.5, 0 ) : new physics.RAPIER.Vector3( 0, - 1.15, 0 ), // Joint position in world space\n\t\t\t\t\tnew physics.RAPIER.Vector3( 0, 1.15, 0 ) // Corresponding attachment on sphere\n\t\t\t\t);\n\t\t\t\tconst body1 = link.userData.physics.body;\n\t\t\t\tconst body2 = mesh.userData.physics.body;\n\t\t\t\tbody2.setAngularDamping( 10.0 );\n\n\t\t\t\tphysics.world.createImpulseJoint( jointParams, body1, body2, true );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize( ) {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( physicsHelper ) physicsHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - rapier joints"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - rapier3d character controller"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - rapier3d character controller:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\t\t\timport { RapierHelper } from 'three/addons/helpers/RapierHelper.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet physics, characterController, physicsHelper;\n\t\t\tlet player, movement;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 2, 5, 15 );\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0x555555, 0xFFFFFF );\n\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\n\t\t\t\tlight.position.set( 0, 12.5, 12.5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.radius = 3;\n\t\t\t\tlight.shadow.blurSamples = 8;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\n\t\t\t\tconst size = 10;\n\t\t\t\tlight.shadow.camera.left = - size;\n\t\t\t\tlight.shadow.camera.bottom = - size;\n\t\t\t\tlight.shadow.camera.right = size;\n\t\t\t\tlight.shadow.camera.top = size;\n\t\t\t\tlight.shadow.camera.near = 1;\n\t\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target = new THREE.Vector3( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 20, 0.5, 20 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xFFFFFF } );\n\n\t\t\t\tconst ground = new THREE.Mesh( geometry, material );\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tground.position.y = - 0.25;\n\t\t\t\tground.userData.physics = { mass: 0 };\n\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tnew THREE.TextureLoader().load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( 20, 20 );\n\t\t\t\t\tground.material.map = texture;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tfor ( let i = 0; i < 10; i ++ ) addBody( Math.random() > 0.7 );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\tinitPhysics();\n\n\t\t\t\tonWindowResize();\n\n\t\t\t\t// Movement input\n\t\t\t\tmovement = { forward: 0, right: 0 };\n\n\t\t\t\twindow.addEventListener( 'keydown', ( event ) => {\n\n\t\t\t\t\tif ( event.key === 'w' || event.key === 'ArrowUp' ) movement.forward = 1;\n\t\t\t\t\tif ( event.key === 's' || event.key === 'ArrowDown' ) movement.forward = - 1;\n\t\t\t\t\tif ( event.key === 'a' || event.key === 'ArrowLeft' ) movement.right = - 1;\n\t\t\t\t\tif ( event.key === 'd' || event.key === 'ArrowRight' ) movement.right = 1;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'keyup', ( event ) => {\n\t\t\t\n\t\t\t\t\tif ( event.key === 'w' || event.key === 's' || event.key === 'ArrowUp' || event.key === 'ArrowDown' ) movement.forward = 0;\n\t\t\t\t\tif ( event.key === 'a' || event.key === 'd' || event.key === 'ArrowLeft' || event.key === 'ArrowRight' ) movement.right = 0;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tfunction random( min, max ) {\n\n\t\t\t\treturn Math.random() * ( max - min ) + min;\n\n\t\t\t}\n\n\t\t\tasync function initPhysics() {\n\n\t\t\t\t//Initialize physics engine using the script in the jsm/physics folder\n\t\t\t\tphysics = await RapierPhysics();\n\n\t\t\t\t//Optionally display collider outlines\n\t\t\t\tphysicsHelper = new RapierHelper( physics.world );\n\t\t\t\tscene.add( physicsHelper );\n\n\t\t\t\tphysics.addScene( scene );\n\n\t\t\t\taddCharacterController( );\n\n\t\t\t}\n\n\t\t\tfunction addCharacterController() {\n\n\t\t\t\t// Character Capsule\n\t\t\t\tconst geometry = new THREE.CapsuleGeometry( 0.3, 1, 8, 8 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0x0000ff } );\n\t\t\t\tplayer = new THREE.Mesh( geometry, material );\n\t\t\t\tplayer.castShadow = true;\n\t\t\t\tplayer.position.set( 0, 0.8, 0 );\n\t\t\t\tscene.add( player );\n\n\t\t\t\t// Rapier Character Controller\n\t\t\t\tcharacterController = physics.world.createCharacterController( 0.01 );\n\t\t\t\tcharacterController.setApplyImpulsesToDynamicBodies( true );\n\t\t\t\tcharacterController.setCharacterMass( 3 );\n\t\t\t\tconst colliderDesc = physics.RAPIER.ColliderDesc.capsule( 0.5, 0.3 ).setTranslation( 0, 0.8, 0 );\n\t\t\t\tplayer.userData.collider = physics.world.createCollider( colliderDesc );\n\n\t\t\t}\n\n\t\t\tfunction addBody( fixed = true ) {\n\t\t\t\n\t\t\t\tconst geometry = ( fixed ) ? new THREE.BoxGeometry( 1, 1, 1 ) : new THREE.SphereGeometry( 0.25 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: fixed ? 0xFF0000 : 0x00FF00 } );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\n\t\t\t\tmesh.position.set( random( - 10, 10 ), 0.5, random( - 10, 10 ) );\n\n\t\t\t\tmesh.userData.physics = { mass: fixed ? 0 : 0.5, restitution: fixed ? 0 : 0.3 };\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize( ) {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( physicsHelper ) physicsHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tif ( physics && characterController ) {\n\n\t\t\t\t\tconst deltaTime = 1 / 60;\n\n\t\t\t\t\t// Character movement\n\t\t\t\t\tconst speed = 2.5 * deltaTime;\n\t\t\t\t\tconst moveVector = new physics.RAPIER.Vector3( movement.right * speed, 0, - movement.forward * speed );\n\n\t\t\t\t\tcharacterController.computeColliderMovement( player.userData.collider, moveVector );\n\n\t\t\t\t\t// Read the result.\n\t\t\t\t\tconst translation = characterController.computedMovement();\n\t\t\t\t\tconst position = player.userData.collider.translation();\n\n\t\t\t\t\tposition.x += translation.x;\n\t\t\t\t\tposition.y += translation.y;\n\t\t\t\t\tposition.z += translation.z;\n\n\t\t\t\t\tplayer.userData.collider.setTranslation( position );\n\n\t\t\t\t\t// Sync Three.js mesh with Rapier collider\n\t\t\t\t\tplayer.position.set( position.x, position.y, position.z );\n\n\t\t\t\t}\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - rapier character controller WASD or Arrow keys to move"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates physics - rapier3d vehicle controller"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js physics - rapier3d vehicle controller:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\t\t\timport { RapierHelper } from 'three/addons/helpers/RapierHelper.js';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet camera, scene, renderer, stats;\n\t\t\tlet physics, physicsHelper, controls;\n\t\t\tlet car, chassis, wheels, movement, vehicleController;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 0, 4, 10 );\n\n\t\t\t\tconst ambient = new THREE.HemisphereLight( 0x555555, 0xFFFFFF );\n\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 4 );\n\n\t\t\t\tlight.position.set( 0, 12.5, 12.5 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.radius = 3;\n\t\t\t\tlight.shadow.blurSamples = 8;\n\t\t\t\tlight.shadow.mapSize.width = 2048;\n\t\t\t\tlight.shadow.mapSize.height = 2048;\n\n\t\t\t\tconst size = 40;\n\t\t\t\tlight.shadow.camera.left = - size;\n\t\t\t\tlight.shadow.camera.bottom = - size;\n\t\t\t\tlight.shadow.camera.right = size;\n\t\t\t\tlight.shadow.camera.top = size;\n\t\t\t\tlight.shadow.camera.near = 1;\n\t\t\t\tlight.shadow.camera.far = 50;\n\n\t\t\t\tscene.add( light );\n\t\t\t\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target = new THREE.Vector3( 0, 2, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 100, 0.5, 100 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xFFFFFF } );\n\t\t\t\n\t\t\t\tconst ground = new THREE.Mesh( geometry, material );\n\t\t\t\tground.receiveShadow = true;\n\n\t\t\t\tground.position.set( 0, - 0.25, - 20 );\n\t\t\t\tground.userData.physics = { mass: 0 };\n\n  \t\t\t\tscene.add( ground );\n\n\t\t\t\tnew THREE.TextureLoader().load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( 80, 80 );\n\t\t\t\t\tground.material.map = texture;\n\t\t\t\t\tground.material.needsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\t\t\t\n\t\t\t\tinitPhysics();\n\t\t\t\n\t\t\t\tonWindowResize();\n\n\t\t\t\t// Movement input\n\t\t\t\tmovement = {\n\t\t\t\t\tforward: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\tbrake: 0,\n\t\t\t\t\treset: false,\n\t\t\t\t\taccelerateForce: { value: 0, min: - 30, max: 30, step: 1 },\n\t\t\t\t\tbrakeForce: { value: 0, min: 0, max: 1, step: 0.05 }\n\t\t\t\t};\n\n\t\t\t\twindow.addEventListener( 'keydown', ( event ) => {\n\n\t\t\t\t\t//console.log( event.key );\n\t\t\t\t\tif ( event.key === 'w' || event.key === 'ArrowUp' ) movement.forward = - 1;\n\t\t\t\t\tif ( event.key === 's' || event.key === 'ArrowDown' ) movement.forward = 1;\n\t\t\t\t\tif ( event.key === 'a' || event.key === 'ArrowLeft' ) movement.right = 1;\n\t\t\t\t\tif ( event.key === 'd' || event.key === 'ArrowRight' ) movement.right = - 1;\n\t\t\t\t\tif ( event.key === 'r' ) movement.reset = true;\n\t\t\t\t\tif ( event.key === ' ' ) movement.brake = 1;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'keyup', ( event ) => {\n\n\t\t\t\t\tif ( event.key === 'w' || event.key === 's' || event.key === 'ArrowUp' || event.key === 'ArrowDown' ) movement.forward = 0;\n\t\t\t\t\tif ( event.key === 'a' || event.key === 'd' || event.key === 'ArrowLeft' || event.key === 'ArrowRight' ) movement.right = 0;\n\t\t\t\t\tif ( event.key === 'r' ) movement.reset = false;\n\t\t\t\t\tif ( event.key === ' ' ) movement.brake = 0;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t}\n\n\t\t\tasync function initPhysics() {\n\n\t\t\t\t//Initialize physics engine using the script in the jsm/physics folder\n\t\t\t\tphysics = await RapierPhysics();\n\n\t\t\t\t//Optionally display collider outlines\n\t\t\t\tphysicsHelper = new RapierHelper( physics.world );\n\t\t\t\tscene.add( physicsHelper );\n\n\t\t\t\tphysics.addScene( scene );\n\n  \t\t\t\tcreateCar();\n\n\t\t\t}\n\n\t\t\tfunction createCar( ) {\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 2, 1, 4 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0xFF0000 } );\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tscene.add( mesh );\n\t\t\t\tcar = mesh;\n\n\t\t\t\tmesh.position.y = 1;\n\n\t\t\t\tphysics.addMesh( mesh, 10, 0.8 ); // addMesh places the RigidBody in the mesh.userData.physics object\n\t\t\t\tchassis = mesh.userData.physics.body;\n\n\t\t\t\tvehicleController = physics.world.createVehicleController( chassis );\n\n\t\t\t\twheels = [];\n\n\t\t\t\taddWheel( 0, { x: - 1, y: 0, z: - 1.5 }, mesh );\n\t\t\t\taddWheel( 1, { x: 1, y: 0, z: - 1.5 }, mesh );\n\t\t\t\taddWheel( 2, { x: - 1, y: 0, z: 1.5 }, mesh );\n\t\t\t\taddWheel( 3, { x: 1, y: 0, z: 1.5 }, mesh );\n\n\t\t\t\tvehicleController.setWheelSteering( 0, Math.PI / 4 );\n\t\t\t\tvehicleController.setWheelSteering( 1, Math.PI / 4 );\n\n\t\t\t}\n\n\t\t\tfunction addWheel( index, pos, carMesh ) {\n\n\t\t\t\t// Define wheel properties\n\t\t\t\tconst wheelRadius = 0.3;\n\t\t\t\tconst wheelWidth = 0.4;\n\t\t\t\tconst suspensionRestLength = 0.8;\n\t\t\t\tconst wheelPosition = pos; // Position relative to chassis\n\t\t\t\tconst wheelDirection = { x: 0.0, y: - 1.0, z: 0.0 }; // Downward direction\n\t\t\t\tconst wheelAxle = { x: - 1.0, y: 0.0, z: 0.0 }; // Axle direction\n\n\t\t\t\t// Add the wheel to the vehicle controller\n\t\t\t\tvehicleController.addWheel(\n\t\t\t\t\twheelPosition,\n\t\t\t\t\twheelDirection,\n\t\t\t\t\twheelAxle,\n\t\t\t\t\tsuspensionRestLength,\n\t\t\t\t\twheelRadius\n\t\t\t\t);\n\n\t\t\t\t// Set suspension stiffness for wheel\n\t\t\t\tvehicleController.setWheelSuspensionStiffness( index, 24.0 );\n\n\t\t\t\t// Set wheel friction\n\t\t\t\tvehicleController.setWheelFrictionSlip( index, 1000.0 );\n\n\t\t\t\t// Enable steering for the wheel\n\t\t\t\tvehicleController.setWheelSteering( index, pos.z < 0 );\n\n\t\t\t\t// Create a wheel mesh\n\t\t\t\tconst geometry = new THREE.CylinderGeometry( wheelRadius, wheelRadius, wheelWidth, 16 );\n\t\t\t\tgeometry.rotateZ( Math.PI * 0.5 );\n\t\t\t\tconst material = new THREE.MeshStandardMaterial( { color: 0x000000 } );\n\t\t\t\tconst wheel = new THREE.Mesh( geometry, material );\n\n\t\t\t\twheel.castShadow = true;\n\n\t\t\t\twheel.position.copy( pos );\n\n\t\t\t\twheels.push( wheel );\n\t\t\t\tcarMesh.add( wheel );\n\n\t\t\t}\n\n\t\t\tfunction updateWheels() {\n\n\t\t\t\tif ( vehicleController === undefined ) return;\n\n\t\t\t\tconst wheelSteeringQuat = new THREE.Quaternion();\n\t\t\t\tconst wheelRotationQuat = new THREE.Quaternion();\n\t\t\t\tconst up = new THREE.Vector3( 0, 1, 0 );\n\n\t\t\t\t//const chassisPosition = chassis.translation();\n\n\t\t\t\twheels.forEach( ( wheel, index ) => {\n\n\t\t\t\t\tconst wheelAxleCs = vehicleController.wheelAxleCs( index );\n\t\t\t\t\tconst connection = vehicleController.wheelChassisConnectionPointCs( index ).y || 0;\n\t\t\t\t\tconst suspension = vehicleController.wheelSuspensionLength( index ) || 0;\n\t\t\t\t\tconst steering = vehicleController.wheelSteering( index ) || 0;\n\t\t\t\t\tconst rotationRad = vehicleController.wheelRotation( index ) || 0;\n\n\t\t\t\t\twheel.position.y = connection - suspension;\n\n\t\t\t\t\twheelSteeringQuat.setFromAxisAngle( up, steering );\n\t\t\t\t\twheelRotationQuat.setFromAxisAngle( wheelAxleCs, rotationRad );\n\n\t\t\t\t\twheel.quaternion.multiplyQuaternions( wheelSteeringQuat, wheelRotationQuat );\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction updateCarControl() {\n\n\t\t\t\tif ( movement.reset ) {\n\n\t\t\t\t\tchassis.setTranslation( new physics.RAPIER.Vector3( 0, 1, 0 ), true );\n\t\t\t\t\tchassis.setRotation( new physics.RAPIER.Quaternion( 0, 0, 0, 1 ), true );\n\t\t\t\t\tchassis.setLinvel( new physics.RAPIER.Vector3( 0, 0, 0 ), true );\n\t\t\t\t\tchassis.setAngvel( new physics.RAPIER.Vector3( 0, 0, 0 ), true );\n\n\t\t\t\t\tmovement.accelerateForce.value = 0;\n\t\t\t\t\tmovement.brakeForce.value = 0;\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tlet accelerateForce = 0;\n\n\t\t\t\tif ( movement.forward < 0 ) {\n\n\t\t\t\t\t//if (movement.accelerateForce.value === 0) chassis.wakeUp();\n\t\t\t\t\taccelerateForce = movement.accelerateForce.value - movement.accelerateForce.step;\n\t\t\t\t\tif ( accelerateForce < movement.accelerateForce.min ) accelerateForce = movement.accelerateForce.min;\n\t\t\t\n\t\t\t\t} else if ( movement.forward > 0 ) {\n\n\t\t\t\t\t//if (movement.accelerateForce.value === 0) chassis.wakeUp();\n\t\t\t\t\taccelerateForce = movement.accelerateForce.value + movement.accelerateForce.step;\n\t\t\t\n\t\t\t\t\tif ( accelerateForce > movement.accelerateForce.max ) accelerateForce = movement.accelerateForce.max;\n\t\t\t\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( chassis.isSleeping() ) chassis.wakeUp();\n\n\t\t\t\t}\n\n\t\t\t\tmovement.accelerateForce.value = accelerateForce;\n\n\t\t\t\t//console.log(accelerateForce);\n\n\t\t\t\tlet brakeForce = 0;\n\n\t\t\t\tif ( movement.brake > 0 ) {\n\t\t\t\n\t\t\t\t\tbrakeForce = movement.brakeForce.value + movement.brakeForce.step;\n\t\t\t\t\tif ( brakeForce > movement.brakeForce.max ) brakeForce = movement.brakeForce.max;\n\n\t\t\t\t}\n\n\t\t\t\tmovement.brakeForce.value = brakeForce;\n\n\t\t\t\tconst engineForce = accelerateForce;\n\n\t\t\t\tvehicleController.setWheelEngineForce( 0, engineForce );\n\t\t\t\tvehicleController.setWheelEngineForce( 1, engineForce );\n\n\t\t\t\tconst currentSteering = vehicleController.wheelSteering( 0 );\n\t\t\t\tconst steerDirection = movement.right;\n\t\t\t\tconst steerAngle = Math.PI / 4;\n\n\t\t\t\tconst steering = THREE.MathUtils.lerp( currentSteering, steerAngle * steerDirection, 0.25 );\n\n\t\t\t\tvehicleController.setWheelSteering( 0, steering );\n\t\t\t\tvehicleController.setWheelSteering( 1, steering );\n\n\t\t\t\tconst wheelBrake = movement.brake * brakeForce;\n\t\t\t\tvehicleController.setWheelBrake( 0, wheelBrake );\n\t\t\t\tvehicleController.setWheelBrake( 1, wheelBrake );\n\t\t\t\tvehicleController.setWheelBrake( 2, wheelBrake );\n\t\t\t\tvehicleController.setWheelBrake( 3, wheelBrake );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize( ) {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tif ( vehicleController ) {\n\n\t\t\t\t\tupdateCarControl();\n\t\t\t\t\tvehicleController.updateVehicle( 1 / 60 );\n\t\t\t\t\tupdateWheels();\n\n\t\t\t\t}\n\n\t\t\t\tif ( controls && car ) {\n\n\t\t\t\t\tcontrols.target.copy( car.position );\n\t\t\t\t\tcontrols.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( physicsHelper ) physicsHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js physics - rapier vehicle controller WASD or Arrow keys to move Space to brake R to reset"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js physics example that demonstrates Rapier.js terrain heightfield demo"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for Rapier.js terrain heightfield demo:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n\n\t\t\t// Heightfield parameters\n\t\t\tconst terrainWidthExtents = 100;\n\t\t\tconst terrainDepthExtents = 100;\n\t\t\tconst terrainWidth = 128;\n\t\t\tconst terrainDepth = 128;\n\t\t\tconst terrainHalfWidth = terrainWidth / 2;\n\t\t\tconst terrainHalfDepth = terrainDepth / 2;\n\t\t\tconst terrainMaxHeight = 8;\n\t\t\tconst terrainMinHeight = - 2;\n\n\t\t\t// Graphics variables\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet terrainMesh;\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\t// Physics variables\n\t\t\tlet physics;\n\t\t\tconst dynamicObjects = [];\n\t\t\tlet heightData = null;\n\n\t\t\tlet time = 0;\n\t\t\tconst objectTimePeriod = 3;\n\t\t\tlet timeNextSpawn = time + objectTimePeriod;\n\t\t\tconst maxNumObjects = 30;\n\n\t\t\tinit();\n\n\t\t\tasync function init() {\n\n\t\t\t\theightData = generateHeight( terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight );\n\t\t\t\tinitGraphics();\n\t\t\t\tawait initPhysics();\n\t\t\t\t// Start animation loop only after physics is initialized\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction initGraphics() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\t// Remove setAnimationLoop from here since we'll start it after physics init\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\t\tstats.domElement.style.top = '0px';\n\t\t\t\tcontainer.appendChild( stats.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xbfd1e5 );\n\n\t\t\t\tcamera.position.y = heightData[ terrainHalfWidth + terrainHalfDepth * terrainWidth ] * ( terrainMaxHeight - terrainMinHeight ) + 5;\n\t\t\t\tcamera.position.z = terrainDepthExtents / 2;\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableZoom = false;\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry( terrainWidthExtents, terrainDepthExtents, terrainWidth - 1, terrainDepth - 1 );\n\t\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\tconst vertices = geometry.attributes.position.array;\n\n\t\t\t\tfor ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {\n\n\t\t\t\t\tvertices[ j + 1 ] = heightData[ i ];\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\tconst groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );\n\t\t\t\tterrainMesh = new THREE.Mesh( geometry, groundMaterial );\n\t\t\t\tterrainMesh.receiveShadow = true;\n\t\t\t\tterrainMesh.castShadow = true;\n\t\t\t\tscene.add( terrainMesh );\n\n\t\t\t\tconst textureLoader = new THREE.TextureLoader();\n\t\t\t\ttextureLoader.load( 'textures/grid.png', function ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\ttexture.repeat.set( terrainWidth - 1, terrainDepth - 1 );\n\t\t\t\t\tgroundMaterial.map = texture;\n\t\t\t\t\tgroundMaterial.needsUpdate = true;\n\t\t\t\n\t\t\t\t} );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xbbbbbb );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tlight.position.set( 100, 100, 50 );\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tconst dLight = 200;\n\t\t\t\tconst sLight = dLight * 0.25;\n\t\t\t\tlight.shadow.camera.left = - sLight;\n\t\t\t\tlight.shadow.camera.right = sLight;\n\t\t\t\tlight.shadow.camera.top = sLight;\n\t\t\t\tlight.shadow.camera.bottom = - sLight;\n\t\t\t\tlight.shadow.camera.near = dLight / 30;\n\t\t\t\tlight.shadow.camera.far = dLight;\n\t\t\t\tlight.shadow.mapSize.x = 1024 * 2;\n\t\t\t\tlight.shadow.mapSize.y = 1024 * 2;\n\t\t\t\tscene.add( light );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tasync function initPhysics() {\n\n\t\t\t\tphysics = await RapierPhysics();\n\n\t\t\t\t// Create the terrain body using RapierPhysics module\n\t\t\t\tphysics.addHeightfield( terrainMesh, terrainWidth - 1, terrainDepth - 1, heightData, { x: terrainWidthExtents, y: 1.0, z: terrainDepthExtents } );\n\n\t\t\t\t// Continue with adding other dynamic objects as needed\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction generateHeight( width, depth, minHeight, maxHeight ) {\n\n\t\t\t\tconst size = width * depth;\n\t\t\t\tconst data = new Float32Array( size );\n\t\t\t\tconst hRange = maxHeight - minHeight;\n\t\t\t\tconst w2 = width / 2;\n\t\t\t\tconst d2 = depth / 2;\n\t\t\t\tconst phaseMult = 12;\n\t\t\t\tlet p = 0;\n\t\t\t\n\t\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\t\tfor ( let i = 0; i < width; i ++ ) {\n\n\t\t\t\t\t\tconst radius = Math.sqrt( Math.pow( ( i - w2 ) / w2, 2.0 ) + Math.pow( ( j - d2 ) / d2, 2.0 ) );\n\t\t\t\t\t\tconst height = ( Math.sin( radius * phaseMult ) + 1 ) * 0.5 * hRange + minHeight;\n\t\t\t\t\t\tdata[ p ] = height;\n\t\t\t\t\t\tp ++;\n\t\t\t\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction generateObject() {\n\n\t\t\t\tconst numTypes = 3; // cones not working\n\t\t\t\tconst objectType = Math.ceil( Math.random() * numTypes );\n\t\t\t\tlet threeObject = null;\n\t\t\t\tconst objectSize = 3;\n\t\t\t\tlet radius, height;\n\n\t\t\t\tswitch ( objectType ) {\n\n\t\t\t\t\tcase 1: // Sphere\n\t\t\t\t\t\tradius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.SphereGeometry( radius, 20, 20 ), createObjectMaterial() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: // Box\n\t\t\t\t\t\tconst sx = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tconst sy = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tconst sz = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), createObjectMaterial() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: // Cylinder\n\t\t\t\t\t\tradius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\theight = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.CylinderGeometry( radius, radius, height, 20, 1 ), createObjectMaterial() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: // Cone\n\t\t\t\t\t\tradius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\theight = 2 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.ConeGeometry( radius, height, 20, 2 ), createObjectMaterial() );\n\t\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// Position objects higher and with more randomization to prevent clustering\n\t\t\t\tthreeObject.position.set(\n\t\t\t\t\t( Math.random() - 0.5 ) * terrainWidth * 0.6,\n\t\t\t\t\tterrainMaxHeight + objectSize + 15 + Math.random() * 5, // Even higher with randomization\n\t\t\t\t\t( Math.random() - 0.5 ) * terrainDepth * 0.6\n\t\t\t\t);\n\n\t\t\t\tconst mass = objectSize * 5;\n\t\t\t\tconst restitution = 0.3; // Add some bounciness\n\n\t\t\t\t// Add to scene first\n\t\t\t\tscene.add( threeObject );\n\n\t\t\t\t// Add physics to the object\n\t\t\t\tphysics.addMesh( threeObject, mass, restitution );\n\n\t\t\t\t// Store the object for later reference\n\t\t\t\tdynamicObjects.push( threeObject );\n\n\t\t\t\t// Force a small delay before adding the next object\n\t\t\t\ttimeNextSpawn = time + 0.5;\n\n\t\t\t\tthreeObject.receiveShadow = true;\n\t\t\t\tthreeObject.castShadow = true;\n\n\t\t\t}\n\n\t\t\tfunction createObjectMaterial() {\n\n\t\t\t\tconst c = Math.floor( Math.random() * ( 1 << 24 ) );\n\t\t\t\treturn new THREE.MeshPhongMaterial( { color: c } );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst deltaTime = clock.getDelta();\n\n\t\t\t\t// Generate new objects with a delay between them\n\t\t\t\tif ( dynamicObjects.length < maxNumObjects && time > timeNextSpawn ) {\n\n\t\t\t\t\t// Generate object directly in this frame\n\t\t\t\t\tgenerateObject();\n\t\t\t\t\t// timeNextSpawn is now set in generateObject()\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// Clean up objects that have fallen off the terrain\n\t\t\t\tfor ( let i = dynamicObjects.length - 1; i >= 0; i -- ) {\n\n\t\t\t\t\tconst obj = dynamicObjects[ i ];\n\t\t\t\t\tif ( obj.position.y < terrainMinHeight - 10 ) {\n\n\t\t\t\t\t\t// Remove from scene and physics world\n\t\t\t\t\t\tscene.remove( obj );\n\t\t\t\t\t\tdynamicObjects.splice( i, 1 );\n\t\t\t\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\n\t\t\t\tupdatePhysics();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\ttime += deltaTime;\n\t\t\t\n\t\t\t}\n\n\t\t\tfunction updatePhysics() {\n\n\t\t\t\t// Check for objects that might need help with physics\n\t\t\t\tfor ( let i = 0, il = dynamicObjects.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst objThree = dynamicObjects[ i ];\n\n\t\t\t\t\t// If object is not moving but should be (based on height), try to fix it\n\t\t\t\t\tif ( objThree.position.y > 1.0 ) {\n\n\t\t\t\t\t\t// Check if physics body exists\n\t\t\t\t\t\tif ( objThree.userData && objThree.userData.physics && objThree.userData.physics.body ) {\n\n\t\t\t\t\t\t\tconst body = objThree.userData.physics.body;\n\n\t\t\t\t\t\t\t// Make sure body is awake\n\t\t\t\t\t\t\tif ( typeof body.wakeUp === 'function' ) {\n\n\t\t\t\t\t\t\t\tbody.wakeUp();\n\t\t\t\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check velocity and apply impulse if needed\n\t\t\t\t\t\t\tif ( typeof body.linvel === 'function' ) {\n\n\t\t\t\t\t\t\t\tconst velocity = body.linvel();\n\t\t\t\t\t\t\t\tconst speed = Math.sqrt( velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z );\n\n\t\t\t\t\t\t\t\t// If object is very slow, give it a stronger impulse\n\t\t\t\t\t\t\t\tif ( speed < 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tbody.applyImpulse( { x: 0, y: - 2.0, z: 0 }, true );\n\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// If the object doesn't have a physics body but should, recreate it\n\t\t\t\t\t\t\tconst mass = 5; // Default mass\n\t\t\t\t\t\t\tconst restitution = 0.3; // Default restitution\n\n\t\t\t\t\t\t\t// Recreate physics for the object\n\t\t\t\t\t\t\tphysics.addMesh( objThree, mass, restitution );\n\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n```\n\nThis example Rapier.js physics terrain heightfield demo"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - animation - groups"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - groups:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet stats, clock;\n\t\t\tlet scene, camera, renderer, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 50, 50, 100 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\t// all objects of this animation group share a common animation state\n\n\t\t\t\tconst animationGroup = new THREE.AnimationObjectGroup();\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 5, 5, 5 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { transparent: true } );\n\n\t\t\t\t//\n\n\t\t\t\tfor ( let i = 0; i < 5; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 5; j ++ ) {\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tmesh.position.x = 32 - ( 16 * i );\n\t\t\t\t\t\tmesh.position.y = 0;\n\t\t\t\t\t\tmesh.position.z = 32 - ( 16 * j );\n\n\t\t\t\t\t\tscene.add( mesh );\n\t\t\t\t\t\tanimationGroup.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create some keyframe tracks\n\n\t\t\t\tconst xAxis = new THREE.Vector3( 1, 0, 0 );\n\t\t\t\tconst qInitial = new THREE.Quaternion().setFromAxisAngle( xAxis, 0 );\n\t\t\t\tconst qFinal = new THREE.Quaternion().setFromAxisAngle( xAxis, Math.PI );\n\t\t\t\tconst quaternionKF = new THREE.QuaternionKeyframeTrack( '.quaternion', [ 0, 1, 2 ], [ qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w, qInitial.x, qInitial.y, qInitial.z, qInitial.w ] );\n\n\t\t\t\tconst colorKF = new THREE.ColorKeyframeTrack( '.material.color', [ 0, 1, 2 ], [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], THREE.InterpolateDiscrete );\n\t\t\t\tconst opacityKF = new THREE.NumberKeyframeTrack( '.material.opacity', [ 0, 1, 2 ], [ 1, 0, 1 ] );\n\n\t\t\t\t// create clip\n\n\t\t\t\tconst clip = new THREE.AnimationClip( 'default', 3, [ quaternionKF, colorKF, opacityKF ] );\n\n\t\t\t\t// apply the animation group to the mixer as the root object\n\n\t\t\t\tmixer = new THREE.AnimationMixer( animationGroup );\n\n\t\t\t\tconst clipAction = mixer.clipAction( clip );\n\t\t\t\tclipAction.play();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - animation - groups"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - animation - basic"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - animation - basic:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\tlet stats, clock;\n\t\t\tlet scene, camera, renderer, mixer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 25, 25, 50 );\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\t//\n\n\t\t\t\tconst axesHelper = new THREE.AxesHelper( 10 );\n\t\t\t\tscene.add( axesHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry( 5, 5, 5 );\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: true } );\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// create a keyframe track (i.e. a timed sequence of keyframes) for each animated property\n\t\t\t\t// Note: the keyframe track type should correspond to the type of the property being animated\n\n\t\t\t\t// POSITION\n\t\t\t\tconst positionKF = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2 ], [ 0, 0, 0, 30, 0, 0, 0, 0, 0 ] );\n\n\t\t\t\t// SCALE\n\t\t\t\tconst scaleKF = new THREE.VectorKeyframeTrack( '.scale', [ 0, 1, 2 ], [ 1, 1, 1, 2, 2, 2, 1, 1, 1 ] );\n\n\t\t\t\t// ROTATION\n\t\t\t\t// Rotation should be performed using quaternions, using a THREE.QuaternionKeyframeTrack\n\t\t\t\t// Interpolating Euler angles (.rotation property) can be problematic and is currently not supported\n\n\t\t\t\t// set up rotation about x axis\n\t\t\t\tconst xAxis = new THREE.Vector3( 1, 0, 0 );\n\n\t\t\t\tconst qInitial = new THREE.Quaternion().setFromAxisAngle( xAxis, 0 );\n\t\t\t\tconst qFinal = new THREE.Quaternion().setFromAxisAngle( xAxis, Math.PI );\n\t\t\t\tconst quaternionKF = new THREE.QuaternionKeyframeTrack( '.quaternion', [ 0, 1, 2 ], [ qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w, qInitial.x, qInitial.y, qInitial.z, qInitial.w ] );\n\n\t\t\t\t// COLOR\n\t\t\t\tconst colorKF = new THREE.ColorKeyframeTrack( '.material.color', [ 0, 1, 2 ], [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], THREE.InterpolateDiscrete );\n\n\t\t\t\t// OPACITY\n\t\t\t\tconst opacityKF = new THREE.NumberKeyframeTrack( '.material.opacity', [ 0, 1, 2 ], [ 1, 0, 1 ] );\n\n\t\t\t\t// create an animation sequence with the tracks\n\t\t\t\t// If a negative time value is passed, the duration will be calculated from the times of the passed tracks array\n\t\t\t\tconst clip = new THREE.AnimationClip( 'Action', 3, [ scaleKF, positionKF, quaternionKF, colorKF, opacityKF ] );\n\n\t\t\t\t// setup the THREE.AnimationMixer\n\t\t\t\tmixer = new THREE.AnimationMixer( mesh );\n\n\t\t\t\t// create a ClipAction and set it to play\n\t\t\t\tconst clipAction = mixer.clipAction( clip );\n\t\t\t\tclipAction.play();\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tclock = new THREE.Clock();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tif ( mixer ) {\n\n\t\t\t\t\tmixer.update( delta );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n```\n\nThis example three.js webgl - animation - basic use"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - box selection"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - box selection:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { SelectionBox } from 'three/addons/interactive/SelectionBox.js';\n\t\t\timport { SelectionHelper } from 'three/addons/interactive/SelectionHelper.js';\n\n\t\t\tlet container, stats;\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 500 );\n\t\t\t\tcamera.position.z = 50;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa ) );\n\n\t\t\t\tconst light = new THREE.SpotLight( 0xffffff, 10000 );\n\t\t\t\tlight.position.set( 0, 25, 50 );\n\t\t\t\tlight.angle = Math.PI / 5;\n\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.near = 10;\n\t\t\t\tlight.shadow.camera.far = 100;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\t\tfor ( let i = 0; i < 200; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 80 - 40;\n\t\t\t\t\tobject.position.y = Math.random() * 45 - 25;\n\t\t\t\t\tobject.position.z = Math.random() * 45 - 25;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() * 2 + 1;\n\t\t\t\t\tobject.scale.y = Math.random() * 2 + 1;\n\t\t\t\t\tobject.scale.z = Math.random() * 2 + 1;\n\n\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\tobject.receiveShadow = true;\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFShadowMap;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tcontainer.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tconst selectionBox = new SelectionBox( camera, scene );\n\t\t\tconst helper = new SelectionHelper( renderer, 'selectBox' );\n\n\t\t\tdocument.addEventListener( 'pointerdown', function ( event ) {\n\n\t\t\t\tfor ( const item of selectionBox.collection ) {\n\n\t\t\t\t\titem.material.emissive.set( 0x000000 );\n\n\t\t\t\t}\n\n\t\t\t\tselectionBox.startPoint.set(\n\t\t\t\t\t( event.clientX / window.innerWidth ) * 2 - 1,\n\t\t\t\t\t- ( event.clientY / window.innerHeight ) * 2 + 1,\n\t\t\t\t\t0.5 );\n\n\t\t\t} );\n\n\t\t\tdocument.addEventListener( 'pointermove', function ( event ) {\n\n\t\t\t\tif ( helper.isDown ) {\n\n\t\t\t\t\tfor ( let i = 0; i < selectionBox.collection.length; i ++ ) {\n\n\t\t\t\t\t\tselectionBox.collection[ i ].material.emissive.set( 0x000000 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tselectionBox.endPoint.set(\n\t\t\t\t\t\t( event.clientX / window.innerWidth ) * 2 - 1,\n\t\t\t\t\t\t- ( event.clientY / window.innerHeight ) * 2 + 1,\n\t\t\t\t\t\t0.5 );\n\n\t\t\t\t\tconst allSelected = selectionBox.select();\n\n\t\t\t\t\tfor ( let i = 0; i < allSelected.length; i ++ ) {\n\n\t\t\t\t\t\tallSelected[ i ].material.emissive.set( 0xffffff );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tdocument.addEventListener( 'pointerup', function ( event ) {\n\n\t\t\t\tselectionBox.endPoint.set(\n\t\t\t\t\t( event.clientX / window.innerWidth ) * 2 - 1,\n\t\t\t\t\t- ( event.clientY / window.innerHeight ) * 2 + 1,\n\t\t\t\t\t0.5 );\n\n\t\t\t\tconst allSelected = selectionBox.select();\n\n\t\t\t\tfor ( let i = 0; i < allSelected.length; i ++ ) {\n\n\t\t\t\t\tallSelected[ i ].material.emissive.set( 0xffffff );\n\n\t\t\t\t}\n\n\t\t\t} );\n```\n\nThis example three.js webgl - box selection"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - arcball controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - arcball controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { ArcballControls } from 'three/addons/controls/ArcballControls.js';\n\n\t\t\timport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\tconst cameras = [ 'Orthographic', 'Perspective' ];\n\t\t\tconst cameraType = { type: 'Perspective' };\n\n\t\t\tconst perspectiveDistance = 2.5;\n\t\t\tconst orthographicDistance = 120;\n\t\t\tlet camera, controls, scene, renderer, gui;\n\t\t\tlet folderOptions, folderAnimations;\n\n\t\t\tconst arcballGui = {\n\n\t\t\t\tgizmoVisible: true,\n\n\t\t\t\tsetArcballControls: function () {\n\n\t\t\t\t\tcontrols = new ArcballControls( camera, renderer.domElement, scene );\n\t\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\t\tthis.gizmoVisible = true;\n\n\t\t\t\t\tthis.populateGui();\n\n\t\t\t\t},\n\n\t\t\t\tpopulateGui: function () {\n\n\t\t\t\t\tfolderOptions.add( controls, 'enabled' ).name( 'Enable controls' );\n\t\t\t\t\tfolderOptions.add( controls, 'enableFocus' ).name( 'Enable focus' );\n\t\t\t\t\tfolderOptions.add( controls, 'enableGrid' ).name( 'Enable Grid' );\n\t\t\t\t\tfolderOptions.add( controls, 'enableRotate' ).name( 'Enable rotate' );\n\t\t\t\t\tfolderOptions.add( controls, 'enablePan' ).name( 'Enable pan' );\n\t\t\t\t\tfolderOptions.add( controls, 'enableZoom' ).name( 'Enable zoom' );\n\t\t\t\t\tfolderOptions.add( controls, 'cursorZoom' ).name( 'Cursor zoom' );\n\t\t\t\t\tfolderOptions.add( controls, 'adjustNearFar' ).name( 'adjust near/far' );\n\t\t\t\t\tfolderOptions.add( controls, 'scaleFactor', 1.1, 10, 0.1 ).name( 'Scale factor' );\n\t\t\t\t\tfolderOptions.add( controls, 'minDistance', 0, 50, 0.5 ).name( 'Min distance' );\n\t\t\t\t\tfolderOptions.add( controls, 'maxDistance', 0, 50, 0.5 ).name( 'Max distance' );\n\t\t\t\t\tfolderOptions.add( controls, 'minZoom', 0, 50, 0.5 ).name( 'Min zoom' );\n\t\t\t\t\tfolderOptions.add( controls, 'maxZoom', 0, 50, 0.5 ).name( 'Max zoom' );\n\t\t\t\t\tfolderOptions.add( arcballGui, 'gizmoVisible' ).name( 'Show gizmos' ).onChange( function () {\n\n\t\t\t\t\t\tcontrols.setGizmosVisible( arcballGui.gizmoVisible );\n\n\t\t\t\t\t} );\n\t\t\t\t\tfolderOptions.add( controls, 'copyState' ).name( 'Copy state(ctrl+c)' );\n\t\t\t\t\tfolderOptions.add( controls, 'pasteState' ).name( 'Paste state(ctrl+v)' );\n\t\t\t\t\tfolderOptions.add( controls, 'reset' ).name( 'Reset' );\n\t\t\t\t\tfolderAnimations.add( controls, 'enableAnimations' ).name( 'Enable anim.' );\n\t\t\t\t\tfolderAnimations.add( controls, 'dampingFactor', 0, 100, 1 ).name( 'Damping' );\n\t\t\t\t\tfolderAnimations.add( controls, 'wMax', 0, 100, 1 ).name( 'Angular spd' );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ReinhardToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 3;\n\t\t\t\trenderer.domElement.style.background = 'linear-gradient( 180deg, rgba( 0,0,0,1 ) 0%, rgba( 128,128,255,1 ) 100% )';\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tcamera = makePerspectiveCamera();\n\t\t\t\tcamera.position.set( 0, 0, perspectiveDistance );\n\n\t\t\t\tconst material = new THREE.MeshStandardMaterial();\n\n\t\t\t\tnew OBJLoader()\n\t\t\t\t\t.setPath( 'models/obj/cerberus/' )\n\t\t\t\t\t.load( 'Cerberus.obj', function ( group ) {\n\n\t\t\t\t\t\tconst textureLoader = new THREE.TextureLoader().setPath( 'models/obj/cerberus/' );\n\n\t\t\t\t\t\tmaterial.roughness = 1;\n\t\t\t\t\t\tmaterial.metalness = 1;\n\n\t\t\t\t\t\tconst diffuseMap = textureLoader.load( 'Cerberus_A.jpg', render );\n\t\t\t\t\t\tdiffuseMap.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\t\t\tmaterial.map = diffuseMap;\n\n\t\t\t\t\t\tmaterial.metalnessMap = material.roughnessMap = textureLoader.load( 'Cerberus_RM.jpg', render );\n\t\t\t\t\t\tmaterial.normalMap = textureLoader.load( 'Cerberus_N.jpg', render );\n\n\t\t\t\t\t\tmaterial.map.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tmaterial.roughnessMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tmaterial.metalnessMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tmaterial.normalMap.wrapS = THREE.RepeatWrapping;\n\n\n\t\t\t\t\t\tgroup.traverse( function ( child ) {\n\n\t\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t\tchild.material = material;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tgroup.rotation.y = Math.PI / 2;\n\t\t\t\t\t\tgroup.position.x += 0.25;\n\t\t\t\t\t\tscene.add( group );\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t\tnew RGBELoader()\n\t\t\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t\t\t.load( 'venice_sunset_1k.hdr', function ( hdrEquirect ) {\n\n\t\t\t\t\t\t\t\thdrEquirect.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\t\t\t\tscene.environment = hdrEquirect;\n\n\t\t\t\t\t\t\t\trender();\n\n\t\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t\twindow.addEventListener( 'keydown', onKeyDown );\n\t\t\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tgui = new GUI();\n\t\t\t\t\t\tgui.add( cameraType, 'type', cameras ).name( 'Choose Camera' ).onChange( function () {\n\n\t\t\t\t\t\t\tsetCamera( cameraType.type );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tfolderOptions = gui.addFolder( 'Arcball parameters' );\n\t\t\t\t\t\tfolderAnimations = folderOptions.addFolder( 'Animations' );\n\n\t\t\t\t\t\tarcballGui.setArcballControls();\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction makeOrthographicCamera() {\n\n\t\t\t\tconst halfFovV = THREE.MathUtils.DEG2RAD * 45 * 0.5;\n\t\t\t\tconst halfFovH = Math.atan( ( window.innerWidth / window.innerHeight ) * Math.tan( halfFovV ) );\n\n\t\t\t\tconst halfW = perspectiveDistance * Math.tan( halfFovH );\n\t\t\t\tconst halfH = perspectiveDistance * Math.tan( halfFovV );\n\t\t\t\tconst near = 0.01;\n\t\t\t\tconst far = 2000;\n\t\t\t\tconst newCamera = new THREE.OrthographicCamera( - halfW, halfW, halfH, - halfH, near, far );\n\t\t\t\treturn newCamera;\n\n\t\t\t}\n\n\t\t\tfunction makePerspectiveCamera() {\n\n\t\t\t\tconst fov = 45;\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tconst near = 0.01;\n\t\t\t\tconst far = 2000;\n\t\t\t\tconst newCamera = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\t\t\treturn newCamera;\n\n\t\t\t}\n\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\t\t\tconst halfFovV = THREE.MathUtils.DEG2RAD * 45 * 0.5;\n\t\t\t\t\tconst halfFovH = Math.atan( ( window.innerWidth / window.innerHeight ) * Math.tan( halfFovV ) );\n\n\t\t\t\t\tconst halfW = perspectiveDistance * Math.tan( halfFovH );\n\t\t\t\t\tconst halfH = perspectiveDistance * Math.tan( halfFovV );\n\t\t\t\t\tcamera.left = - halfW;\n\t\t\t\t\tcamera.right = halfW;\n\t\t\t\t\tcamera.top = halfH;\n\t\t\t\t\tcamera.bottom = - halfH;\n\n\t\t\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\t}\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tif ( event.key === 'c' ) {\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\t\t\tcontrols.copyState();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( event.key === 'v' ) {\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\t\t\tcontrols.pasteState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setCamera( type ) {\n\n\t\t\t\tif ( type == 'Orthographic' ) {\n\n\t\t\t\t\tcamera = makeOrthographicCamera();\n\t\t\t\t\tcamera.position.set( 0, 0, orthographicDistance );\n\n\n\t\t\t\t} else if ( type == 'Perspective' ) {\n\n\t\t\t\t\tcamera = makePerspectiveCamera();\n\t\t\t\t\tcamera.position.set( 0, 0, perspectiveDistance );\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.setCamera( camera );\n\n\t\t\t\trender();\n\n\t\t\t}\n```\n\nThis example three.js - arcball controls Cerberus(FFVII Gun) model by Andrew Maximov."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - drag controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - drag controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { DragControls } from 'three/addons/controls/DragControls.js';\n\n\t\t\tlet container;\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls, group;\n\t\t\tlet enableSelection = false;\n\n\t\t\tconst objects = [];\n\n\t\t\tconst mouse = new THREE.Vector2(), raycaster = new THREE.Raycaster();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 500 );\n\t\t\t\tcamera.position.z = 25;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0xaaaaaa ) );\n\n\t\t\t\tconst light = new THREE.SpotLight( 0xffffff, 10000 );\n\t\t\t\tlight.position.set( 0, 25, 50 );\n\t\t\t\tlight.angle = Math.PI / 9;\n\n\t\t\t\tlight.castShadow = true;\n\t\t\t\tlight.shadow.camera.near = 10;\n\t\t\t\tlight.shadow.camera.far = 100;\n\t\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\t\tlight.shadow.mapSize.height = 1024;\n\n\t\t\t\tscene.add( light );\n\n\t\t\t\tgroup = new THREE.Group();\n\t\t\t\tscene.add( group );\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\n\t\t\t\tfor ( let i = 0; i < 200; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );\n\n\t\t\t\t\tobject.position.x = Math.random() * 30 - 15;\n\t\t\t\t\tobject.position.y = Math.random() * 15 - 7.5;\n\t\t\t\t\tobject.position.z = Math.random() * 20 - 10;\n\n\t\t\t\t\tobject.rotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\t\tobject.rotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\t\tobject.scale.x = Math.random() * 2 + 1;\n\t\t\t\t\tobject.scale.y = Math.random() * 2 + 1;\n\t\t\t\t\tobject.scale.z = Math.random() * 2 + 1;\n\n\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t\tobject.receiveShadow = true;\n\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\trenderer.shadowMap.type = THREE.PCFShadowMap;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tcontrols = new DragControls( [ ... objects ], camera, renderer.domElement );\n\t\t\t\tcontrols.rotateSpeed = 2;\n\t\t\t\tcontrols.addEventListener( 'drag', render );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tdocument.addEventListener( 'click', onClick );\n\t\t\t\twindow.addEventListener( 'keydown', onKeyDown );\n\t\t\t\twindow.addEventListener( 'keyup', onKeyUp );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction onKeyDown( event ) {\n\n\t\t\t\tenableSelection = ( event.keyCode === 16 ) ? true : false;\n\t\t\t\n\t\t\t\tif ( event.keyCode === 77 ) {\n\n\t\t\t\t\tcontrols.touches.ONE = ( controls.touches.ONE === THREE.TOUCH.PAN ) ? THREE.TOUCH.ROTATE : THREE.TOUCH.PAN;\n\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction onKeyUp() {\n\n\t\t\t\tenableSelection = false;\n\n\t\t\t}\n\n\t\t\tfunction onClick( event ) {\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tif ( enableSelection === true ) {\n\n\t\t\t\t\tconst draggableObjects = controls.objects;\n\t\t\t\t\tdraggableObjects.length = 0;\n\n\t\t\t\t\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\t\t\t\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\t\t\t\traycaster.setFromCamera( mouse, camera );\n\n\t\t\t\t\tconst intersections = raycaster.intersectObjects( objects, true );\n\n\t\t\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\t\t\tconst object = intersections[ 0 ].object;\n\n\t\t\t\t\t\tif ( group.children.includes( object ) === true ) {\n\n\t\t\t\t\t\t\tobject.material.emissive.set( 0x000000 );\n\t\t\t\t\t\t\tscene.attach( object );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject.material.emissive.set( 0xaaaaaa );\n\t\t\t\t\t\t\tgroup.attach( object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontrols.transformGroup = true;\n\t\t\t\t\t\tdraggableObjects.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( group.children.length === 0 ) {\n\n\t\t\t\t\t\tcontrols.transformGroup = false;\n\t\t\t\t\t\tdraggableObjects.push( ...objects );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - drag controls Use \"Shift+Click\" to add/remove objects to/from a group. Use \"M\" to toggle between rotate and pan mode (touch only). Grouped objects can be transformed as a union."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgpu - fly controls - earth"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgpu - fly controls - earth:\n\n```javascript\nimport * as THREE from 'three/webgpu';\n\t\t\timport { pass } from 'three/tsl';\n\t\t\timport { film } from 'three/addons/tsl/display/FilmNode.js';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { FlyControls } from 'three/addons/controls/FlyControls.js';\n\n\t\t\tconst radius = 6371;\n\t\t\tconst tilt = 0.41;\n\t\t\tconst rotationSpeed = 0.02;\n\n\t\t\tconst cloudsScale = 1.005;\n\t\t\tconst moonScale = 0.23;\n\n\t\t\tconst MARGIN = 0;\n\t\t\tlet SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;\n\t\t\tlet SCREEN_WIDTH = window.innerWidth;\n\n\t\t\tlet camera, controls, scene, renderer, stats;\n\t\t\tlet geometry, meshPlanet, meshClouds, meshMoon;\n\t\t\tlet dirLight;\n\n\t\t\tlet postProcessing;\n\n\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\tlet d, dPlanet, dMoon;\n\t\t\tconst dMoonVec = new THREE.Vector3();\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 25, SCREEN_WIDTH / SCREEN_HEIGHT, 50, 1e7 );\n\t\t\t\tcamera.position.z = radius * 5;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.FogExp2( 0x000000, 0.00000025 );\n\n\t\t\t\tdirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( - 1, 0, 1 ).normalize();\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst materialNormalMap = new THREE.MeshPhongMaterial( {\n\n\t\t\t\t\tspecular: 0x7c7c7c,\n\t\t\t\t\tshininess: 15,\n\t\t\t\t\tmap: textureLoader.load( 'textures/planets/earth_atmos_2048.jpg' ),\n\t\t\t\t\tspecularMap: textureLoader.load( 'textures/planets/earth_specular_2048.jpg' ),\n\t\t\t\t\tnormalMap: textureLoader.load( 'textures/planets/earth_normal_2048.jpg' ),\n\n\t\t\t\t\t// y scale is negated to compensate for normal map handedness.\n\t\t\t\t\tnormalScale: new THREE.Vector2( 0.85, - 0.85 )\n\n\t\t\t\t} );\n\t\t\t\tmaterialNormalMap.map.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\t// planet\n\n\t\t\t\tgeometry = new THREE.SphereGeometry( radius, 100, 50 );\n\n\t\t\t\tmeshPlanet = new THREE.Mesh( geometry, materialNormalMap );\n\t\t\t\tmeshPlanet.rotation.y = 0;\n\t\t\t\tmeshPlanet.rotation.z = tilt;\n\t\t\t\tscene.add( meshPlanet );\n\n\t\t\t\t// clouds\n\n\t\t\t\tconst materialClouds = new THREE.MeshLambertMaterial( {\n\n\t\t\t\t\tmap: textureLoader.load( 'textures/planets/earth_clouds_1024.png' ),\n\t\t\t\t\ttransparent: true\n\n\t\t\t\t} );\n\t\t\t\tmaterialClouds.map.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tmeshClouds = new THREE.Mesh( geometry, materialClouds );\n\t\t\t\tmeshClouds.scale.set( cloudsScale, cloudsScale, cloudsScale );\n\t\t\t\tmeshClouds.rotation.z = tilt;\n\t\t\t\tscene.add( meshClouds );\n\n\t\t\t\t// moon\n\n\t\t\t\tconst materialMoon = new THREE.MeshPhongMaterial( {\n\n\t\t\t\t\tmap: textureLoader.load( 'textures/planets/moon_1024.jpg' )\n\n\t\t\t\t} );\n\t\t\t\tmaterialMoon.map.colorSpace = THREE.SRGBColorSpace;\n\n\t\t\t\tmeshMoon = new THREE.Mesh( geometry, materialMoon );\n\t\t\t\tmeshMoon.position.set( radius * 5, 0, 0 );\n\t\t\t\tmeshMoon.scale.set( moonScale, moonScale, moonScale );\n\t\t\t\tscene.add( meshMoon );\n\n\t\t\t\t// stars\n\n\t\t\t\tconst r = radius, starsGeometry = [ new THREE.BufferGeometry(), new THREE.BufferGeometry() ];\n\n\t\t\t\tconst vertices1 = [];\n\t\t\t\tconst vertices2 = [];\n\n\t\t\t\tconst vertex = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0; i < 250; i ++ ) {\n\n\t\t\t\t\tvertex.x = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.y = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.z = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.multiplyScalar( r );\n\n\t\t\t\t\tvertices1.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 1500; i ++ ) {\n\n\t\t\t\t\tvertex.x = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.y = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.z = Math.random() * 2 - 1;\n\t\t\t\t\tvertex.multiplyScalar( r );\n\n\t\t\t\t\tvertices2.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t\tstarsGeometry[ 0 ].setAttribute( 'position', new THREE.Float32BufferAttribute( vertices1, 3 ) );\n\t\t\t\tstarsGeometry[ 1 ].setAttribute( 'position', new THREE.Float32BufferAttribute( vertices2, 3 ) );\n\n\t\t\t\tconst starsMaterials = [\n\t\t\t\t\tnew THREE.PointsMaterial( { color: 0x9c9c9c } ),\n\t\t\t\t\tnew THREE.PointsMaterial( { color: 0x838383 } ),\n\t\t\t\t\tnew THREE.PointsMaterial( { color: 0x5a5a5a } )\n\t\t\t\t];\n\n\t\t\t\tfor ( let i = 10; i < 30; i ++ ) {\n\n\t\t\t\t\tconst stars = new THREE.Points( starsGeometry[ i % 2 ], starsMaterials[ i % 3 ] );\n\n\t\t\t\t\tstars.rotation.x = Math.random() * 6;\n\t\t\t\t\tstars.rotation.y = Math.random() * 6;\n\t\t\t\t\tstars.rotation.z = Math.random() * 6;\n\t\t\t\t\tstars.scale.setScalar( i * 10 );\n\n\t\t\t\t\tstars.matrixAutoUpdate = false;\n\t\t\t\t\tstars.updateMatrix();\n\n\t\t\t\t\tscene.add( stars );\n\n\t\t\t\t}\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new FlyControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.movementSpeed = 1000;\n\t\t\t\tcontrols.domElement = renderer.domElement;\n\t\t\t\tcontrols.rollSpeed = Math.PI / 24;\n\t\t\t\tcontrols.autoForward = false;\n\t\t\t\tcontrols.dragToLook = false;\n\n\t\t\t\t//\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// postprocessing\n\n\t\t\t\tpostProcessing = new THREE.PostProcessing( renderer );\n\n\t\t\t\tconst scenePass = pass( scene, camera );\n\t\t\t\tconst scenePassColor = scenePass.getTextureNode();\n\n\t\t\t\tpostProcessing.outputNode = film( scenePassColor );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\t// rotate the planet and clouds\n\n\t\t\t\tconst delta = clock.getDelta();\n\n\t\t\t\tmeshPlanet.rotation.y += rotationSpeed * delta;\n\t\t\t\tmeshClouds.rotation.y += 1.25 * rotationSpeed * delta;\n\n\t\t\t\t// slow down as we approach the surface\n\n\t\t\t\tdPlanet = camera.position.length();\n\n\t\t\t\tdMoonVec.subVectors( camera.position, meshMoon.position );\n\t\t\t\tdMoon = dMoonVec.length();\n\n\t\t\t\tif ( dMoon < dPlanet ) {\n\n\t\t\t\t\td = ( dMoon - radius * moonScale * 1.01 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\td = ( dPlanet - radius * 1.01 );\n\n\t\t\t\t}\n\n\t\t\t\tcontrols.movementSpeed = 0.33 * d;\n\t\t\t\tcontrols.update( delta );\n\n\t\t\t\tpostProcessing.render();\n\n\t\t\t}\n```\n\nThis example three.js - earth [fly controls] WASD move, R|F up | down, Q|E roll, up|down pitch, left|right yaw"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - map controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - map controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { MapControls } from 'three/addons/controls/MapControls.js';\n\n\t\t\tlet camera, controls, scene, renderer;\n\n\t\t\tinit();\n\t\t\t//render(); // remove when using animation loop\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xcccccc );\n\t\t\t\tscene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 200, - 400 );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new MapControls( camera, renderer.domElement );\n\n\t\t\t\t//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)\n\n\t\t\t\tcontrols.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\n\t\t\t\tcontrols.screenSpacePanning = false;\n\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\t// world\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tgeometry.translate( 0, 0.5, 0 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xeeeeee, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 1600 - 800;\n\t\t\t\t\tmesh.position.y = 0;\n\t\t\t\t\tmesh.position.z = Math.random() * 1600 - 800;\n\t\t\t\t\tmesh.scale.x = 20;\n\t\t\t\t\tmesh.scale.y = Math.random() * 80 + 10;\n\t\t\t\t\tmesh.scale.z = 20;\n\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// lights\n\n\t\t\t\tconst dirLight1 = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( dirLight1 );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0x002288, 3 );\n\t\t\t\tdirLight2.position.set( - 1, - 1, - 1 );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0x555555 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( controls, 'zoomToCursor' );\n\t\t\t\tgui.add( controls, 'screenSpacePanning' );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - map controls"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - orbit controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - orbit controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\n\t\t\tlet camera, controls, scene, renderer;\n\n\t\t\tinit();\n\t\t\t//render(); // remove when using animation loop\n\n\t\t\tfunction init() {\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xcccccc );\n\t\t\t\tscene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 400, 200, 0 );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.listenToKeyEvents( window ); // optional\n\n\t\t\t\t//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)\n\n\t\t\t\tcontrols.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled\n\t\t\t\tcontrols.dampingFactor = 0.05;\n\n\t\t\t\tcontrols.screenSpacePanning = false;\n\n\t\t\t\tcontrols.minDistance = 100;\n\t\t\t\tcontrols.maxDistance = 500;\n\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\n\t\t\t\t// world\n\n\t\t\t\tconst geometry = new THREE.ConeGeometry( 10, 30, 4, 1 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = Math.random() * 1600 - 800;\n\t\t\t\t\tmesh.position.y = 0;\n\t\t\t\t\tmesh.position.z = Math.random() * 1600 - 800;\n\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// lights\n\n\t\t\t\tconst dirLight1 = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( dirLight1 );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0x002288, 3 );\n\t\t\t\tdirLight2.position.set( - 1, - 1, - 1 );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0x555555 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - orbit controls"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates - pointerlock controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - pointerlock controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';\n\n\t\t\tlet camera, scene, renderer, controls;\n\n\t\t\tconst objects = [];\n\n\t\t\tlet raycaster;\n\n\t\t\tlet moveForward = false;\n\t\t\tlet moveBackward = false;\n\t\t\tlet moveLeft = false;\n\t\t\tlet moveRight = false;\n\t\t\tlet canJump = false;\n\n\t\t\tlet prevTime = performance.now();\n\t\t\tconst velocity = new THREE.Vector3();\n\t\t\tconst direction = new THREE.Vector3();\n\t\t\tconst vertex = new THREE.Vector3();\n\t\t\tconst color = new THREE.Color();\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.y = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xffffff );\n\t\t\t\tscene.fog = new THREE.Fog( 0xffffff, 0, 750 );\n\n\t\t\t\tconst light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 2.5 );\n\t\t\t\tlight.position.set( 0.5, 1, 0.75 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tcontrols = new PointerLockControls( camera, document.body );\n\n\t\t\t\tconst blocker = document.getElementById( 'blocker' );\n\t\t\t\tconst instructions = document.getElementById( 'instructions' );\n\n\t\t\t\tinstructions.addEventListener( 'click', function () {\n\n\t\t\t\t\tcontrols.lock();\n\n\t\t\t\t} );\n\n\t\t\t\tcontrols.addEventListener( 'lock', function () {\n\n\t\t\t\t\tinstructions.style.display = 'none';\n\t\t\t\t\tblocker.style.display = 'none';\n\n\t\t\t\t} );\n\n\t\t\t\tcontrols.addEventListener( 'unlock', function () {\n\n\t\t\t\t\tblocker.style.display = 'block';\n\t\t\t\t\tinstructions.style.display = '';\n\n\t\t\t\t} );\n\n\t\t\t\tscene.add( controls.object );\n\n\t\t\t\tconst onKeyDown = function ( event ) {\n\n\t\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\t\tcase 'ArrowUp':\n\t\t\t\t\t\tcase 'KeyW':\n\t\t\t\t\t\t\tmoveForward = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ArrowLeft':\n\t\t\t\t\t\tcase 'KeyA':\n\t\t\t\t\t\t\tmoveLeft = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ArrowDown':\n\t\t\t\t\t\tcase 'KeyS':\n\t\t\t\t\t\t\tmoveBackward = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ArrowRight':\n\t\t\t\t\t\tcase 'KeyD':\n\t\t\t\t\t\t\tmoveRight = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Space':\n\t\t\t\t\t\t\tif ( canJump === true ) velocity.y += 350;\n\t\t\t\t\t\t\tcanJump = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tconst onKeyUp = function ( event ) {\n\n\t\t\t\t\tswitch ( event.code ) {\n\n\t\t\t\t\t\tcase 'ArrowUp':\n\t\t\t\t\t\tcase 'KeyW':\n\t\t\t\t\t\t\tmoveForward = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ArrowLeft':\n\t\t\t\t\t\tcase 'KeyA':\n\t\t\t\t\t\t\tmoveLeft = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ArrowDown':\n\t\t\t\t\t\tcase 'KeyS':\n\t\t\t\t\t\t\tmoveBackward = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ArrowRight':\n\t\t\t\t\t\tcase 'KeyD':\n\t\t\t\t\t\t\tmoveRight = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown );\n\t\t\t\tdocument.addEventListener( 'keyup', onKeyUp );\n\n\t\t\t\traycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );\n\n\t\t\t\t// floor\n\n\t\t\t\tlet floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );\n\t\t\t\tfloorGeometry.rotateX( - Math.PI / 2 );\n\n\t\t\t\t// vertex displacement\n\n\t\t\t\tlet position = floorGeometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( position, i );\n\n\t\t\t\t\tvertex.x += Math.random() * 20 - 10;\n\t\t\t\t\tvertex.y += Math.random() * 2;\n\t\t\t\t\tvertex.z += Math.random() * 20 - 10;\n\n\t\t\t\t\tposition.setXYZ( i, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t\tfloorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices\n\n\t\t\t\tposition = floorGeometry.attributes.position;\n\t\t\t\tconst colorsFloor = [];\n\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tcolor.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace );\n\t\t\t\t\tcolorsFloor.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tfloorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsFloor, 3 ) );\n\n\t\t\t\tconst floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: true } );\n\n\t\t\t\tconst floor = new THREE.Mesh( floorGeometry, floorMaterial );\n\t\t\t\tscene.add( floor );\n\n\t\t\t\t// objects\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 20, 20, 20 ).toNonIndexed();\n\n\t\t\t\tposition = boxGeometry.attributes.position;\n\t\t\t\tconst colorsBox = [];\n\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tcolor.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace );\n\t\t\t\t\tcolorsBox.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tboxGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsBox, 3 ) );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: true } );\n\t\t\t\t\tboxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace );\n\n\t\t\t\t\tconst box = new THREE.Mesh( boxGeometry, boxMaterial );\n\t\t\t\t\tbox.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;\n\t\t\t\t\tbox.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;\n\t\t\t\t\tbox.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;\n\n\t\t\t\t\tscene.add( box );\n\t\t\t\t\tobjects.push( box );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst time = performance.now();\n\n\t\t\t\tif ( controls.isLocked === true ) {\n\n\t\t\t\t\traycaster.ray.origin.copy( controls.object.position );\n\t\t\t\t\traycaster.ray.origin.y -= 10;\n\n\t\t\t\t\tconst intersections = raycaster.intersectObjects( objects, false );\n\n\t\t\t\t\tconst onObject = intersections.length > 0;\n\n\t\t\t\t\tconst delta = ( time - prevTime ) / 1000;\n\n\t\t\t\t\tvelocity.x -= velocity.x * 10.0 * delta;\n\t\t\t\t\tvelocity.z -= velocity.z * 10.0 * delta;\n\n\t\t\t\t\tvelocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass\n\n\t\t\t\t\tdirection.z = Number( moveForward ) - Number( moveBackward );\n\t\t\t\t\tdirection.x = Number( moveRight ) - Number( moveLeft );\n\t\t\t\t\tdirection.normalize(); // this ensures consistent movements in all directions\n\n\t\t\t\t\tif ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;\n\t\t\t\t\tif ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;\n\n\t\t\t\t\tif ( onObject === true ) {\n\n\t\t\t\t\t\tvelocity.y = Math.max( 0, velocity.y );\n\t\t\t\t\t\tcanJump = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontrols.moveRight( - velocity.x * delta );\n\t\t\t\t\tcontrols.moveForward( - velocity.z * delta );\n\n\t\t\t\t\tcontrols.object.position.y += ( velocity.y * delta ); // new behavior\n\n\t\t\t\t\tif ( controls.object.position.y < 10 ) {\n\n\t\t\t\t\t\tvelocity.y = 0;\n\t\t\t\t\t\tcontrols.object.position.y = 10;\n\n\t\t\t\t\t\tcanJump = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = time;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - trackball controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - trackball controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\n\t\t\tlet perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;\n\n\t\t\tconst params = {\n\t\t\t\torthographicCamera: false\n\t\t\t};\n\n\t\t\tconst frustumSize = 400;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tperspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, 1000 );\n\t\t\t\tperspectiveCamera.position.z = 500;\n\n\t\t\t\torthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );\n\t\t\t\torthographicCamera.position.z = 500;\n\n\t\t\t\t// world\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xcccccc );\n\t\t\t\tscene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );\n\n\t\t\t\tconst geometry = new THREE.ConeGeometry( 10, 30, 4, 1 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );\n\n\t\t\t\tfor ( let i = 0; i < 500; i ++ ) {\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = ( Math.random() - 0.5 ) * 1000;\n\t\t\t\t\tmesh.position.y = ( Math.random() - 0.5 ) * 1000;\n\t\t\t\t\tmesh.position.z = ( Math.random() - 0.5 ) * 1000;\n\t\t\t\t\tmesh.updateMatrix();\n\t\t\t\t\tmesh.matrixAutoUpdate = false;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t// lights\n\n\t\t\t\tconst dirLight1 = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight1.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( dirLight1 );\n\n\t\t\t\tconst dirLight2 = new THREE.DirectionalLight( 0x002288, 3 );\n\t\t\t\tdirLight2.position.set( - 1, - 1, - 1 );\n\t\t\t\tscene.add( dirLight2 );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0x555555 );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {\n\n\t\t\t\t\tcontrols.dispose();\n\n\t\t\t\t\tcreateControls( value ? orthographicCamera : perspectiveCamera );\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tcreateControls( perspectiveCamera );\n\n\t\t\t}\n\n\t\t\tfunction createControls( camera ) {\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\n\t\t\t\tcontrols.rotateSpeed = 1.0;\n\t\t\t\tcontrols.zoomSpeed = 1.2;\n\t\t\t\tcontrols.panSpeed = 0.8;\n\n\t\t\t\tcontrols.keys = [ 'KeyA', 'KeyS', 'KeyD' ];\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tperspectiveCamera.aspect = aspect;\n\t\t\t\tperspectiveCamera.updateProjectionMatrix();\n\n\t\t\t\torthographicCamera.left = - frustumSize * aspect / 2;\n\t\t\t\torthographicCamera.right = frustumSize * aspect / 2;\n\t\t\t\torthographicCamera.top = frustumSize / 2;\n\t\t\t\torthographicCamera.bottom = - frustumSize / 2;\n\t\t\t\torthographicCamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tcontrols.handleResize();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trender();\n\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst camera = ( params.orthographicCamera ) ? orthographicCamera : perspectiveCamera;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - trackball controls MOVE mouse & press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - transform controls"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - transform controls:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { TransformControls } from 'three/addons/controls/TransformControls.js';\n\n\t\t\tlet cameraPersp, cameraOrtho, currentCamera;\n\t\t\tlet scene, renderer, control, orbit;\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst frustumSize = 5;\n\n\t\t\t\tcameraPersp = new THREE.PerspectiveCamera( 50, aspect, 0.1, 100 );\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( - frustumSize * aspect, frustumSize * aspect, frustumSize, - frustumSize, 0.1, 100 );\n\t\t\t\tcurrentCamera = cameraPersp;\n\n\t\t\t\tcurrentCamera.position.set( 5, 2.5, 5 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.add( new THREE.GridHelper( 5, 10, 0x888888, 0x444444 ) );\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst light = new THREE.DirectionalLight( 0xffffff, 4 );\n\t\t\t\tlight.position.set( 1, 1, 1 );\n\t\t\t\tscene.add( light );\n\n\t\t\t\tconst texture = new THREE.TextureLoader().load( 'textures/crate.gif', render );\n\t\t\t\ttexture.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\ttexture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshLambertMaterial( { map: texture } );\n\n\t\t\t\torbit = new OrbitControls( currentCamera, renderer.domElement );\n\t\t\t\torbit.update();\n\t\t\t\torbit.addEventListener( 'change', render );\n\n\t\t\t\tcontrol = new TransformControls( currentCamera, renderer.domElement );\n\t\t\t\tcontrol.addEventListener( 'change', render );\n\t\t\t\tcontrol.addEventListener( 'dragging-changed', function ( event ) {\n\n\t\t\t\t\torbit.enabled = ! event.value;\n\n\t\t\t\t} );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tcontrol.attach( mesh );\n\n\t\t\t\tconst gizmo = control.getHelper();\n\t\t\t\tscene.add( gizmo );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\twindow.addEventListener( 'keydown', function ( event ) {\n\n\t\t\t\t\tswitch ( event.key ) {\n\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t\tcontrol.setSpace( control.space === 'local' ? 'world' : 'local' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Shift':\n\t\t\t\t\t\t\tcontrol.setTranslationSnap( 1 );\n\t\t\t\t\t\t\tcontrol.setRotationSnap( THREE.MathUtils.degToRad( 15 ) );\n\t\t\t\t\t\t\tcontrol.setScaleSnap( 0.25 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'w':\n\t\t\t\t\t\t\tcontrol.setMode( 'translate' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'e':\n\t\t\t\t\t\t\tcontrol.setMode( 'rotate' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'r':\n\t\t\t\t\t\t\tcontrol.setMode( 'scale' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tconst position = currentCamera.position.clone();\n\n\t\t\t\t\t\t\tcurrentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;\n\t\t\t\t\t\t\tcurrentCamera.position.copy( position );\n\n\t\t\t\t\t\t\torbit.object = currentCamera;\n\t\t\t\t\t\t\tcontrol.camera = currentCamera;\n\n\t\t\t\t\t\t\tcurrentCamera.lookAt( orbit.target.x, orbit.target.y, orbit.target.z );\n\t\t\t\t\t\t\tonWindowResize();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tconst randomFoV = Math.random() + 0.1;\n\t\t\t\t\t\t\tconst randomZoom = Math.random() + 0.1;\n\n\t\t\t\t\t\t\tcameraPersp.fov = randomFoV * 160;\n\t\t\t\t\t\t\tcameraOrtho.bottom = - randomFoV * 500;\n\t\t\t\t\t\t\tcameraOrtho.top = randomFoV * 500;\n\n\t\t\t\t\t\t\tcameraPersp.zoom = randomZoom * 5;\n\t\t\t\t\t\t\tcameraOrtho.zoom = randomZoom * 5;\n\t\t\t\t\t\t\tonWindowResize();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\tcase '=':\n\t\t\t\t\t\t\tcontrol.setSize( control.size + 0.1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\tcase '_':\n\t\t\t\t\t\t\tcontrol.setSize( Math.max( control.size - 0.1, 0.1 ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\tcontrol.showX = ! control.showX;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'y':\n\t\t\t\t\t\t\tcontrol.showY = ! control.showY;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tcontrol.showZ = ! control.showZ;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ' ':\n\t\t\t\t\t\t\tcontrol.enabled = ! control.enabled;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Escape':\n\t\t\t\t\t\t\tcontrol.reset();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\twindow.addEventListener( 'keyup', function ( event ) {\n\n\t\t\t\t\tswitch ( event.key ) {\n\n\t\t\t\t\t\tcase 'Shift':\n\t\t\t\t\t\t\tcontrol.setTranslationSnap( null );\n\t\t\t\t\t\t\tcontrol.setRotationSnap( null );\n\t\t\t\t\t\t\tcontrol.setScaleSnap( null );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcameraPersp.aspect = aspect;\n\t\t\t\tcameraPersp.updateProjectionMatrix();\n\n\t\t\t\tcameraOrtho.left = cameraOrtho.bottom * aspect;\n\t\t\t\tcameraOrtho.right = cameraOrtho.top * aspect;\n\t\t\t\tcameraOrtho.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, currentCamera );\n\n\t\t\t}\n```\n\nThis example \"W\" translate | \"E\" rotate | \"R\" scale | \"+/-\" adjust size \"Q\" toggle world/local space | \"Shift\" snap to grid \"X\" toggle X | \"Y\" toggle Y | \"Z\" toggle Z | \"Spacebar\" toggle enabled \"Esc\" reset current transform \"C\" toggle camera | \"V\" random zoom"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - draco"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - draco:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, renderer, exporter, mesh;\n\n\t\t\tconst params = {\n\t\t\t\texport: exportFile\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 4, 2, 4 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 4, 20 );\n\n\t\t\t\texporter = new DRACOExporter();\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 0, 20, 10 );\n\t\t\t\tdirectionalLight.castShadow = true;\n\t\t\t\tdirectionalLight.shadow.camera.top = 2;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirectionalLight.shadow.camera.left = - 2;\n\t\t\t\tdirectionalLight.shadow.camera.right = 2;\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst ground = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( { color: 0xbbbbbb, depthWrite: false } ) );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 40, 20, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// export mesh\n\n\t\t\t\tconst geometry = new THREE.TorusKnotGeometry( 0.75, 0.2, 200, 30 );\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.position.y = 1.5;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 1.5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'export' ).name( 'Export DRC' );\n\t\t\t\tgui.open();\n\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction exportFile() {\n\n\t\t\t\tconst result = exporter.parse( mesh );\n\t\t\t\tsaveArrayBuffer( result, 'file.drc' );\n\n\t\t\t}\n\n\t\t\tconst link = document.createElement( 'a' );\n\t\t\tlink.style.display = 'none';\n\t\t\tdocument.body.appendChild( link );\n\n\t\t\tfunction save( blob, filename ) {\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t}\n\n\t\t\tfunction saveArrayBuffer( buffer, filename ) {\n\n\t\t\t\tsave( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - draco"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - gltf"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - gltf:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\t\t\timport { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\t\t\timport * as TextureUtils from 'three/addons/utils/WebGLTextureUtils.js';\n\n\t\t\tfunction exportGLTF( input ) {\n\n\t\t\t\tconst gltfExporter = new GLTFExporter().setTextureUtils( TextureUtils );\n\n\t\t\t\tconst options = {\n\t\t\t\t\ttrs: params.trs,\n\t\t\t\t\tonlyVisible: params.onlyVisible,\n\t\t\t\t\tbinary: params.binary,\n\t\t\t\t\tmaxTextureSize: params.maxTextureSize\n\t\t\t\t};\n\t\t\t\tgltfExporter.parse(\n\t\t\t\t\tinput,\n\t\t\t\t\tfunction ( result ) {\n\n\t\t\t\t\t\tif ( result instanceof ArrayBuffer ) {\n\n\t\t\t\t\t\t\tsaveArrayBuffer( result, 'scene.glb' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst output = JSON.stringify( result, null, 2 );\n\t\t\t\t\t\t\tconsole.log( output );\n\t\t\t\t\t\t\tsaveString( output, 'scene.gltf' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tfunction ( error ) {\n\n\t\t\t\t\t\tconsole.log( 'An error happened during parsing', error );\n\n\t\t\t\t\t},\n\t\t\t\t\toptions\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tconst link = document.createElement( 'a' );\n\t\t\tlink.style.display = 'none';\n\t\t\tdocument.body.appendChild( link ); // Firefox workaround, see #6594\n\n\t\t\tfunction save( blob, filename ) {\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t\t// URL.revokeObjectURL( url ); breaks Firefox...\n\n\t\t\t}\n\n\t\t\tfunction saveString( text, filename ) {\n\n\t\t\t\tsave( new Blob( [ text ], { type: 'text/plain' } ), filename );\n\n\t\t\t}\n\n\n\t\t\tfunction saveArrayBuffer( buffer, filename ) {\n\n\t\t\t\tsave( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );\n\n\t\t\t}\n\n\t\t\tlet container;\n\n\t\t\tlet camera, object, object2, material, geometry, scene1, scene2, renderer;\n\t\t\tlet gridHelper, sphere, model, coffeemat;\n\n\t\t\tconst params = {\n\t\t\t\ttrs: false,\n\t\t\t\tonlyVisible: true,\n\t\t\t\tbinary: false,\n\t\t\t\tmaxTextureSize: 4096,\n\t\t\t\texportScene1: exportScene1,\n\t\t\t\texportScenes: exportScenes,\n\t\t\t\texportSphere: exportSphere,\n\t\t\t\texportModel: exportModel,\n\t\t\t\texportObjects: exportObjects,\n\t\t\t\texportSceneObject: exportSceneObject,\n\t\t\t\texportCompressedObject: exportCompressedObject,\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.createElement( 'div' );\n\t\t\t\tdocument.body.appendChild( container );\n\n\t\t\t\t// Make linear gradient texture\n\n\t\t\t\tconst data = new Uint8ClampedArray( 100 * 100 * 4 );\n\n\t\t\t\tfor ( let y = 0; y < 100; y ++ ) {\n\n\t\t\t\t\tfor ( let x = 0; x < 100; x ++ ) {\n\n\t\t\t\t\t\tconst stride = 4 * ( 100 * y + x );\n\n\t\t\t\t\t\tdata[ stride ] = Math.round( 255 * y / 99 );\n\t\t\t\t\t\tdata[ stride + 1 ] = Math.round( 255 - 255 * y / 99 );\n\t\t\t\t\t\tdata[ stride + 2 ] = 0;\n\t\t\t\t\t\tdata[ stride + 3 ] = 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst gradientTexture = new THREE.DataTexture( data, 100, 100, THREE.RGBAFormat );\n\t\t\t\tgradientTexture.minFilter = THREE.LinearFilter;\n\t\t\t\tgradientTexture.magFilter = THREE.LinearFilter;\n\t\t\t\tgradientTexture.needsUpdate = true;\n\n\t\t\t\tscene1 = new THREE.Scene();\n\t\t\t\tscene1.name = 'Scene1';\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Perspective Camera\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\n\t\t\t\tcamera.position.set( 600, 400, 0 );\n\n\t\t\t\tcamera.name = 'PerspectiveCamera';\n\t\t\t\tscene1.add( camera );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Ambient light\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xcccccc );\n\t\t\t\tambientLight.name = 'AmbientLight';\n\t\t\t\tscene1.add( ambientLight );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// DirectLight\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.target.position.set( 0, 0, - 1 );\n\t\t\t\tdirLight.add( dirLight.target );\n\t\t\t\tdirLight.lookAt( - 1, - 1, 0 );\n\t\t\t\tdirLight.name = 'DirectionalLight';\n\t\t\t\tscene1.add( dirLight );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Grid\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tgridHelper = new THREE.GridHelper( 2000, 20, 0xc1c1c1, 0x8d8d8d );\n\t\t\t\tgridHelper.position.y = - 50;\n\t\t\t\tgridHelper.name = 'Grid';\n\t\t\t\tscene1.add( gridHelper );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Axes\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst axes = new THREE.AxesHelper( 500 );\n\t\t\t\taxes.name = 'AxesHelper';\n\t\t\t\tscene1.add( axes );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Simple geometry with basic material\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Icosahedron\n\t\t\t\tconst mapGrid = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );\n\t\t\t\tmapGrid.wrapS = mapGrid.wrapT = THREE.RepeatWrapping;\n\t\t\t\tmapGrid.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\tmap: mapGrid\n\t\t\t\t} );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.IcosahedronGeometry( 75, 0 ), material );\n\t\t\t\tobject.position.set( - 200, 0, 200 );\n\t\t\t\tobject.name = 'Icosahedron';\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// Octahedron\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: 0x0000ff,\n\t\t\t\t\twireframe: true\n\t\t\t\t} );\n\t\t\t\tobject = new THREE.Mesh( new THREE.OctahedronGeometry( 75, 1 ), material );\n\t\t\t\tobject.position.set( 0, 0, 200 );\n\t\t\t\tobject.name = 'Octahedron';\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// Tetrahedron\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 0.5\n\t\t\t\t} );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.TetrahedronGeometry( 75, 0 ), material );\n\t\t\t\tobject.position.set( 200, 0, 200 );\n\t\t\t\tobject.name = 'Tetrahedron';\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Buffered geometry primitives\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Sphere\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xffff00,\n\t\t\t\t\tmetalness: 0.5,\n\t\t\t\t\troughness: 1.0,\n\t\t\t\t\tflatShading: true,\n\t\t\t\t} );\n\t\t\t\tmaterial.map = gradientTexture;\n\t\t\t\tmaterial.bumpMap = mapGrid;\n\t\t\t\tsphere = new THREE.Mesh( new THREE.SphereGeometry( 70, 10, 10 ), material );\n\t\t\t\tsphere.position.set( 0, 0, 0 );\n\t\t\t\tsphere.name = 'Sphere';\n\t\t\t\tscene1.add( sphere );\n\n\t\t\t\t// Cylinder\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xff00ff,\n\t\t\t\t\tflatShading: true\n\t\t\t\t} );\n\t\t\t\tobject = new THREE.Mesh( new THREE.CylinderGeometry( 10, 80, 100 ), material );\n\t\t\t\tobject.position.set( 200, 0, 0 );\n\t\t\t\tobject.name = 'Cylinder';\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// TorusKnot\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\troughness: 1\n\t\t\t\t} );\n\t\t\t\tobject = new THREE.Mesh( new THREE.TorusKnotGeometry( 50, 15, 40, 10 ), material );\n\t\t\t\tobject.position.set( - 200, 0, 0 );\n\t\t\t\tobject.name = 'Cylinder';\n\t\t\t\tscene1.add( object );\n\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Hierarchy\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst mapWood = new THREE.TextureLoader().load( 'textures/hardwood2_diffuse.jpg' );\n\t\t\t\tmaterial = new THREE.MeshStandardMaterial( { map: mapWood, side: THREE.DoubleSide } );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.BoxGeometry( 40, 100, 100 ), material );\n\t\t\t\tobject.position.set( - 200, 0, 400 );\n\t\t\t\tobject.name = 'Cube';\n\t\t\t\tscene1.add( object );\n\n\t\t\t\tobject2 = new THREE.Mesh( new THREE.BoxGeometry( 40, 40, 40, 2, 2, 2 ), material );\n\t\t\t\tobject2.position.set( 0, 0, 50 );\n\t\t\t\tobject2.rotation.set( 0, 45, 0 );\n\t\t\t\tobject2.name = 'SubCube';\n\t\t\t\tobject.add( object2 );\n\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Groups\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst group1 = new THREE.Group();\n\t\t\t\tgroup1.name = 'Group';\n\t\t\t\tscene1.add( group1 );\n\n\t\t\t\tconst group2 = new THREE.Group();\n\t\t\t\tgroup2.name = 'subGroup';\n\t\t\t\tgroup2.position.set( 0, 50, 0 );\n\t\t\t\tgroup1.add( group2 );\n\n\t\t\t\tobject2 = new THREE.Mesh( new THREE.BoxGeometry( 30, 30, 30 ), material );\n\t\t\t\tobject2.name = 'Cube in group';\n\t\t\t\tobject2.position.set( 0, 0, 400 );\n\t\t\t\tgroup2.add( object2 );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// THREE.Line Strip\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\tlet numPoints = 100;\n\t\t\t\tlet positions = new Float32Array( numPoints * 3 );\n\n\t\t\t\tfor ( let i = 0; i < numPoints; i ++ ) {\n\n\t\t\t\t\tpositions[ i * 3 ] = i;\n\t\t\t\t\tpositions[ i * 3 + 1 ] = Math.sin( i / 2 ) * 20;\n\t\t\t\t\tpositions[ i * 3 + 2 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tobject = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\n\t\t\t\tobject.position.set( - 50, 0, - 200 );\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// THREE.Line Loop\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\tnumPoints = 5;\n\t\t\t\tconst radius = 70;\n\t\t\t\tpositions = new Float32Array( numPoints * 3 );\n\n\t\t\t\tfor ( let i = 0; i < numPoints; i ++ ) {\n\n\t\t\t\t\tconst s = i * Math.PI * 2 / numPoints;\n\t\t\t\t\tpositions[ i * 3 ] = radius * Math.sin( s );\n\t\t\t\t\tpositions[ i * 3 + 1 ] = radius * Math.cos( s );\n\t\t\t\t\tpositions[ i * 3 + 2 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\t\t\tobject = new THREE.LineLoop( geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\n\t\t\t\tobject.position.set( 0, 0, - 200 );\n\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// THREE.Points\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tnumPoints = 100;\n\t\t\t\tconst pointsArray = new Float32Array( numPoints * 3 );\n\t\t\t\tfor ( let i = 0; i < numPoints; i ++ ) {\n\n\t\t\t\t\tpointsArray[ 3 * i ] = - 50 + Math.random() * 100;\n\t\t\t\t\tpointsArray[ 3 * i + 1 ] = Math.random() * 100;\n\t\t\t\t\tpointsArray[ 3 * i + 2 ] = - 50 + Math.random() * 100;\n\n\t\t\t\t}\n\n\t\t\t\tconst pointsGeo = new THREE.BufferGeometry();\n\t\t\t\tpointsGeo.setAttribute( 'position', new THREE.BufferAttribute( pointsArray, 3 ) );\n\n\t\t\t\tconst pointsMaterial = new THREE.PointsMaterial( { color: 0xffff00, size: 5 } );\n\t\t\t\tconst pointCloud = new THREE.Points( pointsGeo, pointsMaterial );\n\t\t\t\tpointCloud.name = 'Points';\n\t\t\t\tpointCloud.position.set( - 200, 0, - 200 );\n\t\t\t\tscene1.add( pointCloud );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Ortho camera\n\t\t\t\t// ---------------------------------------------------------------------\n\n\t\t\t\tconst height = 1000; // frustum height\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tconst cameraOrtho = new THREE.OrthographicCamera( - height * aspect, height * aspect, height, - height, 0, 2000 );\n\t\t\t\tcameraOrtho.position.set( 600, 400, 0 );\n\t\t\t\tcameraOrtho.lookAt( 0, 0, 0 );\n\t\t\t\tscene1.add( cameraOrtho );\n\t\t\t\tcameraOrtho.name = 'OrthographicCamera';\n\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial( {\n\t\t\t\t\tcolor: 0xffff00,\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t} );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.CircleGeometry( 50, 20, 0, Math.PI * 2 ), material );\n\t\t\t\tobject.position.set( 200, 0, - 400 );\n\t\t\t\tscene1.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.RingGeometry( 10, 50, 20, 5, 0, Math.PI * 2 ), material );\n\t\t\t\tobject.position.set( 0, 0, - 400 );\n\t\t\t\tscene1.add( object );\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.CylinderGeometry( 25, 75, 100, 40, 5 ), material );\n\t\t\t\tobject.position.set( - 200, 0, - 400 );\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t//\n\t\t\t\tconst points = [];\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( Math.sin( i * 0.2 ) * Math.sin( i * 0.1 ) * 15 + 50, ( i - 5 ) * 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject = new THREE.Mesh( new THREE.LatheGeometry( points, 20 ), material );\n\t\t\t\tobject.position.set( 200, 0, 400 );\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Big red box hidden just for testing `onlyVisible` option\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: 0xff0000\n\t\t\t\t} );\n\t\t\t\tobject = new THREE.Mesh( new THREE.BoxGeometry( 200, 200, 200 ), material );\n\t\t\t\tobject.position.set( 0, 0, 0 );\n\t\t\t\tobject.name = 'CubeHidden';\n\t\t\t\tobject.visible = false;\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Model requiring KHR_mesh_quantization\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst loader = new GLTFLoader();\n\t\t\t\tloader.load( 'models/gltf/ShaderBall.glb', function ( gltf ) {\n\n\t\t\t\t\tmodel = gltf.scene;\n\t\t\t\t\tmodel.scale.setScalar( 50 );\n\t\t\t\t\tmodel.position.set( 200, - 40, - 200 );\n\t\t\t\t\tscene1.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Model requiring KHR_mesh_quantization\n\t\t\t\t// ---------------------------------------------------------------------\n\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t} );\n\t\t\t\tobject = new THREE.InstancedMesh( new THREE.BoxGeometry( 10, 10, 10, 2, 2, 2 ), material, 50 );\n\t\t\t\tconst matrix = new THREE.Matrix4();\n\t\t\t\tconst color = new THREE.Color();\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tmatrix.setPosition( Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50 );\n\t\t\t\t\tobject.setMatrixAt( i, matrix );\n\t\t\t\t\tobject.setColorAt( i, color.setHSL( i / 50, 1, 0.5 ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.position.set( 400, 0, 200 );\n\t\t\t\tscene1.add( object );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// 2nd THREE.Scene\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tscene2 = new THREE.Scene();\n\t\t\t\tobject = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100 ), material );\n\t\t\t\tobject.position.set( 0, 0, 0 );\n\t\t\t\tobject.name = 'Cube2ndScene';\n\t\t\t\tscene2.name = 'Scene2';\n\t\t\t\tscene2.add( object );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\t// Exporting compressed textures and meshes (KTX2 / Draco / Meshopt)\n\t\t\t\t// ---------------------------------------------------------------------\n\t\t\t\tconst ktx2Loader = new KTX2Loader()\n\t\t\t\t\t.setTranscoderPath( 'jsm/libs/basis/' )\n\t\t\t\t\t.detectSupport( renderer );\n\n\t\t\t\tconst gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );\n\t\t\t\tgltfLoader.setKTX2Loader( ktx2Loader );\n\t\t\t\tgltfLoader.setMeshoptDecoder( MeshoptDecoder );\n\t\t\t\tgltfLoader.load( 'coffeemat.glb', function ( gltf ) {\n\n\t\t\t\t\tgltf.scene.position.x = 400;\n\t\t\t\t\tgltf.scene.position.z = - 200;\n\n\t\t\t\t\tscene1.add( gltf.scene );\n\n\t\t\t\t\tcoffeemat = gltf.scene;\n\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tlet h = gui.addFolder( 'Settings' );\n\t\t\t\th.add( params, 'trs' ).name( 'Use TRS' );\n\t\t\t\th.add( params, 'onlyVisible' ).name( 'Only Visible Objects' );\n\t\t\t\th.add( params, 'binary' ).name( 'Binary (GLB)' );\n\t\t\t\th.add( params, 'maxTextureSize', 2, 8192 ).name( 'Max Texture Size' ).step( 1 );\n\n\t\t\t\th = gui.addFolder( 'Export' );\n\t\t\t\th.add( params, 'exportScene1' ).name( 'Export Scene 1' );\n\t\t\t\th.add( params, 'exportScenes' ).name( 'Export Scene 1 and 2' );\n\t\t\t\th.add( params, 'exportSphere' ).name( 'Export Sphere' );\n\t\t\t\th.add( params, 'exportModel' ).name( 'Export Model' );\n\t\t\t\th.add( params, 'exportObjects' ).name( 'Export Sphere With Grid' );\n\t\t\t\th.add( params, 'exportSceneObject' ).name( 'Export Scene 1 and Object' );\n\t\t\t\th.add( params, 'exportCompressedObject' ).name( 'Export Coffeemat (from compressed data)' );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction exportScene1() {\n\n\t\t\t\texportGLTF( scene1 );\n\n\t\t\t}\n\n\t\t\tfunction exportScenes() {\n\n\t\t\t\texportGLTF( [ scene1, scene2 ] );\n\n\t\t\t}\n\n\t\t\tfunction exportSphere() {\n\n\t\t\t\texportGLTF( sphere );\n\n\t\t\t}\n\n\t\t\tfunction exportModel() {\n\n\t\t\t\texportGLTF( model );\n\n\t\t\t}\n\n\t\t\tfunction exportObjects() {\n\n\t\t\t\texportGLTF( [ sphere, gridHelper ] );\n\n\t\t\t}\n\n\t\t\tfunction exportSceneObject() {\n\n\t\t\t\texportGLTF( [ scene1, gridHelper ] );\n\n\t\t\t}\n\n\t\t\tfunction exportCompressedObject() {\n\n\t\t\t\texportGLTF( [ coffeemat ] );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst timer = Date.now() * 0.0001;\n\n\t\t\t\tcamera.position.x = Math.cos( timer ) * 800;\n\t\t\t\tcamera.position.z = Math.sin( timer ) * 800;\n\n\t\t\t\tcamera.lookAt( scene1.position );\n\t\t\t\trenderer.render( scene1, camera );\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - gltf"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - obj"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - obj:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { OBJExporter } from 'three/addons/exporters/OBJExporter.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst params = {\n\t\t\t\taddTriangle: addTriangle,\n\t\t\t\taddCube: addCube,\n\t\t\t\taddCylinder: addCylinder,\n\t\t\t\taddMultiple: addMultiple,\n\t\t\t\taddTransformed: addTransformed,\n\t\t\t\taddPoints: addPoints,\n\t\t\t\texportToObj: exportToObj\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 0, 0, 400 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst ambientLight = new THREE.AmbientLight( 0xffffff );\n\t\t\t\tscene.add( ambientLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\t\tdirectionalLight.position.set( 0, 1, 1 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tlet h = gui.addFolder( 'Geometry Selection' );\n\t\t\t\th.add( params, 'addTriangle' ).name( 'Triangle' );\n\t\t\t\th.add( params, 'addCube' ).name( 'Cube' );\n\t\t\t\th.add( params, 'addCylinder' ).name( 'Cylinder' );\n\t\t\t\th.add( params, 'addMultiple' ).name( 'Multiple objects' );\n\t\t\t\th.add( params, 'addTransformed' ).name( 'Transformed objects' );\n\t\t\t\th.add( params, 'addPoints' ).name( 'Point Cloud' );\n\n\t\t\t\th = gui.addFolder( 'Export' );\n\t\t\t\th.add( params, 'exportToObj' ).name( 'Export OBJ' );\n\n\t\t\t\tgui.open();\n\n\t\t\t\taddGeometry( 1 );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enablePan = false;\n\n\t\t\t}\n\n\t\t\tfunction exportToObj() {\n\n\t\t\t\tconst exporter = new OBJExporter();\n\t\t\t\tconst result = exporter.parse( scene );\n\t\t\t\tsaveString( result, 'object.obj' );\n\n\t\t\t}\n\n\t\t\tfunction addGeometry( type ) {\n\n\t\t\t\tfor ( let i = 0; i < scene.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = scene.children[ i ];\n\n\t\t\t\t\tif ( child.isMesh || child.isPoints ) {\n\n\t\t\t\t\t\tchild.geometry.dispose();\n\t\t\t\t\t\tscene.remove( child );\n\t\t\t\t\t\ti --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( type === 1 ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0x00cc00 } );\n\t\t\t\t\tconst geometry = generateTriangleGeometry();\n\n\t\t\t\t\tscene.add( new THREE.Mesh( geometry, material ) );\n\n\n\t\t\t\t} else if ( type === 2 ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0x00cc00 } );\n\t\t\t\t\tconst geometry = new THREE.BoxGeometry( 100, 100, 100 );\n\t\t\t\t\tscene.add( new THREE.Mesh( geometry, material ) );\n\n\t\t\t\t} else if ( type === 3 ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0x00cc00 } );\n\t\t\t\t\tconst geometry = new THREE.CylinderGeometry( 50, 50, 100, 30, 1 );\n\t\t\t\t\tscene.add( new THREE.Mesh( geometry, material ) );\n\n\t\t\t\t} else if ( type === 4 || type === 5 ) {\n\n\t\t\t\t\tconst material = new THREE.MeshLambertMaterial( { color: 0x00cc00 } );\n\t\t\t\t\tconst geometry = generateTriangleGeometry();\n\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.x = - 200;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\tconst geometry2 = new THREE.BoxGeometry( 100, 100, 100 );\n\t\t\t\t\tconst mesh2 = new THREE.Mesh( geometry2, material );\n\t\t\t\t\tscene.add( mesh2 );\n\n\t\t\t\t\tconst geometry3 = new THREE.CylinderGeometry( 50, 50, 100, 30, 1 );\n\t\t\t\t\tconst mesh3 = new THREE.Mesh( geometry3, material );\n\t\t\t\t\tmesh3.position.x = 200;\n\t\t\t\t\tscene.add( mesh3 );\n\n\t\t\t\t\tif ( type === 5 ) {\n\n\t\t\t\t\t\tmesh.rotation.y = Math.PI / 4.0;\n\t\t\t\t\t\tmesh2.rotation.y = Math.PI / 4.0;\n\t\t\t\t\t\tmesh3.rotation.y = Math.PI / 4.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( type === 6 ) {\n\n\t\t\t\t\tconst points = [ 0, 0, 0, 100, 0, 0, 100, 100, 0, 0, 100, 0 ];\n\t\t\t\t\tconst colors = [ 0.5, 0, 0, 0.5, 0, 0, 0, 0.5, 0, 0, 0.5, 0 ];\n\n\t\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( points, 3 ) );\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t\tconst material = new THREE.PointsMaterial( { size: 10, vertexColors: true } );\n\n\t\t\t\t\tconst pointCloud = new THREE.Points( geometry, material );\n\t\t\t\t\tpointCloud.name = 'point cloud';\n\t\t\t\t\tscene.add( pointCloud );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addTriangle() {\n\n\t\t\t\taddGeometry( 1 );\n\n\t\t\t}\n\n\t\t\tfunction addCube() {\n\n\t\t\t\taddGeometry( 2 );\n\n\t\t\t}\n\n\t\t\tfunction addCylinder() {\n\n\t\t\t\taddGeometry( 3 );\n\n\t\t\t}\n\n\t\t\tfunction addMultiple() {\n\n\t\t\t\taddGeometry( 4 );\n\n\t\t\t}\n\n\t\t\tfunction addTransformed() {\n\n\t\t\t\taddGeometry( 5 );\n\n\t\t\t}\n\n\t\t\tfunction addPoints() {\n\n\t\t\t\taddGeometry( 6 );\n\n\t\t\t}\n\n\t\t\tconst link = document.createElement( 'a' );\n\t\t\tlink.style.display = 'none';\n\t\t\tdocument.body.appendChild( link );\n\n\t\t\tfunction save( blob, filename ) {\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t}\n\n\t\t\tfunction saveString( text, filename ) {\n\n\t\t\t\tsave( new Blob( [ text ], { type: 'text/plain' } ), filename );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction generateTriangleGeometry() {\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tvertices.push( - 50, - 50, 0 );\n\t\t\t\tvertices.push( 50, - 50, 0 );\n\t\t\t\tvertices.push( 50, 50, 0 );\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - obj"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - ply"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - ply:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { PLYExporter } from 'three/addons/exporters/PLYExporter.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, renderer, exporter, mesh;\n\n\t\t\tconst params = {\n\t\t\t\texportASCII: exportASCII,\n\t\t\t\texportBinaryBigEndian: exportBinaryBigEndian,\n\t\t\t\texportBinaryLittleEndian: exportBinaryLittleEndian\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 4, 2, 4 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 4, 20 );\n\n\t\t\t\texporter = new PLYExporter();\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 0, 20, 10 );\n\t\t\t\tdirectionalLight.castShadow = true;\n\t\t\t\tdirectionalLight.shadow.camera.top = 2;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirectionalLight.shadow.camera.left = - 2;\n\t\t\t\tdirectionalLight.shadow.camera.right = 2;\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst ground = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 40, 20, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// export mesh\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { vertexColors: true } );\n\n\t\t\t\t// color vertices based on vertex positions\n\t\t\t\tconst colors = geometry.getAttribute( 'position' ).array.slice();\n\t\t\t\tfor ( let i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( colors[ i ] > 0 ) colors[ i ] = 0.5;\n\t\t\t\t\telse colors[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3, false ) );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.position.y = 0.5;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'exportASCII' ).name( 'Export PLY (ASCII)' );\n\t\t\t\tgui.add( params, 'exportBinaryBigEndian' ).name( 'Export PLY (Binary BE)' );\n\t\t\t\tgui.add( params, 'exportBinaryLittleEndian' ).name( 'Export PLY (Binary LE)' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction exportASCII() {\n\n\t\t\t\texporter.parse( mesh, function ( result ) {\n\n\t\t\t\t\tsaveString( result, 'box.ply' );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction exportBinaryBigEndian() {\n\n\t\t\t\texporter.parse( mesh, function ( result ) {\n\n\t\t\t\t\tsaveArrayBuffer( result, 'box.ply' );\n\n\t\t\t\t}, { binary: true } );\n\n\t\t\t}\n\n\t\t\tfunction exportBinaryLittleEndian() {\n\n\t\t\t\texporter.parse( mesh, function ( result ) {\n\n\t\t\t\t\tsaveArrayBuffer( result, 'box.ply' );\n\n\t\t\t\t}, { binary: true, littleEndian: true } );\n\n\t\t\t}\n\n\t\t\tconst link = document.createElement( 'a' );\n\t\t\tlink.style.display = 'none';\n\t\t\tdocument.body.appendChild( link );\n\n\t\t\tfunction save( blob, filename ) {\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t}\n\n\t\t\tfunction saveString( text, filename ) {\n\n\t\t\t\tsave( new Blob( [ text ], { type: 'text/plain' } ), filename );\n\n\t\t\t}\n\n\t\t\tfunction saveArrayBuffer( buffer, filename ) {\n\n\t\t\t\tsave( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - ply"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - stl"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - stl:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { STLExporter } from 'three/addons/exporters/STLExporter.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, renderer, exporter, mesh;\n\n\t\t\tconst params = {\n\t\t\t\texportASCII: exportASCII,\n\t\t\t\texportBinary: exportBinary\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 4, 2, 4 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xa0a0a0 );\n\t\t\t\tscene.fog = new THREE.Fog( 0xa0a0a0, 4, 20 );\n\n\t\t\t\texporter = new STLExporter();\n\n\t\t\t\t//\n\n\t\t\t\tconst hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 3 );\n\t\t\t\themiLight.position.set( 0, 20, 0 );\n\t\t\t\tscene.add( hemiLight );\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirectionalLight.position.set( 0, 20, 10 );\n\t\t\t\tdirectionalLight.castShadow = true;\n\t\t\t\tdirectionalLight.shadow.camera.top = 2;\n\t\t\t\tdirectionalLight.shadow.camera.bottom = - 2;\n\t\t\t\tdirectionalLight.shadow.camera.left = - 2;\n\t\t\t\tdirectionalLight.shadow.camera.right = 2;\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\t// ground\n\n\t\t\t\tconst ground = new THREE.Mesh( new THREE.PlaneGeometry( 40, 40 ), new THREE.MeshPhongMaterial( { color: 0xbbbbbb, depthWrite: false } ) );\n\t\t\t\tground.rotation.x = - Math.PI / 2;\n\t\t\t\tground.receiveShadow = true;\n\t\t\t\tscene.add( ground );\n\n\t\t\t\tconst grid = new THREE.GridHelper( 40, 20, 0x000000, 0x000000 );\n\t\t\t\tgrid.material.opacity = 0.2;\n\t\t\t\tgrid.material.transparent = true;\n\t\t\t\tscene.add( grid );\n\n\t\t\t\t// export mesh\n\n\t\t\t\tconst geometry = new THREE.BoxGeometry();\n\t\t\t\tconst material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );\n\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.position.y = 0.5;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\trenderer.shadowMap.enabled = true;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.target.set( 0, 0.5, 0 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'exportASCII' ).name( 'Export STL (ASCII)' );\n\t\t\t\tgui.add( params, 'exportBinary' ).name( 'Export STL (Binary)' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction exportASCII() {\n\n\t\t\t\tconst result = exporter.parse( mesh );\n\t\t\t\tsaveString( result, 'box.stl' );\n\n\t\t\t}\n\n\t\t\tfunction exportBinary() {\n\n\t\t\t\tconst result = exporter.parse( mesh, { binary: true } );\n\t\t\t\tsaveArrayBuffer( result, 'box.stl' );\n\n\t\t\t}\n\n\t\t\tconst link = document.createElement( 'a' );\n\t\t\tlink.style.display = 'none';\n\t\t\tdocument.body.appendChild( link );\n\n\t\t\tfunction save( blob, filename ) {\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t}\n\n\t\t\tfunction saveString( text, filename ) {\n\n\t\t\t\tsave( new Blob( [ text ], { type: 'text/plain' } ), filename );\n\n\t\t\t}\n\n\t\t\tfunction saveArrayBuffer( buffer, filename ) {\n\n\t\t\t\tsave( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - stl"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - USDZ exporter"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - USDZ exporter:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';\n\n\t\t\timport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\t\t\timport { USDZExporter } from 'three/addons/exporters/USDZExporter.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tconst params = {\n\t\t\t\texportUSDZ: exportUSDZ\n\t\t\t};\n\n\t\t\tinit();\n\t\t\trender();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );\n\t\t\t\tcamera.position.set( - 2.5, 0.6, 3.0 );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\t\t\t\tscene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;\n\n\t\t\t\tconst loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );\n\t\t\t\tloader.load( 'DamagedHelmet.gltf', async function ( gltf ) {\n\n\t\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\t\tconst shadowMesh = createSpotShadowMesh();\n\t\t\t\t\tshadowMesh.position.y = - 1.1;\n\t\t\t\t\tshadowMesh.position.z = - 0.25;\n\t\t\t\t\tshadowMesh.scale.setScalar( 2 );\n\t\t\t\t\tscene.add( shadowMesh );\n\n\t\t\t\t\trender();\n\n\t\t\t\t\t// USDZ\n\n\t\t\t\t\tconst exporter = new USDZExporter();\n\t\t\t\t\tconst arraybuffer = await exporter.parseAsync( gltf.scene );\n\t\t\t\t\tconst blob = new Blob( [ arraybuffer ], { type: 'application/octet-stream' } );\n\n\t\t\t\t\tconst link = document.getElementById( 'link' );\n\t\t\t\t\tlink.href = URL.createObjectURL( blob );\n\n\t\t\t\t} );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 2;\n\t\t\t\tcontrols.maxDistance = 10;\n\t\t\t\tcontrols.target.set( 0, - 0.15, - 0.2 );\n\t\t\t\tcontrols.update();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst isIOS = /iPad|iPhone|iPod/.test( navigator.userAgent );\n\n\t\t\t\tif ( isIOS === false ) {\n\n\t\t\t\t\tconst gui = new GUI();\n\n\t\t\t\t\tgui.add( params, 'exportUSDZ' ).name( 'Export USDZ' );\n\t\t\t\t\tgui.open();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createSpotShadowMesh() {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = 128;\n\t\t\t\tcanvas.height = 128;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tconst gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );\n\t\t\t\tgradient.addColorStop( 0.1, 'rgba(130,130,130,1)' );\n\t\t\t\tgradient.addColorStop( 1, 'rgba(255,255,255,1)' );\n\n\t\t\t\tcontext.fillStyle = gradient;\n\t\t\t\tcontext.fillRect( 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconst shadowTexture = new THREE.CanvasTexture( canvas );\n\n\t\t\t\tconst geometry = new THREE.PlaneGeometry();\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( {\n\t\t\t\t\tmap: shadowTexture, blending: THREE.MultiplyBlending, toneMapped: false, premultipliedAlpha: true\n\t\t\t\t} );\n\n\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction exportUSDZ() {\n\n\t\t\t\tconst link = document.getElementById( 'link' );\n\t\t\t\tlink.click();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - USDZ exporter Battle Damaged Sci-fi Helmet by theblueturtle_"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - exr"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - exr:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { EXRExporter, ZIP_COMPRESSION, ZIPS_COMPRESSION, NO_COMPRESSION } from 'three/addons/exporters/EXRExporter.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, renderer, exporter, mesh, controls, renderTarget, dataTexture;\n\n\t\t\tconst params = {\n\t\t\t\ttarget: 'pmrem',\n\t\t\t\ttype: 'HalfFloatType',\n\t\t\t\tcompression: 'ZIP',\n\t\t\t\texport: exportFile\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 10, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\texporter = new EXRExporter();\n\t\t\t\tconst rgbeloader = new RGBELoader();\n\n\t\t\t\t//\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tpmremGenerator.compileEquirectangularShader();\n\n\t\t\t\trgbeloader.load( 'textures/equirectangular/san_giuseppe_bridge_2k.hdr', function ( texture ) {\n\n\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\trenderTarget = pmremGenerator.fromEquirectangular( texture );\n\t\t\t\t\tscene.background = renderTarget.texture;\n\n\t\t\t\t} );\n\n\t\t\t\tcreateDataTexture();\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.rotateSpeed = - 0.25; // negative, to track mouse pointer\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tconst input = gui.addFolder( 'Input' );\n\t\t\t\tinput.add( params, 'target' ).options( [ 'pmrem', 'data-texture' ] ).onChange( swapScene );\n\n\t\t\t\tconst options = gui.addFolder( 'Output Options' );\n\t\t\t\toptions.add( params, 'type' ).options( [ 'FloatType', 'HalfFloatType' ] );\n\t\t\t\toptions.add( params, 'compression' ).options( [ 'ZIP', 'ZIPS', 'NONE' ] );\n\n\t\t\t\tgui.add( params, 'export' ).name( 'Export EXR' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction createDataTexture() {\n\n\t\t\t\tconst normal = new THREE.Vector3();\n\t\t\t\tconst coord = new THREE.Vector2();\n\t\t\t\tconst size = 800, radius = 320, factor = Math.PI * 0.5 / radius;\n\t\t\t\tconst data = new Float32Array( 4 * size * size );\n\n\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\tconst idx = i * size * 4 + j * 4;\n\t\t\t\t\t\tcoord.set( j, i ).subScalar( size / 2 );\n\n\t\t\t\t\t\tif ( coord.length() < radius )\n\t\t\t\t\t\t\tnormal.set(\n\t\t\t\t\t\t\t\tMath.sin( coord.x * factor ),\n\t\t\t\t\t\t\t\tMath.sin( coord.y * factor ),\n\t\t\t\t\t\t\t\tMath.cos( coord.x * factor )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t\t\t\tdata[ idx + 0 ] = .5 + .5 * normal.x;\n\t\t\t\t\t\tdata[ idx + 1 ] = .5 + .5 * normal.y;\n\t\t\t\t\t\tdata[ idx + 2 ] = .5 + .5 * normal.z;\n\t\t\t\t\t\tdata[ idx + 3 ] = 1.;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdataTexture = new THREE.DataTexture( data, size, size, THREE.RGBAFormat, THREE.FloatType );\n\t\t\t\tdataTexture.needsUpdate = true;\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: dataTexture } );\n\t\t\t\tconst quad = new THREE.PlaneGeometry( 50, 50 );\n\t\t\t\tmesh = new THREE.Mesh( quad, material );\n\t\t\t\tmesh.visible = false;\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction swapScene() {\n\n\t\t\t\tif ( params.target == 'pmrem' ) {\n\n\t\t\t\t\tcamera.position.set( 10, 0, 0 );\n\t\t\t\t\tcontrols.enabled = true;\n\t\t\t\t\tscene.background = renderTarget.texture;\n\t\t\t\t\tmesh.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcamera.position.set( 0, 0, 70 );\n\t\t\t\t\tcontrols.enabled = false;\n\t\t\t\t\tscene.background = new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tmesh.visible = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tasync function exportFile() {\n\n\t\t\t\tlet result, exportType, exportCompression;\n\n\t\t\t\tif ( params.type == 'HalfFloatType' )\n\t\t\t\t\texportType = THREE.HalfFloatType;\n\t\t\t\telse\n\t\t\t\t\texportType = THREE.FloatType;\n\n\t\t\t\tif ( params.compression == 'ZIP' )\n\t\t\t\t\texportCompression = ZIP_COMPRESSION;\n\t\t\t\telse if ( params.compression == 'ZIPS' )\n\t\t\t\t\texportCompression = ZIPS_COMPRESSION;\n\t\t\t\telse\n\t\t\t\t\texportCompression = NO_COMPRESSION;\n\n\t\t\t\tif ( params.target == 'pmrem' )\n\t\t\t\t\tresult = await exporter.parse( renderer, renderTarget, { type: exportType, compression: exportCompression } );\n\t\t\t\telse\n\t\t\t\t\tresult = await exporter.parse( dataTexture, { type: exportType, compression: exportCompression } );\n\n\t\t\t\tsaveArrayBuffer( result, params.target + '.exr' );\n\n\t\t\t}\n\n\t\t\tfunction saveArrayBuffer( buffer, filename ) {\n\n\t\t\t\tconst blob = new Blob( [ buffer ], { type: 'image/x-exr' } );\n\t\t\t\tconst link = document.createElement( 'a' );\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - exr"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates webgl - exporter - ktx2"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js webgl - exporter - ktx2:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { KTX2Exporter } from 'three/addons/exporters/KTX2Exporter.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, renderer, exporter, mesh, controls, renderTarget, dataTexture;\n\n\t\t\tconst params = {\n\t\t\t\ttarget: 'pmrem',\n\t\t\t\texport: exportFile\n\t\t\t};\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.toneMapping = THREE.AgXToneMapping;\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.set( 10, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\texporter = new KTX2Exporter();\n\t\t\t\tconst rgbeloader = new RGBELoader();\n\n\t\t\t\t//\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tpmremGenerator.compileEquirectangularShader();\n\n\t\t\t\trgbeloader.load( 'textures/equirectangular/venice_sunset_1k.hdr', function ( texture ) {\n\n\t\t\t\t\ttexture.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\t\trenderTarget = pmremGenerator.fromEquirectangular( texture );\n\t\t\t\t\tscene.background = renderTarget.texture;\n\n\t\t\t\t} );\n\n\t\t\t\tcreateDataTexture();\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.enableDamping = true;\n\t\t\t\tcontrols.rotateSpeed = - 0.25; // negative, to track mouse pointer\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'target' ).options( [ 'pmrem', 'data-texture' ] ).onChange( swapScene );\n\t\t\t\tgui.add( params, 'export' ).name( 'Export KTX2' );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tfunction createDataTexture() {\n\n\t\t\t\tconst normal = new THREE.Vector3();\n\t\t\t\tconst coord = new THREE.Vector2();\n\t\t\t\tconst size = 800, radius = 320, factor = Math.PI * 0.5 / radius;\n\t\t\t\tconst data = new Float32Array( 4 * size * size );\n\n\t\t\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\tconst idx = i * size * 4 + j * 4;\n\t\t\t\t\t\tcoord.set( j, i ).subScalar( size / 2 );\n\n\t\t\t\t\t\tif ( coord.length() < radius )\n\t\t\t\t\t\t\tnormal.set(\n\t\t\t\t\t\t\t\tMath.sin( coord.x * factor ),\n\t\t\t\t\t\t\t\tMath.sin( coord.y * factor ),\n\t\t\t\t\t\t\t\tMath.cos( coord.x * factor )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t\t\t\tdata[ idx + 0 ] = .5 + .5 * normal.x;\n\t\t\t\t\t\tdata[ idx + 1 ] = .5 + .5 * normal.y;\n\t\t\t\t\t\tdata[ idx + 2 ] = .5 + .5 * normal.z;\n\t\t\t\t\t\tdata[ idx + 3 ] = 1.;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdataTexture = new THREE.DataTexture( data, size, size, THREE.RGBAFormat, THREE.FloatType );\n\t\t\t\tdataTexture.needsUpdate = true;\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { map: dataTexture } );\n\t\t\t\tconst quad = new THREE.PlaneGeometry( 50, 50 );\n\t\t\t\tmesh = new THREE.Mesh( quad, material );\n\t\t\t\tmesh.visible = false;\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t}\n\n\t\t\tfunction swapScene() {\n\n\t\t\t\tif ( params.target == 'pmrem' ) {\n\n\t\t\t\t\tcamera.position.set( 10, 0, 0 );\n\t\t\t\t\tcontrols.enabled = true;\n\t\t\t\t\tscene.background = renderTarget.texture;\n\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\trenderer.toneMapping = THREE.AgXToneMapping;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcamera.position.set( 0, 0, 70 );\n\t\t\t\t\tcontrols.enabled = false;\n\t\t\t\t\tscene.background = new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tmesh.visible = true;\n\t\t\t\t\trenderer.toneMapping = THREE.NoToneMapping;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tasync function exportFile() {\n\n\t\t\t\tlet result;\n\n\t\t\t\tif ( params.target == 'pmrem' )\n\t\t\t\t\tresult = await exporter.parse( renderer, renderTarget );\n\t\t\t\telse\n\t\t\t\t\tresult = await exporter.parse( dataTexture );\n\n\t\t\t\tsaveArrayBuffer( result, params.target + '.ktx2' );\n\n\t\t\t}\n\n\t\t\tfunction saveArrayBuffer( buffer, filename ) {\n\n\t\t\t\tconst blob = new Blob( [ buffer ], { type: 'image/ktx2' } );\n\t\t\t\tconst link = document.createElement( 'a' );\n\n\t\t\t\tlink.href = URL.createObjectURL( blob );\n\t\t\t\tlink.download = filename;\n\t\t\t\tlink.click();\n\n\t\t\t}\n```\n\nThis example three.js webgl - exporter - ktx2"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates misc - raycaster - helper"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js misc - raycaster - helper:\n\n```javascript\nimport * as THREE from 'three';\n\t\t\timport { RaycasterHelper } from 'https://cdn.jsdelivr.net/npm/@gsimone/three-raycaster-helper@0.1.0/dist/gsimone-three-raycaster-helper.esm.js';\n\n\t\t\tlet scene, renderer;\n\t\t\tlet camera;\n\n\t\t\tlet capsule1, capsule2, capsule3;\n\t\t\tlet raycaster, raycasterHelper;\n\n\t\t\tinit();\n\n\t\t\tfunction init() {\n\n\t\t\t\trenderer = new THREE.WebGPURenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setAnimationLoop( animate );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t//\n\n\t\t\t\tconst geometry = new THREE.CapsuleGeometry( 0.5, 0.5, 4, 32 );\n\t\t\t\tconst material = new THREE.MeshNormalMaterial();\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\n\t\t\t\tcapsule1 = new THREE.Mesh( geometry, material );\n\t\t\t\tcapsule1.position.x = - 2;\n\t\t\t\tcapsule2 = new THREE.Mesh( geometry, material );\n\t\t\t\tcapsule2.position.x = 0;\n\t\t\t\tcapsule3 = new THREE.Mesh( geometry, material );\n\t\t\t\tcapsule3.position.x = 2;\n\n\t\t\t\tscene.add( capsule1 );\n\t\t\t\tscene.add( capsule2 );\n\t\t\t\tscene.add( capsule3 );\n\n\t\t\t\traycaster = new THREE.Raycaster( new THREE.Vector3( - 4, 0, 0 ), new THREE.Vector3( 1, 0, 0 ) );\n\t\t\t\traycaster.near = 1;\n\t\t\t\traycaster.far = 8;\n\t\t\t\traycasterHelper = new RaycasterHelper( raycaster );\n\t\t\t\tscene.add( raycasterHelper );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate( time ) {\n\n\t\t\t\tconst elapsedTime = time / 1000; // ms to s\n\n\t\t\t\t[ capsule1, capsule2, capsule3 ].forEach( capsule => {\n\n\t\t\t\t\tcapsule.position.y = Math.sin( elapsedTime * 0.5 + capsule.position.x );\n\t\t\t\t\tcapsule.rotation.z = Math.sin( elapsedTime * 0.5 ) * Math.PI * 1;\n\n\t\t\t\t} );\n\n\t\t\t\traycasterHelper.hits = raycaster.intersectObjects( scene.children );\n\t\t\t\traycasterHelper.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js - raycaster - helper See external RaycasterHelper for more information."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates css2d - label"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js css2d - label:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet gui;\n\n\t\t\tlet camera, scene, renderer, labelRenderer;\n\n\t\t\tconst layers = {\n\n\t\t\t\t'Toggle Name': function () {\n\n\t\t\t\t\tcamera.layers.toggle( 0 );\n\n\t\t\t\t},\n\t\t\t\t'Toggle Mass': function () {\n\n\t\t\t\t\tcamera.layers.toggle( 1 );\n\n\t\t\t\t},\n\t\t\t\t'Enable All': function () {\n\n\t\t\t\t\tcamera.layers.enableAll();\n\n\t\t\t\t},\n\n\t\t\t\t'Disable All': function () {\n\n\t\t\t\t\tcamera.layers.disableAll();\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst clock = new THREE.Clock();\n\t\t\tconst textureLoader = new THREE.TextureLoader();\n\n\t\t\tlet moon;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst EARTH_RADIUS = 1;\n\t\t\t\tconst MOON_RADIUS = 0.27;\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );\n\t\t\t\tcamera.position.set( 10, 5, 20 );\n\t\t\t\tcamera.layers.enableAll();\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst dirLight = new THREE.DirectionalLight( 0xffffff, 3 );\n\t\t\t\tdirLight.position.set( 0, 0, 1 );\n\t\t\t\tdirLight.layers.enableAll();\n\t\t\t\tscene.add( dirLight );\n\n\t\t\t\tconst axesHelper = new THREE.AxesHelper( 5 );\n\t\t\t\taxesHelper.layers.enableAll();\n\t\t\t\tscene.add( axesHelper );\n\n\t\t\t\t//\n\n\t\t\t\tconst earthGeometry = new THREE.SphereGeometry( EARTH_RADIUS, 16, 16 );\n\t\t\t\tconst earthMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tspecular: 0x333333,\n\t\t\t\t\tshininess: 5,\n\t\t\t\t\tmap: textureLoader.load( 'textures/planets/earth_atmos_2048.jpg' ),\n\t\t\t\t\tspecularMap: textureLoader.load( 'textures/planets/earth_specular_2048.jpg' ),\n\t\t\t\t\tnormalMap: textureLoader.load( 'textures/planets/earth_normal_2048.jpg' ),\n\t\t\t\t\tnormalScale: new THREE.Vector2( 0.85, 0.85 )\n\t\t\t\t} );\n\t\t\t\tearthMaterial.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tconst earth = new THREE.Mesh( earthGeometry, earthMaterial );\n\t\t\t\tscene.add( earth );\n\n\t\t\t\tconst moonGeometry = new THREE.SphereGeometry( MOON_RADIUS, 16, 16 );\n\t\t\t\tconst moonMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tshininess: 5,\n\t\t\t\t\tmap: textureLoader.load( 'textures/planets/moon_1024.jpg' )\n\t\t\t\t} );\n\t\t\t\tmoonMaterial.map.colorSpace = THREE.SRGBColorSpace;\n\t\t\t\tmoon = new THREE.Mesh( moonGeometry, moonMaterial );\n\t\t\t\tscene.add( moon );\n\n\t\t\t\t//\n\n\t\t\t\tearth.layers.enableAll();\n\t\t\t\tmoon.layers.enableAll();\n\n\t\t\t\tconst earthDiv = document.createElement( 'div' );\n\t\t\t\tearthDiv.className = 'label';\n\t\t\t\tearthDiv.textContent = 'Earth';\n\t\t\t\tearthDiv.style.backgroundColor = 'transparent';\n\n\t\t\t\tconst earthLabel = new CSS2DObject( earthDiv );\n\t\t\t\tearthLabel.position.set( 1.5 * EARTH_RADIUS, 0, 0 );\n\t\t\t\tearthLabel.center.set( 0, 1 );\n\t\t\t\tearth.add( earthLabel );\n\t\t\t\tearthLabel.layers.set( 0 );\n\n\t\t\t\tconst earthMassDiv = document.createElement( 'div' );\n\t\t\t\tearthMassDiv.className = 'label';\n\t\t\t\tearthMassDiv.textContent = '5.97237e24 kg';\n\t\t\t\tearthMassDiv.style.backgroundColor = 'transparent';\n\n\t\t\t\tconst earthMassLabel = new CSS2DObject( earthMassDiv );\n\t\t\t\tearthMassLabel.position.set( 1.5 * EARTH_RADIUS, 0, 0 );\n\t\t\t\tearthMassLabel.center.set( 0, 0 );\n\t\t\t\tearth.add( earthMassLabel );\n\t\t\t\tearthMassLabel.layers.set( 1 );\n\n\t\t\t\tconst moonDiv = document.createElement( 'div' );\n\t\t\t\tmoonDiv.className = 'label';\n\t\t\t\tmoonDiv.textContent = 'Moon';\n\t\t\t\tmoonDiv.style.backgroundColor = 'transparent';\n\n\t\t\t\tconst moonLabel = new CSS2DObject( moonDiv );\n\t\t\t\tmoonLabel.position.set( 1.5 * MOON_RADIUS, 0, 0 );\n\t\t\t\tmoonLabel.center.set( 0, 1 );\n\t\t\t\tmoon.add( moonLabel );\n\t\t\t\tmoonLabel.layers.set( 0 );\n\n\t\t\t\tconst moonMassDiv = document.createElement( 'div' );\n\t\t\t\tmoonMassDiv.className = 'label';\n\t\t\t\tmoonMassDiv.textContent = '7.342e22 kg';\n\t\t\t\tmoonMassDiv.style.backgroundColor = 'transparent';\n\n\t\t\t\tconst moonMassLabel = new CSS2DObject( moonMassDiv );\n\t\t\t\tmoonMassLabel.position.set( 1.5 * MOON_RADIUS, 0, 0 );\n\t\t\t\tmoonMassLabel.center.set( 0, 0 );\n\t\t\t\tmoon.add( moonMassLabel );\n\t\t\t\tmoonMassLabel.layers.set( 1 );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tlabelRenderer = new CSS2DRenderer();\n\t\t\t\tlabelRenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tlabelRenderer.domElement.style.position = 'absolute';\n\t\t\t\tlabelRenderer.domElement.style.top = '0px';\n\t\t\t\tdocument.body.appendChild( labelRenderer.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, labelRenderer.domElement );\n\t\t\t\tcontrols.minDistance = 5;\n\t\t\t\tcontrols.maxDistance = 100;\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tinitGui();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\tlabelRenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\tconst elapsed = clock.getElapsedTime();\n\n\t\t\t\tmoon.position.set( Math.sin( elapsed ) * 5, 0, Math.cos( elapsed ) * 5 );\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\tlabelRenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction initGui() {\n\n\t\t\t\tgui = new GUI();\n\n\t\t\t\tgui.title( 'Camera Layers' );\n\n\t\t\t\tgui.add( layers, 'Toggle Name' );\n\t\t\t\tgui.add( layers, 'Toggle Mass' );\n\t\t\t\tgui.add( layers, 'Enable All' );\n\t\t\t\tgui.add( layers, 'Disable All' );\n\n\t\t\t\tgui.open();\n\n\t\t\t}\n```\n\nThis example three.js css2d - label"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates css3d - molecules"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js css3d - molecules:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { PDBLoader } from 'three/addons/loaders/PDBLoader.js';\n\t\t\timport { CSS3DRenderer, CSS3DObject, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\t\t\tlet root;\n\n\t\t\tconst objects = [];\n\t\t\tconst tmpVec1 = new THREE.Vector3();\n\t\t\tconst tmpVec2 = new THREE.Vector3();\n\t\t\tconst tmpVec3 = new THREE.Vector3();\n\t\t\tconst tmpVec4 = new THREE.Vector3();\n\t\t\tconst offset = new THREE.Vector3();\n\n\t\t\tconst VIZ_TYPE = {\n\t\t\t\t'Atoms': 0,\n\t\t\t\t'Bonds': 1,\n\t\t\t\t'Atoms + Bonds': 2\n\t\t\t};\n\n\t\t\tconst MOLECULES = {\n\t\t\t\t'Ethanol': 'ethanol.pdb',\n\t\t\t\t'Aspirin': 'aspirin.pdb',\n\t\t\t\t'Caffeine': 'caffeine.pdb',\n\t\t\t\t'Nicotine': 'nicotine.pdb',\n\t\t\t\t'LSD': 'lsd.pdb',\n\t\t\t\t'Cocaine': 'cocaine.pdb',\n\t\t\t\t'Cholesterol': 'cholesterol.pdb',\n\t\t\t\t'Lycopene': 'lycopene.pdb',\n\t\t\t\t'Glucose': 'glucose.pdb',\n\t\t\t\t'Aluminium oxide': 'Al2O3.pdb',\n\t\t\t\t'Cubane': 'cubane.pdb',\n\t\t\t\t'Copper': 'cu.pdb',\n\t\t\t\t'Fluorite': 'caf2.pdb',\n\t\t\t\t'Salt': 'nacl.pdb',\n\t\t\t\t'YBCO superconductor': 'ybco.pdb',\n\t\t\t\t'Buckyball': 'buckyball.pdb',\n\t\t\t\t// 'Diamond': 'diamond.pdb',\n\t\t\t\t'Graphite': 'graphite.pdb'\n\t\t\t};\n\n\t\t\tconst params = {\n\t\t\t\tvizType: 2,\n\t\t\t\tmolecule: 'caffeine.pdb'\n\t\t\t};\n\n\t\t\tconst loader = new PDBLoader();\n\t\t\tconst colorSpriteMap = {};\n\t\t\tconst baseSprite = document.createElement( 'img' );\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.z = 1000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\troot = new THREE.Object3D();\n\t\t\t\tscene.add( root );\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new CSS3DRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.getElementById( 'container' ).appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.rotateSpeed = 0.5;\n\n\t\t\t\t//\n\n\t\t\t\tbaseSprite.onload = function () {\n\n\t\t\t\t\tloadMolecule( params.molecule );\n\n\t\t\t\t};\n\n\t\t\t\tbaseSprite.src = 'textures/sprites/ball.png';\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t//\n\n\t\t\t\tconst gui = new GUI();\n\n\t\t\t\tgui.add( params, 'vizType', VIZ_TYPE ).onChange( changeVizType );\n\t\t\t\tgui.add( params, 'molecule', MOLECULES ).onChange( loadMolecule );\n\t\t\t\tgui.open();\n\n\t\t\t}\n\n\t\t\tfunction changeVizType( value ) {\n\n\t\t\t\tif ( value === 0 ) showAtoms();\n\t\t\t\telse if ( value === 1 ) showBonds();\n\t\t\t\telse showAtomsBonds();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction showAtoms() {\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tif ( object instanceof CSS3DSprite ) {\n\n\t\t\t\t\t\tobject.element.style.display = '';\n\t\t\t\t\t\tobject.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.element.style.display = 'none';\n\t\t\t\t\t\tobject.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction showBonds() {\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tif ( object instanceof CSS3DSprite ) {\n\n\t\t\t\t\t\tobject.element.style.display = 'none';\n\t\t\t\t\t\tobject.visible = false;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.element.style.display = '';\n\t\t\t\t\t\tobject.element.style.height = object.userData.bondLengthFull;\n\t\t\t\t\t\tobject.visible = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction showAtomsBonds() {\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tobject.element.style.display = '';\n\t\t\t\t\tobject.visible = true;\n\n\t\t\t\t\tif ( ! ( object instanceof CSS3DSprite ) ) {\n\n\t\t\t\t\t\tobject.element.style.height = object.userData.bondLengthShort;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction colorify( ctx, width, height, color ) {\n\n\t\t\t\tconst r = color.r, g = color.g, b = color.b;\n\n\t\t\t\tconst imageData = ctx.getImageData( 0, 0, width, height );\n\t\t\t\tconst data = imageData.data;\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] *= r;\n\t\t\t\t\tdata[ i + 1 ] *= g;\n\t\t\t\t\tdata[ i + 2 ] *= b;\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( imageData, 0, 0 );\n\n\t\t\t}\n\n\t\t\tfunction imageToCanvas( image ) {\n\n\t\t\t\tconst width = image.width;\n\t\t\t\tconst height = image.height;\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction loadMolecule( model ) {\n\n\t\t\t\tconst url = 'models/pdb/' + model;\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobjects.length = 0;\n\n\t\t\t\tloader.load( url, function ( pdb ) {\n\n\t\t\t\t\tconst geometryAtoms = pdb.geometryAtoms;\n\t\t\t\t\tconst geometryBonds = pdb.geometryBonds;\n\t\t\t\t\tconst json = pdb.json;\n\n\t\t\t\t\tgeometryAtoms.computeBoundingBox();\n\t\t\t\t\tgeometryAtoms.boundingBox.getCenter( offset ).negate();\n\n\t\t\t\t\tgeometryAtoms.translate( offset.x, offset.y, offset.z );\n\t\t\t\t\tgeometryBonds.translate( offset.x, offset.y, offset.z );\n\n\t\t\t\t\tconst positionAtoms = geometryAtoms.getAttribute( 'position' );\n\t\t\t\t\tconst colorAtoms = geometryAtoms.getAttribute( 'color' );\n\n\t\t\t\t\tconst position = new THREE.Vector3();\n\t\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\t\tfor ( let i = 0; i < positionAtoms.count; i ++ ) {\n\n\t\t\t\t\t\tposition.fromBufferAttribute( positionAtoms, i );\n\t\t\t\t\t\tcolor.fromBufferAttribute( colorAtoms, i );\n\n\t\t\t\t\t\tconst atomJSON = json.atoms[ i ];\n\t\t\t\t\t\tconst element = atomJSON[ 4 ];\n\n\t\t\t\t\t\tif ( ! colorSpriteMap[ element ] ) {\n\n\t\t\t\t\t\t\tconst canvas = imageToCanvas( baseSprite );\n\t\t\t\t\t\t\tconst context = canvas.getContext( '2d' );\n\n\t\t\t\t\t\t\tcolorify( context, canvas.width, canvas.height, color );\n\n\t\t\t\t\t\t\tconst dataUrl = canvas.toDataURL();\n\n\t\t\t\t\t\t\tcolorSpriteMap[ element ] = dataUrl;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst colorSprite = colorSpriteMap[ element ];\n\n\t\t\t\t\t\tconst atom = document.createElement( 'img' );\n\t\t\t\t\t\tatom.src = colorSprite;\n\n\t\t\t\t\t\tconst object = new CSS3DSprite( atom );\n\t\t\t\t\t\tobject.position.copy( position );\n\t\t\t\t\t\tobject.position.multiplyScalar( 75 );\n\n\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\t\troot.add( object );\n\n\t\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst positionBonds = geometryBonds.getAttribute( 'position' );\n\n\t\t\t\t\tconst start = new THREE.Vector3();\n\t\t\t\t\tconst end = new THREE.Vector3();\n\n\t\t\t\t\tfor ( let i = 0; i < positionBonds.count; i += 2 ) {\n\n\t\t\t\t\t\tstart.fromBufferAttribute( positionBonds, i );\n\t\t\t\t\t\tend.fromBufferAttribute( positionBonds, i + 1 );\n\n\t\t\t\t\t\tstart.multiplyScalar( 75 );\n\t\t\t\t\t\tend.multiplyScalar( 75 );\n\n\t\t\t\t\t\ttmpVec1.subVectors( end, start );\n\t\t\t\t\t\tconst bondLength = tmpVec1.length() - 50;\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tlet bond = document.createElement( 'div' );\n\t\t\t\t\t\tbond.className = 'bond';\n\t\t\t\t\t\tbond.style.height = bondLength + 'px';\n\n\t\t\t\t\t\tlet object = new CSS3DObject( bond );\n\t\t\t\t\t\tobject.position.copy( start );\n\t\t\t\t\t\tobject.position.lerp( end, 0.5 );\n\n\t\t\t\t\t\tobject.userData.bondLengthShort = bondLength + 'px';\n\t\t\t\t\t\tobject.userData.bondLengthFull = ( bondLength + 55 ) + 'px';\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tconst axis = tmpVec2.set( 0, 1, 0 ).cross( tmpVec1 );\n\t\t\t\t\t\tconst radians = Math.acos( tmpVec3.set( 0, 1, 0 ).dot( tmpVec4.copy( tmpVec1 ).normalize() ) );\n\n\t\t\t\t\t\tconst objMatrix = new THREE.Matrix4().makeRotationAxis( axis.normalize(), radians );\n\t\t\t\t\t\tobject.matrix.copy( objMatrix );\n\t\t\t\t\t\tobject.quaternion.setFromRotationMatrix( object.matrix );\n\n\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\t\troot.add( object );\n\n\t\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tconst joint = new THREE.Object3D();\n\t\t\t\t\t\tjoint.position.copy( start );\n\t\t\t\t\t\tjoint.position.lerp( end, 0.5 );\n\n\t\t\t\t\t\tjoint.matrix.copy( objMatrix );\n\t\t\t\t\t\tjoint.quaternion.setFromRotationMatrix( joint.matrix );\n\n\t\t\t\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\t\t\t\tjoint.updateMatrix();\n\n\t\t\t\t\t\tbond = document.createElement( 'div' );\n\t\t\t\t\t\tbond.className = 'bond';\n\t\t\t\t\t\tbond.style.height = bondLength + 'px';\n\n\t\t\t\t\t\tobject = new CSS3DObject( bond );\n\t\t\t\t\t\tobject.rotation.y = Math.PI / 2;\n\n\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\t\tobject.userData.bondLengthShort = bondLength + 'px';\n\t\t\t\t\t\tobject.userData.bondLengthFull = ( bondLength + 55 ) + 'px';\n\n\t\t\t\t\t\tobject.userData.joint = joint;\n\n\t\t\t\t\t\tjoint.add( object );\n\t\t\t\t\t\troot.add( joint );\n\n\t\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//console.log( \"CSS3DObjects:\", objects.length );\n\n\t\t\t\t\tchangeVizType( params.vizType );\n\n\t\t\t\t} );\n\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst time = Date.now() * 0.0004;\n\n\t\t\t\troot.rotation.x = time;\n\t\t\t\troot.rotation.y = time * 0.7;\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js css3d - molecules"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates css3d - orthographic"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js css3d - orthographic:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet scene2, renderer2;\n\n\t\t\tconst frustumSize = 500;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );\n\n\t\t\t\tcamera.position.set( - 200, 200, 200 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tscene2 = new THREE.Scene();\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, wireframeLinewidth: 1, side: THREE.DoubleSide } );\n\n\t\t\t\t// left\n\t\t\t\tcreatePlane(\n\t\t\t\t\t100, 100,\n\t\t\t\t\t'chocolate',\n\t\t\t\t\tnew THREE.Vector3( - 50, 0, 0 ),\n\t\t\t\t\tnew THREE.Euler( 0, - 90 * THREE.MathUtils.DEG2RAD, 0 )\n\t\t\t\t);\n\t\t\t\t// right\n\t\t\t\tcreatePlane(\n\t\t\t\t\t100, 100,\n\t\t\t\t\t'saddlebrown',\n\t\t\t\t\tnew THREE.Vector3( 0, 0, 50 ),\n\t\t\t\t\tnew THREE.Euler( 0, 0, 0 )\n\t\t\t\t);\n\t\t\t\t// top\n\t\t\t\tcreatePlane(\n\t\t\t\t\t100, 100,\n\t\t\t\t\t'yellowgreen',\n\t\t\t\t\tnew THREE.Vector3( 0, 50, 0 ),\n\t\t\t\t\tnew THREE.Euler( - 90 * THREE.MathUtils.DEG2RAD, 0, 0 )\n\t\t\t\t);\n\t\t\t\t// bottom\n\t\t\t\tcreatePlane(\n\t\t\t\t\t300, 300,\n\t\t\t\t\t'seagreen',\n\t\t\t\t\tnew THREE.Vector3( 0, - 50, 0 ),\n\t\t\t\t\tnew THREE.Euler( - 90 * THREE.MathUtils.DEG2RAD, 0, 0 )\n\t\t\t\t);\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer2 = new CSS3DRenderer();\n\t\t\t\trenderer2.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer2.domElement.style.position = 'absolute';\n\t\t\t\trenderer2.domElement.style.top = 0;\n\t\t\t\tdocument.body.appendChild( renderer2.domElement );\n\n\t\t\t\tconst controls = new OrbitControls( camera, renderer2.domElement );\n\t\t\t\tcontrols.minZoom = 0.5;\n\t\t\t\tcontrols.maxZoom = 2;\n\n\t\t\t\tfunction createPlane( width, height, cssColor, pos, rot ) {\n\n\t\t\t\t\tconst element = document.createElement( 'div' );\n\t\t\t\t\telement.style.width = width + 'px';\n\t\t\t\t\telement.style.height = height + 'px';\n\t\t\t\t\telement.style.opacity = 0.75;\n\t\t\t\t\telement.style.background = cssColor;\n\n\t\t\t\t\tconst object = new CSS3DObject( element );\n\t\t\t\t\tobject.position.copy( pos );\n\t\t\t\t\tobject.rotation.copy( rot );\n\t\t\t\t\tscene2.add( object );\n\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( width, height );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.copy( object.position );\n\t\t\t\t\tmesh.rotation.copy( object.rotation );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tcreatePanel();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.left = - frustumSize * aspect / 2;\n\t\t\t\tcamera.right = frustumSize * aspect / 2;\n\t\t\t\tcamera.top = frustumSize / 2;\n\t\t\t\tcamera.bottom = - frustumSize / 2;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trenderer2.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer2.render( scene2, camera );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI();\n\t\t\t\tconst folder1 = panel.addFolder( 'camera setViewOffset' ).close();\n\n\t\t\t\tconst settings = {\n\t\t\t\t\t'setViewOffset'() {\n\n\t\t\t\t\t\tfolder1.children[ 1 ].enable().setValue( window.innerWidth );\n\t\t\t\t\t\tfolder1.children[ 2 ].enable().setValue( window.innerHeight );\n\t\t\t\t\t\tfolder1.children[ 3 ].enable().setValue( 0 );\n\t\t\t\t\t\tfolder1.children[ 4 ].enable().setValue( 0 );\n\t\t\t\t\t\tfolder1.children[ 5 ].enable().setValue( window.innerWidth );\n\t\t\t\t\t\tfolder1.children[ 6 ].enable().setValue( window.innerHeight );\n\n\t\t\t\t\t},\n\t\t\t\t\t'fullWidth': 0,\n\t\t\t\t\t'fullHeight': 0,\n\t\t\t\t\t'offsetX': 0,\n\t\t\t\t\t'offsetY': 0,\n\t\t\t\t\t'width': 0,\n\t\t\t\t\t'height': 0,\n\t\t\t\t\t'clearViewOffset'() {\n\n\t\t\t\t\t\tfolder1.children[ 1 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 2 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 3 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 4 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 5 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 6 ].setValue( 0 ).disable();\n\t\t\t\t\t\tcamera.clearViewOffset();\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfolder1.add( settings, 'setViewOffset' );\n\t\t\t\tfolder1.add( settings, 'fullWidth', window.screen.width / 4, window.screen.width * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { fullWidth: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'fullHeight', window.screen.height / 4, window.screen.height * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { fullHeight: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'offsetX', 0, 256, 1 ).onChange( ( val ) => updateCameraViewOffset( { x: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'offsetY', 0, 256, 1 ).onChange( ( val ) => updateCameraViewOffset( { y: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'width', window.screen.width / 4, window.screen.width * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { width: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'height', window.screen.height / 4, window.screen.height * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { height: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'clearViewOffset' );\n\n\t\t\t}\n\n\t\t\tfunction updateCameraViewOffset( { fullWidth, fullHeight, x, y, width, height } ) {\n\n\t\t\t\tif ( ! camera.view ) {\n\n\t\t\t\t\tcamera.setViewOffset( fullWidth || window.innerWidth, fullHeight || window.innerHeight, x || 0, y || 0, width || window.innerWidth, height || window.innerHeight );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcamera.setViewOffset( fullWidth || camera.view.fullWidth, fullHeight || camera.view.fullHeight, x || camera.view.offsetX, y || camera.view.offsetY, width || camera.view.width, height || camera.view.height );\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js css3d - orthographic"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates css3d - periodic table"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js css3d - periodic table:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';\n\n\t\t\tconst table = [\n\t\t\t\t'H', 'Hydrogen', '1.00794', 1, 1,\n\t\t\t\t'He', 'Helium', '4.002602', 18, 1,\n\t\t\t\t'Li', 'Lithium', '6.941', 1, 2,\n\t\t\t\t'Be', 'Beryllium', '9.012182', 2, 2,\n\t\t\t\t'B', 'Boron', '10.811', 13, 2,\n\t\t\t\t'C', 'Carbon', '12.0107', 14, 2,\n\t\t\t\t'N', 'Nitrogen', '14.0067', 15, 2,\n\t\t\t\t'O', 'Oxygen', '15.9994', 16, 2,\n\t\t\t\t'F', 'Fluorine', '18.9984032', 17, 2,\n\t\t\t\t'Ne', 'Neon', '20.1797', 18, 2,\n\t\t\t\t'Na', 'Sodium', '22.98976...', 1, 3,\n\t\t\t\t'Mg', 'Magnesium', '24.305', 2, 3,\n\t\t\t\t'Al', 'Aluminium', '26.9815386', 13, 3,\n\t\t\t\t'Si', 'Silicon', '28.0855', 14, 3,\n\t\t\t\t'P', 'Phosphorus', '30.973762', 15, 3,\n\t\t\t\t'S', 'Sulfur', '32.065', 16, 3,\n\t\t\t\t'Cl', 'Chlorine', '35.453', 17, 3,\n\t\t\t\t'Ar', 'Argon', '39.948', 18, 3,\n\t\t\t\t'K', 'Potassium', '39.948', 1, 4,\n\t\t\t\t'Ca', 'Calcium', '40.078', 2, 4,\n\t\t\t\t'Sc', 'Scandium', '44.955912', 3, 4,\n\t\t\t\t'Ti', 'Titanium', '47.867', 4, 4,\n\t\t\t\t'V', 'Vanadium', '50.9415', 5, 4,\n\t\t\t\t'Cr', 'Chromium', '51.9961', 6, 4,\n\t\t\t\t'Mn', 'Manganese', '54.938045', 7, 4,\n\t\t\t\t'Fe', 'Iron', '55.845', 8, 4,\n\t\t\t\t'Co', 'Cobalt', '58.933195', 9, 4,\n\t\t\t\t'Ni', 'Nickel', '58.6934', 10, 4,\n\t\t\t\t'Cu', 'Copper', '63.546', 11, 4,\n\t\t\t\t'Zn', 'Zinc', '65.38', 12, 4,\n\t\t\t\t'Ga', 'Gallium', '69.723', 13, 4,\n\t\t\t\t'Ge', 'Germanium', '72.63', 14, 4,\n\t\t\t\t'As', 'Arsenic', '74.9216', 15, 4,\n\t\t\t\t'Se', 'Selenium', '78.96', 16, 4,\n\t\t\t\t'Br', 'Bromine', '79.904', 17, 4,\n\t\t\t\t'Kr', 'Krypton', '83.798', 18, 4,\n\t\t\t\t'Rb', 'Rubidium', '85.4678', 1, 5,\n\t\t\t\t'Sr', 'Strontium', '87.62', 2, 5,\n\t\t\t\t'Y', 'Yttrium', '88.90585', 3, 5,\n\t\t\t\t'Zr', 'Zirconium', '91.224', 4, 5,\n\t\t\t\t'Nb', 'Niobium', '92.90628', 5, 5,\n\t\t\t\t'Mo', 'Molybdenum', '95.96', 6, 5,\n\t\t\t\t'Tc', 'Technetium', '(98)', 7, 5,\n\t\t\t\t'Ru', 'Ruthenium', '101.07', 8, 5,\n\t\t\t\t'Rh', 'Rhodium', '102.9055', 9, 5,\n\t\t\t\t'Pd', 'Palladium', '106.42', 10, 5,\n\t\t\t\t'Ag', 'Silver', '107.8682', 11, 5,\n\t\t\t\t'Cd', 'Cadmium', '112.411', 12, 5,\n\t\t\t\t'In', 'Indium', '114.818', 13, 5,\n\t\t\t\t'Sn', 'Tin', '118.71', 14, 5,\n\t\t\t\t'Sb', 'Antimony', '121.76', 15, 5,\n\t\t\t\t'Te', 'Tellurium', '127.6', 16, 5,\n\t\t\t\t'I', 'Iodine', '126.90447', 17, 5,\n\t\t\t\t'Xe', 'Xenon', '131.293', 18, 5,\n\t\t\t\t'Cs', 'Caesium', '132.9054', 1, 6,\n\t\t\t\t'Ba', 'Barium', '132.9054', 2, 6,\n\t\t\t\t'La', 'Lanthanum', '138.90547', 4, 9,\n\t\t\t\t'Ce', 'Cerium', '140.116', 5, 9,\n\t\t\t\t'Pr', 'Praseodymium', '140.90765', 6, 9,\n\t\t\t\t'Nd', 'Neodymium', '144.242', 7, 9,\n\t\t\t\t'Pm', 'Promethium', '(145)', 8, 9,\n\t\t\t\t'Sm', 'Samarium', '150.36', 9, 9,\n\t\t\t\t'Eu', 'Europium', '151.964', 10, 9,\n\t\t\t\t'Gd', 'Gadolinium', '157.25', 11, 9,\n\t\t\t\t'Tb', 'Terbium', '158.92535', 12, 9,\n\t\t\t\t'Dy', 'Dysprosium', '162.5', 13, 9,\n\t\t\t\t'Ho', 'Holmium', '164.93032', 14, 9,\n\t\t\t\t'Er', 'Erbium', '167.259', 15, 9,\n\t\t\t\t'Tm', 'Thulium', '168.93421', 16, 9,\n\t\t\t\t'Yb', 'Ytterbium', '173.054', 17, 9,\n\t\t\t\t'Lu', 'Lutetium', '174.9668', 18, 9,\n\t\t\t\t'Hf', 'Hafnium', '178.49', 4, 6,\n\t\t\t\t'Ta', 'Tantalum', '180.94788', 5, 6,\n\t\t\t\t'W', 'Tungsten', '183.84', 6, 6,\n\t\t\t\t'Re', 'Rhenium', '186.207', 7, 6,\n\t\t\t\t'Os', 'Osmium', '190.23', 8, 6,\n\t\t\t\t'Ir', 'Iridium', '192.217', 9, 6,\n\t\t\t\t'Pt', 'Platinum', '195.084', 10, 6,\n\t\t\t\t'Au', 'Gold', '196.966569', 11, 6,\n\t\t\t\t'Hg', 'Mercury', '200.59', 12, 6,\n\t\t\t\t'Tl', 'Thallium', '204.3833', 13, 6,\n\t\t\t\t'Pb', 'Lead', '207.2', 14, 6,\n\t\t\t\t'Bi', 'Bismuth', '208.9804', 15, 6,\n\t\t\t\t'Po', 'Polonium', '(209)', 16, 6,\n\t\t\t\t'At', 'Astatine', '(210)', 17, 6,\n\t\t\t\t'Rn', 'Radon', '(222)', 18, 6,\n\t\t\t\t'Fr', 'Francium', '(223)', 1, 7,\n\t\t\t\t'Ra', 'Radium', '(226)', 2, 7,\n\t\t\t\t'Ac', 'Actinium', '(227)', 4, 10,\n\t\t\t\t'Th', 'Thorium', '232.03806', 5, 10,\n\t\t\t\t'Pa', 'Protactinium', '231.0588', 6, 10,\n\t\t\t\t'U', 'Uranium', '238.02891', 7, 10,\n\t\t\t\t'Np', 'Neptunium', '(237)', 8, 10,\n\t\t\t\t'Pu', 'Plutonium', '(244)', 9, 10,\n\t\t\t\t'Am', 'Americium', '(243)', 10, 10,\n\t\t\t\t'Cm', 'Curium', '(247)', 11, 10,\n\t\t\t\t'Bk', 'Berkelium', '(247)', 12, 10,\n\t\t\t\t'Cf', 'Californium', '(251)', 13, 10,\n\t\t\t\t'Es', 'Einstenium', '(252)', 14, 10,\n\t\t\t\t'Fm', 'Fermium', '(257)', 15, 10,\n\t\t\t\t'Md', 'Mendelevium', '(258)', 16, 10,\n\t\t\t\t'No', 'Nobelium', '(259)', 17, 10,\n\t\t\t\t'Lr', 'Lawrencium', '(262)', 18, 10,\n\t\t\t\t'Rf', 'Rutherfordium', '(267)', 4, 7,\n\t\t\t\t'Db', 'Dubnium', '(268)', 5, 7,\n\t\t\t\t'Sg', 'Seaborgium', '(271)', 6, 7,\n\t\t\t\t'Bh', 'Bohrium', '(272)', 7, 7,\n\t\t\t\t'Hs', 'Hassium', '(270)', 8, 7,\n\t\t\t\t'Mt', 'Meitnerium', '(276)', 9, 7,\n\t\t\t\t'Ds', 'Darmstadium', '(281)', 10, 7,\n\t\t\t\t'Rg', 'Roentgenium', '(280)', 11, 7,\n\t\t\t\t'Cn', 'Copernicium', '(285)', 12, 7,\n\t\t\t\t'Nh', 'Nihonium', '(286)', 13, 7,\n\t\t\t\t'Fl', 'Flerovium', '(289)', 14, 7,\n\t\t\t\t'Mc', 'Moscovium', '(290)', 15, 7,\n\t\t\t\t'Lv', 'Livermorium', '(293)', 16, 7,\n\t\t\t\t'Ts', 'Tennessine', '(294)', 17, 7,\n\t\t\t\t'Og', 'Oganesson', '(294)', 18, 7\n\t\t\t];\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tconst objects = [];\n\t\t\tconst targets = { table: [], sphere: [], helix: [], grid: [] };\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 3000;\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// table\n\n\t\t\t\tfor ( let i = 0; i < table.length; i += 5 ) {\n\n\t\t\t\t\tconst element = document.createElement( 'div' );\n\t\t\t\t\telement.className = 'element';\n\t\t\t\t\telement.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.5 + 0.25 ) + ')';\n\n\t\t\t\t\tconst number = document.createElement( 'div' );\n\t\t\t\t\tnumber.className = 'number';\n\t\t\t\t\tnumber.textContent = ( i / 5 ) + 1;\n\t\t\t\t\telement.appendChild( number );\n\n\t\t\t\t\tconst symbol = document.createElement( 'div' );\n\t\t\t\t\tsymbol.className = 'symbol';\n\t\t\t\t\tsymbol.textContent = table[ i ];\n\t\t\t\t\telement.appendChild( symbol );\n\n\t\t\t\t\tconst details = document.createElement( 'div' );\n\t\t\t\t\tdetails.className = 'details';\n\t\t\t\t\tdetails.innerHTML = table[ i + 1 ] + '<br>' + table[ i + 2 ];\n\t\t\t\t\telement.appendChild( details );\n\n\t\t\t\t\tconst objectCSS = new CSS3DObject( element );\n\t\t\t\t\tobjectCSS.position.x = Math.random() * 4000 - 2000;\n\t\t\t\t\tobjectCSS.position.y = Math.random() * 4000 - 2000;\n\t\t\t\t\tobjectCSS.position.z = Math.random() * 4000 - 2000;\n\t\t\t\t\tscene.add( objectCSS );\n\n\t\t\t\t\tobjects.push( objectCSS );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tconst object = new THREE.Object3D();\n\t\t\t\t\tobject.position.x = ( table[ i + 3 ] * 140 ) - 1330;\n\t\t\t\t\tobject.position.y = - ( table[ i + 4 ] * 180 ) + 990;\n\n\t\t\t\t\ttargets.table.push( object );\n\n\t\t\t\t}\n\n\t\t\t\t// sphere\n\n\t\t\t\tconst vector = new THREE.Vector3();\n\n\t\t\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst phi = Math.acos( - 1 + ( 2 * i ) / l );\n\t\t\t\t\tconst theta = Math.sqrt( l * Math.PI ) * phi;\n\n\t\t\t\t\tconst object = new THREE.Object3D();\n\n\t\t\t\t\tobject.position.setFromSphericalCoords( 800, phi, theta );\n\n\t\t\t\t\tvector.copy( object.position ).multiplyScalar( 2 );\n\n\t\t\t\t\tobject.lookAt( vector );\n\n\t\t\t\t\ttargets.sphere.push( object );\n\n\t\t\t\t}\n\n\t\t\t\t// helix\n\n\t\t\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst theta = i * 0.175 + Math.PI;\n\t\t\t\t\tconst y = - ( i * 8 ) + 450;\n\n\t\t\t\t\tconst object = new THREE.Object3D();\n\n\t\t\t\t\tobject.position.setFromCylindricalCoords( 900, theta, y );\n\n\t\t\t\t\tvector.x = object.position.x * 2;\n\t\t\t\t\tvector.y = object.position.y;\n\t\t\t\t\tvector.z = object.position.z * 2;\n\n\t\t\t\t\tobject.lookAt( vector );\n\n\t\t\t\t\ttargets.helix.push( object );\n\n\t\t\t\t}\n\n\t\t\t\t// grid\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tconst object = new THREE.Object3D();\n\n\t\t\t\t\tobject.position.x = ( ( i % 5 ) * 400 ) - 800;\n\t\t\t\t\tobject.position.y = ( - ( Math.floor( i / 5 ) % 5 ) * 400 ) + 800;\n\t\t\t\t\tobject.position.z = ( Math.floor( i / 25 ) ) * 1000 - 2000;\n\n\t\t\t\t\ttargets.grid.push( object );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new CSS3DRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.getElementById( 'container' ).appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.minDistance = 500;\n\t\t\t\tcontrols.maxDistance = 6000;\n\t\t\t\tcontrols.addEventListener( 'change', render );\n\n\t\t\t\tconst buttonTable = document.getElementById( 'table' );\n\t\t\t\tbuttonTable.addEventListener( 'click', function () {\n\n\t\t\t\t\ttransform( targets.table, 2000 );\n\n\t\t\t\t} );\n\n\t\t\t\tconst buttonSphere = document.getElementById( 'sphere' );\n\t\t\t\tbuttonSphere.addEventListener( 'click', function () {\n\n\t\t\t\t\ttransform( targets.sphere, 2000 );\n\n\t\t\t\t} );\n\n\t\t\t\tconst buttonHelix = document.getElementById( 'helix' );\n\t\t\t\tbuttonHelix.addEventListener( 'click', function () {\n\n\t\t\t\t\ttransform( targets.helix, 2000 );\n\n\t\t\t\t} );\n\n\t\t\t\tconst buttonGrid = document.getElementById( 'grid' );\n\t\t\t\tbuttonGrid.addEventListener( 'click', function () {\n\n\t\t\t\t\ttransform( targets.grid, 2000 );\n\n\t\t\t\t} );\n\n\t\t\t\ttransform( targets.table, 2000 );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction transform( targets, duration ) {\n\n\t\t\t\tTWEEN.removeAll();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\t\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\t\tnew TWEEN.Tween( object.position )\n\t\t\t\t\t\t.to( { x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration )\n\t\t\t\t\t\t.easing( TWEEN.Easing.Exponential.InOut )\n\t\t\t\t\t\t.start();\n\n\t\t\t\t\tnew TWEEN.Tween( object.rotation )\n\t\t\t\t\t\t.to( { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration )\n\t\t\t\t\t\t.easing( TWEEN.Easing.Exponential.InOut )\n\t\t\t\t\t\t.start();\n\n\t\t\t\t}\n\n\t\t\t\tnew TWEEN.Tween( this )\n\t\t\t\t\t.to( {}, duration * 2 )\n\t\t\t\t\t.onUpdate( render )\n\t\t\t\t\t.start();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\tTWEEN.update();\n\n\t\t\t\tcontrols.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js css3d - periodic table."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates "}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for :\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tlet scene2, renderer2;\n\n\t\t\tlet controls;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\n\t\t\t\tcamera.position.set( 200, 200, 200 );\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\tscene2 = new THREE.Scene();\n\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, wireframeLinewidth: 1, side: THREE.DoubleSide } );\n\n\t\t\t\t//\n\n\t\t\t\tfor ( let i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\tconst element = document.createElement( 'div' );\n\t\t\t\t\telement.style.width = '100px';\n\t\t\t\t\telement.style.height = '100px';\n\t\t\t\t\telement.style.opacity = ( i < 5 ) ? 0.5 : 1;\n\t\t\t\t\telement.style.background = new THREE.Color( Math.random() * 0xffffff ).getStyle();\n\n\t\t\t\t\tconst object = new CSS3DObject( element );\n\t\t\t\t\tobject.position.x = Math.random() * 200 - 100;\n\t\t\t\t\tobject.position.y = Math.random() * 200 - 100;\n\t\t\t\t\tobject.position.z = Math.random() * 200 - 100;\n\t\t\t\t\tobject.rotation.x = Math.random();\n\t\t\t\t\tobject.rotation.y = Math.random();\n\t\t\t\t\tobject.rotation.z = Math.random();\n\t\t\t\t\tobject.scale.x = Math.random() + 0.5;\n\t\t\t\t\tobject.scale.y = Math.random() + 0.5;\n\t\t\t\t\tscene2.add( object );\n\n\t\t\t\t\tconst geometry = new THREE.PlaneGeometry( 100, 100 );\n\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmesh.position.copy( object.position );\n\t\t\t\t\tmesh.rotation.copy( object.rotation );\n\t\t\t\t\tmesh.scale.copy( object.scale );\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\trenderer2 = new CSS3DRenderer();\n\t\t\t\trenderer2.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer2.domElement.style.position = 'absolute';\n\t\t\t\trenderer2.domElement.style.top = 0;\n\t\t\t\tdocument.body.appendChild( renderer2.domElement );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer2.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\t\t\t\tcreatePanel();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t\trenderer2.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\tcontrols.update();\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer2.render( scene2, camera );\n\n\t\t\t}\n\n\t\t\tfunction createPanel() {\n\n\t\t\t\tconst panel = new GUI();\n\t\t\t\tconst folder1 = panel.addFolder( 'camera setViewOffset' ).close();\n\n\t\t\t\tconst settings = {\n\t\t\t\t\t'setViewOffset'() {\n\n\t\t\t\t\t\tfolder1.children[ 1 ].enable().setValue( window.innerWidth );\n\t\t\t\t\t\tfolder1.children[ 2 ].enable().setValue( window.innerHeight );\n\t\t\t\t\t\tfolder1.children[ 3 ].enable().setValue( 0 );\n\t\t\t\t\t\tfolder1.children[ 4 ].enable().setValue( 0 );\n\t\t\t\t\t\tfolder1.children[ 5 ].enable().setValue( window.innerWidth );\n\t\t\t\t\t\tfolder1.children[ 6 ].enable().setValue( window.innerHeight );\n\n\t\t\t\t\t},\n\t\t\t\t\t'fullWidth': 0,\n\t\t\t\t\t'fullHeight': 0,\n\t\t\t\t\t'offsetX': 0,\n\t\t\t\t\t'offsetY': 0,\n\t\t\t\t\t'width': 0,\n\t\t\t\t\t'height': 0,\n\t\t\t\t\t'clearViewOffset'() {\n\n\t\t\t\t\t\tfolder1.children[ 1 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 2 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 3 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 4 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 5 ].setValue( 0 ).disable();\n\t\t\t\t\t\tfolder1.children[ 6 ].setValue( 0 ).disable();\n\t\t\t\t\t\tcamera.clearViewOffset();\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfolder1.add( settings, 'setViewOffset' );\n\t\t\t\tfolder1.add( settings, 'fullWidth', window.screen.width / 4, window.screen.width * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { fullWidth: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'fullHeight', window.screen.height / 4, window.screen.height * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { fullHeight: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'offsetX', 0, 256, 1 ).onChange( ( val ) => updateCameraViewOffset( { x: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'offsetY', 0, 256, 1 ).onChange( ( val ) => updateCameraViewOffset( { y: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'width', window.screen.width / 4, window.screen.width * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { width: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'height', window.screen.height / 4, window.screen.height * 2, 1 ).onChange( ( val ) => updateCameraViewOffset( { height: val } ) ).disable();\n\t\t\t\tfolder1.add( settings, 'clearViewOffset' );\n\n\t\t\t}\n\n\t\t\tfunction updateCameraViewOffset( { fullWidth, fullHeight, x, y, width, height } ) {\n\n\t\t\t\tif ( ! camera.view ) {\n\n\t\t\t\t\tcamera.setViewOffset( fullWidth || window.innerWidth, fullHeight || window.innerHeight, x || 0, y || 0, width || window.innerWidth, height || window.innerHeight );\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcamera.setViewOffset( fullWidth || camera.view.fullWidth, fullHeight || camera.view.fullHeight, x || camera.view.offsetX, y || camera.view.offsetY, width || camera.view.width, height || camera.view.height );\n\t\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n```\n\nThis example three.js css3d - sandbox"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates css3d - sprites"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js css3d - sprites:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport TWEEN from 'three/addons/libs/tween.module.js';\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { CSS3DRenderer, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tconst particlesTotal = 512;\n\t\t\tconst positions = [];\n\t\t\tconst objects = [];\n\t\t\tlet current = 0;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.set( 600, 400, 1500 );\n\t\t\t\tcamera.lookAt( 0, 0, 0 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\tconst image = document.createElement( 'img' );\n\t\t\t\timage.addEventListener( 'load', function () {\n\n\t\t\t\t\tfor ( let i = 0; i < particlesTotal; i ++ ) {\n\n\t\t\t\t\t\tconst object = new CSS3DSprite( image.cloneNode() );\n\t\t\t\t\t\tobject.position.x = Math.random() * 4000 - 2000,\n\t\t\t\t\t\tobject.position.y = Math.random() * 4000 - 2000,\n\t\t\t\t\t\tobject.position.z = Math.random() * 4000 - 2000;\n\t\t\t\t\t\tscene.add( object );\n\n\t\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransition();\n\n\t\t\t\t} );\n\t\t\t\timage.src = 'textures/sprite.png';\n\n\t\t\t\t// Plane\n\n\t\t\t\tconst amountX = 16;\n\t\t\t\tconst amountZ = 32;\n\t\t\t\tconst separationPlane = 150;\n\t\t\t\tconst offsetX = ( ( amountX - 1 ) * separationPlane ) / 2;\n\t\t\t\tconst offsetZ = ( ( amountZ - 1 ) * separationPlane ) / 2;\n\n\t\t\t\tfor ( let i = 0; i < particlesTotal; i ++ ) {\n\n\t\t\t\t\tconst x = ( i % amountX ) * separationPlane;\n\t\t\t\t\tconst z = Math.floor( i / amountX ) * separationPlane;\n\t\t\t\t\tconst y = ( Math.sin( x * 0.5 ) + Math.sin( z * 0.5 ) ) * 200;\n\n\t\t\t\t\tpositions.push( x - offsetX, y, z - offsetZ );\n\n\t\t\t\t}\n\n\t\t\t\t// Cube\n\n\t\t\t\tconst amount = 8;\n\t\t\t\tconst separationCube = 150;\n\t\t\t\tconst offset = ( ( amount - 1 ) * separationCube ) / 2;\n\n\t\t\t\tfor ( let i = 0; i < particlesTotal; i ++ ) {\n\n\t\t\t\t\tconst x = ( i % amount ) * separationCube;\n\t\t\t\t\tconst y = Math.floor( ( i / amount ) % amount ) * separationCube;\n\t\t\t\t\tconst z = Math.floor( i / ( amount * amount ) ) * separationCube;\n\n\t\t\t\t\tpositions.push( x - offset, y - offset, z - offset );\n\n\t\t\t\t}\n\n\t\t\t\t// Random\n\n\t\t\t\tfor ( let i = 0; i < particlesTotal; i ++ ) {\n\n\t\t\t\t\tpositions.push(\n\t\t\t\t\t\tMath.random() * 4000 - 2000,\n\t\t\t\t\t\tMath.random() * 4000 - 2000,\n\t\t\t\t\t\tMath.random() * 4000 - 2000\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\t// Sphere\n\n\t\t\t\tconst radius = 750;\n\n\t\t\t\tfor ( let i = 0; i < particlesTotal; i ++ ) {\n\n\t\t\t\t\tconst phi = Math.acos( - 1 + ( 2 * i ) / particlesTotal );\n\t\t\t\t\tconst theta = Math.sqrt( particlesTotal * Math.PI ) * phi;\n\n\t\t\t\t\tpositions.push(\n\t\t\t\t\t\tradius * Math.cos( theta ) * Math.sin( phi ),\n\t\t\t\t\t\tradius * Math.sin( theta ) * Math.sin( phi ),\n\t\t\t\t\t\tradius * Math.cos( phi )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\trenderer = new CSS3DRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.getElementById( 'container' ).appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction transition() {\n\n\t\t\t\tconst offset = current * particlesTotal * 3;\n\t\t\t\tconst duration = 2000;\n\n\t\t\t\tfor ( let i = 0, j = offset; i < particlesTotal; i ++, j += 3 ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\n\t\t\t\t\tnew TWEEN.Tween( object.position )\n\t\t\t\t\t\t.to( {\n\t\t\t\t\t\t\tx: positions[ j ],\n\t\t\t\t\t\t\ty: positions[ j + 1 ],\n\t\t\t\t\t\t\tz: positions[ j + 2 ]\n\t\t\t\t\t\t}, Math.random() * duration + duration )\n\t\t\t\t\t\t.easing( TWEEN.Easing.Exponential.InOut )\n\t\t\t\t\t\t.start();\n\n\t\t\t\t}\n\n\t\t\t\tnew TWEEN.Tween( this )\n\t\t\t\t\t.to( {}, duration * 3 )\n\t\t\t\t\t.onComplete( transition )\n\t\t\t\t\t.start();\n\n\t\t\t\tcurrent = ( current + 1 ) % 4;\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\tTWEEN.update();\n\t\t\t\tcontrols.update();\n\n\t\t\t\tconst time = performance.now();\n\n\t\t\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst object = objects[ i ];\n\t\t\t\t\tconst scale = Math.sin( ( Math.floor( object.position.x ) + time ) * 0.002 ) * 0.3 + 1;\n\t\t\t\t\tobject.scale.set( scale, scale, scale );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```\n\nThis example three.js css3d - sprites"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js css_renderers example that demonstrates css3d - youtube"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js css3d - youtube:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { TrackballControls } from 'three/addons/controls/TrackballControls.js';\n\t\t\timport { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';\n\n\t\t\tlet camera, scene, renderer;\n\t\t\tlet controls;\n\n\t\t\tfunction Element( id, x, y, z, ry ) {\n\n\t\t\t\tconst div = document.createElement( 'div' );\n\t\t\t\tdiv.style.width = '480px';\n\t\t\t\tdiv.style.height = '360px';\n\t\t\t\tdiv.style.backgroundColor = '#000';\n\n\t\t\t\tconst iframe = document.createElement( 'iframe' );\n\t\t\t\tiframe.style.width = '480px';\n\t\t\t\tiframe.style.height = '360px';\n\t\t\t\tiframe.style.border = '0px';\n\t\t\t\tiframe.src = [ 'https://www.youtube.com/embed/', id, '?rel=0' ].join( '' );\n\t\t\t\tdiv.appendChild( iframe );\n\n\t\t\t\tconst object = new CSS3DObject( div );\n\t\t\t\tobject.position.set( x, y, z );\n\t\t\t\tobject.rotation.y = ry;\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );\n\t\t\t\tcamera.position.set( 500, 350, 750 );\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\trenderer = new CSS3DRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t\tconst group = new THREE.Group();\n\t\t\t\tgroup.add( new Element( 'SJOz3qjfQXU', 0, 0, 240, 0 ) );\n\t\t\t\tgroup.add( new Element( 'Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2 ) );\n\t\t\t\tgroup.add( new Element( 'IrydklNpcFI', 0, 0, - 240, Math.PI ) );\n\t\t\t\tgroup.add( new Element( '9ubytEsCaS0', - 240, 0, 0, - Math.PI / 2 ) );\n\t\t\t\tscene.add( group );\n\n\t\t\t\tcontrols = new TrackballControls( camera, renderer.domElement );\n\t\t\t\tcontrols.rotateSpeed = 4;\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// Block iframe events when dragging camera\n\n\t\t\t\tconst blocker = document.getElementById( 'blocker' );\n\t\t\t\tblocker.style.display = 'none';\n\n\t\t\t\tcontrols.addEventListener( 'start', function () {\n\n\t\t\t\t\tblocker.style.display = '';\n\n\t\t\t\t} );\n\t\t\t\tcontrols.addEventListener( 'end', function () {\n\n\t\t\t\t\tblocker.style.display = 'none';\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\t\t\t\tcontrols.update();\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates svg - lines"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js svg - lines:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';\n\n\t\t\tTHREE.ColorManagement.enabled = false;\n\n\t\t\tlet camera, scene, renderer;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 33, window.innerWidth / window.innerHeight, 0.1, 100 );\n\t\t\t\tcamera.position.z = 10;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0, 0, 0 );\n\n\t\t\t\trenderer = new SVGRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\t//\n\n\t\t\t\tconst vertices = [];\n\t\t\t\tconst divisions = 50;\n\n\t\t\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\t\tconst v = ( i / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\t\tconst x = Math.sin( v );\n\t\t\t\t\tconst z = Math.cos( v );\n\n\t\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\t//\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.LineBasicMaterial( {\n\t\t\t\t\t\tcolor: Math.random() * 0xffffff,\n\t\t\t\t\t\tlinewidth: 10\n\t\t\t\t\t} );\n\t\t\t\t\tconst line = new THREE.Line( geometry, material );\n\t\t\t\t\tline.scale.setScalar( i / 3 );\n\t\t\t\t\tscene.add( line );\n\n\t\t\t\t}\n\n\t\t\t\tconst material = new THREE.LineDashedMaterial( {\n\t\t\t\t\tcolor: 'blue',\n\t\t\t\t\tlinewidth: 1,\n\t\t\t\t\tdashSize: 10,\n\t\t\t\t\tgapSize: 10\n\t\t\t\t} );\n\t\t\t\tconst line = new THREE.Line( geometry, material );\n\t\t\t\tline.scale.setScalar( 2 );\n\t\t\t\tscene.add( line );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction animate() {\n\n\t\t\t\tlet count = 0;\n\t\t\t\tconst time = performance.now() / 1000;\n\n\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\tchild.rotation.x = count + ( time / 3 );\n\t\t\t\t\tchild.rotation.z = count + ( time / 4 );\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t} );\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t}\n```\n\nThis example three.js svg - lines"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates svg - sandbox"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js svg - sandbox:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport Stats from 'three/addons/libs/stats.module.js';\n\n\t\t\timport { SVGRenderer, SVGObject } from 'three/addons/renderers/SVGRenderer.js';\n\n\t\t\tTHREE.ColorManagement.enabled = false;\n\n\t\t\tlet camera, scene, renderer, stats;\n\n\t\t\tlet group;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );\n\t\t\t\tcamera.position.z = 500;\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.background = new THREE.Color( 0xf0f0f0 );\n\n\t\t\t\t// QRCODE\n\n\t\t\t\tconst loader = new THREE.BufferGeometryLoader();\n\t\t\t\tloader.load( 'models/json/QRCode_buffergeometry.json', function ( geometry ) {\n\n\t\t\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { vertexColors: true } ) );\n\t\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 2;\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t\t\t// CUBES\n\n\t\t\t\tconst boxGeometry = new THREE.BoxGeometry( 100, 100, 100 );\n\n\t\t\t\tlet mesh = new THREE.Mesh( boxGeometry, new THREE.MeshBasicMaterial( { color: 0x0000ff, opacity: 0.5, transparent: true } ) );\n\t\t\t\tmesh.position.x = 500;\n\t\t\t\tmesh.rotation.x = Math.random();\n\t\t\t\tmesh.rotation.y = Math.random();\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\tmesh = new THREE.Mesh( boxGeometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) );\n\t\t\t\tmesh.position.x = 500;\n\t\t\t\tmesh.position.y = 500;\n\t\t\t\tmesh.rotation.x = Math.random();\n\t\t\t\tmesh.rotation.y = Math.random();\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// PLANE\n\n\t\t\t\tmesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );\n\t\t\t\tmesh.position.y = - 500;\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// CYLINDER\n\n\t\t\t\tmesh = new THREE.Mesh( new THREE.CylinderGeometry( 20, 100, 200, 10 ), new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) );\n\t\t\t\tmesh.position.x = - 500;\n\t\t\t\tmesh.rotation.x = - Math.PI / 2;\n\t\t\t\tmesh.scale.x = mesh.scale.y = mesh.scale.z = 2;\n\t\t\t\tscene.add( mesh );\n\n\t\t\t\t// POLYFIELD\n\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\n\t\t\t\tconst material = new THREE.MeshBasicMaterial( { vertexColors: true, side: THREE.DoubleSide } );\n\n\t\t\t\tconst v = new THREE.Vector3();\n\t\t\t\tconst v0 = new THREE.Vector3();\n\t\t\t\tconst v1 = new THREE.Vector3();\n\t\t\t\tconst v2 = new THREE.Vector3();\n\t\t\t\tconst color = new THREE.Color();\n\n\t\t\t\tconst vertices = [];\n\t\t\t\tconst colors = [];\n\n\t\t\t\tfor ( let i = 0; i < 100; i ++ ) {\n\n\t\t\t\t\tv.set(\n\t\t\t\t\t\tMath.random() * 1000 - 500,\n\t\t\t\t\t\tMath.random() * 1000 - 500,\n\t\t\t\t\t\tMath.random() * 1000 - 500\n\t\t\t\t\t);\n\n\t\t\t\t\tv0.set(\n\t\t\t\t\t\tMath.random() * 100 - 50,\n\t\t\t\t\t\tMath.random() * 100 - 50,\n\t\t\t\t\t\tMath.random() * 100 - 50\n\t\t\t\t\t);\n\n\t\t\t\t\tv1.set(\n\t\t\t\t\t\tMath.random() * 100 - 50,\n\t\t\t\t\t\tMath.random() * 100 - 50,\n\t\t\t\t\t\tMath.random() * 100 - 50\n\t\t\t\t\t);\n\n\t\t\t\t\tv2.set(\n\t\t\t\t\t\tMath.random() * 100 - 50,\n\t\t\t\t\t\tMath.random() * 100 - 50,\n\t\t\t\t\t\tMath.random() * 100 - 50\n\t\t\t\t\t);\n\n\t\t\t\t\tv0.add( v );\n\t\t\t\t\tv1.add( v );\n\t\t\t\t\tv2.add( v );\n\n\t\t\t\t\tcolor.setHex( Math.random() * 0xffffff );\n\n\t\t\t\t\t// create a single triangle\n\n\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\t\t\t\t\tvertices.push( v2.x, v2.y, v2.z );\n\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\tgroup = new THREE.Mesh( geometry, material );\n\t\t\t\tgroup.scale.set( 2, 2, 2 );\n\t\t\t\tscene.add( group );\n\n\t\t\t\t// SPRITES\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tconst material = new THREE.SpriteMaterial( { color: Math.random() * 0xffffff } );\n\t\t\t\t\tconst sprite = new THREE.Sprite( material );\n\t\t\t\t\tsprite.position.x = Math.random() * 1000 - 500;\n\t\t\t\t\tsprite.position.y = Math.random() * 1000 - 500;\n\t\t\t\t\tsprite.position.z = Math.random() * 1000 - 500;\n\t\t\t\t\tsprite.scale.set( 64, 64, 1 );\n\t\t\t\t\tscene.add( sprite );\n\n\t\t\t\t}\n\n\t\t\t\t// CUSTOM\n\n\t\t\t\tconst node = document.createElementNS( 'http://www.w3.org/2000/svg', 'circle' );\n\t\t\t\tnode.setAttribute( 'stroke', 'black' );\n\t\t\t\tnode.setAttribute( 'fill', 'red' );\n\t\t\t\tnode.setAttribute( 'r', '40' );\n\n\t\t\t\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\t\t\t\tconst object = new SVGObject( node.cloneNode() );\n\t\t\t\t\tobject.position.x = Math.random() * 1000 - 500;\n\t\t\t\t\tobject.position.y = Math.random() * 1000 - 500;\n\t\t\t\t\tobject.position.z = Math.random() * 1000 - 500;\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t}\n\n\t\t\t\t// CUSTOM FROM FILE\n\n\t\t\t\tconst fileLoader = new THREE.FileLoader();\n\t\t\t\tfileLoader.load( 'models/svg/hexagon.svg', function ( svg ) {\n\n\t\t\t\t\tconst node = document.createElementNS( 'http://www.w3.org/2000/svg', 'g' );\n\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\tconst doc = parser.parseFromString( svg, 'image/svg+xml' );\n\n\t\t\t\t\tnode.appendChild( doc.documentElement );\n\n\t\t\t\t\tconst object = new SVGObject( node );\n\t\t\t\t\tobject.position.x = 500;\n\t\t\t\t\tscene.add( object );\n\n\t\t\t\t} );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tconst ambient = new THREE.AmbientLight( 0x80ffff );\n\t\t\t\tscene.add( ambient );\n\n\t\t\t\tconst directional = new THREE.DirectionalLight( 0xffff00 );\n\t\t\t\tdirectional.position.set( - 1, 0.5, 0 );\n\t\t\t\tscene.add( directional );\n\n\t\t\t\trenderer = new SVGRenderer();\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\t\trenderer.setQuality( 'low' );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\tstats = new Stats();\n\t\t\t\tdocument.body.appendChild( stats.dom );\n\n\t\t\t\t//\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction animate() {\n\n\t\t\t\trequestAnimationFrame( animate );\n\n\t\t\t\trender();\n\t\t\t\tstats.update();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\tconst time = Date.now() * 0.0002;\n\n\t\t\t\tcamera.position.x = Math.sin( time ) * 500;\n\t\t\t\tcamera.position.z = Math.cos( time ) * 500;\n\t\t\t\tcamera.lookAt( scene.position );\n\n\t\t\t\tgroup.rotation.x += 0.01;\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n```"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates white furnace test"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js white furnace test:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\tlet scene, camera, renderer, radianceMap;\n\n\t\t\tconst COLOR = 0xcccccc;\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\t\t\t\tconst aspect = width / height;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setSize( width, height );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\tdocument.body.addEventListener( 'mouseover', function () {\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) child.material.color.setHex( 0xffffff );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\tdocument.body.addEventListener( 'mouseout', function () {\n\n\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\tif ( child.isMesh ) child.material.color.setHex( 0xccccff ); // tinted for visibility\n\n\t\t\t\t\t} );\n\n\t\t\t\t\trender();\n\n\t\t\t\t} );\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, aspect, 1, 30 );\n\t\t\t\tcamera.position.set( 0, 0, 18 );\n\n\t\t\t}\n\n\t\t\tfunction createObjects() {\n\n\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.4, 32, 16 );\n\n\t\t\t\tfor ( let x = 0; x <= 10; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y <= 10; y ++ ) {\n\n\t\t\t\t\t\tconst material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\troughness: x / 10,\n\t\t\t\t\t\t\tmetalness: y / 10,\n\t\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\t\tenvMap: radianceMap,\n\t\t\t\t\t\t\tenvMapIntensity: 1,\n\t\t\t\t\t\t\ttransmission: 0,\n\t\t\t\t\t\t\tior: 1.5\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\tmesh.position.x = x - 5;\n\t\t\t\t\t\tmesh.position.y = 5 - y;\n\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createEnvironment() {\n\n\t\t\t\tconst envScene = new THREE.Scene();\n\t\t\t\tenvScene.background = new THREE.Color( COLOR );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tradianceMap = pmremGenerator.fromScene( envScene ).texture;\n\t\t\t\tpmremGenerator.dispose();\n\n\t\t\t\tscene.background = envScene.background;\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tPromise.resolve()\n\t\t\t\t.then( init )\n\t\t\t\t.then( createEnvironment )\n\t\t\t\t.then( createObjects )\n\t\t\t\t.then( render );\n```\n\nThis example three.js - White Furnace energy conservation test by Jordan Santell Roughness increases left to right Metalness increases top to bottom"}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js webgl_general example that demonstrates PMREM directional light test"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js PMREM directional light test:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t\t\timport { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n\n\t\t\timport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\t\t\tlet scene, camera, controls, renderer;\n\n\t\t\tfunction init() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\t\t\t\tconst aspect = width / height;\n\n\t\t\t\t// renderer\n\n\t\t\t\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\t// tonemapping\n\t\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\t\trenderer.toneMappingExposure = 1;\n\n\t\t\t\tdocument.body.appendChild( renderer.domElement );\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\t\t// scene\n\n\t\t\t\tscene = new THREE.Scene();\n\n\t\t\t\t// camera\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, aspect, 1, 30 );\n\t\t\t\tupdateCamera();\n\t\t\t\tcamera.position.set( 0, 0, 16 );\n\n\t\t\t\t// controls\n\n\t\t\t\tcontrols = new OrbitControls( camera, renderer.domElement );\n\t\t\t\tcontrols.addEventListener( 'change', render ); // use if there is no animation loop\n\t\t\t\tcontrols.minDistance = 4;\n\t\t\t\tcontrols.maxDistance = 20;\n\n\t\t\t\t// light\n\n\t\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 0 ); // set intensity to 0 to start\n\t\t\t\tconst x = 597;\n\t\t\t\tconst y = 213;\n\t\t\t\tconst theta = ( x + 0.5 ) * Math.PI / 512;\n\t\t\t\tconst phi = ( y + 0.5 ) * Math.PI / 512;\n\n\t\t\t\tdirectionalLight.position.setFromSphericalCoords( 100, - phi, Math.PI / 2 - theta );\n\n\t\t\t\tscene.add( directionalLight );\n\t\t\t\t// scene.add( new THREE.DirectionalLightHelper( directionalLight ) );\n\n\t\t\t\t// The spot1Lux HDR environment map is expressed in nits (lux / sr). The directional light has units of lux,\n\t\t\t\t// so to match a 1 lux light, we set a single pixel with a value equal to 1 divided by the solid\n\t\t\t\t// angle of the pixel in steradians. This image is 1024 x 512,\n\t\t\t\t// so the value is 1 / ( sin( phi ) * ( pi / 512 ) ^ 2 ) = 27,490 nits.\n\n\t\t\t\tconst gui = new GUI();\n\t\t\t\tgui.add( { enabled: true }, 'enabled' )\n\t\t\t\t\t.name( 'PMREM' )\n\t\t\t\t\t.onChange( value => {\n\n\t\t\t\t\t\tdirectionalLight.intensity = value ? 0 : 1;\n\n\t\t\t\t\t\tscene.traverse( function ( child ) {\n\n\t\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t\tchild.material.envMapIntensity = 1 - directionalLight.intensity;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction createObjects() {\n\n\t\t\t\tlet radianceMap = null;\n\t\t\t\tnew RGBELoader()\n\t\t\t\t\t// .setDataType( THREE.FloatType )\n\t\t\t\t\t.setPath( 'textures/equirectangular/' )\n\t\t\t\t\t.load( 'spot1Lux.hdr', function ( texture ) {\n\n\t\t\t\t\t\tradianceMap = pmremGenerator.fromEquirectangular( texture ).texture;\n\t\t\t\t\t\tpmremGenerator.dispose();\n\n\t\t\t\t\t\tscene.background = radianceMap;\n\n\t\t\t\t\t\tconst geometry = new THREE.SphereGeometry( 0.4, 32, 32 );\n\n\t\t\t\t\t\tfor ( let x = 0; x <= 10; x ++ ) {\n\n\t\t\t\t\t\t\tfor ( let y = 0; y <= 2; y ++ ) {\n\n\t\t\t\t\t\t\t\tconst material = new THREE.MeshPhysicalMaterial( {\n\t\t\t\t\t\t\t\t\troughness: x / 10,\n\t\t\t\t\t\t\t\t\tmetalness: y < 1 ? 1 : 0,\n\t\t\t\t\t\t\t\t\tcolor: y < 2 ? 0xffffff : 0x000000,\n\t\t\t\t\t\t\t\t\tenvMap: radianceMap,\n\t\t\t\t\t\t\t\t\tenvMapIntensity: 1\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\tconst mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\t\t\t\tmesh.position.x = x - 5;\n\t\t\t\t\t\t\t\tmesh.position.y = 1 - y;\n\t\t\t\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trender();\n\n\t\t\t\t\t} );\n\n\t\t\t\tconst pmremGenerator = new THREE.PMREMGenerator( renderer );\n\t\t\t\tpmremGenerator.compileEquirectangularShader();\n\n\t\t\t}\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tconst width = window.innerWidth;\n\t\t\t\tconst height = window.innerHeight;\n\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tupdateCamera();\n\n\t\t\t\trenderer.setSize( width, height );\n\n\t\t\t\trender();\n\n\t\t\t}\n\n\t\t\tfunction updateCamera() {\n\n\t\t\t\tconst horizontalFoV = 40;\n\t\t\t\tconst verticalFoV = 2 * Math.atan( Math.tan( horizontalFoV / 2 * Math.PI / 180 ) / camera.aspect ) * 180 / Math.PI;\n\t\t\t\tcamera.fov = verticalFoV;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tfunction render() {\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t}\n\n\t\t\tPromise.resolve()\n\t\t\t\t.then( init )\n\t\t\t\t.then( createObjects )\n\t\t\t\t.then( render );\n```\n\nThis example three.js - PMREM test by Emmett Lalish 1: white metal. 2: white dielectric. 3: black dielectric. PMREM on: HDR with a single bright pixel. PMREM off: DirectionalLight. The difference between these renders indicates the error in the PMREM approximations."}]}]}
{"contents": [{"role": "user", "parts": [{"text": "Create a Three.js misc example that demonstrates - uv mapping tests"}]}, {"role": "model", "parts": [{"text": "Here's a Three.js example for three.js - uv mapping tests:\n\n```javascript\nimport * as THREE from 'three';\n\n\t\t\timport { UVsDebug } from 'three/addons/utils/UVsDebug.js';\n\n\t\t\t/*\n\t\t\t * This is to help debug UVs problems in geometry,\n\t\t\t * as well as allow a new user to visualize what UVs are about.\n\t\t\t */\n\n\t\t\tfunction test( name, geometry ) {\n\n\t\t\t\tconst d = document.createElement( 'div' );\n\n\t\t\t\td.innerHTML = '<h3>' + name + '</h3>';\n\n\t\t\t\td.appendChild( UVsDebug( geometry ) );\n\n\t\t\t\tdocument.body.appendChild( d );\n\n\t\t\t}\n\n\t\t\tconst points = [];\n\n\t\t\tfor ( let i = 0; i < 10; i ++ ) {\n\n\t\t\t\tpoints.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 15 + 50, ( i - 5 ) * 2 ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\ttest( 'new THREE.PlaneGeometry( 100, 100, 4, 4 )', new THREE.PlaneGeometry( 100, 100, 4, 4 ) );\n\n\t\t\ttest( 'new THREE.SphereGeometry( 75, 12, 6 )', new THREE.SphereGeometry( 75, 12, 6 ) );\n\n\t\t\ttest( 'new THREE.IcosahedronGeometry( 30, 1 )', new THREE.IcosahedronGeometry( 30, 1 ) );\n\n\t\t\ttest( 'new THREE.OctahedronGeometry( 30, 2 )', new THREE.OctahedronGeometry( 30, 2 ) );\n\n\t\t\ttest( 'new THREE.CylinderGeometry( 25, 75, 100, 10, 5 )', new THREE.CylinderGeometry( 25, 75, 100, 10, 5 ) );\n\n\t\t\ttest( 'new THREE.BoxGeometry( 100, 100, 100, 4, 4, 4 )', new THREE.BoxGeometry( 100, 100, 100, 4, 4, 4 ) );\n\n\t\t\ttest( 'new THREE.LatheGeometry( points, 8 )', new THREE.LatheGeometry( points, 8 ) );\n\n\t\t\ttest( 'new THREE.TorusGeometry( 50, 20, 8, 8 )', new THREE.TorusGeometry( 50, 20, 8, 8 ) );\n\n\t\t\ttest( 'new THREE.TorusKnotGeometry( 50, 10, 12, 6 )', new THREE.TorusKnotGeometry( 50, 10, 12, 6 ) );\n```"}]}]}
